###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       25/Jan/2017  17:35:37
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\lwip\ports\tcp_out.c
#    Command line =  
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\lwip\ports\tcp_out.c" -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_WIFI_TGN_VERIFY_ENABLE -D MTK_SMTCN_ENABLE -D
#        MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D SUPPORT_MBEDTLS -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-basic.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D MTK_MCS_ENABLE -D MTK_BLE_GPIO_SERVICE -D
#        __BT_DEBUG__ -lcN "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List" -lA
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List"
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj" --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\inc\" -I
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\service\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\dhcpd\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\src\ut_app\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\httpclient\inc\"
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List\tcp_out.lst
#    Object file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj\tcp_out.o
#
###############################################################################

C:\LEO\myGit\MTK IOT\SDK_V4.2.0\middleware\third_party\lwip\ports\tcp_out.c
      1          /**
      2           * @file
      3           * Transmission Control Protocol, outgoing traffic
      4           *
      5           * The output functions of TCP.
      6           *
      7           */
      8          
      9          /*
     10           * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
     11           * All rights reserved.
     12           *
     13           * Redistribution and use in source and binary forms, with or without modification,
     14           * are permitted provided that the following conditions are met:
     15           *
     16           * 1. Redistributions of source code must retain the above copyright notice,
     17           *    this list of conditions and the following disclaimer.
     18           * 2. Redistributions in binary form must reproduce the above copyright notice,
     19           *    this list of conditions and the following disclaimer in the documentation
     20           *    and/or other materials provided with the distribution.
     21           * 3. The name of the author may not be used to endorse or promote products
     22           *    derived from this software without specific prior written permission.
     23           *
     24           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
     25           * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     26           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
     27           * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     28           * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
     29           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     30           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     31           * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     32           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
     33           * OF SUCH DAMAGE.
     34           *
     35           * This file is part of the lwIP TCP/IP stack.
     36           *
     37           * Author: Adam Dunkels <adam@sics.se>
     38           *
     39           */
     40          
     41          #include "lwip/opt.h"
     42          
     43          #if LWIP_TCP /* don't build if not configured for use in lwipopts.h */
     44          
     45          #include "lwip/tcp_impl.h"
     46          #include "lwip/def.h"
     47          #include "lwip/mem.h"
     48          #include "lwip/memp.h"
     49          #include "lwip/ip_addr.h"
     50          #include "lwip/netif.h"
     51          #include "lwip/inet_chksum.h"
     52          #include "lwip/stats.h"
     53          #include "lwip/snmp.h"
     54          #include "lwip/ip6.h"
     55          #include "lwip/ip6_addr.h"
     56          #include "lwip/inet_chksum.h"
     57          #if LWIP_TCP_TIMESTAMPS
     58          #include "lwip/sys.h"
     59          #endif
     60          
     61          #include <string.h>
     62          #ifdef MTK_HIF_GDMA_ENABLE
     63          #include "hal_gdma.h" //"dma_sw.h"
     64          #endif
     65          /* Define some copy-macros for checksum-on-copy so that the code looks
     66             nicer by preventing too many ifdef's. */
     67          #if TCP_CHECKSUM_ON_COPY
     68          #define TCP_DATA_COPY(dst, src, len, seg) do { \
     69            tcp_seg_add_chksum(LWIP_CHKSUM_COPY(dst, src, len), \
     70                               len, &seg->chksum, &seg->chksum_swapped); \
     71            seg->flags |= TF_SEG_DATA_CHECKSUMMED; } while(0)
     72          #define TCP_DATA_COPY2(dst, src, len, chksum, chksum_swapped)  \
     73            tcp_seg_add_chksum(LWIP_CHKSUM_COPY(dst, src, len), len, chksum, chksum_swapped);
     74          #else /* TCP_CHECKSUM_ON_COPY*/
     75          
     76          #ifdef MTK_HIF_GDMA_ENABLE
     77          #ifndef IS_ALIGN_4
     78          #define IS_ALIGN_4(_value)          (((_value) & 0x3) ? 0 : 1)
     79          #endif /* IS_ALIGN_4 */
     80          
     81          static void LWIP_DMA_memcpy(void *src, void *dst, unsigned int len)
     82          {
     83              hal_gdma_status_t ret;
     84              hal_gdma_running_status_t running_status;
     85              hal_gdma_channel_t channel = HAL_GDMA_CHANNEL_0;
     86          
     87              /*In MT7687/97 DMA cannot access the TCM Address */
     88              if(((unsigned int)src < 0x10000000) ||
     89                 ((unsigned int)dst < 0x10000000)){
     90                  MEMCPY(dst, src, len);
     91              }else{
     92                  ret = hal_gdma_start_polling(channel, (int)dst, (int)src, len);
     93                  if(HAL_GDMA_STATUS_OK != ret)
     94                  {
     95                      printf("DMA unavailable...\n");
     96                      MEMCPY(dst, src, len);
     97                  }
     98          
     99                  hal_gdma_get_running_status(channel,&running_status);
    100                  hal_gdma_stop(channel); // stop GDMA.
    101              }
    102          }
    103          #define TCP_DATA_COPY(dst, src, len, seg)                     { if (IS_ALIGN_4((uint32_t)src) && IS_ALIGN_4((uint32_t)dst)) LWIP_DMA_memcpy((void *)src, (void *)dst, len); else MEMCPY(dst, src, len); }
    104          #define TCP_DATA_COPY2(dst, src, len, chksum, chksum_swapped) { if (IS_ALIGN_4((uint32_t)src) && IS_ALIGN_4((uint32_t)dst)) LWIP_DMA_memcpy((void *)src, (void *)dst, len); else MEMCPY(dst, src, len); }
    105          #else
    106          #define TCP_DATA_COPY(dst, src, len, seg)                     MEMCPY(dst, src, len)
    107          #define TCP_DATA_COPY2(dst, src, len, chksum, chksum_swapped) MEMCPY(dst, src, len)
    108          #endif /* MTK_HIF_GDMA_ENABLE */
    109          
    110          #endif /* TCP_CHECKSUM_ON_COPY*/
    111          
    112          /** Define this to 1 for an extra check that the output checksum is valid
    113           * (usefule when the checksum is generated by the application, not the stack) */
    114          #ifndef TCP_CHECKSUM_ON_COPY_SANITY_CHECK
    115          #define TCP_CHECKSUM_ON_COPY_SANITY_CHECK   0
    116          #endif
    117          /* Allow to override the failure of sanity check from warning to e.g. hard failure */
    118          #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
    119          #ifndef TCP_CHECKSUM_ON_COPY_SANITY_CHECK_FAIL
    120          #define TCP_CHECKSUM_ON_COPY_SANITY_CHECK_FAIL(msg) LWIP_DEBUGF(TCP_DEBUG | LWIP_DBG_LEVEL_WARNING, msg)
    121          #endif
    122          #endif
    123          
    124          #if TCP_OVERSIZE
    125          /** The size of segment pbufs created when TCP_OVERSIZE is enabled */
    126          #ifndef TCP_OVERSIZE_CALC_LENGTH
    127          #define TCP_OVERSIZE_CALC_LENGTH(length) ((length) + TCP_OVERSIZE)
    128          #endif
    129          #endif
    130          
    131          /* Forward declarations.*/
    132          static err_t tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb);
    133          
    134          /** Allocate a pbuf and create a tcphdr at p->payload, used for output
    135           * functions other than the default tcp_output -> tcp_output_segment
    136           * (e.g. tcp_send_empty_ack, etc.)
    137           *
    138           * @param pcb tcp pcb for which to send a packet (used to initialize tcp_hdr)
    139           * @param optlen length of header-options
    140           * @param datalen length of tcp data to reserve in pbuf
    141           * @param seqno_be seqno in network byte order (big-endian)
    142           * @return pbuf with p->payload being the tcp_hdr
    143           */
    144          static struct pbuf *
    145          tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
    146                                u32_t seqno_be /* already in network byte order */)
    147          {
    148            struct tcp_hdr *tcphdr;
    149            struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    150            if (p != NULL) {
    151              LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
    152                           (p->len >= TCP_HLEN + optlen));
    153              tcphdr = (struct tcp_hdr *)p->payload;
    154              tcphdr->src = htons(pcb->local_port);
    155              tcphdr->dest = htons(pcb->remote_port);
    156              tcphdr->seqno = seqno_be;
    157              tcphdr->ackno = htonl(pcb->rcv_nxt);
    158              TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    159              tcphdr->wnd = htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
    160              tcphdr->chksum = 0;
    161              tcphdr->urgp = 0;
    162          
    163              /* If we're sending a packet, update the announced right window edge */
    164              pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    165            }
    166            return p;
    167          }
    168          
    169          /**
    170           * Called by tcp_close() to send a segment including FIN flag but not data.
    171           *
    172           * @param pcb the tcp_pcb over which to send a segment
    173           * @return ERR_OK if sent, another err_t otherwise
    174           */
    175          err_t
    176          tcp_send_fin(struct tcp_pcb *pcb)
    177          {
    178            /* first, try to add the fin to the last unsent segment */
    179            if (pcb->unsent != NULL) {
    180              struct tcp_seg *last_unsent;
    181              for (last_unsent = pcb->unsent; last_unsent->next != NULL;
    182                   last_unsent = last_unsent->next);
    183          
    184              if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
    185                /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
    186                TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
    187                pcb->flags |= TF_FIN;
    188                return ERR_OK;
    189              }
    190            }
    191            /* no data, no length, flags, copy=1, no optdata */
    192            return tcp_enqueue_flags(pcb, TCP_FIN);
    193          }
    194          
    195          /**
    196           * Create a TCP segment with prefilled header.
    197           *
    198           * Called by tcp_write and tcp_enqueue_flags.
    199           *
    200           * @param pcb Protocol control block for the TCP connection.
    201           * @param p pbuf that is used to hold the TCP header.
    202           * @param flags TCP flags for header.
    203           * @param seqno TCP sequence number of this packet
    204           * @param optflags options to include in TCP header
    205           * @return a new tcp_seg pointing to p, or NULL.
    206           * The TCP header is filled in except ackno and wnd.
    207           * p is freed on failure.
    208           */
    209          static struct tcp_seg *
    210          tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
    211          {
    212            struct tcp_seg *seg;
    213            u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
    214          
    215            if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    216              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    217              pbuf_free(p);
    218              return NULL;
    219            }
    220            seg->flags = optflags;
    221            seg->next = NULL;
    222            seg->p = p;
    223            LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
    224            seg->len = p->tot_len - optlen;
    225          #if TCP_OVERSIZE_DBGCHECK
    226            seg->oversize_left = 0;
    227          #endif /* TCP_OVERSIZE_DBGCHECK */
    228          #if TCP_CHECKSUM_ON_COPY
    229            seg->chksum = 0;
    230            seg->chksum_swapped = 0;
    231            /* check optflags */
    232            LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
    233                        (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
    234          #endif /* TCP_CHECKSUM_ON_COPY */
    235          
    236            /* build TCP header */
    237            if (pbuf_header(p, TCP_HLEN)) {
    238              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    239              TCP_STATS_INC(tcp.err);
    240              tcp_seg_free(seg);
    241              return NULL;
    242            }
    243            seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
    244            seg->tcphdr->src = htons(pcb->local_port);
    245            seg->tcphdr->dest = htons(pcb->remote_port);
    246            seg->tcphdr->seqno = htonl(seqno);
    247            /* ackno is set in tcp_output */
    248            TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    249            /* wnd and chksum are set in tcp_output */
    250            seg->tcphdr->urgp = 0;
    251            return seg;
    252          }
    253          
    254          /**
    255           * Allocate a PBUF_RAM pbuf, perhaps with extra space at the end.
    256           *
    257           * This function is like pbuf_alloc(layer, length, PBUF_RAM) except
    258           * there may be extra bytes available at the end.
    259           *
    260           * @param layer flag to define header size.
    261           * @param length size of the pbuf's payload.
    262           * @param max_length maximum usable size of payload+oversize.
    263           * @param oversize pointer to a u16_t that will receive the number of usable tail bytes.
    264           * @param pcb The TCP connection that willo enqueue the pbuf.
    265           * @param apiflags API flags given to tcp_write.
    266           * @param first_seg true when this pbuf will be used in the first enqueued segment.
    267           */
    268          #if TCP_OVERSIZE
    269          static struct pbuf *
    270          tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
    271                            u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
    272                            u8_t first_seg)
    273          {
    274            struct pbuf *p;
    275            u16_t alloc = length;
    276          
    277          #if LWIP_NETIF_TX_SINGLE_PBUF
    278            LWIP_UNUSED_ARG(max_length);
    279            LWIP_UNUSED_ARG(pcb);
    280            LWIP_UNUSED_ARG(apiflags);
    281            LWIP_UNUSED_ARG(first_seg);
    282            /* always create MSS-sized pbufs */
    283            alloc = max_length;
    284          #else /* LWIP_NETIF_TX_SINGLE_PBUF */
    285            if (length < max_length) {
    286              /* Should we allocate an oversized pbuf, or just the minimum
    287               * length required? If tcp_write is going to be called again
    288               * before this segment is transmitted, we want the oversized
    289               * buffer. If the segment will be transmitted immediately, we can
    290               * save memory by allocating only length. We use a simple
    291               * heuristic based on the following information:
    292               *
    293               * Did the user set TCP_WRITE_FLAG_MORE?
    294               *
    295               * Will the Nagle algorithm defer transmission of this segment?
    296               */
    297              if ((apiflags & TCP_WRITE_FLAG_MORE) ||
    298                  (!(pcb->flags & TF_NODELAY) &&
    299                   (!first_seg ||
    300                    pcb->unsent != NULL ||
    301                    pcb->unacked != NULL))) {
    302                alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
    303              }
    304            }
    305          #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
    306            p = pbuf_alloc(layer, alloc, PBUF_RAM);
    307            if (p == NULL) {
    308              return NULL;
    309            }
    310            LWIP_ASSERT("need unchained pbuf", p->next == NULL);
    311            *oversize = p->len - length;
    312            /* trim p->len to the currently used size */
    313            p->len = p->tot_len = length;
    314            return p;
    315          }
    316          #else /* TCP_OVERSIZE */
    317          #define tcp_pbuf_prealloc(layer, length, mx, os, pcb, api, fst) pbuf_alloc((layer), (length), PBUF_RAM)
    318          #endif /* TCP_OVERSIZE */
    319          
    320          #if TCP_CHECKSUM_ON_COPY
    321          /** Add a checksum of newly added data to the segment */
    322          static void
    323          tcp_seg_add_chksum(u16_t chksum, u16_t len, u16_t *seg_chksum,
    324                             u8_t *seg_chksum_swapped)
    325          {
    326            u32_t helper;
    327            /* add chksum to old chksum and fold to u16_t */
    328            helper = chksum + *seg_chksum;
    329            chksum = FOLD_U32T(helper);
    330            if ((len & 1) != 0) {
    331              *seg_chksum_swapped = 1 - *seg_chksum_swapped;
    332              chksum = SWAP_BYTES_IN_WORD(chksum);
    333            }
    334            *seg_chksum = chksum;
    335          }
    336          #endif /* TCP_CHECKSUM_ON_COPY */
    337          
    338          /** Checks if tcp_write is allowed or not (checks state, snd_buf and snd_queuelen).
    339           *
    340           * @param pcb the tcp pcb to check for
    341           * @param len length of data to send (checked agains snd_buf)
    342           * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
    343           */
    344          static err_t
    345          tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
    346          {
    347            /* connection is in invalid state for data transmission? */
    348            if ((pcb->state != ESTABLISHED) &&
    349                (pcb->state != CLOSE_WAIT) &&
    350                (pcb->state != SYN_SENT) &&
    351                (pcb->state != SYN_RCVD)) {
    352              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    353              return ERR_CONN;
    354            } else if (len == 0) {
    355              return ERR_OK;
    356            }
    357          
    358            /* fail on too much data */
    359            if (len > pcb->snd_buf) {
    360              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
    361                len, pcb->snd_buf));
    362              pcb->flags |= TF_NAGLEMEMERR;
    363              return ERR_MEM;
    364            }
    365          
    366            LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
    367          
    368            /* If total number of pbufs on the unsent/unacked queues exceeds the
    369             * configured maximum, return an error */
    370            /* check for configured max queuelen and possible overflow */
    371            if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    372              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"TCPWNDSIZE_F" (max %"TCPWNDSIZE_F")\n",
    373                pcb->snd_queuelen, TCP_SND_QUEUELEN));
    374              TCP_STATS_INC(tcp.memerr);
    375              pcb->flags |= TF_NAGLEMEMERR;
    376              return ERR_MEM;
    377            }
    378            if (pcb->snd_queuelen != 0) {
    379              LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
    380                pcb->unacked != NULL || pcb->unsent != NULL);
    381            } else {
    382              LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
    383                pcb->unacked == NULL && pcb->unsent == NULL);
    384            }
    385            return ERR_OK;
    386          }
    387          
    388          /**
    389           * Write data for sending (but does not send it immediately).
    390           *
    391           * It waits in the expectation of more data being sent soon (as
    392           * it can send them more efficiently by combining them together).
    393           * To prompt the system to send data now, call tcp_output() after
    394           * calling tcp_write().
    395           *
    396           * @param pcb Protocol control block for the TCP connection to enqueue data for.
    397           * @param arg Pointer to the data to be enqueued for sending.
    398           * @param len Data length in bytes
    399           * @param apiflags combination of following flags :
    400           * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack
    401           * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent,
    402           * @return ERR_OK if enqueued, another err_t on error
    403           */
    404          err_t
    405          tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
    406          {
    407            struct pbuf *concat_p = NULL;
    408            struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
    409            u16_t pos = 0; /* position in 'arg' data */
    410            u16_t queuelen;
    411            u8_t optlen = 0;
    412            u8_t optflags = 0;
    413          #if TCP_OVERSIZE
    414            u16_t oversize = 0;
    415            u16_t oversize_used = 0;
    416          #endif /* TCP_OVERSIZE */
    417          #if TCP_CHECKSUM_ON_COPY
    418            u16_t concat_chksum = 0;
    419            u8_t concat_chksum_swapped = 0;
    420            u16_t concat_chksummed = 0;
    421          #endif /* TCP_CHECKSUM_ON_COPY */
    422            err_t err;
    423            /* don't allocate segments bigger than half the maximum window we ever received */
    424            u16_t mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max/2));
    425            mss_local = mss_local ? mss_local : pcb->mss;
    426          
    427          #if LWIP_NETIF_TX_SINGLE_PBUF
    428            /* Always copy to try to create single pbufs for TX */
    429            apiflags |= TCP_WRITE_FLAG_COPY;
    430          #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
    431          
    432            LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    433              (void *)pcb, arg, len, (u16_t)apiflags));
    434            LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
    435                       arg != NULL, return ERR_ARG;);
    436          
    437            err = tcp_write_checks(pcb, len);
    438            if (err != ERR_OK) {
    439              return err;
    440            }
    441            queuelen = pcb->snd_queuelen;
    442          
    443          #if LWIP_TCP_TIMESTAMPS
    444            if ((pcb->flags & TF_TIMESTAMP)) {
    445              /* Make sure the timestamp option is only included in data segments if we
    446                 agreed about it with the remote host. */
    447              optflags = TF_SEG_OPTS_TS;
    448              optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
    449              /* ensure that segments can hold at least one data byte... */
    450              mss_local = LWIP_MAX(mss_local, LWIP_TCP_OPT_LEN_TS + 1);
    451            }
    452          #endif /* LWIP_TCP_TIMESTAMPS */
    453          
    454          
    455            /*
    456             * TCP segmentation is done in three phases with increasing complexity:
    457             *
    458             * 1. Copy data directly into an oversized pbuf.
    459             * 2. Chain a new pbuf to the end of pcb->unsent.
    460             * 3. Create new segments.
    461             *
    462             * We may run out of memory at any point. In that case we must
    463             * return ERR_MEM and not change anything in pcb. Therefore, all
    464             * changes are recorded in local variables and committed at the end
    465             * of the function. Some pcb fields are maintained in local copies:
    466             *
    467             * queuelen = pcb->snd_queuelen
    468             * oversize = pcb->unsent_oversize
    469             *
    470             * These variables are set consistently by the phases:
    471             *
    472             * seg points to the last segment tampered with.
    473             *
    474             * pos records progress as data is segmented.
    475             */
    476          
    477            /* Find the tail of the unsent queue. */
    478            if (pcb->unsent != NULL) {
    479              u16_t space;
    480              u16_t unsent_optlen;
    481          
    482              /* @todo: this could be sped up by keeping last_unsent in the pcb */
    483              for (last_unsent = pcb->unsent; last_unsent->next != NULL;
    484                   last_unsent = last_unsent->next);
    485          
    486              /* Usable space at the end of the last unsent segment */
    487              unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    488              LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
    489              space = mss_local - (last_unsent->len + unsent_optlen);
    490          
    491              /*
    492               * Phase 1: Copy data directly into an oversized pbuf.
    493               *
    494               * The number of bytes copied is recorded in the oversize_used
    495               * variable. The actual copying is done at the bottom of the
    496               * function.
    497               */
    498          #if TCP_OVERSIZE
    499          #if TCP_OVERSIZE_DBGCHECK
    500              /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    501              LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
    502                          pcb->unsent_oversize == last_unsent->oversize_left);
    503          #endif /* TCP_OVERSIZE_DBGCHECK */
    504              oversize = pcb->unsent_oversize;
    505              if (oversize > 0) {
    506                LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
    507                seg = last_unsent;
    508                oversize_used = oversize < len ? oversize : len;
    509                pos += oversize_used;
    510                oversize -= oversize_used;
    511                space -= oversize_used;
    512              }
    513              /* now we are either finished or oversize is zero */
    514              LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
    515          #endif /* TCP_OVERSIZE */
    516          
    517              /*
    518               * Phase 2: Chain a new pbuf to the end of pcb->unsent.
    519               *
    520               * We don't extend segments containing SYN/FIN flags or options
    521               * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
    522               * the end.
    523               */
    524              if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
    525                u16_t seglen = space < len - pos ? space : len - pos;
    526                seg = last_unsent;
    527          
    528                /* Create a pbuf with a copy or reference to seglen bytes. We
    529                 * can use PBUF_RAW here since the data appears in the middle of
    530                 * a segment. A header will never be prepended. */
    531                if (apiflags & TCP_WRITE_FLAG_COPY) {
    532                  /* Data is copied */
    533                  if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
    534                    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
    535                                ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
    536                                 seglen));
    537                    goto memerr;
    538                  }
    539          #if TCP_OVERSIZE_DBGCHECK
    540                  last_unsent->oversize_left += oversize;
    541          #endif /* TCP_OVERSIZE_DBGCHECK */
    542                  TCP_DATA_COPY2(concat_p->payload, (const u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
    543          #if TCP_CHECKSUM_ON_COPY
    544                  concat_chksummed += seglen;
    545          #endif /* TCP_CHECKSUM_ON_COPY */
    546                } else {
    547                  /* Data is not copied */
    548                  if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
    549                    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
    550                                ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
    551                    goto memerr;
    552                  }
    553          #if TCP_CHECKSUM_ON_COPY
    554                  /* calculate the checksum of nocopy-data */
    555                  tcp_seg_add_chksum(~inet_chksum((const u8_t*)arg + pos, seglen), seglen,
    556                    &concat_chksum, &concat_chksum_swapped);
    557                  concat_chksummed += seglen;
    558          #endif /* TCP_CHECKSUM_ON_COPY */
    559                  /* reference the non-volatile payload data */
    560                  ((struct pbuf_rom*)concat_p)->payload = (const u8_t*)arg + pos;
    561                }
    562          
    563                pos += seglen;
    564                queuelen += pbuf_clen(concat_p);
    565              }
    566            } else {
    567          #if TCP_OVERSIZE
    568              LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
    569                          pcb->unsent_oversize == 0);
    570          #endif /* TCP_OVERSIZE */
    571            }
    572          
    573            /*
    574             * Phase 3: Create new segments.
    575             *
    576             * The new segments are chained together in the local 'queue'
    577             * variable, ready to be appended to pcb->unsent.
    578             */
    579            while (pos < len) {
    580              struct pbuf *p;
    581              u16_t left = len - pos;
    582              u16_t max_len = mss_local - optlen;
    583              u16_t seglen = left > max_len ? max_len : left;
    584          #if TCP_CHECKSUM_ON_COPY
    585              u16_t chksum = 0;
    586              u8_t chksum_swapped = 0;
    587          #endif /* TCP_CHECKSUM_ON_COPY */
    588          
    589              if (apiflags & TCP_WRITE_FLAG_COPY) {
    590                /* If copy is set, memory should be allocated and data copied
    591                 * into pbuf */
    592                if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
    593                  LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
    594                  goto memerr;
    595                }
    596                LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
    597                            (p->len >= seglen));
    598                TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
    599              } else {
    600                /* Copy is not set: First allocate a pbuf for holding the data.
    601                 * Since the referenced data is available at least until it is
    602                 * sent out on the link (as it has to be ACKed by the remote
    603                 * party) we can safely use PBUF_ROM instead of PBUF_REF here.
    604                 */
    605                struct pbuf *p2;
    606          #if TCP_OVERSIZE
    607                LWIP_ASSERT("oversize == 0", oversize == 0);
    608          #endif /* TCP_OVERSIZE */
    609                if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
    610                  LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
    611                  goto memerr;
    612                }
    613          #if TCP_CHECKSUM_ON_COPY
    614                /* calculate the checksum of nocopy-data */
    615                chksum = ~inet_chksum((const u8_t*)arg + pos, seglen);
    616                if (seglen & 1) {
    617                  chksum_swapped = 1;
    618                  chksum = SWAP_BYTES_IN_WORD(chksum);
    619                }
    620          #endif /* TCP_CHECKSUM_ON_COPY */
    621                /* reference the non-volatile payload data */
    622                ((struct pbuf_rom*)p2)->payload = (const u8_t*)arg + pos;
    623          
    624                /* Second, allocate a pbuf for the headers. */
    625                if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    626                  /* If allocation fails, we have to deallocate the data pbuf as
    627                   * well. */
    628                  pbuf_free(p2);
    629                  LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
    630                  goto memerr;
    631                }
    632                /* Concatenate the headers and data pbufs together. */
    633                pbuf_cat(p/*header*/, p2/*data*/);
    634              }
    635          
    636              queuelen += pbuf_clen(p);
    637          
    638              /* Now that there are more segments queued, we check again if the
    639               * length of the queue exceeds the configured maximum or
    640               * overflows. */
    641              if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    642                LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"TCPWNDSIZE_F" (%"TCPWNDSIZE_F")\n", queuelen, TCP_SND_QUEUELEN));
    643                pbuf_free(p);
    644                goto memerr;
    645              }
    646          
    647              if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
    648                goto memerr;
    649              }
    650          #if TCP_OVERSIZE_DBGCHECK
    651              seg->oversize_left = oversize;
    652          #endif /* TCP_OVERSIZE_DBGCHECK */
    653          #if TCP_CHECKSUM_ON_COPY
    654              seg->chksum = chksum;
    655              seg->chksum_swapped = chksum_swapped;
    656              seg->flags |= TF_SEG_DATA_CHECKSUMMED;
    657          #endif /* TCP_CHECKSUM_ON_COPY */
    658          
    659              /* first segment of to-be-queued data? */
    660              if (queue == NULL) {
    661                queue = seg;
    662              } else {
    663                /* Attach the segment to the end of the queued segments */
    664                LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
    665                prev_seg->next = seg;
    666              }
    667              /* remember last segment of to-be-queued data for next iteration */
    668              prev_seg = seg;
    669          
    670              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
    671                ntohl(seg->tcphdr->seqno),
    672                ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));
    673          
    674              pos += seglen;
    675            }
    676          
    677            /*
    678             * All three segmentation phases were successful. We can commit the
    679             * transaction.
    680             */
    681          
    682            /*
    683             * Phase 1: If data has been added to the preallocated tail of
    684             * last_unsent, we update the length fields of the pbuf chain.
    685             */
    686          #if TCP_OVERSIZE
    687            if (oversize_used > 0) {
    688              struct pbuf *p;
    689              /* Bump tot_len of whole chain, len of tail */
    690              for (p = last_unsent->p; p; p = p->next) {
    691                p->tot_len += oversize_used;
    692                if (p->next == NULL) {
    693                  TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
    694                  p->len += oversize_used;
    695                }
    696              }
    697              last_unsent->len += oversize_used;
    698          #if TCP_OVERSIZE_DBGCHECK
    699              LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
    700                          last_unsent->oversize_left >= oversize_used);
    701              last_unsent->oversize_left -= oversize_used;
    702          #endif /* TCP_OVERSIZE_DBGCHECK */
    703            }
    704            pcb->unsent_oversize = oversize;
    705          #endif /* TCP_OVERSIZE */
    706          
    707            /*
    708             * Phase 2: concat_p can be concatenated onto last_unsent->p
    709             */
    710            if (concat_p != NULL) {
    711              LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
    712                (last_unsent != NULL));
    713              pbuf_cat(last_unsent->p, concat_p);
    714              last_unsent->len += concat_p->tot_len;
    715          #if TCP_CHECKSUM_ON_COPY
    716              if (concat_chksummed) {
    717                /*if concat checksumm swapped - swap it back */
    718                if (concat_chksum_swapped){
    719                  concat_chksum = SWAP_BYTES_IN_WORD(concat_chksum);
    720                }
    721                tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
    722                  &last_unsent->chksum_swapped);
    723                last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
    724              }
    725          #endif /* TCP_CHECKSUM_ON_COPY */
    726            }
    727          
    728            /*
    729             * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
    730             * is harmless
    731             */
    732            if (last_unsent == NULL) {
    733              pcb->unsent = queue;
    734            } else {
    735              last_unsent->next = queue;
    736            }
    737          
    738            /*
    739             * Finally update the pcb state.
    740             */
    741            pcb->snd_lbb += len;
    742            pcb->snd_buf -= len;
    743            pcb->snd_queuelen = queuelen;
    744          
    745            LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
    746              pcb->snd_queuelen));
    747            if (pcb->snd_queuelen != 0) {
    748              LWIP_ASSERT("tcp_write: valid queue length",
    749                          pcb->unacked != NULL || pcb->unsent != NULL);
    750            }
    751          
    752            /* Set the PSH flag in the last segment that we enqueued. */
    753            if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    754              TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
    755            }
    756          
    757            return ERR_OK;
    758          memerr:
    759            pcb->flags |= TF_NAGLEMEMERR;
    760            TCP_STATS_INC(tcp.memerr);
    761          
    762            if (concat_p != NULL) {
    763              pbuf_free(concat_p);
    764            }
    765            if (queue != NULL) {
    766              tcp_segs_free(queue);
    767            }
    768            if (pcb->snd_queuelen != 0) {
    769              LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
    770                pcb->unsent != NULL);
    771            }
    772            LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
    773            return ERR_MEM;
    774          }
    775          
    776          /**
    777           * Enqueue TCP options for transmission.
    778           *
    779           * Called by tcp_connect(), tcp_listen_input(), and tcp_send_ctrl().
    780           *
    781           * @param pcb Protocol control block for the TCP connection.
    782           * @param flags TCP header flags to set in the outgoing segment.
    783           * @param optdata pointer to TCP options, or NULL.
    784           * @param optlen length of TCP options in bytes.
    785           */
    786          err_t
    787          tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
    788          {
    789            struct pbuf *p;
    790            struct tcp_seg *seg;
    791            u8_t optflags = 0;
    792            u8_t optlen = 0;
    793          
    794            LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
    795          
    796            LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
    797                        (flags & (TCP_SYN | TCP_FIN)) != 0);
    798          
    799            /* check for configured max queuelen and possible overflow (FIN flag should always come through!) */
    800            if (((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) &&
    801                ((flags & TCP_FIN) == 0)) {
    802              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
    803                                                 pcb->snd_queuelen, TCP_SND_QUEUELEN));
    804              TCP_STATS_INC(tcp.memerr);
    805              pcb->flags |= TF_NAGLEMEMERR;
    806              return ERR_MEM;
    807            }
    808          
    809            if (flags & TCP_SYN) {
    810              optflags = TF_SEG_OPTS_MSS;
    811          #if LWIP_WND_SCALE
    812              if ((pcb->state != SYN_RCVD) || (pcb->flags & TF_WND_SCALE)) {
    813                /* In a <SYN,ACK> (sent in state SYN_RCVD), the window scale option may only
    814                   be sent if we received a window scale option from the remote host. */
    815                optflags |= TF_SEG_OPTS_WND_SCALE;
    816              }
    817          #endif /* LWIP_WND_SCALE */
    818            }
    819          #if LWIP_TCP_TIMESTAMPS
    820            if ((pcb->flags & TF_TIMESTAMP)) {
    821              /* Make sure the timestamp option is only included in data segments if we
    822                 agreed about it with the remote host. */
    823              optflags |= TF_SEG_OPTS_TS;
    824            }
    825          #endif /* LWIP_TCP_TIMESTAMPS */
    826            optlen = LWIP_TCP_OPT_LENGTH(optflags);
    827          
    828            /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
    829             * We need one available snd_buf byte to do that.
    830             * This means we can't send FIN while snd_buf==0. A better fix would be to
    831             * not include SYN and FIN sequence numbers in the snd_buf count. */
    832            if (pcb->snd_buf == 0) {
    833              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
    834              TCP_STATS_INC(tcp.memerr);
    835              return ERR_MEM;
    836            }
    837          
    838            /* Allocate pbuf with room for TCP header + options */
    839            if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    840              pcb->flags |= TF_NAGLEMEMERR;
    841              TCP_STATS_INC(tcp.memerr);
    842              return ERR_MEM;
    843            }
    844            LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
    845                        (p->len >= optlen));
    846          
    847            /* Allocate memory for tcp_seg, and fill in fields. */
    848            if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    849              pcb->flags |= TF_NAGLEMEMERR;
    850              TCP_STATS_INC(tcp.memerr);
    851              return ERR_MEM;
    852            }
    853            LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
    854            LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
    855          
    856            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE,
    857                        ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
    858                         ntohl(seg->tcphdr->seqno),
    859                         ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
    860                         (u16_t)flags));
    861          
    862            /* Now append seg to pcb->unsent queue */
    863            if (pcb->unsent == NULL) {
    864              pcb->unsent = seg;
    865            } else {
    866              struct tcp_seg *useg;
    867              for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
    868              useg->next = seg;
    869            }
    870          #if TCP_OVERSIZE
    871            /* The new unsent tail has no space */
    872            pcb->unsent_oversize = 0;
    873          #endif /* TCP_OVERSIZE */
    874          
    875            /* SYN and FIN bump the sequence number */
    876            if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    877              pcb->snd_lbb++;
    878              /* optlen does not influence snd_buf */
    879              pcb->snd_buf--;
    880            }
    881            if (flags & TCP_FIN) {
    882              pcb->flags |= TF_FIN;
    883            }
    884          
    885            /* update number of segments on the queues */
    886            pcb->snd_queuelen += pbuf_clen(seg->p);
    887            LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
    888            if (pcb->snd_queuelen != 0) {
    889              LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
    890                pcb->unacked != NULL || pcb->unsent != NULL);
    891            }
    892          
    893            return ERR_OK;
    894          }
    895          
    896          #if LWIP_TCP_TIMESTAMPS
    897          /* Build a timestamp option (12 bytes long) at the specified options pointer)
    898           *
    899           * @param pcb tcp_pcb
    900           * @param opts option pointer where to store the timestamp option
    901           */
    902          static void
    903          tcp_build_timestamp_option(struct tcp_pcb *pcb, u32_t *opts)
    904          {
    905            /* Pad with two NOP options to make everything nicely aligned */
    906            opts[0] = PP_HTONL(0x0101080A);
    907            opts[1] = htonl(sys_now());
    908            opts[2] = htonl(pcb->ts_recent);
    909          }
    910          #endif
    911          
    912          #if LWIP_WND_SCALE
    913          /** Build a window scale option (3 bytes long) at the specified options pointer)
    914           *
    915           * @param opts option pointer where to store the window scale option
    916           */
    917          static void
    918          tcp_build_wnd_scale_option(u32_t *opts)
    919          {
    920            /* Pad with one NOP option to make everything nicely aligned */
    921            opts[0] = PP_HTONL(0x01030300 | TCP_RCV_SCALE);
    922          }
    923          #endif
    924          
    925          /** Send an ACK without data.
    926           *
    927           * @param pcb Protocol control block for the TCP connection to send the ACK
    928           */
    929          err_t
    930          tcp_send_empty_ack(struct tcp_pcb *pcb)
    931          {
    932            err_t err;
    933            struct pbuf *p;
    934            u8_t optlen = 0;
    935          #if LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP
    936            struct tcp_hdr *tcphdr;
    937          #endif /* LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP */
    938          
    939          #if LWIP_TCP_TIMESTAMPS
    940            if (pcb->flags & TF_TIMESTAMP) {
    941              optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
    942            }
    943          #endif
    944          
    945            p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
    946            if (p == NULL) {
    947              /* let tcp_fasttmr retry sending this ACK */
    948              pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
    949              LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    950              return ERR_BUF;
    951            }
    952          #if LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP
    953            tcphdr = (struct tcp_hdr *)p->payload;
    954          #endif /* LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP */
    955            LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
    956                        ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    957          
    958            /* NB. MSS and window scale options are only sent on SYNs, so ignore them here */
    959          #if LWIP_TCP_TIMESTAMPS
    960            pcb->ts_lastacksent = pcb->rcv_nxt;
    961          
    962            if (pcb->flags & TF_TIMESTAMP) {
    963              tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
    964            }
    965          #endif
    966          
    967          #if CHECKSUM_GEN_TCP
    968            tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
    969              &pcb->local_ip, &pcb->remote_ip);
    970          #endif
    971          #if LWIP_NETIF_HWADDRHINT
    972            err = ip_output_hinted(PCB_ISIPV6(pcb), p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, pcb->tos,
    973                IP_PROTO_TCP, &pcb->addr_hint);
    974          #else /* LWIP_NETIF_HWADDRHINT*/
    975            err = ip_output(PCB_ISIPV6(pcb), p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, pcb->tos,
    976                IP_PROTO_TCP);
    977          #endif /* LWIP_NETIF_HWADDRHINT*/
    978            pbuf_free(p);
    979          
    980            if (err != ERR_OK) {
    981              /* let tcp_fasttmr retry sending this ACK */
    982              pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
    983            } else {
    984              /* remove ACK flags from the PCB, as we sent an empty ACK now */
    985              pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    986            }
    987          
    988            return err;
    989          }
    990          
    991          /**
    992           * Find out what we can send and send it
    993           *
    994           * @param pcb Protocol control block for the TCP connection to send data
    995           * @return ERR_OK if data has been sent or nothing to send
    996           *         another err_t on error
    997           */
    998          err_t
    999          tcp_output(struct tcp_pcb *pcb)
   1000          {
   1001            struct tcp_seg *seg, *useg;
   1002            u32_t wnd, snd_nxt;
   1003            err_t err;
   1004          #if TCP_CWND_DEBUG
   1005            s16_t i = 0;
   1006          #endif /* TCP_CWND_DEBUG */
   1007          
   1008            /* pcb->state LISTEN not allowed here */
   1009            LWIP_ASSERT("don't call tcp_output for listen-pcbs",
   1010              pcb->state != LISTEN);
   1011          
   1012            /* First, check if we are invoked by the TCP input processing
   1013               code. If so, we do not output anything. Instead, we rely on the
   1014               input processing code to call us when input processing is done
   1015               with. */
   1016            if (tcp_input_pcb == pcb) {
   1017              return ERR_OK;
   1018            }
   1019          
   1020            wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
   1021          
   1022            seg = pcb->unsent;
   1023          
   1024            /* If the TF_ACK_NOW flag is set and no data will be sent (either
   1025             * because the ->unsent queue is empty or because the window does
   1026             * not allow it), construct an empty ACK segment and send it.
   1027             *
   1028             * If data is to be sent, we will just piggyback the ACK (see below).
   1029             */
   1030            if (pcb->flags & TF_ACK_NOW &&
   1031               (seg == NULL ||
   1032                ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
   1033               return tcp_send_empty_ack(pcb);
   1034            }
   1035          
   1036            /* useg should point to last segment on unacked queue */
   1037            useg = pcb->unacked;
   1038            if (useg != NULL) {
   1039              for (; useg->next != NULL; useg = useg->next);
   1040            }
   1041          
   1042          #if TCP_OUTPUT_DEBUG
   1043            if (seg == NULL) {
   1044              LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
   1045                                             (void*)pcb->unsent));
   1046            }
   1047          #endif /* TCP_OUTPUT_DEBUG */
   1048          #if TCP_CWND_DEBUG
   1049            if (seg == NULL) {
   1050              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"TCPWNDSIZE_F
   1051                                           ", cwnd %"TCPWNDSIZE_F", wnd %"U32_F
   1052                                           ", seg == NULL, ack %"U32_F"\n",
   1053                                           pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
   1054            } else {
   1055              LWIP_DEBUGF(TCP_CWND_DEBUG,
   1056                          ("tcp_output: snd_wnd %"TCPWNDSIZE_F", cwnd %"TCPWNDSIZE_F", wnd %"U32_F
   1057                           ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
   1058                           pcb->snd_wnd, pcb->cwnd, wnd,
   1059                           ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
   1060                           ntohl(seg->tcphdr->seqno), pcb->lastack));
   1061            }
   1062          #endif /* TCP_CWND_DEBUG */
   1063            /* data available and window allows it to be sent? */
   1064            while (seg != NULL &&
   1065                   ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
   1066              LWIP_ASSERT("RST not expected here!",
   1067                          (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
   1068              /* Stop sending if the nagle algorithm would prevent it
   1069               * Don't stop:
   1070               * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
   1071               * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
   1072               *   either seg->next != NULL or pcb->unacked == NULL;
   1073               *   RST is no sent using tcp_write/tcp_output.
   1074               */
   1075              if((tcp_do_output_nagle(pcb) == 0) &&
   1076                ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
   1077                break;
   1078              }
   1079          #if TCP_CWND_DEBUG
   1080              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"TCPWNDSIZE_F", cwnd %"TCPWNDSIZE_F", wnd %"U32_F", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"S16_F"\n",
   1081                                      pcb->snd_wnd, pcb->cwnd, wnd,
   1082                                      ntohl(seg->tcphdr->seqno) + seg->len -
   1083                                      pcb->lastack,
   1084                                      ntohl(seg->tcphdr->seqno), pcb->lastack, i));
   1085              ++i;
   1086          #endif /* TCP_CWND_DEBUG */
   1087          
   1088              if (pcb->state != SYN_SENT) {
   1089                TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
   1090              }
   1091          
   1092          #if TCP_OVERSIZE_DBGCHECK
   1093              seg->oversize_left = 0;
   1094          #endif /* TCP_OVERSIZE_DBGCHECK */
   1095              err = tcp_output_segment(seg, pcb);
   1096              if (err != ERR_OK) {
   1097                /* segment could not be sent, for whatever reason */
   1098                pcb->flags |= TF_NAGLEMEMERR;
   1099                return err;
   1100              }
   1101              pcb->unsent = seg->next;
   1102              if (pcb->state != SYN_SENT) {
   1103                pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
   1104              }
   1105              snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
   1106              if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
   1107                pcb->snd_nxt = snd_nxt;
   1108              }
   1109              /* put segment on unacknowledged list if length > 0 */
   1110              if (TCP_TCPLEN(seg) > 0) {
   1111                seg->next = NULL;
   1112                /* unacked list is empty? */
   1113                if (pcb->unacked == NULL) {
   1114                  pcb->unacked = seg;
   1115                  useg = seg;
   1116                /* unacked list is not empty? */
   1117                } else {
   1118                  /* In the case of fast retransmit, the packet should not go to the tail
   1119                   * of the unacked queue, but rather somewhere before it. We need to check for
   1120                   * this case. -STJ Jul 27, 2004 */
   1121                  if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
   1122                    /* add segment to before tail of unacked list, keeping the list sorted */
   1123                    struct tcp_seg **cur_seg = &(pcb->unacked);
   1124                    while (*cur_seg &&
   1125                      TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
   1126                        cur_seg = &((*cur_seg)->next );
   1127                    }
   1128                    seg->next = (*cur_seg);
   1129                    (*cur_seg) = seg;
   1130                  } else {
   1131                    /* add segment to tail of unacked list */
   1132                    useg->next = seg;
   1133                    useg = useg->next;
   1134                  }
   1135                }
   1136              /* do not queue empty segments on the unacked list */
   1137              } else {
   1138                tcp_seg_free(seg);
   1139              }
   1140              seg = pcb->unsent;
   1141            }
   1142          #if TCP_OVERSIZE
   1143            if (pcb->unsent == NULL) {
   1144              /* last unsent has been removed, reset unsent_oversize */
   1145              pcb->unsent_oversize = 0;
   1146            }
   1147          #endif /* TCP_OVERSIZE */
   1148          
   1149            pcb->flags &= ~TF_NAGLEMEMERR;
   1150            return ERR_OK;
   1151          }
   1152          
   1153          /**
   1154           * Called by tcp_output() to actually send a TCP segment over IP.
   1155           *
   1156           * @param seg the tcp_seg to send
   1157           * @param pcb the tcp_pcb for the TCP connection used to send the segment
   1158           */
   1159          static err_t
   1160          tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
   1161          {
   1162            err_t err;
   1163            u16_t len;
   1164            u32_t *opts;
   1165          
   1166            /** @bug Exclude retransmitted segments from this count. */
   1167            snmp_inc_tcpoutsegs();
   1168          
   1169            /* The TCP header has already been constructed, but the ackno and
   1170             wnd fields remain. */
   1171            seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
   1172          
   1173            /* advertise our receive window size in this TCP segment */
   1174          #if LWIP_WND_SCALE
   1175            if (seg->flags & TF_SEG_OPTS_WND_SCALE) {
   1176              /* The Window field in a SYN segment itself (the only type where we send
   1177                 the window scale option) is never scaled. */
   1178              seg->tcphdr->wnd = htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
   1179            } else
   1180          #endif /* LWIP_WND_SCALE */
   1181            {
   1182              seg->tcphdr->wnd = htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
   1183            }
   1184          
   1185            pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
   1186          
   1187            /* Add any requested options.  NB MSS option is only set on SYN
   1188               packets, so ignore it here */
   1189            opts = (u32_t *)(void *)(seg->tcphdr + 1);
   1190            if (seg->flags & TF_SEG_OPTS_MSS) {
   1191              u16_t mss;
   1192          #if TCP_CALCULATE_EFF_SEND_MSS
   1193              mss = tcp_eff_send_mss(TCP_MSS, &pcb->local_ip, &pcb->remote_ip, PCB_ISIPV6(pcb));
   1194          #else /* TCP_CALCULATE_EFF_SEND_MSS */
   1195              mss = TCP_MSS;
   1196          #endif /* TCP_CALCULATE_EFF_SEND_MSS */
   1197              *opts = TCP_BUILD_MSS_OPTION(mss);
   1198              opts += 1;
   1199            }
   1200          #if LWIP_TCP_TIMESTAMPS
   1201            pcb->ts_lastacksent = pcb->rcv_nxt;
   1202          
   1203            if (seg->flags & TF_SEG_OPTS_TS) {
   1204              tcp_build_timestamp_option(pcb, opts);
   1205              opts += 3;
   1206            }
   1207          #endif
   1208          #if LWIP_WND_SCALE
   1209            if (seg->flags & TF_SEG_OPTS_WND_SCALE) {
   1210              tcp_build_wnd_scale_option(opts);
   1211              opts += 1;
   1212            }
   1213          #endif
   1214          
   1215            /* Set retransmission timer running if it is not currently enabled
   1216               This must be set before checking the route. */
   1217            if (pcb->rtime == -1) {
   1218              pcb->rtime = 0;
   1219            }
   1220          
   1221            /* If we don't have a local IP address, we get one by
   1222               calling ip_route(). */
   1223            if (ip_addr_isany(&pcb->local_ip)) {
   1224              struct netif *netif;
   1225              ip_addr_t *local_ip;
   1226              
   1227          #if ((defined MTK_TCPIP_FOR_EXTERNAL_MODULE_ENABLE) && (defined LWIP_SOCKET_OPTION_BINDTODEVICE))
   1228              if (pcb->so_options & SO_BINDTODEVICE) {        
   1229                u16_t netif_num;
   1230                netif_num = (pcb->so_options) & (~SO_BINDTODEVICE);      
   1231          
   1232                if (netif_num > 0) {
   1233                  netif = netif_find_by_context_id(netif_num);
   1234                } else {
   1235                  /* wifi netif_num == 0, ip_route */
   1236                  ip_route_get_local_ip(PCB_ISIPV6(pcb), &pcb->local_ip, &pcb->remote_ip, netif, local_ip, &pcb->local_ip);
   1237                  if ((netif == NULL) || (local_ip == NULL)) {
   1238                    return ERR_RTE;
   1239                  }
   1240                }
   1241                
   1242                if (netif != NULL) {
   1243                  ip_addr_copy(pcb->local_ip, netif->ip_addr);
   1244                }
   1245                if (local_ip == NULL) {
   1246                  return ERR_RTE;
   1247                }
   1248              } else 
   1249          #endif /* LWIP_SOCKET_OPTION_BINDTODEVICE */
   1250              {
   1251              ip_route_get_local_ip(PCB_ISIPV6(pcb), &pcb->local_ip, &pcb->remote_ip, netif, local_ip, &pcb->local_ip);
   1252              if ((netif == NULL) || (local_ip == NULL)) {
   1253                return ERR_RTE;
   1254              }
   1255          #if !LWIP_IPV4 || !LWIP_IPV6
   1256              ip_addr_copy(pcb->local_ip, *local_ip);
   1257          #endif /* !LWIP_IPV4 || !LWIP_IPV6 */
   1258            }
   1259            }
   1260          
   1261            if (pcb->rttest == 0) {
   1262              pcb->rttest = tcp_ticks;
   1263              pcb->rtseq = ntohl(seg->tcphdr->seqno);
   1264          
   1265              LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
   1266            }
   1267            LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
   1268                    htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
   1269                    seg->len));
   1270          
   1271            len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
   1272          
   1273            seg->p->len -= len;
   1274            seg->p->tot_len -= len;
   1275          
   1276            seg->p->payload = seg->tcphdr;
   1277          
   1278            seg->tcphdr->chksum = 0;
   1279          #if TCP_CHECKSUM_ON_COPY
   1280            {
   1281              u32_t acc;
   1282          #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
   1283              u16_t chksum_slow = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
   1284                seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
   1285          #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
   1286              if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
   1287                LWIP_ASSERT("data included but not checksummed",
   1288                  seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
   1289              }
   1290          
   1291              /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
   1292              acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
   1293                seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4, &pcb->local_ip, &pcb->remote_ip);
   1294              /* add payload checksum */
   1295              if (seg->chksum_swapped) {
   1296                seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
   1297                seg->chksum_swapped = 0;
   1298              }
   1299              acc += (u16_t)~(seg->chksum);
   1300              seg->tcphdr->chksum = FOLD_U32T(acc);
   1301          #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
   1302              if (chksum_slow != seg->tcphdr->chksum) {
   1303                TCP_CHECKSUM_ON_COPY_SANITY_CHECK_FAIL(
   1304                            ("tcp_output_segment: calculated checksum is %"X16_F" instead of %"X16_F"\n",
   1305                            seg->tcphdr->chksum, chksum_slow));
   1306                seg->tcphdr->chksum = chksum_slow;
   1307              }
   1308          #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
   1309            }
   1310          #else /* TCP_CHECKSUM_ON_COPY */
   1311          #if CHECKSUM_GEN_TCP
   1312            seg->tcphdr->chksum = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
   1313              seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
   1314          #endif /* CHECKSUM_GEN_TCP */
   1315          #endif /* TCP_CHECKSUM_ON_COPY */
   1316            TCP_STATS_INC(tcp.xmit);
   1317          
   1318          #if LWIP_NETIF_HWADDRHINT
   1319            err = ip_output_hinted(PCB_ISIPV6(pcb), seg->p, &pcb->local_ip, &pcb->remote_ip,
   1320              pcb->ttl, pcb->tos, IP_PROTO_TCP, &pcb->addr_hint);
   1321          #else /* LWIP_NETIF_HWADDRHINT*/
   1322            err = ip_output(PCB_ISIPV6(pcb), seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
   1323              pcb->tos, IP_PROTO_TCP);
   1324          #endif /* LWIP_NETIF_HWADDRHINT*/
   1325            return err;
   1326          }
   1327          
   1328          /**
   1329           * Send a TCP RESET packet (empty segment with RST flag set) either to
   1330           * abort a connection or to show that there is no matching local connection
   1331           * for a received segment.
   1332           *
   1333           * Called by tcp_abort() (to abort a local connection), tcp_input() (if no
   1334           * matching local pcb was found), tcp_listen_input() (if incoming segment
   1335           * has ACK flag set) and tcp_process() (received segment in the wrong state)
   1336           *
   1337           * Since a RST segment is in most cases not sent for an active connection,
   1338           * tcp_rst() has a number of arguments that are taken from a tcp_pcb for
   1339           * most other segment output functions.
   1340           *
   1341           * @param seqno the sequence number to use for the outgoing segment
   1342           * @param ackno the acknowledge number to use for the outgoing segment
   1343           * @param local_ip the local IP address to send the segment from
   1344           * @param remote_ip the remote IP address to send the segment to
   1345           * @param local_port the local TCP port to send the segment from
   1346           * @param remote_port the remote TCP port to send the segment to
   1347           */
   1348          void
   1349          tcp_rst(u32_t seqno, u32_t ackno,
   1350            const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
   1351            u16_t local_port, u16_t remote_port)
   1352          {
   1353            struct pbuf *p;
   1354            struct tcp_hdr *tcphdr;
   1355            p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   1356            if (p == NULL) {
   1357                LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
   1358                return;
   1359            }
   1360            LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
   1361                        (p->len >= sizeof(struct tcp_hdr)));
   1362          
   1363            tcphdr = (struct tcp_hdr *)p->payload;
   1364            tcphdr->src = htons(local_port);
   1365            tcphdr->dest = htons(remote_port);
   1366            tcphdr->seqno = htonl(seqno);
   1367            tcphdr->ackno = htonl(ackno);
   1368            TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
   1369          #if LWIP_WND_SCALE
   1370            tcphdr->wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
   1371          #else
   1372            tcphdr->wnd = PP_HTONS(TCP_WND);
   1373          #endif
   1374            tcphdr->chksum = 0;
   1375            tcphdr->urgp = 0;
   1376          
   1377            TCP_STATS_INC(tcp.xmit);
   1378            snmp_inc_tcpoutrsts();
   1379          
   1380          #if CHECKSUM_GEN_TCP
   1381            tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
   1382                                               local_ip, remote_ip);
   1383          #endif
   1384            /* Send output with hardcoded TTL/HL since we have no access to the pcb */
   1385            ip_output(IP_IS_V6(remote_ip), p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
   1386            pbuf_free(p);
   1387            LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
   1388          }
   1389          
   1390          /**
   1391           * Requeue all unacked segments for retransmission
   1392           *
   1393           * Called by tcp_slowtmr() for slow retransmission.
   1394           *
   1395           * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
   1396           */
   1397          void
   1398          tcp_rexmit_rto(struct tcp_pcb *pcb)
   1399          {
   1400            struct tcp_seg *seg;
   1401          
   1402            if (pcb->unacked == NULL) {
   1403              return;
   1404            }
   1405          
   1406            /* Move all unacked segments to the head of the unsent queue */
   1407            for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
   1408            /* concatenate unsent queue after unacked queue */
   1409            seg->next = pcb->unsent;
   1410          #if TCP_OVERSIZE && TCP_OVERSIZE_DBGCHECK
   1411            /* if last unsent changed, we need to update unsent_oversize */
   1412            if (pcb->unsent == NULL) {
   1413              pcb->unsent_oversize = seg->oversize_left;
   1414            }
   1415          #endif /* TCP_OVERSIZE && TCP_OVERSIZE_DBGCHECK*/
   1416            /* unsent queue is the concatenated queue (of unacked, unsent) */
   1417            pcb->unsent = pcb->unacked;
   1418            /* unacked queue is now empty */
   1419            pcb->unacked = NULL;
   1420          
   1421            /* increment number of retransmissions */
   1422            ++pcb->nrtx;
   1423          
   1424            /* Don't take any RTT measurements after retransmitting. */
   1425            pcb->rttest = 0;
   1426          
   1427            /* Do the actual retransmission */
   1428            tcp_output(pcb);
   1429          }
   1430          
   1431          /**
   1432           * Requeue the first unacked segment for retransmission
   1433           *
   1434           * Called by tcp_receive() for fast retramsmit.
   1435           *
   1436           * @param pcb the tcp_pcb for which to retransmit the first unacked segment
   1437           */
   1438          void
   1439          tcp_rexmit(struct tcp_pcb *pcb)
   1440          {
   1441            struct tcp_seg *seg;
   1442            struct tcp_seg **cur_seg;
   1443          
   1444            if (pcb->unacked == NULL) {
   1445              return;
   1446            }
   1447          
   1448            /* Move the first unacked segment to the unsent queue */
   1449            /* Keep the unsent queue sorted. */
   1450            seg = pcb->unacked;
   1451            pcb->unacked = seg->next;
   1452          
   1453            cur_seg = &(pcb->unsent);
   1454            while (*cur_seg &&
   1455              TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
   1456                cur_seg = &((*cur_seg)->next );
   1457            }
   1458            seg->next = *cur_seg;
   1459            *cur_seg = seg;
   1460          #if TCP_OVERSIZE
   1461            if (seg->next == NULL) {
   1462              /* the retransmitted segment is last in unsent, so reset unsent_oversize */
   1463              pcb->unsent_oversize = 0;
   1464            }
   1465          #endif /* TCP_OVERSIZE */
   1466          
   1467            ++pcb->nrtx;
   1468          
   1469            /* Don't take any rtt measurements after retransmitting. */
   1470            pcb->rttest = 0;
   1471          
   1472            /* Do the actual retransmission. */
   1473            snmp_inc_tcpretranssegs();
   1474            /* No need to call tcp_output: we are always called from tcp_input()
   1475               and thus tcp_output directly returns. */
   1476          }
   1477          
   1478          
   1479          /**
   1480           * Handle retransmission after three dupacks received
   1481           *
   1482           * @param pcb the tcp_pcb for which to retransmit the first unacked segment
   1483           */
   1484          void
   1485          tcp_rexmit_fast(struct tcp_pcb *pcb)
   1486          {
   1487            if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
   1488              /* This is fast retransmit. Retransmit the first unacked segment. */
   1489              LWIP_DEBUGF(TCP_FR_DEBUG,
   1490                          ("tcp_receive: dupacks %"U16_F" (%"U32_F
   1491                           "), fast retransmit %"U32_F"\n",
   1492                           (u16_t)pcb->dupacks, pcb->lastack,
   1493                           ntohl(pcb->unacked->tcphdr->seqno)));
   1494              tcp_rexmit(pcb);
   1495          
   1496              /* Set ssthresh to half of the minimum of the current
   1497               * cwnd and the advertised window */
   1498              if (pcb->cwnd > pcb->snd_wnd) {
   1499                pcb->ssthresh = pcb->snd_wnd / 2;
   1500              } else {
   1501                pcb->ssthresh = pcb->cwnd / 2;
   1502              }
   1503          
   1504              /* The minimum value for ssthresh should be 2 MSS */
   1505              if (pcb->ssthresh < (2U * pcb->mss)) {
   1506                LWIP_DEBUGF(TCP_FR_DEBUG,
   1507                            ("tcp_receive: The minimum value for ssthresh %"U16_F
   1508                             " should be min 2 mss %"U16_F"...\n",
   1509                             pcb->ssthresh, 2*pcb->mss));
   1510                pcb->ssthresh = 2*pcb->mss;
   1511              }
   1512          
   1513              pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
   1514              pcb->flags |= TF_INFR;
   1515            }
   1516          }
   1517          
   1518          
   1519          /**
   1520           * Send keepalive packets to keep a connection active although
   1521           * no data is sent over it.
   1522           *
   1523           * Called by tcp_slowtmr()
   1524           *
   1525           * @param pcb the tcp_pcb for which to send a keepalive packet
   1526           */
   1527          err_t
   1528          tcp_keepalive(struct tcp_pcb *pcb)
   1529          {
   1530            err_t err;
   1531            struct pbuf *p;
   1532          #if CHECKSUM_GEN_TCP
   1533            struct tcp_hdr *tcphdr;
   1534          #endif /* CHECKSUM_GEN_TCP */
   1535          
   1536            LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to "));
   1537            ip_addr_debug_print(TCP_DEBUG, &pcb->remote_ip);
   1538            LWIP_DEBUGF(TCP_DEBUG, ("\n"));
   1539          
   1540            LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
   1541                                    tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   1542          
   1543            p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
   1544            if(p == NULL) {
   1545              LWIP_DEBUGF(TCP_DEBUG,
   1546                          ("tcp_keepalive: could not allocate memory for pbuf\n"));
   1547              return ERR_MEM;
   1548            }
   1549          #if CHECKSUM_GEN_TCP
   1550            tcphdr = (struct tcp_hdr *)p->payload;
   1551          
   1552            tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
   1553                &pcb->local_ip, &pcb->remote_ip);
   1554          #endif /* CHECKSUM_GEN_TCP */
   1555            TCP_STATS_INC(tcp.xmit);
   1556          
   1557            /* Send output to IP */
   1558          #if LWIP_NETIF_HWADDRHINT
   1559            err = ip_output_hinted(PCB_ISIPV6(pcb), p, &pcb->local_ip, &pcb->remote_ip,
   1560              pcb->ttl, 0, IP_PROTO_TCP, &pcb->addr_hint);
   1561          #else /* LWIP_NETIF_HWADDRHINT*/
   1562            err = ip_output(PCB_ISIPV6(pcb), p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
   1563              0, IP_PROTO_TCP);
   1564          #endif /* LWIP_NETIF_HWADDRHINT*/
   1565          
   1566            pbuf_free(p);
   1567          
   1568            LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
   1569                                    pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
   1570            return err;
   1571          }
   1572          
   1573          
   1574          /**
   1575           * Send persist timer zero-window probes to keep a connection active
   1576           * when a window update is lost.
   1577           *
   1578           * Called by tcp_slowtmr()
   1579           *
   1580           * @param pcb the tcp_pcb for which to send a zero-window probe packet
   1581           */
   1582          err_t
   1583          tcp_zero_window_probe(struct tcp_pcb *pcb)
   1584          {
   1585            err_t err;
   1586            struct pbuf *p;
   1587            struct tcp_hdr *tcphdr;
   1588            struct tcp_seg *seg;
   1589            u16_t len;
   1590            u8_t is_fin;
   1591          
   1592            LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: sending ZERO WINDOW probe to "));
   1593            ip_addr_debug_print(TCP_DEBUG, &pcb->remote_ip);
   1594            LWIP_DEBUGF(TCP_DEBUG, ("\n"));
   1595          
   1596            LWIP_DEBUGF(TCP_DEBUG,
   1597                        ("tcp_zero_window_probe: tcp_ticks %"U32_F
   1598                         "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
   1599                         tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   1600          
   1601            seg = pcb->unacked;
   1602          
   1603            if(seg == NULL) {
   1604              seg = pcb->unsent;
   1605            }
   1606            if(seg == NULL) {
   1607              /* nothing to send, zero window probe not needed */
   1608              return ERR_OK;
   1609            }
   1610          
   1611            is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
   1612            /* we want to send one seqno: either FIN or data (no options) */
   1613            len = is_fin ? 0 : 1;
   1614          
   1615            p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
   1616            if(p == NULL) {
   1617              LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
   1618              return ERR_MEM;
   1619            }
   1620            tcphdr = (struct tcp_hdr *)p->payload;
   1621          
   1622            if (is_fin) {
   1623              /* FIN segment, no data */
   1624              TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
   1625            } else {
   1626              /* Data segment, copy in one byte from the head of the unacked queue */
   1627              char *d = ((char *)p->payload + TCP_HLEN);
   1628              /* Depending on whether the segment has already been sent (unacked) or not
   1629                 (unsent), seg->p->payload points to the IP header or TCP header.
   1630                 Ensure we copy the first TCP data byte: */
   1631              pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
   1632            }
   1633          
   1634          #if CHECKSUM_GEN_TCP
   1635            tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
   1636                &pcb->local_ip, &pcb->remote_ip);
   1637          #endif
   1638            TCP_STATS_INC(tcp.xmit);
   1639          
   1640            /* Send output to IP */
   1641          #if LWIP_NETIF_HWADDRHINT
   1642            err = ip_output_hinted(PCB_ISIPV6(pcb), p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
   1643              0, IP_PROTO_TCP, &pcb->addr_hint);
   1644          #else /* LWIP_NETIF_HWADDRHINT*/
   1645            err = ip_output(PCB_ISIPV6(pcb), p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
   1646          #endif /* LWIP_NETIF_HWADDRHINT*/
   1647          
   1648            pbuf_free(p);
   1649          
   1650            LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
   1651                                    " ackno %"U32_F" err %d.\n",
   1652                                    pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
   1653            return err;
   1654          }
   1655          #endif /* LWIP_TCP */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   tcp_build_wnd_scale_option
      32   tcp_create_segment
        32   -> lwip_htonl
        32   -> lwip_htons
        32   -> mem_malloc
        32   -> pbuf_free
        32   -> pbuf_header
        32   -> printf
        32   -> tcp_seg_free
      40   tcp_enqueue_flags
        40   -> pbuf_alloc
        40   -> pbuf_clen
        40   -> printf
        40   -> tcp_create_segment
      24   tcp_keepalive
        24   -> ip4_output
        24   -> ip_chksum_pseudo
        24   -> lwip_htonl
        24   -> pbuf_free
        24   -> tcp_output_alloc_header
      40   tcp_output
        40   -> lwip_htons
        40   -> lwip_ntohl
        40   -> lwip_ntohs
        40   -> printf
        40   -> tcp_output_segment
        40   -> tcp_seg_free
         0   -> tcp_send_empty_ack
      32   tcp_output_alloc_header
        32   -> lwip_htonl
        32   -> lwip_htons
        32   -> pbuf_alloc
        32   -> printf
      24   tcp_output_segment
        24   -> ip4_output
        24   -> ip4_route
        24   -> ip_chksum_pseudo
        24   -> lwip_htonl
        24   -> lwip_htons
        24   -> lwip_ntohl
        24   -> tcp_build_wnd_scale_option
        24   -> tcp_eff_send_mss_impl
      16   tcp_pbuf_prealloc
        16   -> pbuf_alloc
        16   -> printf
      24   tcp_rexmit
        24   -> lwip_ntohl
       8   tcp_rexmit_fast
         8   -> tcp_rexmit
       0   tcp_rexmit_rto
         0   -> tcp_output
      40   tcp_rst
        40   -> ip4_output
        40   -> ip_chksum_pseudo
        40   -> lwip_htonl
        40   -> lwip_htons
        40   -> pbuf_alloc
         0   -> pbuf_free
        40   -> printf
      24   tcp_send_empty_ack
        24   -> ip4_output
        24   -> ip_chksum_pseudo
        24   -> lwip_htonl
        24   -> pbuf_free
        24   -> tcp_output_alloc_header
      16   tcp_send_fin
        16   -> lwip_htons
        16   -> lwip_ntohs
         0   -> tcp_enqueue_flags
      88   tcp_write
        88   -> __aeabi_memcpy
        88   -> lwip_htons
        88   -> pbuf_alloc
        88   -> pbuf_cat
        88   -> pbuf_clen
        88   -> pbuf_free
        88   -> printf
        88   -> tcp_create_segment
        88   -> tcp_pbuf_prealloc
        88   -> tcp_segs_free
        88   -> tcp_write_checks
       8   tcp_write_checks
         8   -> printf
      32   tcp_zero_window_probe
        32   -> ip4_output
        32   -> ip_chksum_pseudo
        32   -> lwip_htons
        32   -> lwip_ntohs
        32   -> pbuf_copy_partial
        32   -> pbuf_free
        32   -> tcp_output_alloc_header


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable31
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_2
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       4  ??DataTable34_3
      40  ?_0
      48  ?_1
      48  ?_10
      64  ?_11
      16  ?_12
      20  ?_13
      56  ?_14
      32  ?_15
      88  ?_16
      60  ?_17
      24  ?_18
      44  ?_19
      76  ?_2
      40  ?_20
      40  ?_21
      24  ?_22
      24  ?_3
      20  ?_4
      60  ?_5
      52  ?_6
      52  ?_7
      24  ?_8
      32  ?_9
       8  tcp_build_wnd_scale_option
     218  tcp_create_segment
     448  tcp_enqueue_flags
      98  tcp_keepalive
     578  tcp_output
     184  tcp_output_alloc_header
     292  tcp_output_segment
     130  tcp_pbuf_prealloc
      80  tcp_rexmit
      78  tcp_rexmit_fast
      44  tcp_rexmit_rto
     170  tcp_rst
     114  tcp_send_empty_ack
      70  tcp_send_fin
    1168  tcp_write
     170  tcp_write_checks
     196  tcp_zero_window_probe

 
 5 070 bytes in section .text
 
 5 070 bytes of CODE memory

Errors: none
Warnings: 5
