###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       25/Jan/2017  17:35:14
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\driver\chip\mt7687\src\common\low_hal_pwm.c
#    Command line =  
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\driver\chip\mt7687\src\common\low_hal_pwm.c" -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_WIFI_TGN_VERIFY_ENABLE -D MTK_SMTCN_ENABLE -D
#        MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D SUPPORT_MBEDTLS -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-basic.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D MTK_MCS_ENABLE -D MTK_BLE_GPIO_SERVICE -D
#        __BT_DEBUG__ -lcN "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List" -lA
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List"
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj" --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\inc\" -I
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\service\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\dhcpd\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\src\ut_app\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\httpclient\inc\"
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List\low_hal_pwm.lst
#    Object file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj\low_hal_pwm.o
#
###############################################################################

C:\LEO\myGit\MTK IOT\SDK_V4.2.0\driver\chip\mt7687\src\common\low_hal_pwm.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          /*
     36          ** $Log: hal_PWM.c $
     37          **
     38          ** 04 23 2015 morris.yeh
     39          ** [PWM]
     40          ** refine code for wake up test command
     41          **
     42          ** 04 20 2015 morris.yeh
     43          ** [PWM]
     44          ** Add test command for wake up test
     45          **
     46          ** 04 02 2015 leo.hung
     47          ** [DVT][PWM]
     48          ** 1. Remove VOID halPWMPinmuxConfig().
     49          ** 2. Set XTAL related CR for PWM.
     50          ** 3. Update PWM test case.
     51          **
     52          ** 02 06 2015 leo.hung
     53          ** [DVT][PWM]
     54          ** 1. Refine code.
     55          **
     56          ** 02 06 2015 morris.yeh
     57          ** [PWM]
     58          ** modify hal PWM AON pinmux config
     59          **
     60          ** 01 15 2015 morris.yeh
     61          ** [PWM]
     62          ** refine AON domain pinmux config
     63          **
     64          ** 12 25 2014 leo.hung
     65          ** [DVT][PWM]
     66          ** 1. Relocate PWM base address to AON domain.
     67          **
     68          ** 12 11 2014 leo.hung
     69          ** [DVT][PWM].
     70          ** 1. Fix global reset.
     71          ** 2. Add test case for global kick.
     72          **
     73          ** 12 08 2014 leo.hung
     74          ** [DVT][PWM][IRDA][RTC][Crypto]
     75          ** 1. Update PWM, IRDA, RTC Crypto_AES/DES.
     76          **
     77          ** 11 26 2014 morris.yeh
     78          ** [PWM]
     79          ** Add detail explanation of PWM formula
     80          **
     81          ** 11 14 2014 leo.hung
     82          ** [DVT][PWM]
     83          ** 1. Update PWM.
     84          **
     85          ** 11 11 2014 leo.hung
     86          ** [DVT][I2C][PWM]
     87          ** 1. Update I2C DMA mode.
     88          ** 2. Replace PWM field access with bit offset access.
     89          **
     90          **
     91          */
     92          
     93          /*******************************************************************************
     94          *                         C O M P I L E R   F L A G S
     95          ********************************************************************************
     96          */
     97          
     98          
     99          /*******************************************************************************
    100          *                    E X T E R N A L   R E F E R E N C E S
    101          ********************************************************************************
    102          */
    103          
    104          
    105          #include "hal_platform.h"
    106          #ifdef HAL_PWM_MODULE_ENABLED
    107          
    108          #include <string.h>
    109          #include "low_hal_pwm.h"
    110          #include "top.h"
    111          
    112          
    113          /*******************************************************************************
    114          *                              C O N S T A N T S
    115          ********************************************************************************
    116          */
    117          
    118          
    119          /*******************************************************************************
    120          *                             D A T A   T Y P E S
    121          ********************************************************************************
    122          */
    123          
    124          
    125          /*******************************************************************************
    126          *                            P U B L I C   D A T A
    127          ********************************************************************************
    128          */
    129          
    130          
    131          /*
    132          ========================================================================
    133          Routine Description:
    134          
    135          Note:
    136          ========================================================================
    137          */
    138          
    139          
    140          ENUM_HAL_RET_T halPWMResetAll()
    141          {
    142              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    143          
    144              // Write 1 and then write 0 to reset all PWM modules and its parameters (PWM_CTRL/PWM_PARAM_S0/PWM_PARAM_S1).
    145              HAL_REG_32(IOT_PWM_GLO_CTRL_ADDR) |= BIT(PWM_GLO_CTRL_PWM_GLOBAL_RESET_OFFSET);
    146              HAL_REG_32(IOT_PWM_GLO_CTRL_ADDR) &= (~BIT(PWM_GLO_CTRL_PWM_GLOBAL_RESET_OFFSET));
    147          
    148              return ret;
    149          
    150          }
    151          
    152          
    153          ENUM_HAL_RET_T halPWMClockSelect(ENUM_PWM_CLK_T ePwmClk)
    154          {
    155              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    156              UINT32 u4Val = 0;
    157          
    158              if (ePwmClk >= PWM_CLK_NUM) {
    159                  return HAL_RET_FAIL;
    160              }
    161          
    162              u4Val = HAL_REG_32(IOT_PWM_GLO_CTRL_ADDR);
    163              u4Val &= (~PWM_GLO_CTRL_PWM_TICK_CLOCK_SEL_MASK);
    164              u4Val |= (ePwmClk << PWM_GLO_CTRL_PWM_TICK_CLOCK_SEL_OFFSET);
    165              HAL_REG_32(IOT_PWM_GLO_CTRL_ADDR) = u4Val;
    166          
    167              return ret;
    168          }
    169          
    170          ENUM_HAL_RET_T halPWMEnable(UINT8 ucPwmIdx, UINT8 ucGlobalKick, UINT8 ucIOCtrl, UINT8 ucPolarity)
    171          {
    172              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    173              IOT_PWM_TypeDef *pCRAddr = NULL;
    174              UINT32 u4Val = 0;
    175          
    176              // pinmux setting for PWM should be configured by system level.
    177          
    178              pCRAddr = (P_IOT_PWM_TypeDef)(((PUINT8)IOT_PWM0_ADDR) + (IOT_PWM_OFFSET * ucPwmIdx));
    179          
    180              u4Val = (pCRAddr->PWM_CTRL);
    181              // Enable clock
    182              u4Val |= (BIT(PWM_CTRL_PWM_CLOCK_EN_OFFSET));
    183          
    184              // Configure PWM
    185              if (ucGlobalKick) {
    186                  u4Val |= (BIT(PWM_CTRL_PWM_GLOBAL_KICK_ENABLE_OFFSET));
    187              } else {
    188                  u4Val &= (~BIT(PWM_CTRL_PWM_GLOBAL_KICK_ENABLE_OFFSET));
    189              }
    190          
    191              if (ucIOCtrl) {
    192                  u4Val |= (BIT(PWM_CTRL_PWM_IO_CTRL_OFFSET));
    193              } else {
    194                  u4Val &= (~BIT(PWM_CTRL_PWM_IO_CTRL_OFFSET));
    195              }
    196          
    197              if (ucPolarity) {
    198                  u4Val |= (BIT(PWM_CTRL_POLARITY_OFFSET));
    199              } else {
    200                  u4Val &= (~BIT(PWM_CTRL_POLARITY_OFFSET));
    201              }
    202          
    203              (pCRAddr->PWM_CTRL) = u4Val;
    204          
    205          
    206              return ret;
    207          }
    208          
    209          ENUM_HAL_RET_T halPWMDisable(UINT8 ucPwmIdx)
    210          {
    211              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    212              IOT_PWM_TypeDef *pCRAddr = NULL;
    213          
    214              pCRAddr = (P_IOT_PWM_TypeDef)(((PUINT8)IOT_PWM0_ADDR) + (IOT_PWM_OFFSET * ucPwmIdx));
    215          
    216              // Disable clock
    217              (pCRAddr->PWM_CTRL) &= (~BIT(PWM_CTRL_PWM_CLOCK_EN_OFFSET));
    218          
    219              return ret;
    220          }
    221          
    222          ENUM_HAL_RET_T halPWMKick(UINT8 ucPwmIdx)
    223          {
    224              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    225              IOT_PWM_TypeDef *pCRAddr = NULL;
    226          
    227          
    228              pCRAddr = (P_IOT_PWM_TypeDef)(((PUINT8)IOT_PWM0_ADDR) + (IOT_PWM_OFFSET * ucPwmIdx));
    229          
    230              (pCRAddr->PWM_CTRL) |= (BIT(PWM_CTRL_KICK_OFFSET));
    231          
    232              return ret;
    233          }
    234          
    235          
    236          ENUM_HAL_RET_T halPWMConfig(UINT8 ucPwmIdx, ENUM_PWM_STATE_T eState, UINT16 u2DutyCycle, UINT32 u4PwmFreq)
    237          {
    238              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    239              ENUM_PWM_CLK_T ePwmClk = PWM_CLK_32K;
    240              UINT32 u4ClkFreq = 0;
    241              UINT32 u4PwmStep = 0;
    242              UINT16 u2OnTime = 0;
    243              UINT16 u2OffTime = 0;
    244              IOT_PWM_TypeDef *pCRAddr = NULL;
    245              UINT32 u4Val = 0;
    246          
    247              pCRAddr = (P_IOT_PWM_TypeDef)(((PUINT8)IOT_PWM0_ADDR) + (IOT_PWM_OFFSET * ucPwmIdx));
    248          
    249              ePwmClk = (ENUM_PWM_CLK_T)(((*IOT_PWM_GLO_CTRL_ADDR) & (PWM_GLO_CTRL_PWM_TICK_CLOCK_SEL_MASK)) >> PWM_GLO_CTRL_PWM_TICK_CLOCK_SEL_OFFSET);
    250          
    251              switch (ePwmClk) {
    252                  case PWM_CLK_32K:
    253                      u4ClkFreq = (32700);
    254                      break;
    255          
    256                  case PWM_CLK_2M:
    257                      u4ClkFreq = (2 * 1000 * 1000);
    258                      break;
    259          
    260                  case PWM_CLK_XTAL: {
    261                      UINT8 ucXtal = 0;
    262                      ucXtal = ((HAL_REG_32(TOP_AON_CM4_STRAP_STA) & CM4_STRAP_STA_XTAL_FREQ_MASK) >> CM4_STRAP_STA_XTAL_FREQ_OFFSET);
    263                      //printf("ucXtal=%d\n", ucXtal);
    264                      if (XTAL_FREQ_20M == ucXtal) {
    265                          u4ClkFreq = (20 * 1000 * 1000);
    266                      } else if (XTAL_FREQ_40M == ucXtal) {
    267                          u4ClkFreq = (40 * 1000 * 1000);
    268                      } else if (XTAL_FREQ_26M == ucXtal) {
    269                          u4ClkFreq = (26 * 1000 * 1000);
    270                      } else if (XTAL_FREQ_52M == ucXtal) {
    271                          u4ClkFreq = (52 * 1000 * 1000);
    272                      }
    273                  }
    274                  break;
    275          
    276                  default:
    277                      return HAL_RET_FAIL;
    278              }
    279          
    280              /*=====================================================
    281              T(second)	PWM period
    282              F (Hz)	    PWM frequency = 1/T
    283              t (second)  Tick clk period
    284              f (Hz)	    Tick clk frequency = 1/t
    285              D (%)	    Duty cycle
    286              X (unit t)	Value of configurable register pwm_on_time[15:0], in unit t
    287              Y (unit t)	Value of configurable register pwm_off_time[15:0], in unit t
    288              Res (step)	PWM resolution of duty cycle on certain F, f
    289          
    290              (X + Y) t = T
    291              (X + Y) = T/t = f/F =Res
    292              D = X/((X+Y))
    293              X = D(X+Y) =  Df/F
    294              Y = f/F - X = f/F - Df/F = ((1-D)f)/F
    295              =====================================================*/
    296          
    297              u4PwmStep = (u4ClkFreq / u4PwmFreq);
    298              u2OnTime =  u2DutyCycle;
    299              u2OffTime = u4PwmStep - u2OnTime;
    300          
    301              /* avoid hw limitation: when u2OffTime is 1, the next individual kick
    302                      for PWM #N invalid, pwm_global_reset can recover it */
    303              if (u2OffTime == 1) {
    304                  u2OffTime = 0;
    305                  u2OnTime += 1;
    306              }
    307          
    308              if (PWM_S0 == eState) {
    309                  u4Val = (pCRAddr->PWM_PARAM_S0);
    310                  u4Val &= (~PWM_PARAM_S0_PWM_OFF_TIME_MASK);
    311                  u4Val |= (u2OffTime << PWM_PARAM_S0_PWM_OFF_TIME_OFFSET);
    312                  u4Val &= (~PWM_PARAM_S0_PWM_ON_TIME_MASK);
    313                  u4Val |= (u2OnTime << PWM_PARAM_S0_PWM_ON_TIME_OFFSET);
    314                  (pCRAddr->PWM_PARAM_S0) = u4Val;
    315              } else {
    316                  u4Val = (pCRAddr->PWM_PARAM_S1);
    317                  u4Val &= (~PWM_PARAM_S1_PWM_OFF_TIME_MASK);
    318                  u4Val |= (u2OffTime << PWM_PARAM_S1_PWM_OFF_TIME_OFFSET);
    319                  u4Val &= (~PWM_PARAM_S1_PWM_ON_TIME_MASK);
    320                  u4Val |= (u2OnTime << PWM_PARAM_S1_PWM_ON_TIME_OFFSET);
    321                  (pCRAddr->PWM_PARAM_S1) = u4Val;
    322              }
    323          
    324              //printf("[%s]u4ClkFreq=%u, u4PwmFreq=%u, ucDutyCycle=%u, u2OnTime=%u, u2OffTime=%u\n", __FUNCTION__, u4ClkFreq, u4PwmFreq, u2DutyCycle,u2OnTime, u2OffTime);
    325          
    326              return ret;
    327          }
    328          
    329          ENUM_HAL_RET_T halPWMStateConfig(UINT8 ucPwmIdx, UINT16 u2S0StayCycle, UINT16 u2S1StayCycle, UINT8 ucReplayMode)
    330          {
    331              ENUM_HAL_RET_T  ret = HAL_RET_SUCCESS;
    332              IOT_PWM_TypeDef *pCRAddr = NULL;
    333              UINT32 u4Val = 0;
    334          
    335          
    336              // stay cycle register only has 12 bits
    337              if ((u2S0StayCycle & 0xF000) || ((u2S1StayCycle & 0xF000))) {
    338                  return HAL_RET_FAIL;
    339              }
    340          
    341              pCRAddr = (P_IOT_PWM_TypeDef)(((PUINT8)IOT_PWM0_ADDR) + (IOT_PWM_OFFSET * ucPwmIdx));
    342              u4Val = (pCRAddr->PWM_CTRL);
    343          
    344              u4Val &= (~PWM_CTRL_S0_STAY_CYCLE_MASK);
    345              u4Val |= (u2S0StayCycle << PWM_CTRL_S0_STAY_CYCLE_OFFSET);
    346          
    347              u4Val &= (~PWM_CTRL_S1_STAY_CYCLE_MASK);
    348              u4Val |= (u2S1StayCycle << PWM_CTRL_S1_STAY_CYCLE_OFFSET);
    349          
    350              if (ucReplayMode) {
    351                  u4Val |= (BIT(PWM_CTRL_REPLAY_MODE_OFFSET));
    352              } else {
    353                  u4Val &= (~BIT(PWM_CTRL_REPLAY_MODE_OFFSET));
    354              }
    355              (pCRAddr->PWM_CTRL) = u4Val;
    356          
    357              return ret;
    358          }
    359          
    360          
    361          
    362          ENUM_HAL_RET_T halPWMQuery(UINT8 ucPwmIdx, ENUM_PWM_STATE_T eState, UINT16 *pu2DutyCycle, UINT32 *pu4PwmFreq, UINT8 *pucEnable)
    363          {
    364              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    365              ENUM_PWM_CLK_T ePwmClk = PWM_CLK_32K;
    366              UINT32 u4ClkFreq = 0;
    367              UINT32 u4PwmStep = 0;
    368              UINT16 u2OnTime = 0;
    369              UINT16 u2OffTime = 0;
    370              IOT_PWM_TypeDef *pCRAddr = NULL;
    371              UINT32 u4Val = 0;
    372          
    373              pCRAddr = (P_IOT_PWM_TypeDef)(((PUINT8)IOT_PWM0_ADDR) + (IOT_PWM_OFFSET * ucPwmIdx));
    374          
    375              u4Val = (pCRAddr->PWM_CTRL);// &= (~BIT(PWM_CTRL_PWM_CLOCK_EN_OFFSET));
    376          
    377              if (u4Val & BIT(PWM_CTRL_PWM_CLOCK_EN_OFFSET)) {
    378                  (*pucEnable) = 1;
    379              } else {
    380                  (*pucEnable) = 0;
    381                  (*pu4PwmFreq) = 0;
    382                  (*pu2DutyCycle) = 0;
    383                  return HAL_RET_SUCCESS;
    384              }
    385          
    386              ePwmClk = (ENUM_PWM_CLK_T)(((*IOT_PWM_GLO_CTRL_ADDR) & (PWM_GLO_CTRL_PWM_TICK_CLOCK_SEL_MASK)) >> PWM_GLO_CTRL_PWM_TICK_CLOCK_SEL_OFFSET);
    387          
    388              switch (ePwmClk) {
    389                  case PWM_CLK_32K:
    390                      u4ClkFreq = (32700);
    391                      break;
    392          
    393                  case PWM_CLK_2M:
    394                      u4ClkFreq = (2 * 1000 * 1000);
    395                      break;
    396          
    397                  case PWM_CLK_XTAL: {
    398                      UINT8 ucXtal = 0;
    399                      ucXtal = ((HAL_REG_32(TOP_AON_CM4_STRAP_STA) & CM4_STRAP_STA_XTAL_FREQ_MASK) >> CM4_STRAP_STA_XTAL_FREQ_OFFSET);
    400                      if (XTAL_FREQ_20M == ucXtal) {
    401                          u4ClkFreq = (20 * 1000 * 1000);
    402                      } else if (XTAL_FREQ_40M == ucXtal) {
    403                          u4ClkFreq = (40 * 1000 * 1000);
    404                      } else if (XTAL_FREQ_26M == ucXtal) {
    405                          u4ClkFreq = (26 * 1000 * 1000);
    406                      } else if (XTAL_FREQ_52M == ucXtal) {
    407                          u4ClkFreq = (52 * 1000 * 1000);
    408                      }
    409                  }
    410                  break;
    411          
    412                  default:
    413                      return HAL_RET_FAIL;
    414              }
    415          
    416              /*=====================================================
    417              T(second)	PWM period
    418              F (Hz)	    PWM frequency = 1/T
    419              t (second)  Tick clk period
    420              f (Hz)	    Tick clk frequency = 1/t
    421              D (%)	    Duty cycle
    422              X (unit t)	Value of configurable register pwm_on_time[15:0], in unit t
    423              Y (unit t)	Value of configurable register pwm_off_time[15:0], in unit t
    424              Res (step)	PWM resolution of duty cycle on certain F, f
    425          
    426              (X + Y) t = T
    427              (X + Y) = T/t = f/F =Res
    428              D = X/((X+Y))
    429              X = D(X+Y) =  Df/F
    430              Y = f/F - X = f/F - Df/F = ((1-D)f)/F
    431              =====================================================*/
    432          
    433              if (PWM_S0 == eState) {
    434                  u4Val = (pCRAddr->PWM_PARAM_S0);
    435                  u2OnTime = ((u4Val & PWM_PARAM_S0_PWM_ON_TIME_MASK) >> PWM_PARAM_S0_PWM_ON_TIME_OFFSET);
    436                  u2OffTime = ((u4Val & PWM_PARAM_S0_PWM_OFF_TIME_MASK) >> PWM_PARAM_S0_PWM_OFF_TIME_OFFSET);
    437              } else {
    438                  u4Val = (pCRAddr->PWM_PARAM_S1);
    439                  u2OnTime = ((u4Val & PWM_PARAM_S1_PWM_ON_TIME_MASK) >> PWM_PARAM_S1_PWM_ON_TIME_OFFSET);
    440                  u2OffTime = ((u4Val & PWM_PARAM_S1_PWM_OFF_TIME_MASK) >> PWM_PARAM_S1_PWM_OFF_TIME_OFFSET);
    441              }
    442          
    443              u4PwmStep = u2OnTime + u2OffTime;
    444              (*pu4PwmFreq) = (u4ClkFreq / u4PwmStep);
    445              (*pu2DutyCycle) = u2OnTime;
    446          
    447              return ret;
    448          }
    449          
    450          #endif
    451          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   halPWMClockSelect
       8   halPWMConfig
       0   halPWMDisable
       4   halPWMEnable
       0   halPWMKick
      12   halPWMQuery
       0   halPWMResetAll
       4   halPWMStateConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
      26  halPWMClockSelect
     124  halPWMConfig
      18  halPWMDisable
      64  halPWMEnable
      18  halPWMKick
     138  halPWMQuery
      22  halPWMResetAll
      56  halPWMStateConfig

 
 498 bytes in section .text
 
 498 bytes of CODE memory

Errors: none
Warnings: none
