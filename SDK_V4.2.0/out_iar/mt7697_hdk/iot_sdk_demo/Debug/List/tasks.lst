###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       25/Jan/2017  17:35:36
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK IOT\SDK_V4.2.0\kernel\rtos\FreeRTOS\Source\tasks.c
#    Command line =  
#        "C:\LEO\myGit\MTK IOT\SDK_V4.2.0\kernel\rtos\FreeRTOS\Source\tasks.c"
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_WIFI_TGN_VERIFY_ENABLE -D MTK_SMTCN_ENABLE -D
#        MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D SUPPORT_MBEDTLS -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-basic.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D MTK_MCS_ENABLE -D MTK_BLE_GPIO_SERVICE -D
#        __BT_DEBUG__ -lcN "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List" -lA
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List"
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj" --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\inc\" -I
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\service\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\dhcpd\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\src\ut_app\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\httpclient\inc\"
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List\tasks.lst
#    Object file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj\tasks.o
#
###############################################################################

C:\LEO\myGit\MTK IOT\SDK_V4.2.0\kernel\rtos\FreeRTOS\Source\tasks.c
      1          /*
      2              FreeRTOS V8.2.0 - Copyright (C) 2015 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     12          
     13          	***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18          	***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40          	the FAQ page "My application does not run, what could be wrong?".  Have you
     41          	defined configASSERT()?
     42          
     43          	http://www.FreeRTOS.org/support - In return for receiving this top quality
     44          	embedded software for free we request you assist our global community by
     45          	participating in the support forum.
     46          
     47          	http://www.FreeRTOS.org/training - Investing in training allows your team to
     48          	be as productive as possible as early as possible.  Now you can receive
     49          	FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50          	Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /* Standard includes. */
     71          #include <stdlib.h>
     72          #include <string.h>
     73          
     74          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     75          all the API functions to use the MPU wrappers.  That should only be done when
     76          task.h is included from an application file. */
     77          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     78          
     79          /* FreeRTOS includes. */
     80          #include "FreeRTOS.h"
     81          #include "task.h"
     82          #include "timers.h"
     83          #include "StackMacros.h"
     84          
     85          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     86          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     87          header files above, but not in this file, in order to generate the correct
     88          privileged Vs unprivileged linkage and placement. */
     89          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     90          
     91          /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
     92          functions but without including stdio.h here. */
     93          #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
     94          	/* At the bottom of this file are two optional functions that can be used
     95          	to generate human readable text from the raw data generated by the
     96          	uxTaskGetSystemState() function.  Note the formatting functions are provided
     97          	for convenience only, and are NOT considered part of the kernel. */
     98          	#include <stdio.h>
     99          #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
    100          
    101          /* Sanity check the configuration. */
    102          #if configUSE_TICKLESS_IDLE != 0
    103          	#if INCLUDE_vTaskSuspend != 1
    104          		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
    105          	#endif /* INCLUDE_vTaskSuspend */
    106          #endif /* configUSE_TICKLESS_IDLE */
    107          
    108          /*
    109           * Defines the size, in words, of the stack allocated to the idle task.
    110           */
    111          #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
    112          
    113          #if( configUSE_PREEMPTION == 0 )
    114          	/* If the cooperative scheduler is being used then a yield should not be
    115          	performed just because a higher priority task has been woken. */
    116          	#define taskYIELD_IF_USING_PREEMPTION()
    117          #else
    118          	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
    119          #endif
    120          
    121          /* Value that can be assigned to the eNotifyState member of the TCB. */
    122          typedef enum
    123          {
    124          	eNotWaitingNotification = 0,
    125          	eWaitingNotification,
    126          	eNotified
    127          } eNotifyValue;
    128          
    129          /*
    130           * Task control block.  A task control block (TCB) is allocated for each task,
    131           * and stores task state information, including a pointer to the task's context
    132           * (the task's run time environment, including register values)
    133           */
    134          typedef struct tskTaskControlBlock
    135          {
    136          	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
    137          
    138          	#if ( portUSING_MPU_WRAPPERS == 1 )
    139          		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    140          		BaseType_t		xUsingStaticallyAllocatedStack; /* Set to pdTRUE if the stack is a statically allocated array, and pdFALSE if the stack is dynamically allocated. */
    141          	#endif
    142          
    143          	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
    144          	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
    145          	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
    146          	StackType_t			*pxStack;			/*< Points to the start of the stack. */
    147          	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    148          
    149          	#if ( portSTACK_GROWTH > 0 )
    150          		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
    151          	#endif
    152          
    153          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
    154          		UBaseType_t 	uxCriticalNesting; 	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
    155          	#endif
    156          
    157          	#if ( configUSE_TRACE_FACILITY == 1 )
    158          		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
    159          		UBaseType_t  	uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
    160          	#endif
    161          
    162          	#if ( configUSE_MUTEXES == 1 )
    163          		UBaseType_t 	uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
    164          		UBaseType_t 	uxMutexesHeld;
    165          	#endif
    166          
    167          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    168          		TaskHookFunction_t pxTaskTag;
    169          	#endif
    170          
    171          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
    172          		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
    173          	#endif
    174          
    175          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
    176          		/* Allocate a Newlib reent structure that is specific to this task.
    177          		Note Newlib support has been included by popular demand, but is not
    178          		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
    179          		responsible for resulting newlib operation.  User must be familiar with
    180          		newlib and must provide system-wide implementations of the necessary
    181          		stubs. Be warned that (at the time of writing) the current newlib design
    182          		implements a system-wide malloc() that must be provided with locks. */
    183          		struct 	_reent xNewLib_reent;
    184          	#endif
    185          
    186          	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
    187          		volatile uint32_t ulNotifiedValue;
    188          		volatile eNotifyValue eNotifyState;
    189          	#endif
    190          
    191          } tskTCB;
    192          
    193          /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
    194          below to enable the use of older kernel aware debuggers. */
    195          typedef tskTCB TCB_t;
    196          
    197          /*
    198           * Some kernel aware debuggers require the data the debugger needs access to to
    199           * be global, rather than file scope.
    200           */
    201          #ifdef portREMOVE_STATIC_QUALIFIER
    202          	#define static
    203          #endif
    204          
    205          /*lint -e956 A manual analysis and inspection has been used to determine which
    206          static variables must be declared volatile. */
    207          
    208          PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
    209          
    210          /* Lists for ready and blocked tasks. --------------------*/
    211          PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
    212          PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
    213          PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
    214          PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
    215          PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
    216          PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
    217          
    218          #if ( INCLUDE_vTaskDelete == 1 )
    219          
    220          	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
    221          	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
    222          
    223          #endif
    224          
    225          #if ( INCLUDE_vTaskSuspend == 1 )
    226          
    227          	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
    228          
    229          #endif
    230          
    231          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
    232          
    233          	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
    234          
    235          #endif
    236          
    237          /* Other file private variables. --------------------------------*/
    238          PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
    239          PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
    240          PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
    241          PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
    242          PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
    243          PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
    244          PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
    245          PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
    246          PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= portMAX_DELAY;
    247          
    248          /* Context switches are held pending while the scheduler is suspended.  Also,
    249          interrupts must not manipulate the xGenericListItem of a TCB, or any of the
    250          lists the xGenericListItem can be referenced from, if the scheduler is suspended.
    251          If an interrupt needs to unblock a task while the scheduler is suspended then it
    252          moves the task's event list item into the xPendingReadyList, ready for the
    253          kernel to move the task from the pending ready list into the real ready list
    254          when the scheduler is unsuspended.  The pending ready list itself can only be
    255          accessed from a critical section. */
    256          PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
    257          
    258          #if ( configGENERATE_RUN_TIME_STATS == 1 )
    259          
    260          	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
    261          	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
    262          
    263          #endif
    264          
    265          /*lint +e956 */
    266          
    267          /* Debugging and trace facilities private variables and macros. ------------*/
    268          
    269          /*
    270           * The value used to fill the stack of a task when the task is created.  This
    271           * is used purely for checking the high water mark for tasks.
    272           */
    273          #define tskSTACK_FILL_BYTE	( 0xa5U )
    274          
    275          /*
    276           * Macros used by vListTask to indicate which state a task is in.
    277           */
    278          #define tskBLOCKED_CHAR		( 'B' )
    279          #define tskREADY_CHAR		( 'R' )
    280          #define tskDELETED_CHAR		( 'D' )
    281          #define tskSUSPENDED_CHAR	( 'S' )
    282          
    283          /*-----------------------------------------------------------*/
    284          
    285          #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
    286          
    287          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
    288          	performed in a generic way that is not optimised to any particular
    289          	microcontroller architecture. */
    290          
    291          	/* uxTopReadyPriority holds the priority of the highest priority ready
    292          	state task. */
    293          	#define taskRECORD_READY_PRIORITY( uxPriority )														\
    294          	{																									\
    295          		if( ( uxPriority ) > uxTopReadyPriority )														\
    296          		{																								\
    297          			uxTopReadyPriority = ( uxPriority );														\
    298          		}																								\
    299          	} /* taskRECORD_READY_PRIORITY */
    300          
    301          	/*-----------------------------------------------------------*/
    302          
    303          	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
    304          	{																									\
    305          		/* Find the highest priority queue that contains ready tasks. */								\
    306          		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
    307          		{																								\
    308          			configASSERT( uxTopReadyPriority );															\
    309          			--uxTopReadyPriority;																		\
    310          		}																								\
    311          																										\
    312          		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
    313          		the	same priority get an equal share of the processor time. */									\
    314          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
    315          	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
    316          
    317          	/*-----------------------------------------------------------*/
    318          
    319          	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
    320          	they are only required when a port optimised method of task selection is
    321          	being used. */
    322          	#define taskRESET_READY_PRIORITY( uxPriority )
    323          	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    324          
    325          #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    326          
    327          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
    328          	performed in a way that is tailored to the particular microcontroller
    329          	architecture being used. */
    330          
    331          	/* A port optimised version is provided.  Call the port defined macros. */
    332          	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    333          
    334          	/*-----------------------------------------------------------*/
    335          
    336          	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
    337          	{																								\
    338          	UBaseType_t uxTopPriority;																		\
    339          																									\
    340          		/* Find the highest priority queue that contains ready tasks. */							\
    341          		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
    342          		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
    343          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
    344          	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
    345          
    346          	/*-----------------------------------------------------------*/
    347          
    348          	/* A port optimised version is provided, call it only if the TCB being reset
    349          	is being referenced from a ready list.  If it is referenced from a delayed
    350          	or suspended list then it won't be in a ready list. */
    351          	#define taskRESET_READY_PRIORITY( uxPriority )														\
    352          	{																									\
    353          		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
    354          		{																								\
    355          			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
    356          		}																								\
    357          	}
    358          
    359          #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    360          
    361          /*-----------------------------------------------------------*/
    362          
    363          /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
    364          count overflows. */
    365          #define taskSWITCH_DELAYED_LISTS()																	\
    366          {																									\
    367          	List_t *pxTemp;																					\
    368          																									\
    369          	/* The delayed tasks list should be empty when the lists are switched. */						\
    370          	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
    371          																									\
    372          	pxTemp = pxDelayedTaskList;																		\
    373          	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
    374          	pxOverflowDelayedTaskList = pxTemp;																\
    375          	xNumOfOverflows++;																				\
    376          	prvResetNextTaskUnblockTime();																	\
    377          }
    378          
    379          /*-----------------------------------------------------------*/
    380          
    381          /*
    382           * Place the task represented by pxTCB into the appropriate ready list for
    383           * the task.  It is inserted at the end of the list.
    384           */
    385          #define prvAddTaskToReadyList( pxTCB )																\
    386          	traceMOVED_TASK_TO_READY_STATE( pxTCB )															\
    387          	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
    388          	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )
    389          /*-----------------------------------------------------------*/
    390          
    391          /*
    392           * Several functions take an TaskHandle_t parameter that can optionally be NULL,
    393           * where NULL is used to indicate that the handle of the currently executing
    394           * task should be used in place of the parameter.  This macro simply checks to
    395           * see if the parameter is NULL and returns a pointer to the appropriate TCB.
    396           */
    397          #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
    398          
    399          /* The item value of the event list item is normally used to hold the priority
    400          of the task to which it belongs (coded to allow it to be held in reverse
    401          priority order).  However, it is occasionally borrowed for other purposes.  It
    402          is important its value is not updated due to a task priority change while it is
    403          being used for another purpose.  The following bit definition is used to inform
    404          the scheduler that the value should not be changed - in which case it is the
    405          responsibility of whichever module is using the value to ensure it gets set back
    406          to its original value when it is released. */
    407          #if configUSE_16_BIT_TICKS == 1
    408          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
    409          #else
    410          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
    411          #endif
    412          
    413          /* Callback function prototypes. --------------------------*/
    414          #if configCHECK_FOR_STACK_OVERFLOW > 0
    415          	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
    416          #endif
    417          
    418          #if configUSE_TICK_HOOK > 0
    419          	extern void vApplicationTickHook( void );
    420          #endif
    421          
    422          /* File private functions. --------------------------------*/
    423          
    424          /*
    425           * Utility to ready a TCB for a given task.  Mainly just copies the parameters
    426           * into the TCB structure.
    427           */
    428          static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    429          
    430          /**
    431           * Utility task that simply returns pdTRUE if the task referenced by xTask is
    432           * currently in the Suspended state, or pdFALSE if the task referenced by xTask
    433           * is in any other state.
    434           */
    435          #if ( INCLUDE_vTaskSuspend == 1 )
    436          	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
    437          #endif /* INCLUDE_vTaskSuspend */
    438          
    439          /*
    440           * Utility to ready all the lists used by the scheduler.  This is called
    441           * automatically upon the creation of the first task.
    442           */
    443          static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
    444          
    445          /*
    446           * The idle task, which as all tasks is implemented as a never ending loop.
    447           * The idle task is automatically created and added to the ready lists upon
    448           * creation of the first user task.
    449           *
    450           * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
    451           * language extensions.  The equivalent prototype for this function is:
    452           *
    453           * void prvIdleTask( void *pvParameters );
    454           *
    455           */
    456          static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
    457          
    458          /*
    459           * Utility to free all memory allocated by the scheduler to hold a TCB,
    460           * including the stack pointed to by the TCB.
    461           *
    462           * This does not free memory allocated by the task itself (i.e. memory
    463           * allocated by calls to pvPortMalloc from within the tasks application code).
    464           */
    465          #if ( INCLUDE_vTaskDelete == 1 )
    466          
    467          	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
    468          
    469          #endif
    470          
    471          /*
    472           * Used only by the idle task.  This checks to see if anything has been placed
    473           * in the list of tasks waiting to be deleted.  If so the task is cleaned up
    474           * and its TCB deleted.
    475           */
    476          static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
    477          
    478          /*
    479           * The currently executing task is entering the Blocked state.  Add the task to
    480           * either the current or the overflow delayed task list.
    481           */
    482          static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
    483          
    484          /*
    485           * Allocates memory from the heap for a TCB and associated stack.  Checks the
    486           * allocation was successful.
    487           */
    488          static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer ) PRIVILEGED_FUNCTION;
    489          
    490          /*
    491           * Fills an TaskStatus_t structure with information on each task that is
    492           * referenced from the pxList list (which may be a ready list, a delayed list,
    493           * a suspended list, etc.).
    494           *
    495           * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
    496           * NORMAL APPLICATION CODE.
    497           */
    498          #if ( configUSE_TRACE_FACILITY == 1 )
    499          
    500          	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
    501          
    502          #endif
    503          
    504          /*
    505           * When a task is created, the stack of the task is filled with a known value.
    506           * This function determines the 'high water mark' of the task stack by
    507           * determining how much of the stack remains at the original preset value.
    508           */
    509          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    510          
    511          	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
    512          
    513          #endif
    514          
    515          /*
    516           * Return the amount of time, in ticks, that will pass before the kernel will
    517           * next move a task from the Blocked state to the Running state.
    518           *
    519           * This conditional compilation should use inequality to 0, not equality to 1.
    520           * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
    521           * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
    522           * set to a value other than 1.
    523           */
    524          #if ( configUSE_TICKLESS_IDLE != 0 )
    525          
    526          	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
    527          
    528          #endif
    529          
    530          /*
    531           * Set xNextTaskUnblockTime to the time at which the next Blocked state task
    532           * will exit the Blocked state.
    533           */
    534          static void prvResetNextTaskUnblockTime( void );
    535          
    536          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
    537          
    538          	/*
    539          	 * Helper function used to pad task names with spaces when printing out
    540          	 * human readable tables of task information.
    541          	 */
    542          	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName );
    543          
    544          #endif
    545          /*-----------------------------------------------------------*/
    546          
    547          BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    548          {
    549          BaseType_t xReturn;
    550          TCB_t * pxNewTCB;
    551          StackType_t *pxTopOfStack;
    552          
    553          	configASSERT( pxTaskCode );
    554          	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
    555          
    556          	/* Allocate the memory required by the TCB and stack for the new task,
    557          	checking that the allocation was successful. */
    558          	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    559          
    560          	if( pxNewTCB != NULL )
    561          	{
    562          		#if( portUSING_MPU_WRAPPERS == 1 )
    563          			/* Should the task be created in privileged mode? */
    564          			BaseType_t xRunPrivileged;
    565          			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
    566          			{
    567          				xRunPrivileged = pdTRUE;
    568          			}
    569          			else
    570          			{
    571          				xRunPrivileged = pdFALSE;
    572          			}
    573          			uxPriority &= ~portPRIVILEGE_BIT;
    574          
    575          			if( puxStackBuffer != NULL )
    576          			{
    577          				/* The application provided its own stack.  Note this so no
    578          				attempt is made to delete the stack should that task be
    579          				deleted. */
    580          				pxNewTCB->xUsingStaticallyAllocatedStack = pdTRUE;
    581          			}
    582          			else
    583          			{
    584          				/* The stack was allocated dynamically.  Note this so it can be
    585          				deleted again if the task is deleted. */
    586          				pxNewTCB->xUsingStaticallyAllocatedStack = pdFALSE;
    587          			}
    588          		#endif /* portUSING_MPU_WRAPPERS == 1 */
    589          
    590          		/* Calculate the top of stack address.  This depends on whether the
    591          		stack grows from high memory to low (as per the 80x86) or vice versa.
    592          		portSTACK_GROWTH is used to make the result positive or negative as
    593          		required by the port. */
    594          		#if( portSTACK_GROWTH < 0 )
    595          		{
    596          			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    597          			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    598          
    599          			/* Check the alignment of the calculated top of stack is correct. */
    600          			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    601          		}
    602          		#else /* portSTACK_GROWTH */
    603          		{
    604          			pxTopOfStack = pxNewTCB->pxStack;
    605          
    606          			/* Check the alignment of the stack buffer is correct. */
    607          			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    608          
    609          			/* If we want to use stack checking on architectures that use
    610          			a positive stack growth direction then we also need to store the
    611          			other extreme of the stack space. */
    612          			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    613          		}
    614          		#endif /* portSTACK_GROWTH */
    615          
    616          		/* Setup the newly allocated TCB with the initial state of the task. */
    617          		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    618          
    619          		/* Initialize the TCB stack to look as if the task was already running,
    620          		but had been interrupted by the scheduler.  The return address is set
    621          		to the start of the task function. Once the stack has been initialised
    622          		the	top of stack variable is updated. */
    623          		#if( portUSING_MPU_WRAPPERS == 1 )
    624          		{
    625          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
    626          		}
    627          		#else /* portUSING_MPU_WRAPPERS */
    628          		{
    629          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    630          		}
    631          		#endif /* portUSING_MPU_WRAPPERS */
    632          
    633          		if( ( void * ) pxCreatedTask != NULL )
    634          		{
    635          			/* Pass the TCB out - in an anonymous way.  The calling function/
    636          			task can use this as a handle to delete the task later if
    637          			required.*/
    638          			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    639          		}
    640          		else
    641          		{
    642          			mtCOVERAGE_TEST_MARKER();
    643          		}
    644          
    645          		/* Ensure interrupts don't access the task lists while they are being
    646          		updated. */
    647          		taskENTER_CRITICAL();
    648          		{
    649          			uxCurrentNumberOfTasks++;
    650          			if( pxCurrentTCB == NULL )
    651          			{
    652          				/* There are no other tasks, or all the other tasks are in
    653          				the suspended state - make this the current task. */
    654          				pxCurrentTCB =  pxNewTCB;
    655          
    656          				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    657          				{
    658          					/* This is the first task to be created so do the preliminary
    659          					initialisation required.  We will not recover if this call
    660          					fails, but we will report the failure. */
    661          					prvInitialiseTaskLists();
    662          				}
    663          				else
    664          				{
    665          					mtCOVERAGE_TEST_MARKER();
    666          				}
    667          			}
    668          			else
    669          			{
    670          				/* If the scheduler is not already running, make this task the
    671          				current task if it is the highest priority task to be created
    672          				so far. */
    673          				if( xSchedulerRunning == pdFALSE )
    674          				{
    675          					if( pxCurrentTCB->uxPriority <= uxPriority )
    676          					{
    677          						pxCurrentTCB = pxNewTCB;
    678          					}
    679          					else
    680          					{
    681          						mtCOVERAGE_TEST_MARKER();
    682          					}
    683          				}
    684          				else
    685          				{
    686          					mtCOVERAGE_TEST_MARKER();
    687          				}
    688          			}
    689          
    690          			uxTaskNumber++;
    691          
    692          			#if ( configUSE_TRACE_FACILITY == 1 )
    693          			{
    694          				/* Add a counter into the TCB for tracing only. */
    695          				pxNewTCB->uxTCBNumber = uxTaskNumber;
    696          			}
    697          			#endif /* configUSE_TRACE_FACILITY */
    698          			traceTASK_CREATE( pxNewTCB );
    699          
    700          			prvAddTaskToReadyList( pxNewTCB );
    701          
    702          			xReturn = pdPASS;
    703          			portSETUP_TCB( pxNewTCB );
    704          		}
    705          		taskEXIT_CRITICAL();
    706          	}
    707          	else
    708          	{
    709          		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    710          		traceTASK_CREATE_FAILED();
    711          	}
    712          
    713          	if( xReturn == pdPASS )
    714          	{
    715          		if( xSchedulerRunning != pdFALSE )
    716          		{
    717          			/* If the created task is of a higher priority than the current task
    718          			then it should run now. */
    719          			if( pxCurrentTCB->uxPriority < uxPriority )
    720          			{
    721          				taskYIELD_IF_USING_PREEMPTION();
    722          			}
    723          			else
    724          			{
    725          				mtCOVERAGE_TEST_MARKER();
    726          			}
    727          		}
    728          		else
    729          		{
    730          			mtCOVERAGE_TEST_MARKER();
    731          		}
    732          	}
    733          
    734          	return xReturn;
    735          }
    736          /*-----------------------------------------------------------*/
    737          
    738          #if ( INCLUDE_vTaskDelete == 1 )
    739          
    740          	void vTaskDelete( TaskHandle_t xTaskToDelete )
    741          	{
    742          	TCB_t *pxTCB;
    743          
    744          		taskENTER_CRITICAL();
    745          		{
    746          			/* If null is passed in here then it is the calling task that is
    747          			being deleted. */
    748          			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    749          
    750          			/* Remove task from the ready list and place in the	termination list.
    751          			This will stop the task from be scheduled.  The idle task will check
    752          			the termination list and free up any memory allocated by the
    753          			scheduler for the TCB and stack. */
    754          			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    755          			{
    756          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
    757          			}
    758          			else
    759          			{
    760          				mtCOVERAGE_TEST_MARKER();
    761          			}
    762          
    763          			/* Is the task waiting on an event also? */
    764          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    765          			{
    766          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    767          			}
    768          			else
    769          			{
    770          				mtCOVERAGE_TEST_MARKER();
    771          			}
    772          
    773          			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    774          
    775          			/* Increment the ucTasksDeleted variable so the idle task knows
    776          			there is a task that has been deleted and that it should therefore
    777          			check the xTasksWaitingTermination list. */
    778          			++uxTasksDeleted;
    779          
    780          			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
    781          			can detect that the task lists need re-generating. */
    782          			uxTaskNumber++;
    783          
    784          			traceTASK_DELETE( pxTCB );
    785          		}
    786          		taskEXIT_CRITICAL();
    787          
    788          		/* Force a reschedule if it is the currently running task that has just
    789          		been deleted. */
    790          		if( xSchedulerRunning != pdFALSE )
    791          		{
    792          			if( pxTCB == pxCurrentTCB )
    793          			{
    794          				configASSERT( uxSchedulerSuspended == 0 );
    795          
    796          				/* The pre-delete hook is primarily for the Windows simulator,
    797          				in which Windows specific clean up operations are performed,
    798          				after which it is not possible to yield away from this task -
    799          				hence xYieldPending is used to latch that a context switch is
    800          				required. */
    801          				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
    802          				portYIELD_WITHIN_API();
    803          			}
    804          			else
    805          			{
    806          				/* Reset the next expected unblock time in case it referred to
    807          				the task that has just been deleted. */
    808          				taskENTER_CRITICAL();
    809          				{
    810          					prvResetNextTaskUnblockTime();
    811          				}
    812          				taskEXIT_CRITICAL();
    813          			}
    814          		}
    815          	}
    816          
    817          #endif /* INCLUDE_vTaskDelete */
    818          /*-----------------------------------------------------------*/
    819          
    820          #if ( INCLUDE_vTaskDelayUntil == 1 )
    821          
    822          	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
    823          	{
    824          	TickType_t xTimeToWake;
    825          	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    826          
    827          		configASSERT( pxPreviousWakeTime );
    828          		configASSERT( ( xTimeIncrement > 0U ) );
    829          		configASSERT( uxSchedulerSuspended == 0 );
    830          
    831          		vTaskSuspendAll();
    832          		{
    833          			/* Minor optimisation.  The tick count cannot change in this
    834          			block. */
    835          			const TickType_t xConstTickCount = xTickCount;
    836          
    837          			/* Generate the tick time at which the task wants to wake. */
    838          			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    839          
    840          			if( xConstTickCount < *pxPreviousWakeTime )
    841          			{
    842          				/* The tick count has overflowed since this function was
    843          				lasted called.  In this case the only time we should ever
    844          				actually delay is if the wake time has also	overflowed,
    845          				and the wake time is greater than the tick time.  When this
    846          				is the case it is as if neither time had overflowed. */
    847          				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    848          				{
    849          					xShouldDelay = pdTRUE;
    850          				}
    851          				else
    852          				{
    853          					mtCOVERAGE_TEST_MARKER();
    854          				}
    855          			}
    856          			else
    857          			{
    858          				/* The tick time has not overflowed.  In this case we will
    859          				delay if either the wake time has overflowed, and/or the
    860          				tick time is less than the wake time. */
    861          				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    862          				{
    863          					xShouldDelay = pdTRUE;
    864          				}
    865          				else
    866          				{
    867          					mtCOVERAGE_TEST_MARKER();
    868          				}
    869          			}
    870          
    871          			/* Update the wake time ready for the next call. */
    872          			*pxPreviousWakeTime = xTimeToWake;
    873          
    874          			if( xShouldDelay != pdFALSE )
    875          			{
    876          				traceTASK_DELAY_UNTIL();
    877          
    878          				/* Remove the task from the ready list before adding it to the
    879          				blocked list as the same list item is used for both lists. */
    880          				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    881          				{
    882          					/* The current task must be in a ready list, so there is
    883          					no need to check, and the port reset macro can be called
    884          					directly. */
    885          					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    886          				}
    887          				else
    888          				{
    889          					mtCOVERAGE_TEST_MARKER();
    890          				}
    891          
    892          				prvAddCurrentTaskToDelayedList( xTimeToWake );
    893          			}
    894          			else
    895          			{
    896          				mtCOVERAGE_TEST_MARKER();
    897          			}
    898          		}
    899          		xAlreadyYielded = xTaskResumeAll();
    900          
    901          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    902          		have put ourselves to sleep. */
    903          		if( xAlreadyYielded == pdFALSE )
    904          		{
    905          			portYIELD_WITHIN_API();
    906          		}
    907          		else
    908          		{
    909          			mtCOVERAGE_TEST_MARKER();
    910          		}
    911          	}
    912          
    913          #endif /* INCLUDE_vTaskDelayUntil */
    914          /*-----------------------------------------------------------*/
    915          
    916          #if ( INCLUDE_vTaskDelay == 1 )
    917          
    918          	void vTaskDelay( const TickType_t xTicksToDelay )
    919          	{
    920          	TickType_t xTimeToWake;
    921          	BaseType_t xAlreadyYielded = pdFALSE;
    922          
    923          
    924          		/* A delay time of zero just forces a reschedule. */
    925          		if( xTicksToDelay > ( TickType_t ) 0U )
    926          		{
    927          			configASSERT( uxSchedulerSuspended == 0 );
    928          			vTaskSuspendAll();
    929          			{
    930          				traceTASK_DELAY();
    931          
    932          				/* A task that is removed from the event list while the
    933          				scheduler is suspended will not get placed in the ready
    934          				list or removed from the blocked list until the scheduler
    935          				is resumed.
    936          
    937          				This task cannot be in an event list as it is the currently
    938          				executing task. */
    939          
    940          				/* Calculate the time to wake - this may overflow but this is
    941          				not a problem. */
    942          				xTimeToWake = xTickCount + xTicksToDelay;
    943          
    944          				/* We must remove ourselves from the ready list before adding
    945          				ourselves to the blocked list as the same list item is used for
    946          				both lists. */
    947          				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    948          				{
    949          					/* The current task must be in a ready list, so there is
    950          					no need to check, and the port reset macro can be called
    951          					directly. */
    952          					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    953          				}
    954          				else
    955          				{
    956          					mtCOVERAGE_TEST_MARKER();
    957          				}
    958          				prvAddCurrentTaskToDelayedList( xTimeToWake );
    959          			}
    960          			xAlreadyYielded = xTaskResumeAll();
    961          		}
    962          		else
    963          		{
    964          			mtCOVERAGE_TEST_MARKER();
    965          		}
    966          
    967          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    968          		have put ourselves to sleep. */
    969          		if( xAlreadyYielded == pdFALSE )
    970          		{
    971          			portYIELD_WITHIN_API();
    972          		}
    973          		else
    974          		{
    975          			mtCOVERAGE_TEST_MARKER();
    976          		}
    977          	}
    978          
    979          #endif /* INCLUDE_vTaskDelay */
    980          /*-----------------------------------------------------------*/
    981          
    982          #if ( INCLUDE_eTaskGetState == 1 )
    983          
    984          	eTaskState eTaskGetState( TaskHandle_t xTask )
    985          	{
    986          	eTaskState eReturn;
    987          	List_t *pxStateList;
    988          	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    989          
    990          		configASSERT( pxTCB );
    991          
    992          		if( pxTCB == pxCurrentTCB )
    993          		{
    994          			/* The task calling this function is querying its own state. */
    995          			eReturn = eRunning;
    996          		}
    997          		else
    998          		{
    999          			taskENTER_CRITICAL();
   1000          			{
   1001          				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
   1002          			}
   1003          			taskEXIT_CRITICAL();
   1004          
   1005          			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
   1006          			{
   1007          				/* The task being queried is referenced from one of the Blocked
   1008          				lists. */
   1009          				eReturn = eBlocked;
   1010          			}
   1011          
   1012          			#if ( INCLUDE_vTaskSuspend == 1 )
   1013          				else if( pxStateList == &xSuspendedTaskList )
   1014          				{
   1015          					/* The task being queried is referenced from the suspended
   1016          					list.  Is it genuinely suspended or is it block
   1017          					indefinitely? */
   1018          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
   1019          					{
   1020          						eReturn = eSuspended;
   1021          					}
   1022          					else
   1023          					{
   1024          						eReturn = eBlocked;
   1025          					}
   1026          				}
   1027          			#endif
   1028          
   1029          			#if ( INCLUDE_vTaskDelete == 1 )
   1030          				else if( pxStateList == &xTasksWaitingTermination )
   1031          				{
   1032          					/* The task being queried is referenced from the deleted
   1033          					tasks list. */
   1034          					eReturn = eDeleted;
   1035          				}
   1036          			#endif
   1037          
   1038          			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
   1039          			{
   1040          				/* If the task is not in any other state, it must be in the
   1041          				Ready (including pending ready) state. */
   1042          				eReturn = eReady;
   1043          			}
   1044          		}
   1045          
   1046          		return eReturn;
   1047          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1048          
   1049          #endif /* INCLUDE_eTaskGetState */
   1050          /*-----------------------------------------------------------*/
   1051          
   1052          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1053          
   1054          	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
   1055          	{
   1056          	TCB_t *pxTCB;
   1057          	UBaseType_t uxReturn;
   1058          
   1059          		taskENTER_CRITICAL();
   1060          		{
   1061          			/* If null is passed in here then we are changing the
   1062          			priority of the calling function. */
   1063          			pxTCB = prvGetTCBFromHandle( xTask );
   1064          			uxReturn = pxTCB->uxPriority;
   1065          		}
   1066          		taskEXIT_CRITICAL();
   1067          
   1068          		return uxReturn;
   1069          	}
   1070          
   1071          #endif /* INCLUDE_uxTaskPriorityGet */
   1072          /*-----------------------------------------------------------*/
   1073          
   1074          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1075          
   1076          	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
   1077          	{
   1078          	TCB_t *pxTCB;
   1079          	UBaseType_t uxReturn, uxSavedInterruptState;
   1080          
   1081          		/* RTOS ports that support interrupt nesting have the concept of a
   1082          		maximum	system call (or maximum API call) interrupt priority.
   1083          		Interrupts that are	above the maximum system call priority are keep
   1084          		permanently enabled, even when the RTOS kernel is in a critical section,
   1085          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1086          		is defined in FreeRTOSConfig.h then
   1087          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1088          		failure if a FreeRTOS API function is called from an interrupt that has
   1089          		been assigned a priority above the configured maximum system call
   1090          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1091          		from interrupts	that have been assigned a priority at or (logically)
   1092          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1093          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1094          		simple as possible.  More information (albeit Cortex-M specific) is
   1095          		provided on the following link:
   1096          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1097          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1098          
   1099          		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
   1100          		{
   1101          			/* If null is passed in here then it is the priority of the calling
   1102          			task that is being queried. */
   1103          			pxTCB = prvGetTCBFromHandle( xTask );
   1104          			uxReturn = pxTCB->uxPriority;
   1105          		}
   1106          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
   1107          
   1108          		return uxReturn;
   1109          	}
   1110          
   1111          #endif /* INCLUDE_uxTaskPriorityGet */
   1112          /*-----------------------------------------------------------*/
   1113          
   1114          #if ( INCLUDE_vTaskPrioritySet == 1 )
   1115          
   1116          	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
   1117          	{
   1118          	TCB_t *pxTCB;
   1119          	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
   1120          	BaseType_t xYieldRequired = pdFALSE;
   1121          
   1122          		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
   1123          
   1124          		/* Ensure the new priority is valid. */
   1125          		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   1126          		{
   1127          			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   1128          		}
   1129          		else
   1130          		{
   1131          			mtCOVERAGE_TEST_MARKER();
   1132          		}
   1133          
   1134          		taskENTER_CRITICAL();
   1135          		{
   1136          			/* If null is passed in here then it is the priority of the calling
   1137          			task that is being changed. */
   1138          			pxTCB = prvGetTCBFromHandle( xTask );
   1139          
   1140          			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
   1141          
   1142          			#if ( configUSE_MUTEXES == 1 )
   1143          			{
   1144          				uxCurrentBasePriority = pxTCB->uxBasePriority;
   1145          			}
   1146          			#else
   1147          			{
   1148          				uxCurrentBasePriority = pxTCB->uxPriority;
   1149          			}
   1150          			#endif
   1151          
   1152          			if( uxCurrentBasePriority != uxNewPriority )
   1153          			{
   1154          				/* The priority change may have readied a task of higher
   1155          				priority than the calling task. */
   1156          				if( uxNewPriority > uxCurrentBasePriority )
   1157          				{
   1158          					if( pxTCB != pxCurrentTCB )
   1159          					{
   1160          						/* The priority of a task other than the currently
   1161          						running task is being raised.  Is the priority being
   1162          						raised above that of the running task? */
   1163          						if( uxNewPriority >= pxCurrentTCB->uxPriority )
   1164          						{
   1165          							xYieldRequired = pdTRUE;
   1166          						}
   1167          						else
   1168          						{
   1169          							mtCOVERAGE_TEST_MARKER();
   1170          						}
   1171          					}
   1172          					else
   1173          					{
   1174          						/* The priority of the running task is being raised,
   1175          						but the running task must already be the highest
   1176          						priority task able to run so no yield is required. */
   1177          					}
   1178          				}
   1179          				else if( pxTCB == pxCurrentTCB )
   1180          				{
   1181          					/* Setting the priority of the running task down means
   1182          					there may now be another task of higher priority that
   1183          					is ready to execute. */
   1184          					xYieldRequired = pdTRUE;
   1185          				}
   1186          				else
   1187          				{
   1188          					/* Setting the priority of any other task down does not
   1189          					require a yield as the running task must be above the
   1190          					new priority of the task being modified. */
   1191          				}
   1192          
   1193          				/* Remember the ready list the task might be referenced from
   1194          				before its uxPriority member is changed so the
   1195          				taskRESET_READY_PRIORITY() macro can function correctly. */
   1196          				uxPriorityUsedOnEntry = pxTCB->uxPriority;
   1197          
   1198          				#if ( configUSE_MUTEXES == 1 )
   1199          				{
   1200          					/* Only change the priority being used if the task is not
   1201          					currently using an inherited priority. */
   1202          					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
   1203          					{
   1204          						pxTCB->uxPriority = uxNewPriority;
   1205          					}
   1206          					else
   1207          					{
   1208          						mtCOVERAGE_TEST_MARKER();
   1209          					}
   1210          
   1211          					/* The base priority gets set whatever. */
   1212          					pxTCB->uxBasePriority = uxNewPriority;
   1213          				}
   1214          				#else
   1215          				{
   1216          					pxTCB->uxPriority = uxNewPriority;
   1217          				}
   1218          				#endif
   1219          
   1220          				/* Only reset the event list item value if the value is not
   1221          				being used for anything else. */
   1222          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   1223          				{
   1224          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1225          				}
   1226          				else
   1227          				{
   1228          					mtCOVERAGE_TEST_MARKER();
   1229          				}
   1230          
   1231          				/* If the task is in the blocked or suspended list we need do
   1232          				nothing more than change it's priority variable. However, if
   1233          				the task is in a ready list it needs to be removed and placed
   1234          				in the list appropriate to its new priority. */
   1235          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   1236          				{
   1237          					/* The task is currently in its ready list - remove before adding
   1238          					it to it's new ready list.  As we are in a critical section we
   1239          					can do this even if the scheduler is suspended. */
   1240          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   1241          					{
   1242          						/* It is known that the task is in its ready list so
   1243          						there is no need to check again and the port level
   1244          						reset macro can be called directly. */
   1245          						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
   1246          					}
   1247          					else
   1248          					{
   1249          						mtCOVERAGE_TEST_MARKER();
   1250          					}
   1251          					prvAddTaskToReadyList( pxTCB );
   1252          				}
   1253          				else
   1254          				{
   1255          					mtCOVERAGE_TEST_MARKER();
   1256          				}
   1257          
   1258          				if( xYieldRequired == pdTRUE )
   1259          				{
   1260          					taskYIELD_IF_USING_PREEMPTION();
   1261          				}
   1262          				else
   1263          				{
   1264          					mtCOVERAGE_TEST_MARKER();
   1265          				}
   1266          
   1267          				/* Remove compiler warning about unused variables when the port
   1268          				optimised task selection is not being used. */
   1269          				( void ) uxPriorityUsedOnEntry;
   1270          			}
   1271          		}
   1272          		taskEXIT_CRITICAL();
   1273          	}
   1274          
   1275          #endif /* INCLUDE_vTaskPrioritySet */
   1276          /*-----------------------------------------------------------*/
   1277          
   1278          #if ( INCLUDE_vTaskSuspend == 1 )
   1279          
   1280          	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
   1281          	{
   1282          	TCB_t *pxTCB;
   1283          
   1284          		taskENTER_CRITICAL();
   1285          		{
   1286          			/* If null is passed in here then it is the running task that is
   1287          			being suspended. */
   1288          			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   1289          
   1290          			traceTASK_SUSPEND( pxTCB );
   1291          
   1292          			/* Remove task from the ready/delayed list and place in the
   1293          			suspended list. */
   1294          			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   1295          			{
   1296          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1297          			}
   1298          			else
   1299          			{
   1300          				mtCOVERAGE_TEST_MARKER();
   1301          			}
   1302          
   1303          			/* Is the task waiting on an event also? */
   1304          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   1305          			{
   1306          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1307          			}
   1308          			else
   1309          			{
   1310          				mtCOVERAGE_TEST_MARKER();
   1311          			}
   1312          
   1313          			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
   1314          		}
   1315          		taskEXIT_CRITICAL();
   1316          
   1317          		if( pxTCB == pxCurrentTCB )
   1318          		{
   1319          			if( xSchedulerRunning != pdFALSE )
   1320          			{
   1321          				/* The current task has just been suspended. */
   1322          				configASSERT( uxSchedulerSuspended == 0 );
   1323          				portYIELD_WITHIN_API();
   1324          			}
   1325          			else
   1326          			{
   1327          				/* The scheduler is not running, but the task that was pointed
   1328          				to by pxCurrentTCB has just been suspended and pxCurrentTCB
   1329          				must be adjusted to point to a different task. */
   1330          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
   1331          				{
   1332          					/* No other tasks are ready, so set pxCurrentTCB back to
   1333          					NULL so when the next task is created pxCurrentTCB will
   1334          					be set to point to it no matter what its relative priority
   1335          					is. */
   1336          					pxCurrentTCB = NULL;
   1337          				}
   1338          				else
   1339          				{
   1340          					vTaskSwitchContext();
   1341          				}
   1342          			}
   1343          		}
   1344          		else
   1345          		{
   1346          			if( xSchedulerRunning != pdFALSE )
   1347          			{
   1348          				/* A task other than the currently running task was suspended,
   1349          				reset the next expected unblock time in case it referred to the
   1350          				task that is now in the Suspended state. */
   1351          				taskENTER_CRITICAL();
   1352          				{
   1353          					prvResetNextTaskUnblockTime();
   1354          				}
   1355          				taskEXIT_CRITICAL();
   1356          			}
   1357          			else
   1358          			{
   1359          				mtCOVERAGE_TEST_MARKER();
   1360          			}
   1361          		}
   1362          	}
   1363          
   1364          #endif /* INCLUDE_vTaskSuspend */
   1365          /*-----------------------------------------------------------*/
   1366          
   1367          #if ( INCLUDE_vTaskSuspend == 1 )
   1368          
   1369          	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
   1370          	{
   1371          	BaseType_t xReturn = pdFALSE;
   1372          	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
   1373          
   1374          		/* Accesses xPendingReadyList so must be called from a critical
   1375          		section. */
   1376          
   1377          		/* It does not make sense to check if the calling task is suspended. */
   1378          		configASSERT( xTask );
   1379          
   1380          		/* Is the task being resumed actually in the suspended list? */
   1381          		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
   1382          		{
   1383          			/* Has the task already been resumed from within an ISR? */
   1384          			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
   1385          			{
   1386          				/* Is it in the suspended list because it is in the	Suspended
   1387          				state, or because is is blocked with no timeout? */
   1388          				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
   1389          				{
   1390          					xReturn = pdTRUE;
   1391          				}
   1392          				else
   1393          				{
   1394          					mtCOVERAGE_TEST_MARKER();
   1395          				}
   1396          			}
   1397          			else
   1398          			{
   1399          				mtCOVERAGE_TEST_MARKER();
   1400          			}
   1401          		}
   1402          		else
   1403          		{
   1404          			mtCOVERAGE_TEST_MARKER();
   1405          		}
   1406          
   1407          		return xReturn;
   1408          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1409          
   1410          #endif /* INCLUDE_vTaskSuspend */
   1411          /*-----------------------------------------------------------*/
   1412          
   1413          #if ( INCLUDE_vTaskSuspend == 1 )
   1414          
   1415          	void vTaskResume( TaskHandle_t xTaskToResume )
   1416          	{
   1417          	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   1418          
   1419          		/* It does not make sense to resume the calling task. */
   1420          		configASSERT( xTaskToResume );
   1421          
   1422          		/* The parameter cannot be NULL as it is impossible to resume the
   1423          		currently executing task. */
   1424          		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   1425          		{
   1426          			taskENTER_CRITICAL();
   1427          			{
   1428          				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   1429          				{
   1430          					traceTASK_RESUME( pxTCB );
   1431          
   1432          					/* As we are in a critical section we can access the ready
   1433          					lists even if the scheduler is suspended. */
   1434          					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
   1435          					prvAddTaskToReadyList( pxTCB );
   1436          
   1437          					/* We may have just resumed a higher priority task. */
   1438          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1439          					{
   1440          						/* This yield may not cause the task just resumed to run,
   1441          						but will leave the lists in the correct state for the
   1442          						next yield. */
   1443          						taskYIELD_IF_USING_PREEMPTION();
   1444          					}
   1445          					else
   1446          					{
   1447          						mtCOVERAGE_TEST_MARKER();
   1448          					}
   1449          				}
   1450          				else
   1451          				{
   1452          					mtCOVERAGE_TEST_MARKER();
   1453          				}
   1454          			}
   1455          			taskEXIT_CRITICAL();
   1456          		}
   1457          		else
   1458          		{
   1459          			mtCOVERAGE_TEST_MARKER();
   1460          		}
   1461          	}
   1462          
   1463          #endif /* INCLUDE_vTaskSuspend */
   1464          
   1465          /*-----------------------------------------------------------*/
   1466          
   1467          #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
   1468          
   1469          	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
   1470          	{
   1471          	BaseType_t xYieldRequired = pdFALSE;
   1472          	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   1473          	UBaseType_t uxSavedInterruptStatus;
   1474          
   1475          		configASSERT( xTaskToResume );
   1476          
   1477          		/* RTOS ports that support interrupt nesting have the concept of a
   1478          		maximum	system call (or maximum API call) interrupt priority.
   1479          		Interrupts that are	above the maximum system call priority are keep
   1480          		permanently enabled, even when the RTOS kernel is in a critical section,
   1481          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1482          		is defined in FreeRTOSConfig.h then
   1483          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1484          		failure if a FreeRTOS API function is called from an interrupt that has
   1485          		been assigned a priority above the configured maximum system call
   1486          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1487          		from interrupts	that have been assigned a priority at or (logically)
   1488          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1489          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1490          		simple as possible.  More information (albeit Cortex-M specific) is
   1491          		provided on the following link:
   1492          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1493          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1494          
   1495          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   1496          		{
   1497          			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   1498          			{
   1499          				traceTASK_RESUME_FROM_ISR( pxTCB );
   1500          
   1501          				/* Check the ready lists can be accessed. */
   1502          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1503          				{
   1504          					/* Ready lists can be accessed so move the task from the
   1505          					suspended list to the ready list directly. */
   1506          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1507          					{
   1508          						xYieldRequired = pdTRUE;
   1509          					}
   1510          					else
   1511          					{
   1512          						mtCOVERAGE_TEST_MARKER();
   1513          					}
   1514          
   1515          					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
   1516          					prvAddTaskToReadyList( pxTCB );
   1517          				}
   1518          				else
   1519          				{
   1520          					/* The delayed or ready lists cannot be accessed so the task
   1521          					is held in the pending ready list until the scheduler is
   1522          					unsuspended. */
   1523          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   1524          				}
   1525          			}
   1526          			else
   1527          			{
   1528          				mtCOVERAGE_TEST_MARKER();
   1529          			}
   1530          		}
   1531          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1532          
   1533          		return xYieldRequired;
   1534          	}
   1535          
   1536          #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
   1537          /*-----------------------------------------------------------*/
   1538          
   1539          void vTaskStartScheduler( void )
   1540          {
   1541          BaseType_t xReturn;
   1542          
   1543          	/* Add the idle task at the lowest priority. */
   1544          	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1545          	{
   1546          		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
   1547          		be returned by the xTaskGetIdleTaskHandle() function. */
   1548          		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   1549          	}
   1550          	#else
   1551          	{
   1552          		/* Create the idle task without storing its handle. */
   1553          		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   1554          	}
   1555          	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
   1556          
   1557          	#if ( configUSE_TIMERS == 1 )
   1558          	{
   1559          		if( xReturn == pdPASS )
   1560          		{
   1561          			xReturn = xTimerCreateTimerTask();
   1562          		}
   1563          		else
   1564          		{
   1565          			mtCOVERAGE_TEST_MARKER();
   1566          		}
   1567          	}
   1568          	#endif /* configUSE_TIMERS */
   1569          
   1570          	if( xReturn == pdPASS )
   1571          	{
   1572          		/* Interrupts are turned off here, to ensure a tick does not occur
   1573          		before or during the call to xPortStartScheduler().  The stacks of
   1574          		the created tasks contain a status word with interrupts switched on
   1575          		so interrupts will automatically get re-enabled when the first task
   1576          		starts to run. */
   1577          		portDISABLE_INTERRUPTS();
   1578          
   1579          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   1580          		{
   1581          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   1582          			structure specific to the task that will run first. */
   1583          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   1584          		}
   1585          		#endif /* configUSE_NEWLIB_REENTRANT */
   1586          
   1587          		xSchedulerRunning = pdTRUE;
   1588          		xTickCount = ( TickType_t ) 0U;
   1589          
   1590          		/* If configGENERATE_RUN_TIME_STATS is defined then the following
   1591          		macro must be defined to configure the timer/counter used to generate
   1592          		the run time counter time base. */
   1593          		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   1594          
   1595          		/* Setting up the timer tick is hardware specific and thus in the
   1596          		portable interface. */
   1597          		if( xPortStartScheduler() != pdFALSE )
   1598          		{
   1599          			/* Should not reach here as if the scheduler is running the
   1600          			function will not return. */
   1601          		}
   1602          		else
   1603          		{
   1604          			/* Should only reach here if a task calls xTaskEndScheduler(). */
   1605          		}
   1606          	}
   1607          	else
   1608          	{
   1609          		/* This line will only be reached if the kernel could not be started,
   1610          		because there was not enough FreeRTOS heap to create the idle task
   1611          		or the timer task. */
   1612          		configASSERT( xReturn );
   1613          	}
   1614          }
   1615          /*-----------------------------------------------------------*/
   1616          
   1617          void vTaskEndScheduler( void )
   1618          {
   1619          	/* Stop the scheduler interrupts and call the portable scheduler end
   1620          	routine so the original ISRs can be restored if necessary.  The port
   1621          	layer must ensure interrupts enable	bit is left in the correct state. */
   1622          	portDISABLE_INTERRUPTS();
   1623          	xSchedulerRunning = pdFALSE;
   1624          	vPortEndScheduler();
   1625          }
   1626          /*----------------------------------------------------------*/
   1627          
   1628          void vTaskSuspendAll( void )
   1629          {
   1630          	/* A critical section is not required as the variable is of type
   1631          	BaseType_t.  Please read Richard Barry's reply in the following link to a
   1632          	post in the FreeRTOS support forum before reporting this as a bug! -
   1633          	http://goo.gl/wu4acr */
   1634          	++uxSchedulerSuspended;
   1635          }
   1636          /*----------------------------------------------------------*/
   1637          
   1638          #if ( configUSE_TICKLESS_IDLE != 0 )
   1639          
   1640          	static TickType_t prvGetExpectedIdleTime( void )
   1641          	{
   1642          	TickType_t xReturn;
   1643          
   1644          		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
   1645          		{
   1646          			xReturn = 0;
   1647          		}
   1648          		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
   1649          		{
   1650          			/* There are other idle priority tasks in the ready state.  If
   1651          			time slicing is used then the very next tick interrupt must be
   1652          			processed. */
   1653          			xReturn = 0;
   1654          		}
   1655          		else
   1656          		{
   1657          			xReturn = xNextTaskUnblockTime - xTickCount;
   1658          		}
   1659          
   1660          		return xReturn;
   1661          	}
   1662          
   1663          #endif /* configUSE_TICKLESS_IDLE */
   1664          /*----------------------------------------------------------*/
   1665          
   1666          BaseType_t xTaskResumeAll( void )
   1667          {
   1668          TCB_t *pxTCB;
   1669          BaseType_t xAlreadyYielded = pdFALSE;
   1670          
   1671          	/* If uxSchedulerSuspended is zero then this function does not match a
   1672          	previous call to vTaskSuspendAll(). */
   1673          	configASSERT( uxSchedulerSuspended );
   1674          
   1675          	/* It is possible that an ISR caused a task to be removed from an event
   1676          	list while the scheduler was suspended.  If this was the case then the
   1677          	removed task will have been added to the xPendingReadyList.  Once the
   1678          	scheduler has been resumed it is safe to move all the pending ready
   1679          	tasks from this list into their appropriate ready list. */
   1680          	taskENTER_CRITICAL();
   1681          	{
   1682          		--uxSchedulerSuspended;
   1683          
   1684          		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1685          		{
   1686          			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   1687          			{
   1688          				/* Move any readied tasks from the pending list into the
   1689          				appropriate ready list. */
   1690          				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   1691          				{
   1692          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   1693          					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1694          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   1695          					prvAddTaskToReadyList( pxTCB );
   1696          
   1697          					/* If the moved task has a priority higher than the current
   1698          					task then a yield must be performed. */
   1699          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1700          					{
   1701          						xYieldPending = pdTRUE;
   1702          					}
   1703          					else
   1704          					{
   1705          						mtCOVERAGE_TEST_MARKER();
   1706          					}
   1707          				}
   1708          
   1709          				/* If any ticks occurred while the scheduler was suspended then
   1710          				they should be processed now.  This ensures the tick count does
   1711          				not	slip, and that any delayed tasks are resumed at the correct
   1712          				time. */
   1713          				if( uxPendedTicks > ( UBaseType_t ) 0U )
   1714          				{
   1715          					while( uxPendedTicks > ( UBaseType_t ) 0U )
   1716          					{
   1717          						if( xTaskIncrementTick() != pdFALSE )
   1718          						{
   1719          							xYieldPending = pdTRUE;
   1720          						}
   1721          						else
   1722          						{
   1723          							mtCOVERAGE_TEST_MARKER();
   1724          						}
   1725          						--uxPendedTicks;
   1726          					}
   1727          				}
   1728          				else
   1729          				{
   1730          					mtCOVERAGE_TEST_MARKER();
   1731          				}
   1732          
   1733          				if( xYieldPending == pdTRUE )
   1734          				{
   1735          					#if( configUSE_PREEMPTION != 0 )
   1736          					{
   1737          						xAlreadyYielded = pdTRUE;
   1738          					}
   1739          					#endif
   1740          					taskYIELD_IF_USING_PREEMPTION();
   1741          				}
   1742          				else
   1743          				{
   1744          					mtCOVERAGE_TEST_MARKER();
   1745          				}
   1746          			}
   1747          		}
   1748          		else
   1749          		{
   1750          			mtCOVERAGE_TEST_MARKER();
   1751          		}
   1752          	}
   1753          	taskEXIT_CRITICAL();
   1754          
   1755          	return xAlreadyYielded;
   1756          }
   1757          /*-----------------------------------------------------------*/
   1758          
   1759          TickType_t xTaskGetTickCount( void )
   1760          {
   1761          TickType_t xTicks;
   1762          
   1763          	/* Critical section required if running on a 16 bit processor. */
   1764          	portTICK_TYPE_ENTER_CRITICAL();
   1765          	{
   1766          		xTicks = xTickCount;
   1767          	}
   1768          	portTICK_TYPE_EXIT_CRITICAL();
   1769          
   1770          	return xTicks;
   1771          }
   1772          /*-----------------------------------------------------------*/
   1773          
   1774          TickType_t xTaskGetTickCountFromISR( void )
   1775          {
   1776          TickType_t xReturn;
   1777          UBaseType_t uxSavedInterruptStatus;
   1778          
   1779          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1780          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1781          	above the maximum system call priority are kept permanently enabled, even
   1782          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1783          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1784          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1785          	failure if a FreeRTOS API function is called from an interrupt that has been
   1786          	assigned a priority above the configured maximum system call priority.
   1787          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1788          	that have been assigned a priority at or (logically) below the maximum
   1789          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1790          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1791          	More information (albeit Cortex-M specific) is provided on the following
   1792          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1793          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1794          
   1795          	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
   1796          	{
   1797          		xReturn = xTickCount;
   1798          	}
   1799          	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1800          
   1801          	return xReturn;
   1802          }
   1803          /*-----------------------------------------------------------*/
   1804          
   1805          UBaseType_t uxTaskGetNumberOfTasks( void )
   1806          {
   1807          	/* A critical section is not required because the variables are of type
   1808          	BaseType_t. */
   1809          	return uxCurrentNumberOfTasks;
   1810          }
   1811          /*-----------------------------------------------------------*/
   1812          
   1813          #if ( INCLUDE_pcTaskGetTaskName == 1 )
   1814          
   1815          	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   1816          	{
   1817          	TCB_t *pxTCB;
   1818          
   1819          		/* If null is passed in here then the name of the calling task is being queried. */
   1820          		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   1821          		configASSERT( pxTCB );
   1822          		return &( pxTCB->pcTaskName[ 0 ] );
   1823          	}
   1824          
   1825          #endif /* INCLUDE_pcTaskGetTaskName */
   1826          /*-----------------------------------------------------------*/
   1827          
   1828          #if ( configUSE_TRACE_FACILITY == 1 )
   1829          
   1830          	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
   1831          	{
   1832          	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
   1833          
   1834          		vTaskSuspendAll();
   1835          		{
   1836          			/* Is there a space in the array for each task in the system? */
   1837          			if( uxArraySize >= uxCurrentNumberOfTasks )
   1838          			{
   1839          				/* Fill in an TaskStatus_t structure with information on each
   1840          				task in the Ready state. */
   1841          				do
   1842          				{
   1843          					uxQueue--;
   1844          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
   1845          
   1846          				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1847          
   1848          				/* Fill in an TaskStatus_t structure with information on each
   1849          				task in the Blocked state. */
   1850          				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
   1851          				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
   1852          
   1853          				#if( INCLUDE_vTaskDelete == 1 )
   1854          				{
   1855          					/* Fill in an TaskStatus_t structure with information on
   1856          					each task that has been deleted but not yet cleaned up. */
   1857          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
   1858          				}
   1859          				#endif
   1860          
   1861          				#if ( INCLUDE_vTaskSuspend == 1 )
   1862          				{
   1863          					/* Fill in an TaskStatus_t structure with information on
   1864          					each task in the Suspended state. */
   1865          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
   1866          				}
   1867          				#endif
   1868          
   1869          				#if ( configGENERATE_RUN_TIME_STATS == 1)
   1870          				{
   1871          					if( pulTotalRunTime != NULL )
   1872          					{
   1873          						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   1874          							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
   1875          						#else
   1876          							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   1877          						#endif
   1878          					}
   1879          				}
   1880          				#else
   1881          				{
   1882          					if( pulTotalRunTime != NULL )
   1883          					{
   1884          						*pulTotalRunTime = 0;
   1885          					}
   1886          				}
   1887          				#endif
   1888          			}
   1889          			else
   1890          			{
   1891          				mtCOVERAGE_TEST_MARKER();
   1892          			}
   1893          		}
   1894          		( void ) xTaskResumeAll();
   1895          
   1896          		return uxTask;
   1897          	}
   1898          
   1899          #endif /* configUSE_TRACE_FACILITY */
   1900          /*----------------------------------------------------------*/
   1901          
   1902          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1903          
   1904          	TaskHandle_t xTaskGetIdleTaskHandle( void )
   1905          	{
   1906          		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
   1907          		started, then xIdleTaskHandle will be NULL. */
   1908          		configASSERT( ( xIdleTaskHandle != NULL ) );
   1909          		return xIdleTaskHandle;
   1910          	}
   1911          
   1912          #endif /* INCLUDE_xTaskGetIdleTaskHandle */
   1913          /*----------------------------------------------------------*/
   1914          
   1915          /* This conditional compilation should use inequality to 0, not equality to 1.
   1916          This is to ensure vTaskStepTick() is available when user defined low power mode
   1917          implementations require configUSE_TICKLESS_IDLE to be set to a value other than
   1918          1. */
   1919          #if ( configUSE_TICKLESS_IDLE != 0 )
   1920          
   1921          	void vTaskStepTick( const TickType_t xTicksToJump )
   1922          	{
   1923          		/* Correct the tick count value after a period during which the tick
   1924          		was suppressed.  Note this does *not* call the tick hook function for
   1925          		each stepped tick. */
   1926          		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
   1927          		xTickCount += xTicksToJump;
   1928          		traceINCREASE_TICK_COUNT( xTicksToJump );
   1929          	}
   1930          
   1931          #endif /* configUSE_TICKLESS_IDLE */
   1932          /*----------------------------------------------------------*/
   1933          
   1934          BaseType_t xTaskIncrementTick( void )
   1935          {
   1936          TCB_t * pxTCB;
   1937          TickType_t xItemValue;
   1938          BaseType_t xSwitchRequired = pdFALSE;
   1939          
   1940          	/* Called by the portable layer each time a tick interrupt occurs.
   1941          	Increments the tick then checks to see if the new tick value will cause any
   1942          	tasks to be unblocked. */
   1943          	traceTASK_INCREMENT_TICK( xTickCount );
   1944          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1945          	{
   1946          		/* Increment the RTOS tick, switching the delayed and overflowed
   1947          		delayed lists if it wraps to 0. */
   1948          		++xTickCount;
   1949          
   1950          		{
   1951          			/* Minor optimisation.  The tick count cannot change in this
   1952          			block. */
   1953          			const TickType_t xConstTickCount = xTickCount;
   1954          
   1955          			if( xConstTickCount == ( TickType_t ) 0U )
   1956          			{
   1957          				taskSWITCH_DELAYED_LISTS();
   1958          			}
   1959          			else
   1960          			{
   1961          				mtCOVERAGE_TEST_MARKER();
   1962          			}
   1963          
   1964          			/* See if this tick has made a timeout expire.  Tasks are stored in
   1965          			the	queue in the order of their wake time - meaning once one task
   1966          			has been found whose block time has not expired there is no need to
   1967          			look any further down the list. */
   1968          			if( xConstTickCount >= xNextTaskUnblockTime )
   1969          			{
   1970          				for( ;; )
   1971          				{
   1972          					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   1973          					{
   1974          						/* The delayed list is empty.  Set xNextTaskUnblockTime
   1975          						to the maximum possible value so it is extremely
   1976          						unlikely that the
   1977          						if( xTickCount >= xNextTaskUnblockTime ) test will pass
   1978          						next time through. */
   1979          						xNextTaskUnblockTime = portMAX_DELAY;
   1980          						break;
   1981          					}
   1982          					else
   1983          					{
   1984          						/* The delayed list is not empty, get the value of the
   1985          						item at the head of the delayed list.  This is the time
   1986          						at which the task at the head of the delayed list must
   1987          						be removed from the Blocked state. */
   1988          						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   1989          						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   1990          
   1991          						if( xConstTickCount < xItemValue )
   1992          						{
   1993          							/* It is not time to unblock this item yet, but the
   1994          							item value is the time at which the task at the head
   1995          							of the blocked list must be removed from the Blocked
   1996          							state -	so record the item value in
   1997          							xNextTaskUnblockTime. */
   1998          							xNextTaskUnblockTime = xItemValue;
   1999          							break;
   2000          						}
   2001          						else
   2002          						{
   2003          							mtCOVERAGE_TEST_MARKER();
   2004          						}
   2005          
   2006          						/* It is time to remove the item from the Blocked state. */
   2007          						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   2008          
   2009          						/* Is the task waiting on an event also?  If so remove
   2010          						it from the event list. */
   2011          						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   2012          						{
   2013          							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   2014          						}
   2015          						else
   2016          						{
   2017          							mtCOVERAGE_TEST_MARKER();
   2018          						}
   2019          
   2020          						/* Place the unblocked task into the appropriate ready
   2021          						list. */
   2022          						prvAddTaskToReadyList( pxTCB );
   2023          
   2024          						/* A task being unblocked cannot cause an immediate
   2025          						context switch if preemption is turned off. */
   2026          						#if (  configUSE_PREEMPTION == 1 )
   2027          						{
   2028          							/* Preemption is on, but a context switch should
   2029          							only be performed if the unblocked task has a
   2030          							priority that is equal to or higher than the
   2031          							currently executing task. */
   2032          							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   2033          							{
   2034          								xSwitchRequired = pdTRUE;
   2035          							}
   2036          							else
   2037          							{
   2038          								mtCOVERAGE_TEST_MARKER();
   2039          							}
   2040          						}
   2041          						#endif /* configUSE_PREEMPTION */
   2042          					}
   2043          				}
   2044          			}
   2045          		}
   2046          
   2047          		/* Tasks of equal priority to the currently running task will share
   2048          		processing time (time slice) if preemption is on, and the application
   2049          		writer has not explicitly turned time slicing off. */
   2050          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
   2051          		{
   2052          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   2053          			{
   2054          				xSwitchRequired = pdTRUE;
   2055          			}
   2056          			else
   2057          			{
   2058          				mtCOVERAGE_TEST_MARKER();
   2059          			}
   2060          		}
   2061          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
   2062          
   2063          		#if ( configUSE_TICK_HOOK == 1 )
   2064          		{
   2065          			/* Guard against the tick hook being called when the pended tick
   2066          			count is being unwound (when the scheduler is being unlocked). */
   2067          			if( uxPendedTicks == ( UBaseType_t ) 0U )
   2068          			{
   2069          				vApplicationTickHook();
   2070          			}
   2071          			else
   2072          			{
   2073          				mtCOVERAGE_TEST_MARKER();
   2074          			}
   2075          		}
   2076          		#endif /* configUSE_TICK_HOOK */
   2077          	}
   2078          	else
   2079          	{
   2080          		++uxPendedTicks;
   2081          
   2082          		/* The tick hook gets called at regular intervals, even if the
   2083          		scheduler is locked. */
   2084          		#if ( configUSE_TICK_HOOK == 1 )
   2085          		{
   2086          			vApplicationTickHook();
   2087          		}
   2088          		#endif
   2089          	}
   2090          
   2091          	#if ( configUSE_PREEMPTION == 1 )
   2092          	{
   2093          		if( xYieldPending != pdFALSE )
   2094          		{
   2095          			xSwitchRequired = pdTRUE;
   2096          		}
   2097          		else
   2098          		{
   2099          			mtCOVERAGE_TEST_MARKER();
   2100          		}
   2101          	}
   2102          	#endif /* configUSE_PREEMPTION */
   2103          
   2104          	return xSwitchRequired;
   2105          }
   2106          /*-----------------------------------------------------------*/
   2107          
   2108          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2109          
   2110          	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
   2111          	{
   2112          	TCB_t *xTCB;
   2113          
   2114          		/* If xTask is NULL then it is the task hook of the calling task that is
   2115          		getting set. */
   2116          		if( xTask == NULL )
   2117          		{
   2118          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2119          		}
   2120          		else
   2121          		{
   2122          			xTCB = ( TCB_t * ) xTask;
   2123          		}
   2124          
   2125          		/* Save the hook function in the TCB.  A critical section is required as
   2126          		the value can be accessed from an interrupt. */
   2127          		taskENTER_CRITICAL();
   2128          			xTCB->pxTaskTag = pxHookFunction;
   2129          		taskEXIT_CRITICAL();
   2130          	}
   2131          
   2132          #endif /* configUSE_APPLICATION_TASK_TAG */
   2133          /*-----------------------------------------------------------*/
   2134          
   2135          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2136          
   2137          	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
   2138          	{
   2139          	TCB_t *xTCB;
   2140          	TaskHookFunction_t xReturn;
   2141          
   2142          		/* If xTask is NULL then we are setting our own task hook. */
   2143          		if( xTask == NULL )
   2144          		{
   2145          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2146          		}
   2147          		else
   2148          		{
   2149          			xTCB = ( TCB_t * ) xTask;
   2150          		}
   2151          
   2152          		/* Save the hook function in the TCB.  A critical section is required as
   2153          		the value can be accessed from an interrupt. */
   2154          		taskENTER_CRITICAL();
   2155          		{
   2156          			xReturn = xTCB->pxTaskTag;
   2157          		}
   2158          		taskEXIT_CRITICAL();
   2159          
   2160          		return xReturn;
   2161          	}
   2162          
   2163          #endif /* configUSE_APPLICATION_TASK_TAG */
   2164          /*-----------------------------------------------------------*/
   2165          
   2166          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2167          
   2168          	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
   2169          	{
   2170          	TCB_t *xTCB;
   2171          	BaseType_t xReturn;
   2172          
   2173          		/* If xTask is NULL then we are calling our own task hook. */
   2174          		if( xTask == NULL )
   2175          		{
   2176          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2177          		}
   2178          		else
   2179          		{
   2180          			xTCB = ( TCB_t * ) xTask;
   2181          		}
   2182          
   2183          		if( xTCB->pxTaskTag != NULL )
   2184          		{
   2185          			xReturn = xTCB->pxTaskTag( pvParameter );
   2186          		}
   2187          		else
   2188          		{
   2189          			xReturn = pdFAIL;
   2190          		}
   2191          
   2192          		return xReturn;
   2193          	}
   2194          
   2195          #endif /* configUSE_APPLICATION_TASK_TAG */
   2196          /*-----------------------------------------------------------*/
   2197          
   2198          void vTaskSwitchContext( void )
   2199          {
   2200          	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   2201          	{
   2202          		/* The scheduler is currently suspended - do not allow a context
   2203          		switch. */
   2204          		xYieldPending = pdTRUE;
   2205          	}
   2206          	else
   2207          	{
   2208          		xYieldPending = pdFALSE;
   2209          		traceTASK_SWITCHED_OUT();
   2210          
   2211          		#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2212          		{
   2213          				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   2214          					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
   2215          				#else
   2216          					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   2217          				#endif
   2218          
   2219          				/* Add the amount of time the task has been running to the
   2220          				accumulated	time so far.  The time the task started running was
   2221          				stored in ulTaskSwitchedInTime.  Note that there is no overflow
   2222          				protection here	so count values are only valid until the timer
   2223          				overflows.  The guard against negative values is to protect
   2224          				against suspect run time stat counter implementations - which
   2225          				are provided by the application, not the kernel. */
   2226          				if( ulTotalRunTime > ulTaskSwitchedInTime )
   2227          				{
   2228          					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   2229          				}
   2230          				else
   2231          				{
   2232          					mtCOVERAGE_TEST_MARKER();
   2233          				}
   2234          				ulTaskSwitchedInTime = ulTotalRunTime;
   2235          		}
   2236          		#endif /* configGENERATE_RUN_TIME_STATS */
   2237          
   2238          		/* Check for stack overflow, if configured. */
   2239          		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
   2240          		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
   2241          
   2242          		/* Select a new task to run using either the generic C or port
   2243          		optimised asm code. */
   2244          		taskSELECT_HIGHEST_PRIORITY_TASK();
   2245          		traceTASK_SWITCHED_IN();
   2246          
   2247          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2248          		{
   2249          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   2250          			structure specific to this task. */
   2251          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   2252          		}
   2253          		#endif /* configUSE_NEWLIB_REENTRANT */
   2254          	}
   2255          }
   2256          /*-----------------------------------------------------------*/
   2257          
   2258          void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
   2259          {
   2260          TickType_t xTimeToWake;
   2261          
   2262          	configASSERT( pxEventList );
   2263          
   2264          	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
   2265          	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
   2266          
   2267          	/* Place the event list item of the TCB in the appropriate event list.
   2268          	This is placed in the list in priority order so the highest priority task
   2269          	is the first to be woken by the event.  The queue that contains the event
   2270          	list is locked, preventing simultaneous access from interrupts. */
   2271          	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2272          
   2273          	/* The task must be removed from from the ready list before it is added to
   2274          	the blocked list as the same list item is used for both lists.  Exclusive
   2275          	access to the ready lists guaranteed because the scheduler is locked. */
   2276          	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   2277          	{
   2278          		/* The current task must be in a ready list, so there is no need to
   2279          		check, and the port reset macro can be called directly. */
   2280          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2281          	}
   2282          	else
   2283          	{
   2284          		mtCOVERAGE_TEST_MARKER();
   2285          	}
   2286          
   2287          	#if ( INCLUDE_vTaskSuspend == 1 )
   2288          	{
   2289          		if( xTicksToWait == portMAX_DELAY )
   2290          		{
   2291          			/* Add the task to the suspended task list instead of a delayed task
   2292          			list to ensure the task is not woken by a timing event.  It will
   2293          			block indefinitely. */
   2294          			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   2295          		}
   2296          		else
   2297          		{
   2298          			/* Calculate the time at which the task should be woken if the event
   2299          			does not occur.  This may overflow but this doesn't matter, the
   2300          			scheduler will handle it. */
   2301          			xTimeToWake = xTickCount + xTicksToWait;
   2302          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2303          		}
   2304          	}
   2305          	#else /* INCLUDE_vTaskSuspend */
   2306          	{
   2307          			/* Calculate the time at which the task should be woken if the event does
   2308          			not occur.  This may overflow but this doesn't matter, the scheduler
   2309          			will handle it. */
   2310          			xTimeToWake = xTickCount + xTicksToWait;
   2311          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2312          	}
   2313          	#endif /* INCLUDE_vTaskSuspend */
   2314          }
   2315          /*-----------------------------------------------------------*/
   2316          
   2317          void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
   2318          {
   2319          TickType_t xTimeToWake;
   2320          
   2321          	configASSERT( pxEventList );
   2322          
   2323          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   2324          	the event groups implementation. */
   2325          	configASSERT( uxSchedulerSuspended != 0 );
   2326          
   2327          	/* Store the item value in the event list item.  It is safe to access the
   2328          	event list item here as interrupts won't access the event list item of a
   2329          	task that is not in the Blocked state. */
   2330          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   2331          
   2332          	/* Place the event list item of the TCB at the end of the appropriate event
   2333          	list.  It is safe to access the event list here because it is part of an
   2334          	event group implementation - and interrupts don't access event groups
   2335          	directly (instead they access them indirectly by pending function calls to
   2336          	the task level). */
   2337          	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2338          
   2339          	/* The task must be removed from the ready list before it is added to the
   2340          	blocked list.  Exclusive access can be assured to the ready list as the
   2341          	scheduler is locked. */
   2342          	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   2343          	{
   2344          		/* The current task must be in a ready list, so there is no need to
   2345          		check, and the port reset macro can be called directly. */
   2346          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2347          	}
   2348          	else
   2349          	{
   2350          		mtCOVERAGE_TEST_MARKER();
   2351          	}
   2352          
   2353          	#if ( INCLUDE_vTaskSuspend == 1 )
   2354          	{
   2355          		if( xTicksToWait == portMAX_DELAY )
   2356          		{
   2357          			/* Add the task to the suspended task list instead of a delayed task
   2358          			list to ensure it is not woken by a timing event.  It will block
   2359          			indefinitely. */
   2360          			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   2361          		}
   2362          		else
   2363          		{
   2364          			/* Calculate the time at which the task should be woken if the event
   2365          			does not occur.  This may overflow but this doesn't matter, the
   2366          			kernel will manage it correctly. */
   2367          			xTimeToWake = xTickCount + xTicksToWait;
   2368          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2369          		}
   2370          	}
   2371          	#else /* INCLUDE_vTaskSuspend */
   2372          	{
   2373          			/* Calculate the time at which the task should be woken if the event does
   2374          			not occur.  This may overflow but this doesn't matter, the kernel
   2375          			will manage it correctly. */
   2376          			xTimeToWake = xTickCount + xTicksToWait;
   2377          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2378          	}
   2379          	#endif /* INCLUDE_vTaskSuspend */
   2380          }
   2381          /*-----------------------------------------------------------*/
   2382          
   2383          #if configUSE_TIMERS == 1
   2384          
   2385          	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
   2386          	{
   2387          	TickType_t xTimeToWake;
   2388          
   2389          		configASSERT( pxEventList );
   2390          
   2391          		/* This function should not be called by application code hence the
   2392          		'Restricted' in its name.  It is not part of the public API.  It is
   2393          		designed for use by kernel code, and has special calling requirements -
   2394          		it should be called from a critical section. */
   2395          
   2396          
   2397          		/* Place the event list item of the TCB in the appropriate event list.
   2398          		In this case it is assume that this is the only task that is going to
   2399          		be waiting on this event list, so the faster vListInsertEnd() function
   2400          		can be used in place of vListInsert. */
   2401          		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2402          
   2403          		/* We must remove this task from the ready list before adding it to the
   2404          		blocked list as the same list item is used for both lists.  This
   2405          		function is called form a critical section. */
   2406          		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   2407          		{
   2408          			/* The current task must be in a ready list, so there is no need to
   2409          			check, and the port reset macro can be called directly. */
   2410          			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2411          		}
   2412          		else
   2413          		{
   2414          			mtCOVERAGE_TEST_MARKER();
   2415          		}
   2416          
   2417          		/* Calculate the time at which the task should be woken if the event does
   2418          		not occur.  This may overflow but this doesn't matter. */
   2419          		xTimeToWake = xTickCount + xTicksToWait;
   2420          
   2421          		traceTASK_DELAY_UNTIL();
   2422          		prvAddCurrentTaskToDelayedList( xTimeToWake );
   2423          	}
   2424          
   2425          #endif /* configUSE_TIMERS */
   2426          /*-----------------------------------------------------------*/
   2427          
   2428          BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
   2429          {
   2430          TCB_t *pxUnblockedTCB;
   2431          BaseType_t xReturn;
   2432          
   2433          	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
   2434          	called from a critical section within an ISR. */
   2435          
   2436          	/* The event list is sorted in priority order, so the first in the list can
   2437          	be removed as it is known to be the highest priority.  Remove the TCB from
   2438          	the delayed list, and add it to the ready list.
   2439          
   2440          	If an event is for a queue that is locked then this function will never
   2441          	get called - the lock count on the queue will get modified instead.  This
   2442          	means exclusive access to the event list is guaranteed here.
   2443          
   2444          	This function assumes that a check has already been made to ensure that
   2445          	pxEventList is not empty. */
   2446          	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   2447          	configASSERT( pxUnblockedTCB );
   2448          	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   2449          
   2450          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2451          	{
   2452          		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   2453          		prvAddTaskToReadyList( pxUnblockedTCB );
   2454          	}
   2455          	else
   2456          	{
   2457          		/* The delayed and ready lists cannot be accessed, so hold this task
   2458          		pending until the scheduler is resumed. */
   2459          		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   2460          	}
   2461          
   2462          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   2463          	{
   2464          		/* Return true if the task removed from the event list has a higher
   2465          		priority than the calling task.  This allows the calling task to know if
   2466          		it should force a context switch now. */
   2467          		xReturn = pdTRUE;
   2468          
   2469          		/* Mark that a yield is pending in case the user is not using the
   2470          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   2471          		xYieldPending = pdTRUE;
   2472          	}
   2473          	else
   2474          	{
   2475          		xReturn = pdFALSE;
   2476          	}
   2477          
   2478          	#if( configUSE_TICKLESS_IDLE == 1 )
   2479          	{
   2480          		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
   2481          		might be set to the blocked task's time out time.  If the task is
   2482          		unblocked for a reason other than a timeout xNextTaskUnblockTime is
   2483          		normally left unchanged, because it is automatically get reset to a new
   2484          		value when the tick count equals xNextTaskUnblockTime.  However if
   2485          		tickless idling is used it might be more important to enter sleep mode
   2486          		at the earliest possible time - so reset xNextTaskUnblockTime here to
   2487          		ensure it is updated at the earliest possible time. */
   2488          		prvResetNextTaskUnblockTime();
   2489          	}
   2490          	#endif
   2491          
   2492          	return xReturn;
   2493          }
   2494          /*-----------------------------------------------------------*/
   2495          
   2496          BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
   2497          {
   2498          TCB_t *pxUnblockedTCB;
   2499          BaseType_t xReturn;
   2500          
   2501          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   2502          	the event flags implementation. */
   2503          	configASSERT( uxSchedulerSuspended != pdFALSE );
   2504          
   2505          	/* Store the new item value in the event list. */
   2506          	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   2507          
   2508          	/* Remove the event list form the event flag.  Interrupts do not access
   2509          	event flags. */
   2510          	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
   2511          	configASSERT( pxUnblockedTCB );
   2512          	( void ) uxListRemove( pxEventListItem );
   2513          
   2514          	/* Remove the task from the delayed list and add it to the ready list.  The
   2515          	scheduler is suspended so interrupts will not be accessing the ready
   2516          	lists. */
   2517          	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   2518          	prvAddTaskToReadyList( pxUnblockedTCB );
   2519          
   2520          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   2521          	{
   2522          		/* Return true if the task removed from the event list has
   2523          		a higher priority than the calling task.  This allows
   2524          		the calling task to know if it should force a context
   2525          		switch now. */
   2526          		xReturn = pdTRUE;
   2527          
   2528          		/* Mark that a yield is pending in case the user is not using the
   2529          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   2530          		xYieldPending = pdTRUE;
   2531          	}
   2532          	else
   2533          	{
   2534          		xReturn = pdFALSE;
   2535          	}
   2536          
   2537          	return xReturn;
   2538          }
   2539          /*-----------------------------------------------------------*/
   2540          
   2541          void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
   2542          {
   2543          	configASSERT( pxTimeOut );
   2544          	pxTimeOut->xOverflowCount = xNumOfOverflows;
   2545          	pxTimeOut->xTimeOnEntering = xTickCount;
   2546          }
   2547          /*-----------------------------------------------------------*/
   2548          
   2549          BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
   2550          {
   2551          BaseType_t xReturn;
   2552          
   2553          	configASSERT( pxTimeOut );
   2554          	configASSERT( pxTicksToWait );
   2555          
   2556          	taskENTER_CRITICAL();
   2557          	{
   2558          		/* Minor optimisation.  The tick count cannot change in this block. */
   2559          		const TickType_t xConstTickCount = xTickCount;
   2560          
   2561          		#if ( INCLUDE_vTaskSuspend == 1 )
   2562          			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
   2563          			the maximum block time then the task should block indefinitely, and
   2564          			therefore never time out. */
   2565          			if( *pxTicksToWait == portMAX_DELAY )
   2566          			{
   2567          				xReturn = pdFALSE;
   2568          			}
   2569          			else /* We are not blocking indefinitely, perform the checks below. */
   2570          		#endif
   2571          
   2572          		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   2573          		{
   2574          			/* The tick count is greater than the time at which vTaskSetTimeout()
   2575          			was called, but has also overflowed since vTaskSetTimeOut() was called.
   2576          			It must have wrapped all the way around and gone past us again. This
   2577          			passed since vTaskSetTimeout() was called. */
   2578          			xReturn = pdTRUE;
   2579          		}
   2580          		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
   2581          		{
   2582          			/* Not a genuine timeout. Adjust parameters for time remaining. */
   2583          			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
   2584          			vTaskSetTimeOutState( pxTimeOut );
   2585          			xReturn = pdFALSE;
   2586          		}
   2587          		else
   2588          		{
   2589          			xReturn = pdTRUE;
   2590          		}
   2591          	}
   2592          	taskEXIT_CRITICAL();
   2593          
   2594          	return xReturn;
   2595          }
   2596          /*-----------------------------------------------------------*/
   2597          
   2598          void vTaskMissedYield( void )
   2599          {
   2600          	xYieldPending = pdTRUE;
   2601          }
   2602          /*-----------------------------------------------------------*/
   2603          
   2604          #if ( configUSE_TRACE_FACILITY == 1 )
   2605          
   2606          	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
   2607          	{
   2608          	UBaseType_t uxReturn;
   2609          	TCB_t *pxTCB;
   2610          
   2611          		if( xTask != NULL )
   2612          		{
   2613          			pxTCB = ( TCB_t * ) xTask;
   2614          			uxReturn = pxTCB->uxTaskNumber;
   2615          		}
   2616          		else
   2617          		{
   2618          			uxReturn = 0U;
   2619          		}
   2620          
   2621          		return uxReturn;
   2622          	}
   2623          
   2624          #endif /* configUSE_TRACE_FACILITY */
   2625          /*-----------------------------------------------------------*/
   2626          
   2627          #if ( configUSE_TRACE_FACILITY == 1 )
   2628          
   2629          	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
   2630          	{
   2631          	TCB_t *pxTCB;
   2632          
   2633          		if( xTask != NULL )
   2634          		{
   2635          			pxTCB = ( TCB_t * ) xTask;
   2636          			pxTCB->uxTaskNumber = uxHandle;
   2637          		}
   2638          	}
   2639          
   2640          #endif /* configUSE_TRACE_FACILITY */
   2641          
   2642          /*
   2643           * -----------------------------------------------------------
   2644           * The Idle task.
   2645           * ----------------------------------------------------------
   2646           *
   2647           * The portTASK_FUNCTION() macro is used to allow port/compiler specific
   2648           * language extensions.  The equivalent prototype for this function is:
   2649           *
   2650           * void prvIdleTask( void *pvParameters );
   2651           *
   2652           */
   2653          static portTASK_FUNCTION( prvIdleTask, pvParameters )
   2654          {
   2655          	/* Stop warnings. */
   2656          	( void ) pvParameters;
   2657          
   2658          	for( ;; )
   2659          	{
   2660          		/* See if any tasks have been deleted. */
   2661          		prvCheckTasksWaitingTermination();
   2662          
   2663          		#if ( configUSE_PREEMPTION == 0 )
   2664          		{
   2665          			/* If we are not using preemption we keep forcing a task switch to
   2666          			see if any other task has become available.  If we are using
   2667          			preemption we don't need to do this as any task becoming available
   2668          			will automatically get the processor anyway. */
   2669          			taskYIELD();
   2670          		}
   2671          		#endif /* configUSE_PREEMPTION */
   2672          
   2673          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
   2674          		{
   2675          			/* When using preemption tasks of equal priority will be
   2676          			timesliced.  If a task that is sharing the idle priority is ready
   2677          			to run then the idle task should yield before the end of the
   2678          			timeslice.
   2679          
   2680          			A critical region is not required here as we are just reading from
   2681          			the list, and an occasional incorrect value will not matter.  If
   2682          			the ready list at the idle priority contains more than one task
   2683          			then a task other than the idle task is ready to execute. */
   2684          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   2685          			{
   2686          				taskYIELD();
   2687          			}
   2688          			else
   2689          			{
   2690          				mtCOVERAGE_TEST_MARKER();
   2691          			}
   2692          		}
   2693          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
   2694          
   2695          		#if ( configUSE_IDLE_HOOK == 1 )
   2696          		{
   2697          			extern void vApplicationIdleHook( void );
   2698          
   2699          			/* Call the user defined function from within the idle task.  This
   2700          			allows the application designer to add background functionality
   2701          			without the overhead of a separate task.
   2702          			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
   2703          			CALL A FUNCTION THAT MIGHT BLOCK. */
   2704          			vApplicationIdleHook();
   2705          		}
   2706          		#endif /* configUSE_IDLE_HOOK */
   2707          
   2708          		/* This conditional compilation should use inequality to 0, not equality
   2709          		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
   2710          		user defined low power mode	implementations require
   2711          		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
   2712          		#if ( configUSE_TICKLESS_IDLE != 0 )
   2713          		{
   2714          		TickType_t xExpectedIdleTime;
   2715          
   2716          			/* It is not desirable to suspend then resume the scheduler on
   2717          			each iteration of the idle task.  Therefore, a preliminary
   2718          			test of the expected idle time is performed without the
   2719          			scheduler suspended.  The result here is not necessarily
   2720          			valid. */
   2721          			xExpectedIdleTime = prvGetExpectedIdleTime();
   2722          
   2723          			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   2724          			{
   2725          				vTaskSuspendAll();
   2726          				{
   2727          					/* Now the scheduler is suspended, the expected idle
   2728          					time can be sampled again, and this time its value can
   2729          					be used. */
   2730          					configASSERT( xNextTaskUnblockTime >= xTickCount );
   2731          					xExpectedIdleTime = prvGetExpectedIdleTime();
   2732          
   2733          					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   2734          					{
   2735          						traceLOW_POWER_IDLE_BEGIN();
   2736          						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
   2737          						traceLOW_POWER_IDLE_END();
   2738          					}
   2739          					else
   2740          					{
   2741          						mtCOVERAGE_TEST_MARKER();
   2742          					}
   2743          				}
   2744          				( void ) xTaskResumeAll();
   2745          			}
   2746          			else
   2747          			{
   2748          				mtCOVERAGE_TEST_MARKER();
   2749          			}
   2750          		}
   2751          		#endif /* configUSE_TICKLESS_IDLE */
   2752          	}
   2753          }
   2754          /*-----------------------------------------------------------*/
   2755          
   2756          #if configUSE_TICKLESS_IDLE != 0
   2757          
   2758          	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
   2759          	{
   2760          	eSleepModeStatus eReturn = eStandardSleep;
   2761          
   2762          		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
   2763          		{
   2764          			/* A task was made ready while the scheduler was suspended. */
   2765          			eReturn = eAbortSleep;
   2766          		}
   2767          		else if( xYieldPending != pdFALSE )
   2768          		{
   2769          			/* A yield was pended while the scheduler was suspended. */
   2770          			eReturn = eAbortSleep;
   2771          		}
   2772          		else
   2773          		{
   2774          			#if configUSE_TIMERS == 0
   2775          			{
   2776          				/* The idle task exists in addition to the application tasks. */
   2777          				const UBaseType_t uxNonApplicationTasks = 1;
   2778          
   2779          				/* If timers are not being used and all the tasks are in the
   2780          				suspended list (which might mean they have an infinite block
   2781          				time rather than actually being suspended) then it is safe to
   2782          				turn all clocks off and just wait for external interrupts. */
   2783          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
   2784          				{
   2785          					eReturn = eNoTasksWaitingTimeout;
   2786          				}
   2787          				else
   2788          				{
   2789          					mtCOVERAGE_TEST_MARKER();
   2790          				}
   2791          			}
   2792          			#endif /* configUSE_TIMERS */
   2793          		}
   2794          
   2795          		return eReturn;
   2796          	}
   2797          #endif /* configUSE_TICKLESS_IDLE */
   2798          /*-----------------------------------------------------------*/
   2799          
   2800          static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2801          {
   2802          UBaseType_t x;
   2803          
   2804          	/* Store the task name in the TCB. */
   2805          	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   2806          	{
   2807          		pxTCB->pcTaskName[ x ] = pcName[ x ];
   2808          
   2809          		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
   2810          		configMAX_TASK_NAME_LEN characters just in case the memory after the
   2811          		string is not accessible (extremely unlikely). */
   2812          		if( pcName[ x ] == 0x00 )
   2813          		{
   2814          			break;
   2815          		}
   2816          		else
   2817          		{
   2818          			mtCOVERAGE_TEST_MARKER();
   2819          		}
   2820          	}
   2821          
   2822          	/* Ensure the name string is terminated in the case that the string length
   2823          	was greater or equal to configMAX_TASK_NAME_LEN. */
   2824          	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   2825          
   2826          	/* This is used as an array index so must ensure it's not too large.  First
   2827          	remove the privilege bit if one is present. */
   2828          	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   2829          	{
   2830          		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   2831          	}
   2832          	else
   2833          	{
   2834          		mtCOVERAGE_TEST_MARKER();
   2835          	}
   2836          
   2837          	pxTCB->uxPriority = uxPriority;
   2838          	#if ( configUSE_MUTEXES == 1 )
   2839          	{
   2840          		pxTCB->uxBasePriority = uxPriority;
   2841          		pxTCB->uxMutexesHeld = 0;
   2842          	}
   2843          	#endif /* configUSE_MUTEXES */
   2844          
   2845          	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   2846          	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   2847          
   2848          	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
   2849          	back to	the containing TCB from a generic item in a list. */
   2850          	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   2851          
   2852          	/* Event lists are always in priority order. */
   2853          	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2854          	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   2855          
   2856          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2857          	{
   2858          		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
   2859          	}
   2860          	#endif /* portCRITICAL_NESTING_IN_TCB */
   2861          
   2862          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2863          	{
   2864          		pxTCB->pxTaskTag = NULL;
   2865          	}
   2866          	#endif /* configUSE_APPLICATION_TASK_TAG */
   2867          
   2868          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2869          	{
   2870          		pxTCB->ulRunTimeCounter = 0UL;
   2871          	}
   2872          	#endif /* configGENERATE_RUN_TIME_STATS */
   2873          
   2874          	#if ( portUSING_MPU_WRAPPERS == 1 )
   2875          	{
   2876          		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
   2877          	}
   2878          	#else /* portUSING_MPU_WRAPPERS */
   2879          	{
   2880          		( void ) xRegions;
   2881          		( void ) usStackDepth;
   2882          	}
   2883          	#endif /* portUSING_MPU_WRAPPERS */
   2884          
   2885          	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
   2886          	{
   2887          		pxTCB->ulNotifiedValue = 0;
   2888          		pxTCB->eNotifyState = eNotWaitingNotification;
   2889          	}
   2890          	#endif
   2891          
   2892          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2893          	{
   2894          		/* Initialise this task's Newlib reent structure. */
   2895          		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
   2896          	}
   2897          	#endif /* configUSE_NEWLIB_REENTRANT */
   2898          }
   2899          /*-----------------------------------------------------------*/
   2900          
   2901          #if ( portUSING_MPU_WRAPPERS == 1 )
   2902          
   2903          	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
   2904          	{
   2905          	TCB_t *pxTCB;
   2906          
   2907          		/* If null is passed in here then we are deleting ourselves. */
   2908          		pxTCB = prvGetTCBFromHandle( xTaskToModify );
   2909          
   2910                  vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
   2911          	}
   2912          
   2913          #endif /* portUSING_MPU_WRAPPERS */
   2914          /*-----------------------------------------------------------*/
   2915          
   2916          static void prvInitialiseTaskLists( void )
   2917          {
   2918          UBaseType_t uxPriority;
   2919          
   2920          	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   2921          	{
   2922          		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   2923          	}
   2924          
   2925          	vListInitialise( &xDelayedTaskList1 );
   2926          	vListInitialise( &xDelayedTaskList2 );
   2927          	vListInitialise( &xPendingReadyList );
   2928          
   2929          	#if ( INCLUDE_vTaskDelete == 1 )
   2930          	{
   2931          		vListInitialise( &xTasksWaitingTermination );
   2932          	}
   2933          	#endif /* INCLUDE_vTaskDelete */
   2934          
   2935          	#if ( INCLUDE_vTaskSuspend == 1 )
   2936          	{
   2937          		vListInitialise( &xSuspendedTaskList );
   2938          	}
   2939          	#endif /* INCLUDE_vTaskSuspend */
   2940          
   2941          	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
   2942          	using list2. */
   2943          	pxDelayedTaskList = &xDelayedTaskList1;
   2944          	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   2945          }
   2946          /*-----------------------------------------------------------*/
   2947          
   2948          static void prvCheckTasksWaitingTermination( void )
   2949          {
   2950          	#if ( INCLUDE_vTaskDelete == 1 )
   2951          	{
   2952          		BaseType_t xListIsEmpty;
   2953          
   2954          		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
   2955          		too often in the idle task. */
   2956          		while( uxTasksDeleted > ( UBaseType_t ) 0U )
   2957          		{
   2958          			vTaskSuspendAll();
   2959          			{
   2960          				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   2961          			}
   2962          			( void ) xTaskResumeAll();
   2963          
   2964          			if( xListIsEmpty == pdFALSE )
   2965          			{
   2966          				TCB_t *pxTCB;
   2967          
   2968          				taskENTER_CRITICAL();
   2969          				{
   2970          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   2971          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   2972          					--uxCurrentNumberOfTasks;
   2973          					--uxTasksDeleted;
   2974          				}
   2975          				taskEXIT_CRITICAL();
   2976          
   2977          				prvDeleteTCB( pxTCB );
   2978          			}
   2979          			else
   2980          			{
   2981          				mtCOVERAGE_TEST_MARKER();
   2982          			}
   2983          		}
   2984          	}
   2985          	#endif /* vTaskDelete */
   2986          }
   2987          /*-----------------------------------------------------------*/
   2988          
   2989          static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
   2990          {
   2991          	/* The list item will be inserted in wake time order. */
   2992          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   2993          
   2994          	if( xTimeToWake < xTickCount )
   2995          	{
   2996          		/* Wake time has overflowed.  Place this item in the overflow list. */
   2997          		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   2998          	}
   2999          	else
   3000          	{
   3001          		/* The wake time has not overflowed, so the current block list is used. */
   3002          		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   3003          
   3004          		/* If the task entering the blocked state was placed at the head of the
   3005          		list of blocked tasks then xNextTaskUnblockTime needs to be updated
   3006          		too. */
   3007          		if( xTimeToWake < xNextTaskUnblockTime )
   3008          		{
   3009          			xNextTaskUnblockTime = xTimeToWake;
   3010          		}
   3011          		else
   3012          		{
   3013          			mtCOVERAGE_TEST_MARKER();
   3014          		}
   3015          	}
   3016          }
   3017          /*-----------------------------------------------------------*/
   3018          
   3019          static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
   3020          {
   3021          TCB_t *pxNewTCB;
   3022          
   3023          	/* If the stack grows down then allocate the stack then the TCB so the stack
   3024          	does not grow into the TCB.  Likewise if the stack grows up then allocate
   3025          	the TCB then the stack. */
   3026          	#if( portSTACK_GROWTH > 0 )
   3027          	{
   3028          		/* Allocate space for the TCB.  Where the memory comes from depends on
   3029          		the implementation of the port malloc function. */
   3030          		pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
   3031          
   3032          		if( pxNewTCB != NULL )
   3033          		{
   3034          			/* Allocate space for the stack used by the task being created.
   3035          			The base of the stack memory stored in the TCB so the task can
   3036          			be deleted later if required. */
   3037          			pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3038          
   3039          			if( pxNewTCB->pxStack == NULL )
   3040          			{
   3041          				/* Could not allocate the stack.  Delete the allocated TCB. */
   3042          				vPortFree( pxNewTCB );
   3043          				pxNewTCB = NULL;
   3044          			}
   3045          		}
   3046          	}
   3047          	#else /* portSTACK_GROWTH */
   3048          	{
   3049          	StackType_t *pxStack;
   3050          
   3051          		/* Allocate space for the stack used by the task being created. */
   3052          		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3053          
   3054          		if( pxStack != NULL )
   3055          		{
   3056          			/* Allocate space for the TCB.  Where the memory comes from depends
   3057          			on the implementation of the port malloc function. */
   3058          			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
   3059          
   3060          			if( pxNewTCB != NULL )
   3061          			{
   3062          				/* Store the stack location in the TCB. */
   3063          				pxNewTCB->pxStack = pxStack;
   3064          			}
   3065          			else
   3066          			{
   3067          				/* The stack cannot be used as the TCB was not created.  Free it
   3068          				again. */
   3069          				vPortFree( pxStack );
   3070          			}
   3071          		}
   3072          		else
   3073          		{
   3074          			pxNewTCB = NULL;
   3075          		}
   3076          	}
   3077          	#endif /* portSTACK_GROWTH */
   3078          
   3079          	if( pxNewTCB != NULL )
   3080          	{
   3081          		/* Avoid dependency on memset() if it is not required. */
   3082          		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   3083          		{
   3084          			/* Just to help debugging. */
   3085          			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
   3086          		}
   3087          		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
   3088          	}
   3089          
   3090          	return pxNewTCB;
   3091          }
   3092          /*-----------------------------------------------------------*/
   3093          
   3094          #if ( configUSE_TRACE_FACILITY == 1 )
   3095          
   3096          	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
   3097          	{
   3098          	volatile TCB_t *pxNextTCB, *pxFirstTCB;
   3099          	UBaseType_t uxTask = 0;
   3100          
   3101          		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   3102          		{
   3103          			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   3104          
   3105          			/* Populate an TaskStatus_t structure within the
   3106          			pxTaskStatusArray array for each task that is referenced from
   3107          			pxList.  See the definition of TaskStatus_t in task.h for the
   3108          			meaning of each TaskStatus_t structure member. */
   3109          			do
   3110          			{
   3111          				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   3112          
   3113          				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
   3114          				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
   3115          				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
   3116          				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
   3117          				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
   3118          
   3119          				#if ( INCLUDE_vTaskSuspend == 1 )
   3120          				{
   3121          					/* If the task is in the suspended list then there is a chance
   3122          					it is actually just blocked indefinitely - so really it should
   3123          					be reported as being in the Blocked state. */
   3124          					if( eState == eSuspended )
   3125          					{
   3126          						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
   3127          						{
   3128          							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
   3129          						}
   3130          					}
   3131          				}
   3132          				#endif /* INCLUDE_vTaskSuspend */
   3133          
   3134          				#if ( configUSE_MUTEXES == 1 )
   3135          				{
   3136          					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
   3137          				}
   3138          				#else
   3139          				{
   3140          					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
   3141          				}
   3142          				#endif
   3143          
   3144          				#if ( configGENERATE_RUN_TIME_STATS == 1 )
   3145          				{
   3146          					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
   3147          				}
   3148          				#else
   3149          				{
   3150          					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
   3151          				}
   3152          				#endif
   3153          
   3154          				#if ( portSTACK_GROWTH > 0 )
   3155          				{
   3156          					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
   3157          				}
   3158          				#else
   3159          				{
   3160          					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
   3161          				}
   3162          				#endif
   3163          
   3164          				uxTask++;
   3165          
   3166          			} while( pxNextTCB != pxFirstTCB );
   3167          		}
   3168          		else
   3169          		{
   3170          			mtCOVERAGE_TEST_MARKER();
   3171          		}
   3172          
   3173          		return uxTask;
   3174          	}
   3175          
   3176          #endif /* configUSE_TRACE_FACILITY */
   3177          /*-----------------------------------------------------------*/
   3178          
   3179          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   3180          
   3181          	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
   3182          	{
   3183          	uint32_t ulCount = 0U;
   3184          
   3185          		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   3186          		{
   3187          			pucStackByte -= portSTACK_GROWTH;
   3188          			ulCount++;
   3189          		}
   3190          
   3191          		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
   3192          
   3193          		return ( uint16_t ) ulCount;
   3194          	}
   3195          
   3196          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
   3197          /*-----------------------------------------------------------*/
   3198          
   3199          #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
   3200          
   3201          	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
   3202          	{
   3203          	TCB_t *pxTCB;
   3204          	uint8_t *pucEndOfStack;
   3205          	UBaseType_t uxReturn;
   3206          
   3207          		pxTCB = prvGetTCBFromHandle( xTask );
   3208          
   3209          		#if portSTACK_GROWTH < 0
   3210          		{
   3211          			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
   3212          		}
   3213          		#else
   3214          		{
   3215          			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
   3216          		}
   3217          		#endif
   3218          
   3219          		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
   3220          
   3221          		return uxReturn;
   3222          	}
   3223          
   3224          #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
   3225          /*-----------------------------------------------------------*/
   3226          
   3227          #if ( INCLUDE_vTaskDelete == 1 )
   3228          
   3229          	static void prvDeleteTCB( TCB_t *pxTCB )
   3230          	{
   3231          		/* This call is required specifically for the TriCore port.  It must be
   3232          		above the vPortFree() calls.  The call is also used by ports/demos that
   3233          		want to allocate and clean RAM statically. */
   3234          		portCLEAN_UP_TCB( pxTCB );
   3235          
   3236          		/* Free up the memory allocated by the scheduler for the task.  It is up
   3237          		to the task to free any memory allocated at the application level. */
   3238          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   3239          		{
   3240          			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
   3241          		}
   3242          		#endif /* configUSE_NEWLIB_REENTRANT */
   3243          
   3244          		#if( portUSING_MPU_WRAPPERS == 1 )
   3245          		{
   3246          			/* Only free the stack if it was allocated dynamically in the first
   3247          			place. */
   3248          			if( pxTCB->xUsingStaticallyAllocatedStack == pdFALSE )
   3249          			{
   3250          				vPortFreeAligned( pxTCB->pxStack );
   3251          			}
   3252          		}
   3253          		#else
   3254          		{
   3255          			vPortFreeAligned( pxTCB->pxStack );
   3256          		}
   3257          		#endif
   3258          
   3259          		vPortFree( pxTCB );
   3260          	}
   3261          
   3262          #endif /* INCLUDE_vTaskDelete */
   3263          /*-----------------------------------------------------------*/
   3264          
   3265          static void prvResetNextTaskUnblockTime( void )
   3266          {
   3267          TCB_t *pxTCB;
   3268          
   3269          	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   3270          	{
   3271          		/* The new current delayed list is empty.  Set
   3272          		xNextTaskUnblockTime to the maximum possible value so it is
   3273          		extremely unlikely that the
   3274          		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
   3275          		there is an item in the delayed list. */
   3276          		xNextTaskUnblockTime = portMAX_DELAY;
   3277          	}
   3278          	else
   3279          	{
   3280          		/* The new current delayed list is not empty, get the value of
   3281          		the item at the head of the delayed list.  This is the time at
   3282          		which the task at the head of the delayed list should be removed
   3283          		from the Blocked state. */
   3284          		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   3285          		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
   3286          	}
   3287          }
   3288          /*-----------------------------------------------------------*/
   3289          
   3290          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
   3291          
   3292          	TaskHandle_t xTaskGetCurrentTaskHandle( void )
   3293          	{
   3294          	TaskHandle_t xReturn;
   3295          
   3296          		/* A critical section is not required as this is not called from
   3297          		an interrupt and the current TCB will always be the same for any
   3298          		individual execution thread. */
   3299          		xReturn = pxCurrentTCB;
   3300          
   3301          		return xReturn;
   3302          	}
   3303          
   3304          #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
   3305          /*-----------------------------------------------------------*/
   3306          
   3307          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   3308          
   3309          	BaseType_t xTaskGetSchedulerState( void )
   3310          	{
   3311          	BaseType_t xReturn;
   3312          
   3313          		if( xSchedulerRunning == pdFALSE )
   3314          		{
   3315          			xReturn = taskSCHEDULER_NOT_STARTED;
   3316          		}
   3317          		else
   3318          		{
   3319          			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   3320          			{
   3321          				xReturn = taskSCHEDULER_RUNNING;
   3322          			}
   3323          			else
   3324          			{
   3325          				xReturn = taskSCHEDULER_SUSPENDED;
   3326          			}
   3327          		}
   3328          
   3329          		return xReturn;
   3330          	}
   3331          
   3332          #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
   3333          /*-----------------------------------------------------------*/
   3334          
   3335          #if ( configUSE_MUTEXES == 1 )
   3336          
   3337          	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
   3338          	{
   3339          	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   3340          
   3341          		/* If the mutex was given back by an interrupt while the queue was
   3342          		locked then the mutex holder might now be NULL. */
   3343          		if( pxMutexHolder != NULL )
   3344          		{
   3345          			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   3346          			{
   3347          				/* Adjust the mutex holder state to account for its new
   3348          				priority.  Only reset the event list item value if the value is
   3349          				not	being used for anything else. */
   3350          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   3351          				{
   3352          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3353          				}
   3354          				else
   3355          				{
   3356          					mtCOVERAGE_TEST_MARKER();
   3357          				}
   3358          
   3359          				/* If the task being modified is in the ready state it will need to
   3360          				be moved into a new list. */
   3361          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   3362          				{
   3363          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   3364          					{
   3365          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   3366          					}
   3367          					else
   3368          					{
   3369          						mtCOVERAGE_TEST_MARKER();
   3370          					}
   3371          
   3372          					/* Inherit the priority before being moved into the new list. */
   3373          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   3374          					prvAddTaskToReadyList( pxTCB );
   3375          				}
   3376          				else
   3377          				{
   3378          					/* Just inherit the priority. */
   3379          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   3380          				}
   3381          
   3382          				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
   3383          			}
   3384          			else
   3385          			{
   3386          				mtCOVERAGE_TEST_MARKER();
   3387          			}
   3388          		}
   3389          		else
   3390          		{
   3391          			mtCOVERAGE_TEST_MARKER();
   3392          		}
   3393          	}
   3394          
   3395          #endif /* configUSE_MUTEXES */
   3396          /*-----------------------------------------------------------*/
   3397          
   3398          #if ( configUSE_MUTEXES == 1 )
   3399          
   3400          	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
   3401          	{
   3402          	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   3403          	BaseType_t xReturn = pdFALSE;
   3404          
   3405          		if( pxMutexHolder != NULL )
   3406          		{
   3407          			configASSERT( pxTCB->uxMutexesHeld );
   3408          			( pxTCB->uxMutexesHeld )--;
   3409          
   3410          			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   3411          			{
   3412          				/* Only disinherit if no other mutexes are held. */
   3413          				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   3414          				{
   3415          					/* A task can only have an inhertied priority if it holds
   3416          					the mutex.  If the mutex is held by a task then it cannot be
   3417          					given from an interrupt, and if a mutex is given by the
   3418          					holding	task then it must be the running state task.  Remove
   3419          					the	holding task from the ready	list. */
   3420          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   3421          					{
   3422          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   3423          					}
   3424          					else
   3425          					{
   3426          						mtCOVERAGE_TEST_MARKER();
   3427          					}
   3428          
   3429          					/* Disinherit the priority before adding the task into the
   3430          					new	ready list. */
   3431          					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   3432          					pxTCB->uxPriority = pxTCB->uxBasePriority;
   3433          
   3434          					/* Reset the event list item value.  It cannot be in use for
   3435          					any other purpose if this task is running, and it must be
   3436          					running to give back the mutex. */
   3437          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3438          					prvAddTaskToReadyList( pxTCB );
   3439          
   3440          					/* Return true to indicate that a context switch is required.
   3441          					This is only actually required in the corner case whereby
   3442          					multiple mutexes were held and the mutexes were given back
   3443          					in an order different to that in which they were taken.
   3444          					If a context switch did not occur when the first mutex was
   3445          					returned, even if a task was waiting on it, then a context
   3446          					switch should occur when the last mutex is returned whether
   3447          					a task is waiting on it or not. */
   3448          					xReturn = pdTRUE;
   3449          				}
   3450          				else
   3451          				{
   3452          					mtCOVERAGE_TEST_MARKER();
   3453          				}
   3454          			}
   3455          			else
   3456          			{
   3457          				mtCOVERAGE_TEST_MARKER();
   3458          			}
   3459          		}
   3460          		else
   3461          		{
   3462          			mtCOVERAGE_TEST_MARKER();
   3463          		}
   3464          
   3465          		return xReturn;
   3466          	}
   3467          
   3468          #endif /* configUSE_MUTEXES */
   3469          /*-----------------------------------------------------------*/
   3470          
   3471          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   3472          
   3473          	void vTaskEnterCritical( void )
   3474          	{
   3475          		portDISABLE_INTERRUPTS();
   3476          
   3477          		if( xSchedulerRunning != pdFALSE )
   3478          		{
   3479          			( pxCurrentTCB->uxCriticalNesting )++;
   3480          
   3481          			/* This is not the interrupt safe version of the enter critical
   3482          			function so	assert() if it is being called from an interrupt
   3483          			context.  Only API functions that end in "FromISR" can be used in an
   3484          			interrupt.  Only assert if the critical nesting count is 1 to
   3485          			protect against recursive calls if the assert function also uses a
   3486          			critical section. */
   3487          			if( pxCurrentTCB->uxCriticalNesting == 1 )
   3488          			{
   3489          				portASSERT_IF_IN_ISR();
   3490          			}
   3491          
   3492          		}
   3493          		else
   3494          		{
   3495          			mtCOVERAGE_TEST_MARKER();
   3496          		}
   3497          	}
   3498          
   3499          #endif /* portCRITICAL_NESTING_IN_TCB */
   3500          /*-----------------------------------------------------------*/
   3501          
   3502          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   3503          
   3504          	void vTaskExitCritical( void )
   3505          	{
   3506          		if( xSchedulerRunning != pdFALSE )
   3507          		{
   3508          			if( pxCurrentTCB->uxCriticalNesting > 0U )
   3509          			{
   3510          				( pxCurrentTCB->uxCriticalNesting )--;
   3511          
   3512          				if( pxCurrentTCB->uxCriticalNesting == 0U )
   3513          				{
   3514          					portENABLE_INTERRUPTS();
   3515          				}
   3516          				else
   3517          				{
   3518          					mtCOVERAGE_TEST_MARKER();
   3519          				}
   3520          			}
   3521          			else
   3522          			{
   3523          				mtCOVERAGE_TEST_MARKER();
   3524          			}
   3525          		}
   3526          		else
   3527          		{
   3528          			mtCOVERAGE_TEST_MARKER();
   3529          		}
   3530          	}
   3531          
   3532          #endif /* portCRITICAL_NESTING_IN_TCB */
   3533          /*-----------------------------------------------------------*/
   3534          
   3535          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   3536          
   3537          	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
   3538          	{
   3539          	BaseType_t x;
   3540          
   3541          		/* Start by copying the entire string. */
   3542          		strcpy( pcBuffer, pcTaskName );
   3543          
   3544          		/* Pad the end of the string with spaces to ensure columns line up when
   3545          		printed out. */
   3546          		for( x = strlen( pcBuffer ); x < ( configMAX_TASK_NAME_LEN - 1 ); x++ )
   3547          		{
   3548          			pcBuffer[ x ] = ' ';
   3549          		}
   3550          
   3551          		/* Terminate. */
   3552          		pcBuffer[ x ] = 0x00;
   3553          
   3554          		/* Return the new end of string. */
   3555          		return &( pcBuffer[ x ] );
   3556          	}
   3557          
   3558          #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
   3559          /*-----------------------------------------------------------*/
   3560          
   3561          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   3562          
   3563          	void vTaskList( char * pcWriteBuffer )
   3564          	{
   3565          	TaskStatus_t *pxTaskStatusArray;
   3566          	volatile UBaseType_t uxArraySize, x;
   3567          	char cStatus;
   3568          
   3569          		/*
   3570          		 * PLEASE NOTE:
   3571          		 *
   3572          		 * This function is provided for convenience only, and is used by many
   3573          		 * of the demo applications.  Do not consider it to be part of the
   3574          		 * scheduler.
   3575          		 *
   3576          		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
   3577          		 * uxTaskGetSystemState() output into a human readable table that
   3578          		 * displays task names, states and stack usage.
   3579          		 *
   3580          		 * vTaskList() has a dependency on the sprintf() C library function that
   3581          		 * might bloat the code size, use a lot of stack, and provide different
   3582          		 * results on different platforms.  An alternative, tiny, third party,
   3583          		 * and limited functionality implementation of sprintf() is provided in
   3584          		 * many of the FreeRTOS/Demo sub-directories in a file called
   3585          		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
   3586          		 * snprintf() implementation!).
   3587          		 *
   3588          		 * It is recommended that production systems call uxTaskGetSystemState()
   3589          		 * directly to get access to raw stats data, rather than indirectly
   3590          		 * through a call to vTaskList().
   3591          		 */
   3592          
   3593          
   3594          		/* Make sure the write buffer does not contain a string. */
   3595          		*pcWriteBuffer = 0x00;
   3596          
   3597          		/* Take a snapshot of the number of tasks in case it changes while this
   3598          		function is executing. */
   3599          		uxArraySize = uxCurrentNumberOfTasks;
   3600          
   3601          		/* Allocate an array index for each task. */
   3602          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   3603          
   3604          		if( pxTaskStatusArray != NULL )
   3605          		{
   3606          			/* Generate the (binary) data. */
   3607          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
   3608          
   3609          			/* Create a human readable table from the binary data. */
   3610          			for( x = 0; x < uxArraySize; x++ )
   3611          			{
   3612          				switch( pxTaskStatusArray[ x ].eCurrentState )
   3613          				{
   3614          					case eReady:		cStatus = tskREADY_CHAR;
   3615          										break;
   3616          
   3617          					case eBlocked:		cStatus = tskBLOCKED_CHAR;
   3618          										break;
   3619          
   3620          					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
   3621          										break;
   3622          
   3623          					case eDeleted:		cStatus = tskDELETED_CHAR;
   3624          										break;
   3625          
   3626          					default:			/* Should not get here, but it is included
   3627          										to prevent static checking errors. */
   3628          										cStatus = 0x00;
   3629          										break;
   3630          				}
   3631          
   3632          				/* Write the task name to the string, padding with spaces so it
   3633          				can be printed in tabular form more easily. */
   3634          				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   3635          
   3636          				/* Write the rest of the string. */
   3637          				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
   3638          				pcWriteBuffer += strlen( pcWriteBuffer );
   3639          			}
   3640          
   3641          			/* Free the array again. */
   3642          			vPortFree( pxTaskStatusArray );
   3643          		}
   3644          		else
   3645          		{
   3646          			mtCOVERAGE_TEST_MARKER();
   3647          		}
   3648          	}
   3649          
   3650          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
   3651          /*----------------------------------------------------------*/
   3652          
   3653          #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   3654          
   3655          	void vTaskGetRunTimeStats( char *pcWriteBuffer )
   3656          	{
   3657          	TaskStatus_t *pxTaskStatusArray;
   3658          	volatile UBaseType_t uxArraySize, x;
   3659          	uint32_t ulTotalTime, ulStatsAsPercentage;
   3660          
   3661          		#if( configUSE_TRACE_FACILITY != 1 )
   3662          		{
   3663          			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
   3664          		}
   3665          		#endif
   3666          
   3667          		/*
   3668          		 * PLEASE NOTE:
   3669          		 *
   3670          		 * This function is provided for convenience only, and is used by many
   3671          		 * of the demo applications.  Do not consider it to be part of the
   3672          		 * scheduler.
   3673          		 *
   3674          		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
   3675          		 * of the uxTaskGetSystemState() output into a human readable table that
   3676          		 * displays the amount of time each task has spent in the Running state
   3677          		 * in both absolute and percentage terms.
   3678          		 *
   3679          		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
   3680          		 * function that might bloat the code size, use a lot of stack, and
   3681          		 * provide different results on different platforms.  An alternative,
   3682          		 * tiny, third party, and limited functionality implementation of
   3683          		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
   3684          		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
   3685          		 * a full snprintf() implementation!).
   3686          		 *
   3687          		 * It is recommended that production systems call uxTaskGetSystemState()
   3688          		 * directly to get access to raw stats data, rather than indirectly
   3689          		 * through a call to vTaskGetRunTimeStats().
   3690          		 */
   3691          
   3692          		/* Make sure the write buffer does not contain a string. */
   3693          		*pcWriteBuffer = 0x00;
   3694          
   3695          		/* Take a snapshot of the number of tasks in case it changes while this
   3696          		function is executing. */
   3697          		uxArraySize = uxCurrentNumberOfTasks;
   3698          
   3699          		/* Allocate an array index for each task. */
   3700          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   3701          
   3702          		if( pxTaskStatusArray != NULL )
   3703          		{
   3704          			/* Generate the (binary) data. */
   3705          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
   3706          
   3707          			/* For percentage calculations. */
   3708          			ulTotalTime /= 100UL;
   3709          
   3710          			/* Avoid divide by zero errors. */
   3711          			if( ulTotalTime > 0 )
   3712          			{
   3713          				/* Create a human readable table from the binary data. */
   3714          				for( x = 0; x < uxArraySize; x++ )
   3715          				{
   3716          					/* What percentage of the total run time has the task used?
   3717          					This will always be rounded down to the nearest integer.
   3718          					ulTotalRunTimeDiv100 has already been divided by 100. */
   3719          					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
   3720          
   3721          					/* Write the task name to the string, padding with
   3722          					spaces so it can be printed in tabular form more
   3723          					easily. */
   3724          					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   3725          
   3726          					if( ulStatsAsPercentage > 0UL )
   3727          					{
   3728          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   3729          						{
   3730          							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
   3731          						}
   3732          						#else
   3733          						{
   3734          							/* sizeof( int ) == sizeof( long ) so a smaller
   3735          							printf() library can be used. */
   3736          							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
   3737          						}
   3738          						#endif
   3739          					}
   3740          					else
   3741          					{
   3742          						/* If the percentage is zero here then the task has
   3743          						consumed less than 1% of the total run time. */
   3744          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   3745          						{
   3746          							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
   3747          						}
   3748          						#else
   3749          						{
   3750          							/* sizeof( int ) == sizeof( long ) so a smaller
   3751          							printf() library can be used. */
   3752          							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
   3753          						}
   3754          						#endif
   3755          					}
   3756          
   3757          					pcWriteBuffer += strlen( pcWriteBuffer );
   3758          				}
   3759          			}
   3760          			else
   3761          			{
   3762          				mtCOVERAGE_TEST_MARKER();
   3763          			}
   3764          
   3765          			/* Free the array again. */
   3766          			vPortFree( pxTaskStatusArray );
   3767          		}
   3768          		else
   3769          		{
   3770          			mtCOVERAGE_TEST_MARKER();
   3771          		}
   3772          	}
   3773          
   3774          #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
   3775          /*-----------------------------------------------------------*/
   3776          
   3777          TickType_t uxTaskResetEventItemValue( void )
   3778          {
   3779          TickType_t uxReturn;
   3780          
   3781          	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
   3782          
   3783          	/* Reset the event list item to its normal value - so it can be used with
   3784          	queues and semaphores. */
   3785          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3786          
   3787          	return uxReturn;
   3788          }
   3789          /*-----------------------------------------------------------*/
   3790          
   3791          #if ( configUSE_MUTEXES == 1 )
   3792          
   3793          	void *pvTaskIncrementMutexHeldCount( void )
   3794          	{
   3795          		/* If xSemaphoreCreateMutex() is called before any tasks have been created
   3796          		then pxCurrentTCB will be NULL. */
   3797          		if( pxCurrentTCB != NULL )
   3798          		{
   3799          			( pxCurrentTCB->uxMutexesHeld )++;
   3800          		}
   3801          
   3802          		return pxCurrentTCB;
   3803          	}
   3804          
   3805          #endif /* configUSE_MUTEXES */
   3806          /*-----------------------------------------------------------*/
   3807          
   3808          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   3809          
   3810          	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
   3811          	{
   3812          	TickType_t xTimeToWake;
   3813          	uint32_t ulReturn;
   3814          
   3815          		taskENTER_CRITICAL();
   3816          		{
   3817          			/* Only block if the notification count is not already non-zero. */
   3818          			if( pxCurrentTCB->ulNotifiedValue == 0UL )
   3819          			{
   3820          				/* Mark this task as waiting for a notification. */
   3821          				pxCurrentTCB->eNotifyState = eWaitingNotification;
   3822          
   3823          				if( xTicksToWait > ( TickType_t ) 0 )
   3824          				{
   3825          					/* The task is going to block.  First it must be removed
   3826          					from the ready list. */
   3827          					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   3828          					{
   3829          						/* The current task must be in a ready list, so there is
   3830          						no need to check, and the port reset macro can be called
   3831          						directly. */
   3832          						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   3833          					}
   3834          					else
   3835          					{
   3836          						mtCOVERAGE_TEST_MARKER();
   3837          					}
   3838          
   3839          					#if ( INCLUDE_vTaskSuspend == 1 )
   3840          					{
   3841          						if( xTicksToWait == portMAX_DELAY )
   3842          						{
   3843          							/* Add the task to the suspended task list instead
   3844          							of a delayed task list to ensure the task is not
   3845          							woken by a timing event.  It will block
   3846          							indefinitely. */
   3847          							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   3848          						}
   3849          						else
   3850          						{
   3851          							/* Calculate the time at which the task should be
   3852          							woken if no notification events occur.  This may
   3853          							overflow but this doesn't matter, the scheduler will
   3854          							handle it. */
   3855          							xTimeToWake = xTickCount + xTicksToWait;
   3856          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   3857          						}
   3858          					}
   3859          					#else /* INCLUDE_vTaskSuspend */
   3860          					{
   3861          							/* Calculate the time at which the task should be
   3862          							woken if the event does not occur.  This may
   3863          							overflow but this doesn't matter, the scheduler will
   3864          							handle it. */
   3865          							xTimeToWake = xTickCount + xTicksToWait;
   3866          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   3867          					}
   3868          					#endif /* INCLUDE_vTaskSuspend */
   3869          
   3870          					/* All ports are written to allow a yield in a critical
   3871          					section (some will yield immediately, others wait until the
   3872          					critical section exits) - but it is not something that
   3873          					application code should ever do. */
   3874          					portYIELD_WITHIN_API();
   3875          				}
   3876          				else
   3877          				{
   3878          					mtCOVERAGE_TEST_MARKER();
   3879          				}
   3880          			}
   3881          			else
   3882          			{
   3883          				mtCOVERAGE_TEST_MARKER();
   3884          			}
   3885          		}
   3886          		taskEXIT_CRITICAL();
   3887          
   3888          		taskENTER_CRITICAL();
   3889          		{
   3890          			ulReturn = pxCurrentTCB->ulNotifiedValue;
   3891          
   3892          			if( ulReturn != 0UL )
   3893          			{
   3894          				if( xClearCountOnExit != pdFALSE )
   3895          				{
   3896          					pxCurrentTCB->ulNotifiedValue = 0UL;
   3897          				}
   3898          				else
   3899          				{
   3900          					( pxCurrentTCB->ulNotifiedValue )--;
   3901          				}
   3902          			}
   3903          			else
   3904          			{
   3905          				mtCOVERAGE_TEST_MARKER();
   3906          			}
   3907          
   3908          			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
   3909          		}
   3910          		taskEXIT_CRITICAL();
   3911          
   3912          		return ulReturn;
   3913          	}
   3914          
   3915          #endif /* configUSE_TASK_NOTIFICATIONS */
   3916          /*-----------------------------------------------------------*/
   3917          
   3918          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   3919          
   3920          	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
   3921          	{
   3922          	TickType_t xTimeToWake;
   3923          	BaseType_t xReturn;
   3924          
   3925          		taskENTER_CRITICAL();
   3926          		{
   3927          			/* Only block if a notification is not already pending. */
   3928          			if( pxCurrentTCB->eNotifyState != eNotified )
   3929          			{
   3930          				/* Clear bits in the task's notification value as bits may get
   3931          				set	by the notifying task or interrupt.  This can be used to
   3932          				clear the value to zero. */
   3933          				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
   3934          
   3935          				/* Mark this task as waiting for a notification. */
   3936          				pxCurrentTCB->eNotifyState = eWaitingNotification;
   3937          
   3938          				if( xTicksToWait > ( TickType_t ) 0 )
   3939          				{
   3940          					/* The task is going to block.  First it must be removed
   3941          					from the	ready list. */
   3942          					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   3943          					{
   3944          						/* The current task must be in a ready list, so there is
   3945          						no need to check, and the port reset macro can be called
   3946          						directly. */
   3947          						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   3948          					}
   3949          					else
   3950          					{
   3951          						mtCOVERAGE_TEST_MARKER();
   3952          					}
   3953          
   3954          					#if ( INCLUDE_vTaskSuspend == 1 )
   3955          					{
   3956          						if( xTicksToWait == portMAX_DELAY )
   3957          						{
   3958          							/* Add the task to the suspended task list instead
   3959          							of a delayed task list to ensure the task is not
   3960          							woken by a timing event.  It will block
   3961          							indefinitely. */
   3962          							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   3963          						}
   3964          						else
   3965          						{
   3966          							/* Calculate the time at which the task should be
   3967          							woken if no notification events occur.  This may
   3968          							overflow but this doesn't matter, the scheduler will
   3969          							handle it. */
   3970          							xTimeToWake = xTickCount + xTicksToWait;
   3971          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   3972          						}
   3973          					}
   3974          					#else /* INCLUDE_vTaskSuspend */
   3975          					{
   3976          							/* Calculate the time at which the task should be
   3977          							woken if the event does not occur.  This may
   3978          							overflow but this doesn't matter, the scheduler will
   3979          							handle it. */
   3980          							xTimeToWake = xTickCount + xTicksToWait;
   3981          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   3982          					}
   3983          					#endif /* INCLUDE_vTaskSuspend */
   3984          
   3985          					/* All ports are written to allow a yield in a critical
   3986          					section (some will yield immediately, others wait until the
   3987          					critical section exits) - but it is not something that
   3988          					application code should ever do. */
   3989          					portYIELD_WITHIN_API();
   3990          				}
   3991          				else
   3992          				{
   3993          					mtCOVERAGE_TEST_MARKER();
   3994          				}
   3995          			}
   3996          			else
   3997          			{
   3998          				mtCOVERAGE_TEST_MARKER();
   3999          			}
   4000          		}
   4001          		taskEXIT_CRITICAL();
   4002          
   4003          		taskENTER_CRITICAL();
   4004          		{
   4005          			if( pulNotificationValue != NULL )
   4006          			{
   4007          				/* Output the current notification value, which may or may not
   4008          				have changed. */
   4009          				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
   4010          			}
   4011          
   4012          			/* If eNotifyValue is set then either the task never entered the
   4013          			blocked state (because a notification was already pending) or the
   4014          			task unblocked because of a notification.  Otherwise the task
   4015          			unblocked because of a timeout. */
   4016          			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
   4017          			{
   4018          				/* A notification was not received. */
   4019          				xReturn = pdFALSE;
   4020          			}
   4021          			else
   4022          			{
   4023          				/* A notification was already pending or a notification was
   4024          				received while the task was waiting. */
   4025          				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
   4026          				xReturn = pdTRUE;
   4027          			}
   4028          
   4029          			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
   4030          		}
   4031          		taskEXIT_CRITICAL();
   4032          
   4033          		return xReturn;
   4034          	}
   4035          
   4036          #endif /* configUSE_TASK_NOTIFICATIONS */
   4037          /*-----------------------------------------------------------*/
   4038          
   4039          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4040          
   4041          	BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction )
   4042          	{
   4043          	TCB_t * pxTCB;
   4044          	eNotifyValue eOriginalNotifyState;
   4045          	BaseType_t xReturn = pdPASS;
   4046          
   4047          		configASSERT( xTaskToNotify );
   4048          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4049          
   4050          		taskENTER_CRITICAL();
   4051          		{
   4052          			eOriginalNotifyState = pxTCB->eNotifyState;
   4053          
   4054          			pxTCB->eNotifyState = eNotified;
   4055          
   4056          			switch( eAction )
   4057          			{
   4058          				case eSetBits	:
   4059          					pxTCB->ulNotifiedValue |= ulValue;
   4060          					break;
   4061          
   4062          				case eIncrement	:
   4063          					( pxTCB->ulNotifiedValue )++;
   4064          					break;
   4065          
   4066          				case eSetValueWithOverwrite	:
   4067          					pxTCB->ulNotifiedValue = ulValue;
   4068          					break;
   4069          
   4070          				case eSetValueWithoutOverwrite :
   4071          					if( eOriginalNotifyState != eNotified )
   4072          					{
   4073          						pxTCB->ulNotifiedValue = ulValue;
   4074          					}
   4075          					else
   4076          					{
   4077          						/* The value could not be written to the task. */
   4078          						xReturn = pdFAIL;
   4079          					}
   4080          					break;
   4081          
   4082          				case eNoAction:
   4083          					/* The task is being notified without its notify value being
   4084          					updated. */
   4085          					break;
   4086          			}
   4087          
   4088          
   4089          			/* If the task is in the blocked state specifically to wait for a
   4090          			notification then unblock it now. */
   4091          			if( eOriginalNotifyState == eWaitingNotification )
   4092          			{
   4093          				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   4094          				prvAddTaskToReadyList( pxTCB );
   4095          
   4096          				/* The task should not have been on an event list. */
   4097          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4098          
   4099          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4100          				{
   4101          					/* The notified task has a priority above the currently
   4102          					executing task so a yield is required. */
   4103          					portYIELD_WITHIN_API();
   4104          				}
   4105          				else
   4106          				{
   4107          					mtCOVERAGE_TEST_MARKER();
   4108          				}
   4109          			}
   4110          			else
   4111          			{
   4112          				mtCOVERAGE_TEST_MARKER();
   4113          			}
   4114          		}
   4115          		taskEXIT_CRITICAL();
   4116          
   4117          		return xReturn;
   4118          	}
   4119          
   4120          #endif /* configUSE_TASK_NOTIFICATIONS */
   4121          /*-----------------------------------------------------------*/
   4122          
   4123          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4124          
   4125          	BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken )
   4126          	{
   4127          	TCB_t * pxTCB;
   4128          	eNotifyValue eOriginalNotifyState;
   4129          	BaseType_t xReturn = pdPASS;
   4130          	UBaseType_t uxSavedInterruptStatus;
   4131          
   4132          		configASSERT( xTaskToNotify );
   4133          
   4134          		/* RTOS ports that support interrupt nesting have the concept of a
   4135          		maximum	system call (or maximum API call) interrupt priority.
   4136          		Interrupts that are	above the maximum system call priority are keep
   4137          		permanently enabled, even when the RTOS kernel is in a critical section,
   4138          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4139          		is defined in FreeRTOSConfig.h then
   4140          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   4141          		failure if a FreeRTOS API function is called from an interrupt that has
   4142          		been assigned a priority above the configured maximum system call
   4143          		priority.  Only FreeRTOS functions that end in FromISR can be called
   4144          		from interrupts	that have been assigned a priority at or (logically)
   4145          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   4146          		separate interrupt safe API to ensure interrupt entry is as fast and as
   4147          		simple as possible.  More information (albeit Cortex-M specific) is
   4148          		provided on the following link:
   4149          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   4150          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   4151          
   4152          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4153          
   4154          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   4155          		{
   4156          			eOriginalNotifyState = pxTCB->eNotifyState;
   4157          
   4158          			pxTCB->eNotifyState = eNotified;
   4159          
   4160          			switch( eAction )
   4161          			{
   4162          				case eSetBits	:
   4163          					pxTCB->ulNotifiedValue |= ulValue;
   4164          					break;
   4165          
   4166          				case eIncrement	:
   4167          					( pxTCB->ulNotifiedValue )++;
   4168          					break;
   4169          
   4170          				case eSetValueWithOverwrite	:
   4171          					pxTCB->ulNotifiedValue = ulValue;
   4172          					break;
   4173          
   4174          				case eSetValueWithoutOverwrite :
   4175          					if( eOriginalNotifyState != eNotified )
   4176          					{
   4177          						pxTCB->ulNotifiedValue = ulValue;
   4178          					}
   4179          					else
   4180          					{
   4181          						/* The value could not be written to the task. */
   4182          						xReturn = pdFAIL;
   4183          					}
   4184          					break;
   4185          
   4186          				case eNoAction :
   4187          					/* The task is being notified without its notify value being
   4188          					updated. */
   4189          					break;
   4190          			}
   4191          
   4192          
   4193          			/* If the task is in the blocked state specifically to wait for a
   4194          			notification then unblock it now. */
   4195          			if( eOriginalNotifyState == eWaitingNotification )
   4196          			{
   4197          				/* The task should not have been on an event list. */
   4198          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4199          
   4200          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   4201          				{
   4202          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   4203          					prvAddTaskToReadyList( pxTCB );
   4204          				}
   4205          				else
   4206          				{
   4207          					/* The delayed and ready lists cannot be accessed, so hold
   4208          					this task pending until the scheduler is resumed. */
   4209          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   4210          				}
   4211          
   4212          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4213          				{
   4214          					/* The notified task has a priority above the currently
   4215          					executing task so a yield is required. */
   4216          					if( pxHigherPriorityTaskWoken != NULL )
   4217          					{
   4218          						*pxHigherPriorityTaskWoken = pdTRUE;
   4219          					}
   4220          				}
   4221          				else
   4222          				{
   4223          					mtCOVERAGE_TEST_MARKER();
   4224          				}
   4225          			}
   4226          		}
   4227          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   4228          
   4229          		return xReturn;
   4230          	}
   4231          
   4232          #endif /* configUSE_TASK_NOTIFICATIONS */
   4233          /*-----------------------------------------------------------*/
   4234          
   4235          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4236          
   4237          	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
   4238          	{
   4239          	TCB_t * pxTCB;
   4240          	eNotifyValue eOriginalNotifyState;
   4241          	UBaseType_t uxSavedInterruptStatus;
   4242          
   4243          		configASSERT( xTaskToNotify );
   4244          
   4245          		/* RTOS ports that support interrupt nesting have the concept of a
   4246          		maximum	system call (or maximum API call) interrupt priority.
   4247          		Interrupts that are	above the maximum system call priority are keep
   4248          		permanently enabled, even when the RTOS kernel is in a critical section,
   4249          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4250          		is defined in FreeRTOSConfig.h then
   4251          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   4252          		failure if a FreeRTOS API function is called from an interrupt that has
   4253          		been assigned a priority above the configured maximum system call
   4254          		priority.  Only FreeRTOS functions that end in FromISR can be called
   4255          		from interrupts	that have been assigned a priority at or (logically)
   4256          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   4257          		separate interrupt safe API to ensure interrupt entry is as fast and as
   4258          		simple as possible.  More information (albeit Cortex-M specific) is
   4259          		provided on the following link:
   4260          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   4261          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   4262          
   4263          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4264          
   4265          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   4266          		{
   4267          			eOriginalNotifyState = pxTCB->eNotifyState;
   4268          			pxTCB->eNotifyState = eNotified;
   4269          
   4270          			/* 'Giving' is equivalent to incrementing a count in a counting
   4271          			semaphore. */
   4272          			( pxTCB->ulNotifiedValue )++;
   4273          
   4274          			/* If the task is in the blocked state specifically to wait for a
   4275          			notification then unblock it now. */
   4276          			if( eOriginalNotifyState == eWaitingNotification )
   4277          			{
   4278          				/* The task should not have been on an event list. */
   4279          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4280          
   4281          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   4282          				{
   4283          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   4284          					prvAddTaskToReadyList( pxTCB );
   4285          				}
   4286          				else
   4287          				{
   4288          					/* The delayed and ready lists cannot be accessed, so hold
   4289          					this task pending until the scheduler is resumed. */
   4290          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   4291          				}
   4292          
   4293          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4294          				{
   4295          					/* The notified task has a priority above the currently
   4296          					executing task so a yield is required. */
   4297          					if( pxHigherPriorityTaskWoken != NULL )
   4298          					{
   4299          						*pxHigherPriorityTaskWoken = pdTRUE;
   4300          					}
   4301          				}
   4302          				else
   4303          				{
   4304          					mtCOVERAGE_TEST_MARKER();
   4305          				}
   4306          			}
   4307          		}
   4308          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   4309          	}
   4310          
   4311          #endif /* configUSE_TASK_NOTIFICATIONS */
   4312          /*-----------------------------------------------------------*/
   4313          
   4314          #if ( configGENERATE_RUN_TIME_STATS == 1 )
   4315          
   4316          	void vTaskClearTaskRunTimeCounter( void )
   4317          	{
   4318          		TaskStatus_t *pxTaskStatusArray;
   4319          		volatile UBaseType_t uxArraySize, x;
   4320          		uint32_t ulTotalTime;
   4321          		TCB_t *pxTCB;
   4322          
   4323          		/* Take a snapshot of the number of tasks in case it changes while this
   4324          		function is executing. */
   4325          		uxArraySize = uxCurrentNumberOfTasks;
   4326          
   4327          		/* Allocate an array index for each task. */
   4328          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   4329          
   4330          		if( pxTaskStatusArray != NULL )
   4331          		{
   4332          			/* Generate the (binary) data. */
   4333          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
   4334          
   4335          			for( x = 0; x < uxArraySize; x++ )
   4336          			{
   4337          				/* If null is passed in here then the name of the calling task is being queried. */
   4338          				pxTCB = prvGetTCBFromHandle(pxTaskStatusArray[x].xHandle);
   4339          				configASSERT( pxTCB );
   4340          				pxTCB->ulRunTimeCounter = 0;
   4341          			}
   4342          			
   4343          			vPortFree(pxTaskStatusArray);
   4344          		}
   4345          	}
   4346          
   4347          #endif /* configGENERATE_RUN_TIME_STATS */
   4348          /*-----------------------------------------------------------*/
   4349          
   4350          #ifdef FREERTOS_MODULE_TEST
   4351          	#include "tasks_test_access_functions.h"
   4352          #endif
   4353          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   eTaskGetState
        16   -> platform_assert
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       8   pcTaskGetTaskName
         8   -> platform_assert
      16   prvAddCurrentTaskToDelayedList
         0   -> vListInsert
        16   -> vListInsert
      16   prvAllocateTCBAndStack
        16   -> __aeabi_memset4
        16   -> pvPortMalloc
        16   -> vPortFree
      16   prvCheckTasksWaitingTermination
        16   -> prvDeleteTCB
        16   -> uxListRemove
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskSuspendAll
        16   -> xTaskResumeAll
       8   prvDeleteTCB
         0   -> vPortFree
         8   -> vPortFree
       8   prvIdleTask
         8   -> prvCheckTasksWaitingTermination
      24   prvInitialiseTCBVariables
        24   -> vListInitialiseItem
      16   prvInitialiseTaskLists
        16   -> vListInitialise
      32   prvListTaskWithinSingleList
        32   -> prvTaskCheckFreeStackSpace
       0   prvResetNextTaskUnblockTime
       0   prvTaskCheckFreeStackSpace
      16   prvTaskIsTaskSuspended
        16   -> platform_assert
       8   prvWriteNameToBuffer
         8   -> strcpy
         8   -> strlen
       0   pvTaskIncrementMutexHeldCount
      16   ulTaskNotifyTake
        16   -> prvAddCurrentTaskToDelayedList
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       0   uxTaskGetNumberOfTasks
       0   uxTaskGetStackHighWaterMark
         0   -> prvTaskCheckFreeStackSpace
      32   uxTaskGetSystemState
        32   -> prvListTaskWithinSingleList
        32   -> vTaskSuspendAll
        32   -> xTaskResumeAll
       0   uxTaskGetTaskNumber
       8   uxTaskPriorityGet
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   uxTaskPriorityGetFromISR
         8   -> vPortValidateInterruptPriority
       0   uxTaskResetEventItemValue
      16   vTaskDelay
        16   -> platform_assert
        16   -> prvAddCurrentTaskToDelayedList
        16   -> uxListRemove
        16   -> vTaskSuspendAll
        16   -> xTaskResumeAll
      24   vTaskDelayUntil
        24   -> platform_assert
        24   -> prvAddCurrentTaskToDelayedList
        24   -> uxListRemove
        24   -> vTaskSuspendAll
        24   -> xTaskResumeAll
      16   vTaskDelete
        16   -> platform_assert
        16   -> prvResetNextTaskUnblockTime
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
        16   -> vPortExitCritical
       0   vTaskEndScheduler
         0   -> vPortEndScheduler
      32   vTaskList
        32   -> prvWriteNameToBuffer
        32   -> pvPortMalloc
        32   -> sprintf
        32   -> strlen
        32   -> uxTaskGetSystemState
         0   -> vPortFree
       0   vTaskMissedYield
      24   vTaskNotifyGiveFromISR
        24   -> platform_assert
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortValidateInterruptPriority
      16   vTaskPlaceOnEventList
        16   -> platform_assert
         0   -> prvAddCurrentTaskToDelayedList
        16   -> uxListRemove
        16   -> vListInsert
         0   -> vListInsertEnd
      16   vTaskPlaceOnEventListRestricted
        16   -> platform_assert
         0   -> prvAddCurrentTaskToDelayedList
        16   -> uxListRemove
        16   -> vListInsertEnd
      24   vTaskPlaceOnUnorderedEventList
        24   -> platform_assert
         0   -> prvAddCurrentTaskToDelayedList
        24   -> uxListRemove
         0   -> vListInsertEnd
        24   -> vListInsertEnd
      24   vTaskPriorityInherit
        24   -> uxListRemove
         0   -> vListInsertEnd
      32   vTaskPrioritySet
        32   -> platform_assert
        32   -> uxListRemove
        32   -> vListInsertEnd
        32   -> vPortEnterCritical
         0   -> vPortExitCritical
      16   vTaskResume
        16   -> platform_assert
        16   -> prvTaskIsTaskSuspended
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
       0   vTaskSetTaskNumber
       8   vTaskSetTimeOutState
         8   -> platform_assert
      24   vTaskStartScheduler
         0   -> platform_assert
         0   -> xPortStartScheduler
        24   -> xTaskGenericCreate
        24   -> xTimerCreateTimerTask
      16   vTaskSuspend
        16   -> platform_assert
        16   -> prvResetNextTaskUnblockTime
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
        16   -> vPortExitCritical
         0   -> vTaskSwitchContext
       0   vTaskSuspendAll
      16   vTaskSwitchContext
        16   -> memcmp
        16   -> platform_assert
        16   -> vApplicationStackOverflowHook
      16   xTaskCheckForTimeOut
        16   -> platform_assert
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskSetTimeOutState
      40   xTaskGenericCreate
        40   -> platform_assert
        40   -> prvAllocateTCBAndStack
        40   -> prvInitialiseTCBVariables
        40   -> prvInitialiseTaskLists
        40   -> pxPortInitialiseStack
        40   -> vListInsertEnd
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
       0   xTaskGetCurrentTaskHandle
       0   xTaskGetSchedulerState
       0   xTaskGetTickCount
       8   xTaskGetTickCountFromISR
         8   -> vPortValidateInterruptPriority
      24   xTaskIncrementTick
        24   -> platform_assert
        24   -> prvResetNextTaskUnblockTime
        24   -> uxListRemove
        24   -> vListInsertEnd
      24   xTaskNotify
        24   -> platform_assert
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      32   xTaskNotifyFromISR
        32   -> platform_assert
        32   -> uxListRemove
        32   -> vListInsertEnd
        32   -> vPortValidateInterruptPriority
      24   xTaskNotifyWait
        24   -> prvAddCurrentTaskToDelayedList
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      16   xTaskPriorityDisinherit
        16   -> platform_assert
        16   -> uxListRemove
        16   -> vListInsertEnd
      16   xTaskRemoveFromEventList
        16   -> platform_assert
        16   -> uxListRemove
        16   -> vListInsertEnd
      16   xTaskRemoveFromUnorderedEventList
        16   -> platform_assert
        16   -> uxListRemove
        16   -> vListInsertEnd
      16   xTaskResumeAll
        16   -> platform_assert
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> xTaskIncrementTick
      24   xTaskResumeFromISR
        24   -> platform_assert
        24   -> prvTaskIsTaskSuspended
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortValidateInterruptPriority


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable52
       4  ??DataTable53
       4  ??DataTable53_1
       4  ??DataTable57
       4  ??DataTable75
       4  ??DataTable75_1
       4  ??DataTable75_2
      12  ?_0
      68  ?_1
      16  ?_10
       8  ?_11
       8  ?_12
      24  ?_13
      44  ?_14
      72  ?_15
      12  ?_16
      28  ?_17
      16  ?_18
      32  ?_19
      68  ?_2
      12  ?_20
      16  ?_21
      24  ?_22
      16  ?_23
      16  ?_24
      64  ?_25
     108  ?_3
      28  ?_4
      20  ?_5
      24  ?_6
       8  ?_7
      44  ?_8
       8  ?_9
     100  eTaskGetState
      38  pcTaskGetTaskName
      50  prvAddCurrentTaskToDelayedList
      62  prvAllocateTCBAndStack
      72  prvCheckTasksWaitingTermination
      20  prvDeleteTCB
      36  prvIdleTask
      88  prvInitialiseTCBVariables
      82  prvInitialiseTaskLists
     158  prvListTaskWithinSingleList
      32  prvResetNextTaskUnblockTime
      20  prvTaskCheckFreeStackSpace
      56  prvTaskIsTaskSuspended
      34  prvWriteNameToBuffer
      22  pvTaskIncrementMutexHeldCount
     400  pxReadyTasksLists
      20  ucExpectedStackBytes
     162  ulTaskNotifyTake
       8  uxTaskGetNumberOfTasks
      14  uxTaskGetStackHighWaterMark
     142  uxTaskGetSystemState
      12  uxTaskGetTaskNumber
      28  uxTaskPriorityGet
      44  uxTaskPriorityGetFromISR
      22  uxTaskResetEventItemValue
     108  vTaskDelay
     180  vTaskDelayUntil
     170  vTaskDelete
      26  vTaskEndScheduler
     178  vTaskList
      10  vTaskMissedYield
     186  vTaskNotifyGiveFromISR
     102  vTaskPlaceOnEventList
      80  vTaskPlaceOnEventListRestricted
     134  vTaskPlaceOnUnorderedEventList
     124  vTaskPriorityInherit
     218  vTaskPrioritySet
     124  vTaskResume
       8  vTaskSetTaskNumber
      36  vTaskSetTimeOutState
     110  vTaskStartScheduler
     182  vTaskSuspend
      12  vTaskSuspendAll
     142  vTaskSwitchContext
     156  xPendingReadyList
          xTasksWaitingTermination
          pxCurrentTCB
          pxDelayedTaskList
          pxOverflowDelayedTaskList
          uxTasksDeleted
          xSuspendedTaskList
          uxCurrentNumberOfTasks
          xTickCount
          uxTopReadyPriority
          xSchedulerRunning
          uxPendedTicks
          xYieldPending
          xNumOfOverflows
          uxTaskNumber
          xNextTaskUnblockTime
          uxSchedulerSuspended
          xDelayedTaskList1
          xDelayedTaskList2
     118  xTaskCheckForTimeOut
     288  xTaskGenericCreate
       8  xTaskGetCurrentTaskHandle
      28  xTaskGetSchedulerState
       8  xTaskGetTickCount
      14  xTaskGetTickCountFromISR
     202  xTaskIncrementTick
     204  xTaskNotify
     256  xTaskNotifyFromISR
     184  xTaskNotifyWait
     136  xTaskPriorityDisinherit
     112  xTaskRemoveFromEventList
     124  xTaskRemoveFromUnorderedEventList
     188  xTaskResumeAll
     136  xTaskResumeFromISR

 
   400 bytes in section .bss
   156 bytes in section .data
 6 282 bytes in section .text
 
 6 282 bytes of CODE memory
   556 bytes of DATA memory

Errors: none
Warnings: none
