###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       25/Jan/2017  17:35:29
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\sha512.c
#    Command line =  
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\sha512.c" -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_WIFI_TGN_VERIFY_ENABLE -D MTK_SMTCN_ENABLE -D
#        MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D SUPPORT_MBEDTLS -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-basic.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D MTK_MCS_ENABLE -D MTK_BLE_GPIO_SERVICE -D
#        __BT_DEBUG__ -lcN "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List" -lA
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List"
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj" --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\inc\" -I
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\service\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\dhcpd\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\src\ut_app\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\httpclient\inc\"
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List\sha512.lst
#    Object file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj\sha512.o
#
###############################################################################

C:\LEO\myGit\MTK IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\sha512.c
      1          /*
      2           *  FIPS-180-2 compliant SHA-384/512 implementation
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          /*
     22           *  The SHA-512 Secure Hash Standard was published by NIST in 2002.
     23           *
     24           *  http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf
     25           */
     26          
     27          #if !defined(MBEDTLS_CONFIG_FILE)
     28          #include "mbedtls/config.h"
     29          #else
     30          #include MBEDTLS_CONFIG_FILE
     31          #endif
     32          
     33          #if defined(MBEDTLS_SHA512_C)
     34          
     35          #include "mbedtls/sha512.h"
     36          
     37          #if defined(MBEDTLS_THREADING_C) && defined(MBEDTLS_SHA512_ALT)
     38          #include "mbedtls/threading.h"
     39          #endif
     40          
     41          #if defined(_MSC_VER) || defined(__WATCOMC__)
     42            #define UL64(x) x##ui64
     43          #else
     44            #define UL64(x) x##ULL
     45          #endif
     46          
     47          #include <string.h>
     48          
     49          #if defined(MBEDTLS_SELF_TEST)
     50          #if defined(MBEDTLS_PLATFORM_C)
     51          #include "mbedtls/platform.h"
     52          #else
     53          #include <stdio.h>
     54          #define mbedtls_printf printf
     55          #endif /* MBEDTLS_PLATFORM_C */
     56          #endif /* MBEDTLS_SELF_TEST */
     57          
     58          #if !defined(MBEDTLS_SHA512_ALT)
     59          
     60          /* Implementation that should never be optimized out by the compiler */
     61          static void mbedtls_zeroize( void *v, size_t n ) {
     62              volatile unsigned char *p = v; while( n-- ) *p++ = 0;
     63          }
     64          
     65          /*
     66           * 64-bit integer manipulation macros (big endian)
     67           */
     68          #ifndef GET_UINT64_BE
     69          #define GET_UINT64_BE(n,b,i)                            \
     70          {                                                       \
     71              (n) = ( (uint64_t) (b)[(i)    ] << 56 )       \
     72                  | ( (uint64_t) (b)[(i) + 1] << 48 )       \
     73                  | ( (uint64_t) (b)[(i) + 2] << 40 )       \
     74                  | ( (uint64_t) (b)[(i) + 3] << 32 )       \
     75                  | ( (uint64_t) (b)[(i) + 4] << 24 )       \
     76                  | ( (uint64_t) (b)[(i) + 5] << 16 )       \
     77                  | ( (uint64_t) (b)[(i) + 6] <<  8 )       \
     78                  | ( (uint64_t) (b)[(i) + 7]       );      \
     79          }
     80          #endif /* GET_UINT64_BE */
     81          
     82          #ifndef PUT_UINT64_BE
     83          #define PUT_UINT64_BE(n,b,i)                            \
     84          {                                                       \
     85              (b)[(i)    ] = (unsigned char) ( (n) >> 56 );       \
     86              (b)[(i) + 1] = (unsigned char) ( (n) >> 48 );       \
     87              (b)[(i) + 2] = (unsigned char) ( (n) >> 40 );       \
     88              (b)[(i) + 3] = (unsigned char) ( (n) >> 32 );       \
     89              (b)[(i) + 4] = (unsigned char) ( (n) >> 24 );       \
     90              (b)[(i) + 5] = (unsigned char) ( (n) >> 16 );       \
     91              (b)[(i) + 6] = (unsigned char) ( (n) >>  8 );       \
     92              (b)[(i) + 7] = (unsigned char) ( (n)       );       \
     93          }
     94          #endif /* PUT_UINT64_BE */
     95          
     96          /*
     97           * Round constants
     98           */
     99          static const uint64_t K[80] =
    100          {
    101              UL64(0x428A2F98D728AE22),  UL64(0x7137449123EF65CD),
    102              UL64(0xB5C0FBCFEC4D3B2F),  UL64(0xE9B5DBA58189DBBC),
    103              UL64(0x3956C25BF348B538),  UL64(0x59F111F1B605D019),
    104              UL64(0x923F82A4AF194F9B),  UL64(0xAB1C5ED5DA6D8118),
    105              UL64(0xD807AA98A3030242),  UL64(0x12835B0145706FBE),
    106              UL64(0x243185BE4EE4B28C),  UL64(0x550C7DC3D5FFB4E2),
    107              UL64(0x72BE5D74F27B896F),  UL64(0x80DEB1FE3B1696B1),
    108              UL64(0x9BDC06A725C71235),  UL64(0xC19BF174CF692694),
    109              UL64(0xE49B69C19EF14AD2),  UL64(0xEFBE4786384F25E3),
    110              UL64(0x0FC19DC68B8CD5B5),  UL64(0x240CA1CC77AC9C65),
    111              UL64(0x2DE92C6F592B0275),  UL64(0x4A7484AA6EA6E483),
    112              UL64(0x5CB0A9DCBD41FBD4),  UL64(0x76F988DA831153B5),
    113              UL64(0x983E5152EE66DFAB),  UL64(0xA831C66D2DB43210),
    114              UL64(0xB00327C898FB213F),  UL64(0xBF597FC7BEEF0EE4),
    115              UL64(0xC6E00BF33DA88FC2),  UL64(0xD5A79147930AA725),
    116              UL64(0x06CA6351E003826F),  UL64(0x142929670A0E6E70),
    117              UL64(0x27B70A8546D22FFC),  UL64(0x2E1B21385C26C926),
    118              UL64(0x4D2C6DFC5AC42AED),  UL64(0x53380D139D95B3DF),
    119              UL64(0x650A73548BAF63DE),  UL64(0x766A0ABB3C77B2A8),
    120              UL64(0x81C2C92E47EDAEE6),  UL64(0x92722C851482353B),
    121              UL64(0xA2BFE8A14CF10364),  UL64(0xA81A664BBC423001),
    122              UL64(0xC24B8B70D0F89791),  UL64(0xC76C51A30654BE30),
    123              UL64(0xD192E819D6EF5218),  UL64(0xD69906245565A910),
    124              UL64(0xF40E35855771202A),  UL64(0x106AA07032BBD1B8),
    125              UL64(0x19A4C116B8D2D0C8),  UL64(0x1E376C085141AB53),
    126              UL64(0x2748774CDF8EEB99),  UL64(0x34B0BCB5E19B48A8),
    127              UL64(0x391C0CB3C5C95A63),  UL64(0x4ED8AA4AE3418ACB),
    128              UL64(0x5B9CCA4F7763E373),  UL64(0x682E6FF3D6B2B8A3),
    129              UL64(0x748F82EE5DEFB2FC),  UL64(0x78A5636F43172F60),
    130              UL64(0x84C87814A1F0AB72),  UL64(0x8CC702081A6439EC),
    131              UL64(0x90BEFFFA23631E28),  UL64(0xA4506CEBDE82BDE9),
    132              UL64(0xBEF9A3F7B2C67915),  UL64(0xC67178F2E372532B),
    133              UL64(0xCA273ECEEA26619C),  UL64(0xD186B8C721C0C207),
    134              UL64(0xEADA7DD6CDE0EB1E),  UL64(0xF57D4F7FEE6ED178),
    135              UL64(0x06F067AA72176FBA),  UL64(0x0A637DC5A2C898A6),
    136              UL64(0x113F9804BEF90DAE),  UL64(0x1B710B35131C471B),
    137              UL64(0x28DB77F523047D84),  UL64(0x32CAAB7B40C72493),
    138              UL64(0x3C9EBE0A15C9BEBC),  UL64(0x431D67C49C100D4C),
    139              UL64(0x4CC5D4BECB3E42B6),  UL64(0x597F299CFC657E2A),
    140              UL64(0x5FCB6FAB3AD6FAEC),  UL64(0x6C44198C4A475817)
    141          };
    142          
    143          void mbedtls_sha512_init( mbedtls_sha512_context *ctx )
    144          {
    145              memset( ctx, 0, sizeof( mbedtls_sha512_context ) );
    146          }
    147          
    148          void mbedtls_sha512_free( mbedtls_sha512_context *ctx )
    149          {
    150              if( ctx == NULL )
    151                  return;
    152          
    153              mbedtls_zeroize( ctx, sizeof( mbedtls_sha512_context ) );
    154          }
    155          
    156          void mbedtls_sha512_clone( mbedtls_sha512_context *dst,
    157                                     const mbedtls_sha512_context *src )
    158          {
    159              *dst = *src;
    160          }
    161          
    162          /*
    163           * SHA-512 context setup
    164           */
    165          void mbedtls_sha512_starts( mbedtls_sha512_context *ctx, int is384 )
    166          {
    167              ctx->total[0] = 0;
    168              ctx->total[1] = 0;
    169          
    170              if( is384 == 0 )
    171              {
    172                  /* SHA-512 */
    173                  ctx->state[0] = UL64(0x6A09E667F3BCC908);
    174                  ctx->state[1] = UL64(0xBB67AE8584CAA73B);
    175                  ctx->state[2] = UL64(0x3C6EF372FE94F82B);
    176                  ctx->state[3] = UL64(0xA54FF53A5F1D36F1);
    177                  ctx->state[4] = UL64(0x510E527FADE682D1);
    178                  ctx->state[5] = UL64(0x9B05688C2B3E6C1F);
    179                  ctx->state[6] = UL64(0x1F83D9ABFB41BD6B);
    180                  ctx->state[7] = UL64(0x5BE0CD19137E2179);
    181              }
    182              else
    183              {
    184                  /* SHA-384 */
    185                  ctx->state[0] = UL64(0xCBBB9D5DC1059ED8);
    186                  ctx->state[1] = UL64(0x629A292A367CD507);
    187                  ctx->state[2] = UL64(0x9159015A3070DD17);
    188                  ctx->state[3] = UL64(0x152FECD8F70E5939);
    189                  ctx->state[4] = UL64(0x67332667FFC00B31);
    190                  ctx->state[5] = UL64(0x8EB44A8768581511);
    191                  ctx->state[6] = UL64(0xDB0C2E0D64F98FA7);
    192                  ctx->state[7] = UL64(0x47B5481DBEFA4FA4);
    193              }
    194          
    195              ctx->is384 = is384;
    196          }
    197          
    198          #if !defined(MBEDTLS_SHA512_PROCESS_ALT)
    199          void mbedtls_sha512_process( mbedtls_sha512_context *ctx, const unsigned char data[128] )
    200          {
    201              int i;
    202              uint64_t temp1, temp2, W[80];
    203              uint64_t A, B, C, D, E, F, G, H;
    204          
    205          #define  SHR(x,n) (x >> n)
    206          #define ROTR(x,n) (SHR(x,n) | (x << (64 - n)))
    207          
    208          #define S0(x) (ROTR(x, 1) ^ ROTR(x, 8) ^  SHR(x, 7))
    209          #define S1(x) (ROTR(x,19) ^ ROTR(x,61) ^  SHR(x, 6))
    210          
    211          #define S2(x) (ROTR(x,28) ^ ROTR(x,34) ^ ROTR(x,39))
    212          #define S3(x) (ROTR(x,14) ^ ROTR(x,18) ^ ROTR(x,41))
    213          
    214          #define F0(x,y,z) ((x & y) | (z & (x | y)))
    215          #define F1(x,y,z) (z ^ (x & (y ^ z)))
    216          
    217          #define P(a,b,c,d,e,f,g,h,x,K)                  \
    218          {                                               \
    219              temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    220              temp2 = S2(a) + F0(a,b,c);                  \
    221              d += temp1; h = temp1 + temp2;              \
    222          }
    223          
    224              for( i = 0; i < 16; i++ )
    225              {
    226                  GET_UINT64_BE( W[i], data, i << 3 );
    227              }
    228          
    229              for( ; i < 80; i++ )
    230              {
    231                  W[i] = S1(W[i -  2]) + W[i -  7] +
    232                         S0(W[i - 15]) + W[i - 16];
    233              }
    234          
    235              A = ctx->state[0];
    236              B = ctx->state[1];
    237              C = ctx->state[2];
    238              D = ctx->state[3];
    239              E = ctx->state[4];
    240              F = ctx->state[5];
    241              G = ctx->state[6];
    242              H = ctx->state[7];
    243              i = 0;
    244          
    245              do
    246              {
    247                  P( A, B, C, D, E, F, G, H, W[i], K[i] ); i++;
    248                  P( H, A, B, C, D, E, F, G, W[i], K[i] ); i++;
    249                  P( G, H, A, B, C, D, E, F, W[i], K[i] ); i++;
    250                  P( F, G, H, A, B, C, D, E, W[i], K[i] ); i++;
    251                  P( E, F, G, H, A, B, C, D, W[i], K[i] ); i++;
    252                  P( D, E, F, G, H, A, B, C, W[i], K[i] ); i++;
    253                  P( C, D, E, F, G, H, A, B, W[i], K[i] ); i++;
    254                  P( B, C, D, E, F, G, H, A, W[i], K[i] ); i++;
    255              }
    256              while( i < 80 );
    257          
    258              ctx->state[0] += A;
    259              ctx->state[1] += B;
    260              ctx->state[2] += C;
    261              ctx->state[3] += D;
    262              ctx->state[4] += E;
    263              ctx->state[5] += F;
    264              ctx->state[6] += G;
    265              ctx->state[7] += H;
    266          }
    267          #endif /* !MBEDTLS_SHA512_PROCESS_ALT */
    268          
    269          /*
    270           * SHA-512 process buffer
    271           */
    272          void mbedtls_sha512_update( mbedtls_sha512_context *ctx, const unsigned char *input,
    273                              size_t ilen )
    274          {
    275              size_t fill;
    276              unsigned int left;
    277          
    278              if( ilen == 0 )
    279                  return;
    280          
    281              left = (unsigned int) (ctx->total[0] & 0x7F);
    282              fill = 128 - left;
    283          
    284              ctx->total[0] += (uint64_t) ilen;
    285          
    286              if( ctx->total[0] < (uint64_t) ilen )
    287                  ctx->total[1]++;
    288          
    289              if( left && ilen >= fill )
    290              {
    291                  memcpy( (void *) (ctx->buffer + left), input, fill );
    292                  mbedtls_sha512_process( ctx, ctx->buffer );
    293                  input += fill;
    294                  ilen  -= fill;
    295                  left = 0;
    296              }
    297          
    298              while( ilen >= 128 )
    299              {
    300                  mbedtls_sha512_process( ctx, input );
    301                  input += 128;
    302                  ilen  -= 128;
    303              }
    304          
    305              if( ilen > 0 )
    306                  memcpy( (void *) (ctx->buffer + left), input, ilen );
    307          }
    308          
    309          static const unsigned char sha512_padding[128] =
    310          {
    311           0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    312              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    313              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    314              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    315              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    316              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    317              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    318              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    319          };
    320          
    321          /*
    322           * SHA-512 final digest
    323           */
    324          void mbedtls_sha512_finish( mbedtls_sha512_context *ctx, unsigned char output[64] )
    325          {
    326              size_t last, padn;
    327              uint64_t high, low;
    328              unsigned char msglen[16];
    329          
    330              high = ( ctx->total[0] >> 61 )
    331                   | ( ctx->total[1] <<  3 );
    332              low  = ( ctx->total[0] <<  3 );
    333          
    334              PUT_UINT64_BE( high, msglen, 0 );
    335              PUT_UINT64_BE( low,  msglen, 8 );
    336          
    337              last = (size_t)( ctx->total[0] & 0x7F );
    338              padn = ( last < 112 ) ? ( 112 - last ) : ( 240 - last );
    339          
    340              mbedtls_sha512_update( ctx, sha512_padding, padn );
    341              mbedtls_sha512_update( ctx, msglen, 16 );
    342          
    343              PUT_UINT64_BE( ctx->state[0], output,  0 );
    344              PUT_UINT64_BE( ctx->state[1], output,  8 );
    345              PUT_UINT64_BE( ctx->state[2], output, 16 );
    346              PUT_UINT64_BE( ctx->state[3], output, 24 );
    347              PUT_UINT64_BE( ctx->state[4], output, 32 );
    348              PUT_UINT64_BE( ctx->state[5], output, 40 );
    349          
    350              if( ctx->is384 == 0 )
    351              {
    352                  PUT_UINT64_BE( ctx->state[6], output, 48 );
    353                  PUT_UINT64_BE( ctx->state[7], output, 56 );
    354              }
    355          }
    356          
    357          #else
    358          void mbedtls_sha512_init( mbedtls_sha512_context *ctx )
    359          {
    360              memset( ctx, 0, sizeof( mbedtls_sha512_context ) );
    361          }
    362          
    363          void mbedtls_sha512_free( mbedtls_sha512_context *ctx )
    364          {
    365              if( ctx == NULL )
    366                  return;
    367              memset( ctx, 0, sizeof( mbedtls_sha512_context ) );
    368          }
    369          
    370          void mbedtls_sha512_clone( mbedtls_sha512_context *dst,
    371                                     const mbedtls_sha512_context *src )
    372          {
    373              *dst = *src;
    374          }
    375          
    376          void mbedtls_sha512_starts( mbedtls_sha512_context *ctx, int is384 )
    377          {
    378              int ret;
    379          
    380              if( is384 == 1 ){
    381                  do{
    382                      ret = (int)hal_sha384_init( ctx );
    383                      if( ret == -100 )
    384                          delay_ms(1);
    385                  } while( ret == -100 );
    386              }else{
    387                  do {
    388                      ret = (int)hal_sha512_init( ctx );
    389                      if( ret == -100 )
    390                          delay_ms(1);
    391                  } while( ret == -100 );
    392              }
    393          }
    394          
    395          void mbedtls_sha512_update( mbedtls_sha512_context *ctx, const unsigned char *input, size_t ilen )
    396          {
    397              int ret;
    398          
    399              do {
    400                  ret = (int)hal_sha512_append( ctx, (uint8_t*)input, (uint32_t)ilen );
    401                  if( ret == -100 )
    402                      delay_ms(1);
    403              } while( ret == -100 );
    404          }
    405          
    406          void mbedtls_sha512_finish( mbedtls_sha512_context *ctx, unsigned char output[64] )
    407          {
    408              int ret;
    409          
    410              do {
    411                  ret = (int)hal_sha512_end( ctx, (uint8_t*)output );
    412                  if( ret == -100 )
    413                      delay_ms(1);
    414              } while( ret == -100 );
    415          }
    416          
    417          void mbedtls_sha512_process( mbedtls_sha512_context *ctx, const unsigned char data[128] )
    418          {
    419          #if 0
    420              int ret;
    421              ctx->block = data;
    422              ctx->block_length = 128;
    423          
    424              do {
    425                  ret = (int)crypt_sha512_hash( ctx );
    426                  if( ret == -100 )
    427                      delay_ms(1);
    428              } while( ret == -100 );
    429          #else
    430          	unsigned char output[64] = {0};
    431          
    432          	mbedtls_sha512_starts(ctx, 0);
    433          	mbedtls_sha512_update(ctx, data, 128);
    434          	mbedtls_sha512_finish(ctx, output);
    435          #endif
    436          }
    437          
    438          #endif /* !MBEDTLS_SHA512_ALT */
    439          
    440          /*
    441           * output = SHA-512( input buffer )
    442           */
    443          void mbedtls_sha512( const unsigned char *input, size_t ilen,
    444                       unsigned char output[64], int is384 )
    445          {
    446              mbedtls_sha512_context ctx;
    447          
    448              mbedtls_sha512_init( &ctx );
    449              mbedtls_sha512_starts( &ctx, is384 );
    450              mbedtls_sha512_update( &ctx, input, ilen );
    451              mbedtls_sha512_finish( &ctx, output );
    452              mbedtls_sha512_free( &ctx );
    453          }
    454          
    455          #if defined(MBEDTLS_SELF_TEST)
    456          
    457          /*
    458           * FIPS-180-2 test vectors
    459           */
    460          static const unsigned char sha512_test_buf[3][113] =
    461          {
    462              { "abc" },
    463              { "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn"
    464                "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu" },
    465              { "" }
    466          };
    467          
    468          static const int sha512_test_buflen[3] =
    469          {
    470              3, 112, 1000
    471          };
    472          
    473          static const unsigned char sha512_test_sum[6][64] =
    474          {
    475              /*
    476               * SHA-384 test vectors
    477               */
    478              { 0xCB, 0x00, 0x75, 0x3F, 0x45, 0xA3, 0x5E, 0x8B,
    479                0xB5, 0xA0, 0x3D, 0x69, 0x9A, 0xC6, 0x50, 0x07,
    480                0x27, 0x2C, 0x32, 0xAB, 0x0E, 0xDE, 0xD1, 0x63,
    481                0x1A, 0x8B, 0x60, 0x5A, 0x43, 0xFF, 0x5B, 0xED,
    482                0x80, 0x86, 0x07, 0x2B, 0xA1, 0xE7, 0xCC, 0x23,
    483                0x58, 0xBA, 0xEC, 0xA1, 0x34, 0xC8, 0x25, 0xA7 },
    484              { 0x09, 0x33, 0x0C, 0x33, 0xF7, 0x11, 0x47, 0xE8,
    485                0x3D, 0x19, 0x2F, 0xC7, 0x82, 0xCD, 0x1B, 0x47,
    486                0x53, 0x11, 0x1B, 0x17, 0x3B, 0x3B, 0x05, 0xD2,
    487                0x2F, 0xA0, 0x80, 0x86, 0xE3, 0xB0, 0xF7, 0x12,
    488                0xFC, 0xC7, 0xC7, 0x1A, 0x55, 0x7E, 0x2D, 0xB9,
    489                0x66, 0xC3, 0xE9, 0xFA, 0x91, 0x74, 0x60, 0x39 },
    490              { 0x9D, 0x0E, 0x18, 0x09, 0x71, 0x64, 0x74, 0xCB,
    491                0x08, 0x6E, 0x83, 0x4E, 0x31, 0x0A, 0x4A, 0x1C,
    492                0xED, 0x14, 0x9E, 0x9C, 0x00, 0xF2, 0x48, 0x52,
    493                0x79, 0x72, 0xCE, 0xC5, 0x70, 0x4C, 0x2A, 0x5B,
    494                0x07, 0xB8, 0xB3, 0xDC, 0x38, 0xEC, 0xC4, 0xEB,
    495                0xAE, 0x97, 0xDD, 0xD8, 0x7F, 0x3D, 0x89, 0x85 },
    496          
    497              /*
    498               * SHA-512 test vectors
    499               */
    500              { 0xDD, 0xAF, 0x35, 0xA1, 0x93, 0x61, 0x7A, 0xBA,
    501                0xCC, 0x41, 0x73, 0x49, 0xAE, 0x20, 0x41, 0x31,
    502                0x12, 0xE6, 0xFA, 0x4E, 0x89, 0xA9, 0x7E, 0xA2,
    503                0x0A, 0x9E, 0xEE, 0xE6, 0x4B, 0x55, 0xD3, 0x9A,
    504                0x21, 0x92, 0x99, 0x2A, 0x27, 0x4F, 0xC1, 0xA8,
    505                0x36, 0xBA, 0x3C, 0x23, 0xA3, 0xFE, 0xEB, 0xBD,
    506                0x45, 0x4D, 0x44, 0x23, 0x64, 0x3C, 0xE8, 0x0E,
    507                0x2A, 0x9A, 0xC9, 0x4F, 0xA5, 0x4C, 0xA4, 0x9F },
    508              { 0x8E, 0x95, 0x9B, 0x75, 0xDA, 0xE3, 0x13, 0xDA,
    509                0x8C, 0xF4, 0xF7, 0x28, 0x14, 0xFC, 0x14, 0x3F,
    510                0x8F, 0x77, 0x79, 0xC6, 0xEB, 0x9F, 0x7F, 0xA1,
    511                0x72, 0x99, 0xAE, 0xAD, 0xB6, 0x88, 0x90, 0x18,
    512                0x50, 0x1D, 0x28, 0x9E, 0x49, 0x00, 0xF7, 0xE4,
    513                0x33, 0x1B, 0x99, 0xDE, 0xC4, 0xB5, 0x43, 0x3A,
    514                0xC7, 0xD3, 0x29, 0xEE, 0xB6, 0xDD, 0x26, 0x54,
    515                0x5E, 0x96, 0xE5, 0x5B, 0x87, 0x4B, 0xE9, 0x09 },
    516              { 0xE7, 0x18, 0x48, 0x3D, 0x0C, 0xE7, 0x69, 0x64,
    517                0x4E, 0x2E, 0x42, 0xC7, 0xBC, 0x15, 0xB4, 0x63,
    518                0x8E, 0x1F, 0x98, 0xB1, 0x3B, 0x20, 0x44, 0x28,
    519                0x56, 0x32, 0xA8, 0x03, 0xAF, 0xA9, 0x73, 0xEB,
    520                0xDE, 0x0F, 0xF2, 0x44, 0x87, 0x7E, 0xA6, 0x0A,
    521                0x4C, 0xB0, 0x43, 0x2C, 0xE5, 0x77, 0xC3, 0x1B,
    522                0xEB, 0x00, 0x9C, 0x5C, 0x2C, 0x49, 0xAA, 0x2E,
    523                0x4E, 0xAD, 0xB2, 0x17, 0xAD, 0x8C, 0xC0, 0x9B }
    524          };
    525          
    526          /*
    527           * Checkup routine
    528           */
    529          int mbedtls_sha512_self_test( int verbose )
    530          {
    531              int i, j, k, buflen, ret = 0;
    532              unsigned char buf[1024];
    533              unsigned char sha512sum[64];
    534              mbedtls_sha512_context ctx;
    535          
    536              mbedtls_sha512_init( &ctx );
    537          
    538              for( i = 0; i < 6; i++ )
    539              {
    540                  j = i % 3;
    541                  k = i < 3;
    542          
    543                  if( verbose != 0 )
    544                      mbedtls_printf( "  SHA-%d test #%d: ", 512 - k * 128, j + 1 );
    545          
    546                  mbedtls_sha512_starts( &ctx, k );
    547          
    548                  if( j == 2 )
    549                  {
    550                      memset( buf, 'a', buflen = 1000 );
    551          
    552                      for( j = 0; j < 1000; j++ )
    553                          mbedtls_sha512_update( &ctx, buf, buflen );
    554                  }
    555                  else
    556                      mbedtls_sha512_update( &ctx, sha512_test_buf[j],
    557                                           sha512_test_buflen[j] );
    558          
    559                  mbedtls_sha512_finish( &ctx, sha512sum );
    560          
    561                  if( memcmp( sha512sum, sha512_test_sum[i], 64 - k * 16 ) != 0 )
    562                  {
    563                      if( verbose != 0 )
    564                          mbedtls_printf( "failed\n" );
    565          
    566                      ret = 1;
    567                      goto exit;
    568                  }
    569          
    570                  if( verbose != 0 )
    571                      mbedtls_printf( "passed\n" );
    572              }
    573          
    574              if( verbose != 0 )
    575                  mbedtls_printf( "\n" );
    576          
    577          exit:
    578              mbedtls_sha512_free( &ctx );
    579          
    580              return( ret );
    581          }
    582          
    583          #endif /* MBEDTLS_SELF_TEST */
    584          
    585          #endif /* MBEDTLS_SHA512_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     240   mbedtls_sha512
       240   -> mbedtls_sha512_finish
       240   -> mbedtls_sha512_free
       240   -> mbedtls_sha512_init
       240   -> mbedtls_sha512_starts
       240   -> mbedtls_sha512_update
       0   mbedtls_sha512_clone
         0   -> __aeabi_memcpy4
      40   mbedtls_sha512_finish
        40   -> mbedtls_sha512_update
       0   mbedtls_sha512_free
         0   -> mbedtls_zeroize
       0   mbedtls_sha512_init
         0   -> __aeabi_memset4
     736   mbedtls_sha512_process
    1344   mbedtls_sha512_self_test
      1344   -- Indirect call
      1344   -> __aeabi_memset4
      1344   -> mbedtls_sha512_finish
      1344   -> mbedtls_sha512_free
      1344   -> mbedtls_sha512_init
      1344   -> mbedtls_sha512_starts
      1344   -> mbedtls_sha512_update
      1344   -> memcmp
       0   mbedtls_sha512_starts
      24   mbedtls_sha512_update
         0   -> __aeabi_memcpy
        24   -> __aeabi_memcpy
        24   -> mbedtls_sha512_process
       0   mbedtls_zeroize


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_21
       4  ??DataTable10_22
       4  ??DataTable10_23
       4  ??DataTable10_24
       4  ??DataTable10_25
       4  ??DataTable10_26
       4  ??DataTable10_27
       4  ??DataTable10_28
       4  ??DataTable10_29
       4  ??DataTable10_3
       4  ??DataTable10_30
       4  ??DataTable10_31
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable11
       4  ??DataTable11_1
      20  ?_0
       8  ?_1
       8  ?_2
       2  ?_3
     640  K
      54  mbedtls_sha512
       6  mbedtls_sha512_clone
     694  mbedtls_sha512_finish
      10  mbedtls_sha512_free
       8  mbedtls_sha512_init
    3638  mbedtls_sha512_process
     296  mbedtls_sha512_self_test
     152  mbedtls_sha512_starts
     140  mbedtls_sha512_update
      18  mbedtls_zeroize
     128  sha512_padding
     340  sha512_test_buf
      12  sha512_test_buflen
     384  sha512_test_sum
      28  -- Other

 
     2 bytes in section .rodata
 6 720 bytes in section .text
 
 6 720 bytes of CODE  memory
     2 bytes of CONST memory

Errors: none
Warnings: none
