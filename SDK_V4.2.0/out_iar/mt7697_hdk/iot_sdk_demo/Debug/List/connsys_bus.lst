###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       25/Jan/2017  17:34:51
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\driver\chip\mt7687\src\sdio_gen3\connsys_bus.c
#    Command line =  
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\driver\chip\mt7687\src\sdio_gen3\connsys_bus.c" -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_WIFI_TGN_VERIFY_ENABLE -D MTK_SMTCN_ENABLE -D
#        MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D SUPPORT_MBEDTLS -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-basic.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D MTK_MCS_ENABLE -D MTK_BLE_GPIO_SERVICE -D
#        __BT_DEBUG__ -lcN "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List" -lA
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List"
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj" --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\inc\" -I
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\service\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\dhcpd\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\src\ut_app\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\httpclient\inc\"
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List\connsys_bus.lst
#    Object file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj\connsys_bus.o
#
###############################################################################

C:\LEO\myGit\MTK IOT\SDK_V4.2.0\driver\chip\mt7687\src\sdio_gen3\connsys_bus.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          /*
     36              Module Name:
     37              connsys_bus_driver.c
     38          
     39              Abstract:
     40              Provide SDIO-GEN3  based bus driver routines
     41          
     42              Revision History:
     43              Who         When            What
     44              --------    ----------      ----------------------------------------------
     45          */
     46          #include <stdio.h>
     47          #include <string.h>
     48          #include "type_def.h"
     49          #include "connsys_driver.h"
     50          #include "connsys_bus.h"
     51          #include "cmsis_nvic.h"
     52          #include "nvic.h"
     53          #include "dma_sw.h"
     54          #include "dma_hw.h"
     55          #include "debug.h"
     56          #include "misc.h"
     57          #include "syslog.h"
     58          #include "type_def.h"
     59          #include "cos_api.h"
     60          
     61          log_create_module(connsys, PRINT_LEVEL_WARNING);
     62          
     63          //#include <errno.h>
     64          #define EIO 5     // errno.h not available for Keil compiler
     65          #define ETIME 62  // errno.h not available for Keil compiler
     66          
     67          // ========================== SDIO Private Routines =============================
     68          
     69          void connsys_bus_get_bus(struct connsys_func *func)
     70          {
     71          }
     72          
     73          void connsys_bus_release_bus(struct connsys_func *func)
     74          {
     75          }
     76          
     77          void connsys_bus_read_port_pio(connsys_gen3_cmd53_info *info, void *dst, int32_t count)
     78          {
     79              int32_t i;
     80              int32_t drop_count = 0;
     81              uint32_t flags;
     82          
     83              local_irq_save(flags);
     84              REG32(SDIO_GEN3_CMD_SETUP) = info->word;
     85              /* 2. CMD53 read out */
     86              for (i = 0; i < count; i += 4) {
     87                  uint32_t value = REG32(SDIO_GEN3_CMD53_DATA);
     88                  if (i < CONNSYS_MAX_RX_PKT_SIZE && dst != NULL) {
     89                      *(((uint8_t *)dst) + i) = (value & 0xFF);
     90                      *(((uint8_t *)dst) + i + 1) = ((value & 0xFF00) >> 8);
     91                      *(((uint8_t *)dst) + i + 2) = ((value & 0xFF0000) >> 16);
     92                      *(((uint8_t *)dst) + i + 3) = ((value & 0xFF000000) >> 24);
     93                  } else {
     94                      drop_count += 4;
     95                  }
     96              }
     97              local_irq_restore(flags);
     98          }
     99          
    100          
    101          void connsys_bus_read_port_pio_garbage(connsys_gen3_cmd53_info *info, int32_t count)
    102          {
    103              int32_t i;
    104              uint32_t flags;
    105          
    106              local_irq_save(flags);
    107              REG32(SDIO_GEN3_CMD_SETUP) = info->word;
    108              /* 2. CMD53 read out */
    109              for (i = 0; i < count; i += 4) {
    110                  REG32(SDIO_GEN3_CMD53_DATA);
    111              }
    112              local_irq_restore(flags);
    113          }
    114          
    115          
    116          
    117          
    118          void connsys_bus_read_port_dma(connsys_gen3_cmd53_info *info, void *dst, int32_t count)
    119          {
    120          
    121              uint32_t flags;
    122              uint32_t reg;
    123          #if 0
    124              printf("==>connsys_bus_read_port_dma 2, dst = 0x%x, count = %d\n",
    125                     (unsigned int)dst, (int)count);
    126          
    127              printf("block_mode = %u\n", (unsigned int)info->field.block_mode);
    128              printf("field.count = %u\n", (unsigned int)info->field.count);
    129          #endif
    130          
    131              local_irq_save(flags);
    132              REG32(SDIO_GEN3_CMD_SETUP) = info->word;
    133              /* DMA setting */
    134              REG32(GDMA_CH4_START) &= ~(0x1 << 15);	   /* Clear DMA channel */
    135              REG32(GDMA_CH4_PGMADDR) = (uint32_t)dst;			/* Setting CM4 SRAM Start Address */
    136              REG32(GDMA_CH4_COUNT) = (count >> 2);	   /* Setting DMA transfer length in DW */
    137              REG32(GDMA_CH4_CON) = 0;
    138              REG32(GDMA_CH4_CON) |= (0x15 << 20);	   /* select HIF(SDIO) Tx/Rx */
    139              REG32(GDMA_CH4_CON) |= (0x1 << 18); 	   /* DIR=1, HIF to CM4 Sysram	=> WRITE */
    140          //	REG32(GDMA_CH4_CON) |= (0x1 << 15); 	   /* Enable DMA finish interrupt */
    141              REG32(GDMA_CH4_CON) |= (0x6 << 8);		   /* Burst transfer 4 beats in DW */
    142              REG32(GDMA_CH4_CON) |= (0x1 << 3);		   /* Increase destination address, HIF address */
    143              REG32(GDMA_CH4_CON) |= (0x0 << 2);		   /* Don't increase source address, CM4 Sysram address */
    144              REG32(GDMA_CH4_CON) |= (0x2 << 0);		   /* Double word transfer, 4 bytes */
    145          
    146              /* DMA kick out */
    147              REG32(GDMA_CH4_START) |= (0x1 << 15); /* Start DMA channel*/
    148              do {
    149                  reg = REG32(GDMA_CH4_RLCT);
    150              } while (reg != 0x00);
    151          
    152              local_irq_restore(flags);
    153          
    154          
    155          }
    156          
    157          /**
    158           *	connsys_readsb - read from a FIFO on a SDIO function
    159           *	@func: SDIO function to access
    160           *	@dst: buffer to store the data
    161           *	@addr: address of (single byte) FIFO
    162           *	@count: number of bytes to read
    163           *
    164           *	Reads from the specified FIFO of a given SDIO function. Return
    165           *	value indicates if the transfer succeeded or not.
    166           */
    167          int32_t connsys_bus_read_port(struct connsys_func *func, void *dst, uint32_t addr,
    168                                        int32_t size)
    169          {
    170              connsys_gen3_cmd53_info info;
    171              int32_t count;
    172          
    173              if ((unsigned int)dst & 0x3) {
    174                  LOG_E(connsys, "==>connsys_bus_read_port, align error, dst = 0x%x", (unsigned int)dst);
    175                  connsys_bus_read_port_garbage(addr, size);
    176                  return CONNSYS_STATUS_FAIL;
    177              }
    178          
    179              /* CMD53 port mode to write n-byte, if count >= block size => block mode, otherwise =>  byte mode  */
    180              count = ALIGN_4BYTE(size);
    181          
    182              /* 1. Setup command information */
    183              info.word = 0;
    184              info.field.rw_flag = SDIO_GEN3_READ;
    185              info.field.func_num = func->num; //SDIO_GEN3_FUNCTION_WIFI;
    186              if (count >= func->blksize) {
    187                  info.field.block_mode = SDIO_GEN3_BLOCK_MODE; /* block  mode */
    188                  info.field.count = count / func->blksize;
    189                  if (count % func->blksize > 0) {
    190                      info.field.count++;
    191                  }
    192                  count = info.field.count * func->blksize;
    193              } else {
    194                  info.field.block_mode = SDIO_GEN3_BYTE_MODE; /* byte  mode */
    195                  info.field.count = count;
    196              }
    197              info.field.op_mode = SDIO_GEN3_FIXED_PORT_MODE; /* fix mode */
    198              info.field.addr = addr;
    199          
    200              if ((func->use_dma) &&
    201                      (info.field.block_mode == SDIO_GEN3_BLOCK_MODE) &&
    202                      (count < CONNSYS_MAX_RX_PKT_SIZE)) {
    203                  /*
    204                  	uint32_t drop_count = 0;
    205                  	if (count >  CONNSYS_MAX_RX_PKT_SIZE)
    206                  	{
    207                  		count = CONNSYS_MAX_RX_PKT_SIZE;
    208                  		drop_count = CONNSYS_MAX_RX_PKT_SIZE - count;
    209                  	}
    210                  */
    211                  connsys_bus_read_port_dma(&info, dst, count);
    212                  /*
    213                  	if (drop_count >  0)
    214                  	{
    215                  		// TODO: take care of info of drop count
    216                  		LOG_E(connsys, "DMA mode drop count(%d) not support yet!", (int)drop_count);
    217                  	}
    218                  */
    219              } else {
    220                  connsys_bus_read_port_pio(&info, dst, count);
    221              }
    222          
    223              return CONNSYS_STATUS_SUCCESS;
    224          }
    225          
    226          
    227          int32_t connsys_bus_read_port_garbage(uint32_t addr, int32_t size)
    228          {
    229              connsys_gen3_cmd53_info info;
    230              int32_t count;
    231              struct connsys_func *func = &g_connsys_func;
    232          
    233          
    234              /* CMD53 port mode to write n-byte, if count >= block size => block mode, otherwise =>  byte mode  */
    235              count = ALIGN_4BYTE(size);
    236          
    237              /* 1. Setup command information */
    238              info.word = 0;
    239              info.field.rw_flag = SDIO_GEN3_READ;
    240              info.field.func_num = func->num; //SDIO_GEN3_FUNCTION_WIFI;
    241              if (count >= func->blksize) {
    242                  info.field.block_mode = SDIO_GEN3_BLOCK_MODE; /* block  mode */
    243                  info.field.count = count / func->blksize;
    244                  if (count % func->blksize > 0) {
    245                      info.field.count++;
    246                  }
    247                  count = info.field.count * func->blksize;
    248              } else {
    249                  info.field.block_mode = SDIO_GEN3_BYTE_MODE; /* byte  mode */
    250                  info.field.count = count;
    251              }
    252              info.field.op_mode = SDIO_GEN3_FIXED_PORT_MODE; /* fix mode */
    253              info.field.addr = addr;
    254          
    255              connsys_bus_read_port_pio_garbage(&info, count);
    256          
    257              return 0;
    258          }
    259          
    260          
    261          void connsys_dump_cmd53_info(connsys_gen3_cmd53_info *info)
    262          {
    263              LOG_I(connsys, "info: 0x%x", (unsigned int)info->word);
    264              LOG_I(connsys, "\tByte/Block Count: %u", info->field.count);
    265              LOG_I(connsys, "\tRegister Address: 0x%x", info->field.addr);
    266              LOG_I(connsys, "\tOP Code: 0x%x", info->field.op_mode);
    267              LOG_I(connsys, "\tBlock Mode: 0x%x", info->field.block_mode);
    268              LOG_I(connsys, "\tFunction Number: 0x%x", info->field.func_num);
    269              LOG_I(connsys, "\tR/W flag: 0x%x", info->field.rw_flag);
    270          }
    271          
    272          
    273          
    274          static void connsys_bus_write_port_pio(connsys_gen3_cmd53_info *info, void *src, int32_t count)
    275          {
    276              int32_t i;
    277              uint32_t flags;
    278              uint32_t value;
    279          
    280          
    281              if (g_connsys_debug_feature & CONNSYS_DBG_PORT) {
    282                  DBG_CONNSYS(CONNSYS_DBG_PORT,
    283                              ("==>connsys_bus_write_port_pio, src = 0x%x, count = %u",
    284                               (unsigned int)src, (unsigned int)count));
    285          
    286                  connsys_dump_cmd53_info(info);
    287              }
    288          
    289              local_irq_save(flags);
    290              REG32(SDIO_GEN3_CMD_SETUP) = info->word;
    291              for (i = 0; i < count; i += 4) {
    292                  if (i >= count) {
    293                      /* Padding with all "0" */
    294                      value = 0;
    295                  } else {
    296                      value = *(((uint8_t *)src) + i);
    297                      value |= ((*(((uint8_t *)src) + i + 1)) << 8);
    298                      value |= ((*(((uint8_t *)src) + i + 2)) << 16);
    299                      value |= ((*(((uint8_t *)src) + i + 3)) << 24);
    300                  }
    301                  REG32(SDIO_GEN3_CMD53_DATA) = value;
    302              }
    303              local_irq_restore(flags);
    304          }
    305          
    306          // TODO: Support scattered packets
    307          static void connsys_bus_write_port_dma(connsys_gen3_cmd53_info *info, void *src, int32_t count)
    308          {
    309          
    310          
    311              uint32_t reg;
    312              uint32_t flags;
    313          
    314              local_irq_save(flags);
    315              REG32(SDIO_GEN3_CMD_SETUP) = info->word;
    316              /* DMA setting */
    317              REG32(GDMA_CH4_START) = 0;	   /* Clear DMA channel */
    318              REG32(GDMA_CH4_PGMADDR) = (uint32_t)src;			/* Setting CM4 SRAM Start Address */
    319              REG32(GDMA_CH4_COUNT) = (count >> 2);	   /* Setting DMA transfer length in DW */
    320              REG32(GDMA_CH4_CON) = 0;
    321              REG32(GDMA_CH4_CON) |= (0x15 << 20);	   /* select HIF(SDIO) Tx/Rx */
    322              REG32(GDMA_CH4_CON) |= (0x0 << 18); 	   /* DIR=0, CM4 Sysram to HIF => READ */
    323          //	REG32(GDMA_CH4_CON) |= (0x0 << 15); 	   /* Enable DMA finish interrupt */
    324              REG32(GDMA_CH4_CON) |= (0x6 << 8);		   /* Burst transfer 4 beats in DW */
    325              REG32(GDMA_CH4_CON) |= (0x0 << 3);		   /* Don't increase destination address, HIF address */
    326              REG32(GDMA_CH4_CON) |= (0x1 << 2);		   /* Increase source address, CM4 Sysram address */
    327              REG32(GDMA_CH4_CON) |= (0x2 << 0);		   /* Double word transfer, 4 bytes */
    328              /* DMA kick out */
    329              REG32(GDMA_CH4_START) |= (0x1 << 15); /* Start DMA channel*/
    330              /* wait DMA finish */
    331              do {
    332                  reg = REG32(GDMA_CH4_RLCT);
    333              } while (reg != 0x00);
    334              local_irq_restore(flags);
    335          }
    336          
    337          void connsys_bus_write_port_transfer(struct connsys_func *func, connsys_gen3_cmd53_info *info, void *src, int32_t size)
    338          {
    339          
    340              if (func->use_dma) {
    341                  connsys_bus_write_port_dma(info, src, size);
    342              } else {
    343                  connsys_bus_write_port_pio(info, src, size);
    344          
    345              }
    346          }
    347          
    348          int32_t connsys_bus_write_port(struct connsys_func *func, uint32_t addr, void *src,
    349                                         int32_t size)
    350          {
    351              connsys_gen3_cmd53_info info;
    352              int32_t count;
    353          
    354              DBG_CONNSYS(CONNSYS_DBG_PORT, ("==>connsys_bus_write_port, addr = 0x%x, src = 0x%x, size = %u\n",
    355                                             (unsigned int)addr, (unsigned int)src, (unsigned int)size));
    356          
    357              if (!(IS_ALIGN_4((uint32_t)src)) && (func->use_dma)) {
    358                  LOG_HEXDUMP_E(connsys, "connsys_bus_write_port, align error, packet: ", (uint8_t *)src, (uint32_t)size);
    359                  return CONNSYS_STATUS_FAIL;
    360              }
    361          
    362              /* CMD53 port mode to write n-byte, if count >= block size => block mode, otherwise =>  byte mode  */
    363              count = ALIGN_4BYTE(size);
    364          
    365              /* 1. Setup command information */
    366              info.word = 0;
    367              info.field.rw_flag = SDIO_GEN3_WRITE;
    368              info.field.func_num = func->num; //SDIO_GEN3_FUNCTION_WIFI;
    369          
    370              if (count >= func->blksize) {
    371                  info.field.block_mode = SDIO_GEN3_BLOCK_MODE; /* block  mode */
    372                  info.field.count = count / func->blksize;
    373                  if (count % func->blksize > 0) {
    374                      info.field.count++;
    375                  }
    376                  count = info.field.count * func->blksize;
    377              } else {
    378                  info.field.block_mode = SDIO_GEN3_BYTE_MODE; /* byte  mode */
    379                  info.field.count = count;
    380              }
    381          
    382              info.field.op_mode = SDIO_GEN3_FIXED_PORT_MODE; /* fix mode */
    383              info.field.addr = addr;
    384          
    385              if ((func->use_dma) &&
    386                      (info.field.block_mode == SDIO_GEN3_BLOCK_MODE) &&
    387                      (count < CONNSYS_MAX_RX_PKT_SIZE))
    388          
    389              {
    390                  connsys_bus_write_port_dma(&info, src, count);
    391              } else {
    392                  connsys_bus_write_port_pio(&info, src, count);
    393          
    394              }
    395              return CONNSYS_STATUS_SUCCESS;
    396          }
    397          
    398          void connsys_dump_tx_scatter_info(connsys_tx_scatter_info_t *tx_info)
    399          {
    400              uint32_t i;
    401              LOG_I(connsys, "dump tx scatter info:");
    402              LOG_HEXDUMP_I(connsys, "txd", tx_info->txd, 12);
    403              LOG_I(connsys, "reserved_headroom_len = %u, tx_len = %u, real_tx_len = %u, buf_num = %u, fg_wmm = %d",
    404                    (unsigned int)tx_info->reserved_headroom_len,
    405                    (unsigned int)tx_info->tx_len,
    406                    (unsigned int)tx_info->real_tx_len,
    407                    (unsigned int)tx_info->buf_num,
    408                    (int)tx_info->fg_wmm);
    409          
    410              for (i = 0; i < tx_info->buf_num; i++) {
    411                  LOG_I(connsys, "[%u]: ", (unsigned int)i);
    412                  LOG_HEXDUMP_I(connsys, "content", tx_info->buff[i].buf_ptr, tx_info->buff[i].buf_len);
    413              }
    414          }
    415          
    416          int32_t connsys_write_data(connsys_tx_scatter_info_t *tx_info)
    417          {
    418              connsys_gen3_cmd53_info info;
    419              struct connsys_func *func = &g_connsys_func;
    420              uint32_t addr = WTDR1;
    421              int32_t count;
    422              uint32_t i;
    423              uint32_t src;
    424              uint32_t send_len;
    425              int32_t remain_send_len = 0;
    426              int32_t remain_reserved_headroom_len = 0;
    427              uint32_t  n9_pad_buf;
    428              uint32_t send_cnt = 0;
    429              uint32_t  byte_idx;
    430              uint32_t  buf_idx;
    431              uint32_t flags;
    432              uint32_t send_buf = 0;
    433          
    434              /* CMD53 port mode to write n-byte, if count >= block size => block mode, otherwise =>  byte mode  */
    435              count = tx_info->real_tx_len;
    436          
    437              /* 1. Setup command information */
    438              info.word = 0;
    439              info.field.rw_flag = SDIO_GEN3_WRITE;
    440              info.field.func_num = func->num; //SDIO_GEN3_FUNCTION_WIFI;
    441          
    442              if (count >= func->blksize) {
    443                  info.field.block_mode = SDIO_GEN3_BLOCK_MODE; /* block  mode */
    444                  info.field.count = count / func->blksize;
    445                  if (count % func->blksize > 0) {
    446                      info.field.count++;
    447                  }
    448                  count = info.field.count * func->blksize;
    449              } else {
    450                  info.field.block_mode = SDIO_GEN3_BYTE_MODE; /* byte  mode */
    451                  info.field.count = count;
    452              }
    453          
    454              info.field.op_mode = SDIO_GEN3_FIXED_PORT_MODE; /* fix mode */
    455              info.field.addr = addr;
    456          
    457          
    458          #if (CONNSYS_DEBUG_MODE_EN == 1)
    459              if (CONNSYS_TEST_DEBUG(CONNSYS_DBG_PORT)) {
    460                  DBG_CONNSYS(CONNSYS_DBG_PORT, ("==>connsys_write_data\n"));
    461                  connsys_dump_cmd53_info(&info);
    462              }
    463          #endif
    464          
    465              local_irq_save(flags);
    466              REG32(SDIO_GEN3_CMD_SETUP) = info.word;
    467          
    468              /* Send HIF TXD */
    469              src = (uint32_t) &tx_info->txd;
    470              for (i = 0; i < 12; i += 4) {
    471                  REG32(SDIO_GEN3_CMD53_DATA) = *(uint32_t *)(src + i);
    472              }
    473          
    474              send_cnt += 12;
    475          
    476          
    477              /* Send N9 padding */
    478              send_len = (tx_info->reserved_headroom_len / 4) * 4;
    479              for (i = 0; i < send_len; i += 4) {
    480                  REG32(SDIO_GEN3_CMD53_DATA) = 0;
    481              }
    482              send_cnt += send_len;
    483          
    484              remain_reserved_headroom_len = tx_info->reserved_headroom_len - send_len;
    485          
    486              if (remain_reserved_headroom_len && (!func->use_dma)) {
    487                  /* PIO sent out 1st DW of payload */
    488                  n9_pad_buf = 0;
    489                  memcpy((void *)((uint32_t)((uint8_t *)&n9_pad_buf) + remain_reserved_headroom_len),
    490                         tx_info->buff[0].buf_ptr,
    491                         (4 - remain_reserved_headroom_len));
    492          
    493                  REG32(SDIO_GEN3_CMD53_DATA) = n9_pad_buf;
    494                  send_cnt += 4;
    495              }
    496          
    497              /* Send packet payload */
    498              byte_idx = 0;
    499              for (buf_idx = 0; buf_idx < tx_info->buf_num; buf_idx++) {
    500                  if ((buf_idx == 0) && (remain_reserved_headroom_len)) {
    501                      if (func->use_dma) {
    502                          //ASSERT(remain_reserved_headroom_len == RESERVED_HLEN);
    503                          /* DMA not sent out 1st DW of payload  */
    504                          src = (uint32_t)tx_info->buff[0].buf_ptr - remain_reserved_headroom_len;
    505                          remain_send_len = tx_info->buff[0].buf_len + remain_reserved_headroom_len;
    506                      } else {
    507                          /* PIO has sent out 1st DW of payload  */
    508                          src = (uint32_t)tx_info->buff[0].buf_ptr + remain_reserved_headroom_len;
    509                          remain_send_len = tx_info->buff[0].buf_len - (4 - remain_reserved_headroom_len);
    510                      }
    511                  } else {
    512                      src = (uint32_t)tx_info->buff[buf_idx].buf_ptr;
    513                      remain_send_len = tx_info->buff[buf_idx].buf_len;
    514                  }
    515                  /* 2. CMD53 write out */
    516                  if (func->use_dma) {
    517          
    518                      unsigned int reg;
    519                      unsigned int len_moved_by_dma;
    520                      if (!IS_ALIGN_4((uint32_t)src)) {
    521                          /* Sometimes, LWIP use RX buffer for TX directly, w/o pbuf_free and allocation again, in this case, PBUF_RAW type will lead to unaligned 4-byte */
    522                          LOG_I(connsys, "[DMA] 4-align addr(%d), len(%d), src:0x%x, tx_info->reserved_headroom_len(%d), remain_reserved_headroom_len(%d), src offset 2 bytes...\n",
    523                                IS_ALIGN_4((uint32_t)src), IS_ALIGN_4(remain_send_len), src,
    524                                tx_info->reserved_headroom_len, remain_reserved_headroom_len);
    525                          goto pure_pio;
    526                      }
    527                      REG32(GDMA_CHANNEL_ENABLE) = 0xFFFFFFFF; // enable all DMA channel
    528                      //REG32(SDIO_GEN3_CMD_SETUP) = info.word; // DMA mode same as PIO
    529                      /* DMA setting */
    530                      REG32(GDMA_CH4_START) = 0;     /* Clear DMA channel */
    531                      REG32(GDMA_CH4_PGMADDR) = (unsigned int)src;            /* Setting CM4 SRAM Start Address */
    532                      REG32(GDMA_CH4_COUNT) = (remain_send_len >> 2);    /* Setting DMA transfer length in DW */
    533                      REG32(GDMA_CH4_CON) = 0;
    534                      REG32(GDMA_CH4_CON) |= (0x15 << 20);       /* select HIF(SDIO) Tx/Rx */
    535                      REG32(GDMA_CH4_CON) |= (0x0 << 18);        /* DIR=0, CM4 Sysram to HIF => READ */
    536                      //REG32(GDMA_CH4_CON) |= (0x0 << 15);      /* Enable DMA finish interrupt */
    537                      REG32(GDMA_CH4_CON) |= (0x6 << 8);         /* Burst transfer 4 beats in DW */
    538                      REG32(GDMA_CH4_CON) |= (0x0 << 3);         /* Don't increase destination address, HIF address */
    539                      REG32(GDMA_CH4_CON) |= (0x1 << 2);         /* Increase source address, CM4 Sysram address */
    540                      REG32(GDMA_CH4_CON) |= (0x2 << 0);         /* Double word transfer, 4 bytes */
    541          
    542                      byte_idx = 0;   //byte_idx indicate remaing bytes for residual (div by 4)
    543                      len_moved_by_dma = (remain_send_len >> 2) << 2;
    544                      src +=  len_moved_by_dma;
    545                      send_cnt += len_moved_by_dma;
    546                      remain_send_len -= len_moved_by_dma;
    547                      //printf("byte_idx=%d\n", byte_idx);
    548          
    549          #if 0 //(CONSYS_BUG_DBG==1)
    550                      printf("GDMA_CON(0x%x)=0x%x\n", GDMA_CH4_CON, REG32(GDMA_CH4_CON));
    551          
    552                      // wait DMA finish
    553                      printf("Wait GDMA finishing...\n");
    554          #endif
    555          
    556                      /* DMA kick out */
    557                      REG32(GDMA_CH4_START) |= (0x1 << 15); /* Start DMA channel*/
    558                      //printf("DMA kick done\n");
    559          #if 1
    560                      do {
    561                          reg = REG32(GDMA_CH4_RLCT);
    562                      } while (reg != 0x00);
    563                      //printf("GDMA done! byte_idx(%d), sent count(%d), count(%d)\n", byte_idx, send_cnt, count);
    564          #endif
    565                  }
    566          #if (CFG_WIFI_HIF_GDMA_EN == 1)
    567                  if (!IS_ALIGN_4((uint32_t)src)) {
    568                      LOG_E(connsys, "[TX] 4-byte align(%d), src:0x%x\n", IS_ALIGN_4((uint32_t)src), src);
    569                  }
    570          #endif
    571          
    572          pure_pio:
    573                  /* Pure PIO mode */
    574                  for (i = 0; i < remain_send_len; i++) {
    575                      *(((uint8_t *)&send_buf) + byte_idx) = *(uint8_t *)src;
    576                      byte_idx ++;
    577                      src ++;
    578                      if (byte_idx == 4) {
    579                          REG32(SDIO_GEN3_CMD53_DATA) = send_buf;
    580                          byte_idx = 0;
    581                          send_cnt += 4;
    582                      }
    583                  }
    584              }
    585          
    586              if (byte_idx) {
    587                  REG32(SDIO_GEN3_CMD53_DATA) = send_buf;
    588                  byte_idx = 0;
    589                  send_cnt += 4;
    590              }
    591          
    592              /* Send all zero */
    593              for (i = send_cnt; i < count; i += 4) {
    594                  REG32(SDIO_GEN3_CMD53_DATA) = 0;
    595              }
    596          
    597              local_irq_restore(flags);
    598              return CONNSYS_STATUS_SUCCESS;
    599          }
    600          
    601          /**
    602           *	connsys_bus_readl - read a 32 bit integer from a SDIO function
    603           *	@func: SDIO function to access
    604           *	@addr: address to read
    605           *	@err_ret: optional status value from transfer
    606           *
    607           *	Reads a 32 bit integer from the address space of a given SDIO
    608           *	function. If there is a problem reading the address,
    609           *	0xffffffff is returned and @err_ret will contain the error
    610           *	code.
    611           */
    612          uint32_t connsys_bus_readl(struct connsys_func *func, uint32_t addr, int32_t *err_ret)
    613          {
    614              uint32_t value;
    615              connsys_gen3_cmd53_info info;
    616              uint32_t flags;
    617          
    618              if (err_ret) {
    619                  *err_ret = 0;
    620              }
    621          
    622              /* CMD53 incremental mode to read 4-byte */
    623              /* 1. Setup command information */
    624              info.word = 0;
    625              info.field.rw_flag = SDIO_GEN3_READ;
    626              info.field.func_num = func->num; //SDIO_GEN3_FUNCTION_WIFI;
    627              info.field.block_mode = SDIO_GEN3_BYTE_MODE; /* byte  mode */
    628              info.field.op_mode = SDIO_GEN3_FIXED_PORT_MODE; // SDIO-GEN3 only apply to fix port, forget  SDIO_GEN3_INCREMENT_MODE; /* increment mode */
    629              info.field.addr = addr;
    630              info.field.count = 4;
    631          
    632              local_irq_save(flags);
    633              REG32(SDIO_GEN3_CMD_SETUP) = info.word;
    634              /* 2. CMD53 read out */
    635              value = REG32(SDIO_GEN3_CMD53_DATA);
    636              local_irq_restore(flags);
    637          
    638              return value;
    639          }
    640          
    641          /**
    642           *	connsys_bus_writel - write a 32 bit integer to a SDIO function
    643           *	@func: SDIO function to access
    644           *	@b: integer to write
    645           *	@addr: address to write to
    646           *	@err_ret: optional status value from transfer
    647           *
    648           *	Writes a 32 bit integer to the address space of a given SDIO
    649           *	function. @err_ret will contain the status of the actual
    650           *	transfer.
    651           */
    652          void connsys_bus_writel(struct connsys_func *func, uint32_t b, uint32_t addr, int32_t *err_ret)
    653          {
    654              connsys_gen3_cmd53_info info;
    655              uint32_t flags;
    656          
    657              if (err_ret) {
    658                  *err_ret = 0;
    659              }
    660          
    661              /* CMD53 incremental mode to read 4-byte */
    662              /* 1. Setup command information */
    663              info.word = 0;
    664              info.field.rw_flag = SDIO_GEN3_WRITE;
    665              info.field.func_num = func->num; //SDIO_GEN3_FUNCTION_WIFI;
    666              info.field.block_mode = SDIO_GEN3_BYTE_MODE; /* byte  mode */
    667              info.field.op_mode = SDIO_GEN3_FIXED_PORT_MODE; // SDIO-GEN3 only apply to fix port, forget  SDIO_GEN3_INCREMENT_MODE; /* increment mode */
    668              info.field.addr = addr;
    669              info.field.count = 4;
    670              local_irq_save(flags);
    671              REG32(SDIO_GEN3_CMD_SETUP) = info.word;
    672              /* 2. CMD53 write data  */
    673              REG32(SDIO_GEN3_CMD53_DATA) = b;
    674              local_irq_restore(flags);
    675          
    676          
    677          }
    678          
    679          /**
    680           *	connsys_bus_fn0_read_byte - read a single byte from SDIO function 0
    681           *	@func: an SDIO function of the card
    682           *	@addr: address to read
    683           *	@err_ret: optional status value from transfer
    684           *
    685           *	Reads a single byte from the address space of SDIO function 0.
    686           *	If there is a problem reading the address, 0xff is returned
    687           *	and @err_ret will contain the error code.
    688           */
    689          uint8_t connsys_bus_fn0_read_byte(struct connsys_func *func, uint32_t addr,
    690                                            int32_t *err_ret)
    691          {
    692              //int32_t ret;
    693              uint8_t val;
    694              connsys_gen3_cmd52_info info;
    695              info.word = 0;
    696              uint32_t flags;
    697              /* CMD52 read 1-byte of func0 */
    698          
    699              if (err_ret) {
    700                  *err_ret = 0;
    701              }
    702          
    703              /* 1. Setup command information */
    704              info.field.rw_flag = SDIO_GEN3_READ;
    705              info.field.func_num = 0; //func->num;
    706              info.field.addr = addr;
    707          
    708              local_irq_save(flags);
    709              REG32(SDIO_GEN3_CMD_SETUP) = info.word;
    710              /* 2. CMD52 read  data  */
    711              val = REG32(SDIO_GEN3_CMD52_DATA);
    712              local_irq_restore(flags);
    713              //ret = mmc_io_rw_direct(func->card, 0, 0, addr, 0, &val);
    714          
    715              return val;
    716          }
    717          
    718          /**
    719           *	connsys_bus_fn0_write_byte - write a single byte to SDIO function 0
    720           *	@func: an SDIO function of the card
    721           *	@b: byte to write
    722           *	@addr: address to write to
    723           *	@err_ret: optional status value from transfer
    724           *
    725           *	Writes a single byte to the address space of SDIO function 0.
    726           *	@err_ret will contain the status of the actual transfer.
    727           *
    728           *	Only writes to the vendor specific CCCR registers (0xF0 -
    729           *	0xFF) are permiited; @err_ret will be set to -EINVAL for *
    730           *	writes outside this range.
    731           */
    732          void connsys_bus_fn0_write_byte(struct connsys_func *func, uint8_t b, uint32_t addr,
    733                                          int32_t *err_ret)
    734          {
    735              //int32_t ret;
    736              connsys_gen3_cmd52_info info;
    737              info.word = 0;
    738              uint32_t flags;
    739              /* CMD52 write 1-byte of func0 */
    740          
    741              if (err_ret) {
    742                  *err_ret = 0;
    743              }
    744          
    745              /* 1. Setup command information */
    746              info.field.rw_flag = SDIO_GEN3_WRITE;
    747              info.field.func_num = 0; //func->num;
    748              info.field.addr = addr;
    749              info.field.data = b;
    750              LOG_I(connsys, "=== write f0, setup=0x%x\n", (unsigned int)info.word);
    751          
    752              local_irq_save(flags);
    753              REG32(SDIO_GEN3_CMD_SETUP) = info.word;
    754              /* 2. CMD52 write dummy 0 to trigger write  data  */
    755              REG32(SDIO_GEN3_CMD52_DATA) = b;
    756              local_irq_restore(flags);
    757          }
    758          
    759          
    760          /**
    761           *	connsys_bus_enable_func - enables a SDIO function for usage
    762           *	@func: SDIO function to enable
    763           *
    764           *	Powers up and activates a SDIO function so that register
    765           *	access is possible.
    766           */
    767          int32_t connsys_bus_enable_func(struct connsys_func *func)
    768          {
    769              int32_t ret;
    770              uint8_t reg;
    771          
    772              LOG_I(connsys, "SDIO: Enabling Function %d...\n", (int)func->num);
    773          
    774              reg = connsys_bus_fn0_read_byte(func, SDIO_CCCR_IOEx, &ret);
    775              if (ret) {
    776                  goto err;
    777              }
    778              LOG_I(connsys, "Origin Func enable=0x%x\n", reg);
    779              reg |= 1 << func->num;
    780          
    781              connsys_bus_fn0_write_byte(func, reg, SDIO_CCCR_IOEx, &ret);
    782              if (ret) {
    783                  goto err;
    784              }
    785          
    786              reg = connsys_bus_fn0_read_byte(func, SDIO_CCCR_IORx, &ret);
    787              if (ret) {
    788                  goto err;
    789              }
    790              LOG_I(connsys, "Read CCCR_IORx=0x%x\n", reg);
    791              if (!(reg & (1 << func->num))) {
    792                  ret = -ETIME;
    793                  goto err;
    794              }
    795              LOG_I(connsys, "SDIO: Enabled Function %d\n", (int)func->num);
    796          
    797              return 0;
    798          
    799          err:
    800              LOG_I(connsys, "SDIO: Failed to enable Function %d", (int)func->num);
    801              return ret;
    802          }
    803          /**
    804           *	connsys_bus_disable_func - disable a SDIO function
    805           *	@func: SDIO function to disable
    806           *
    807           *	Powers down and deactivates a SDIO function. Register access
    808           *	to this function will fail until the function is reenabled.
    809           */
    810          int32_t connsys_bus_disable_func(struct connsys_func *func)
    811          {
    812              int32_t ret;
    813              uint8_t reg;
    814          
    815              LOG_I(connsys, "SDIO: Disabling Function %d...", (int)func->num);
    816          
    817              reg = connsys_bus_fn0_read_byte(func, SDIO_CCCR_IOEx, &ret);
    818              if (ret) {
    819                  goto err;
    820              }
    821          
    822              reg &= ~(1 << func->num);
    823          
    824              connsys_bus_fn0_write_byte(func, reg, SDIO_CCCR_IOEx, &ret);
    825              if (ret) {
    826                  goto err;
    827              }
    828          
    829              LOG_I(connsys, "SDIO: Disabled Function %d", (int)func->num);
    830          
    831              return 0;
    832          
    833          err:
    834              ret = -EIO;
    835              LOG_I(connsys, "SDIO: Failed to Disable Function %d", (int)func->num);
    836              return ret;
    837          
    838          }
    839          
    840          /**
    841           *	connsys_bus_set_block_size - set the block size of an SDIO function
    842           *	@func: SDIO function to change
    843           *	@blksz: new block size or 0 to use the default.
    844           *
    845           *	The default block size is the largest supported by both the function
    846           *	and the host, with a maximum of 512 to ensure that arbitrarily sized
    847           *	data transfer use the optimal (least) number of commands.
    848           *
    849           *	A driver may call this to override the default block size set by the
    850           *	core. This can be used to set a block size greater than the maximum
    851           *	that reported by the card; it is the driver's responsibility to ensure
    852           *	it uses a value that the card supports.
    853           *
    854           *	Returns 0 on success, -EINVAL if the host does not support the
    855           *	requested block size, or -EIO (etc.) if one of the resultant FBR block
    856           *	size register writes failed.
    857           *
    858           */
    859          int32_t connsys_bus_set_block_size(struct connsys_func *func, uint32_t blksz)
    860          {
    861              int32_t ret;
    862          
    863              //ret = mmc_io_rw_direct(func->card, 1, 0,
    864              //	SDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE,
    865              //	blksz & 0xff, NULL);
    866          
    867              connsys_bus_fn0_write_byte(func, (blksz & 0xff),
    868                                         SDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE, &ret);
    869          
    870              if (ret) {
    871                  return ret;
    872              }
    873          
    874              connsys_bus_fn0_write_byte(func, ((blksz >> 8) & 0xff),
    875                                         SDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE + 1, &ret);
    876          
    877              if (ret) {
    878                  return ret;
    879              }
    880              func->blksize = blksz;
    881              return 0;
    882          }
    883          
    884          /**
    885           *	connsys_claim_irq - claim the IRQ for a SDIO function
    886           *	@func: SDIO function
    887           *	@handler: IRQ handler callback
    888           *
    889           *	Claim and activate the IRQ for the given SDIO function. The provided
    890           *	handler will be called when that IRQ is asserted.  The host is always
    891           *	claimed already when the handler is called so the handler must not
    892           *	call connsys_claim_host() nor connsys_release_host().
    893           */
    894          int32_t connsys_bus_get_irq(struct connsys_func *func, connsys_irq_handler_t handler)
    895          {
    896              int32_t ret;
    897              uint8_t reg = 0;
    898          
    899              LOG_I(connsys, "SDIO: Enabling IRQ for func%d...\n", (int)func->num);
    900          
    901              if (func->irq_callback) {
    902                  LOG_E(connsys, "SDIO: IRQ for func%d already in use.\n", (int)func->num);
    903                  return -2; //-EBUSY;
    904              }
    905          
    906              reg = connsys_bus_fn0_read_byte(func, SDIO_CCCR_IENx, &ret);
    907              if (ret) {
    908                  return ret;
    909              }
    910          
    911              reg |= 1 << func->num;
    912          
    913              reg |= 1; /* Master interrupt enable */
    914              LOG_I(connsys, "Write IENx=0x%x\n", reg);
    915              connsys_bus_fn0_write_byte(func, reg, SDIO_CCCR_IENx, &ret);
    916              if (ret) {
    917                  return ret;
    918              }
    919          
    920              func->irq_callback = handler;
    921          
    922              reg = connsys_bus_fn0_read_byte(func, SDIO_CCCR_IENx, &ret);
    923              if (ret) {
    924                  return ret;
    925              }
    926              LOG_I(connsys, "===> IENx=0x%x\n", reg);
    927              return ret;
    928          }
    929          
    930          /**
    931           *	connsys_bus_release_irq - release the IRQ for a SDIO function
    932           *	@func: SDIO function
    933           *
    934           *	Disable and release the IRQ for the given SDIO function.
    935           */
    936          int32_t connsys_bus_release_irq(struct connsys_func *func)
    937          {
    938              int32_t ret;
    939              uint8_t reg = 0;
    940          
    941              LOG_I(connsys, "SDIO: Disabling IRQ for func%d...", (int)func->num);
    942          
    943              if (func->irq_callback) {
    944                  func->irq_callback = NULL;
    945              }
    946          
    947              connsys_bus_fn0_read_byte(func, SDIO_CCCR_IENx, &ret);
    948              if (ret) {
    949                  return ret;
    950              }
    951          
    952              reg &= ~(1 << func->num);
    953          
    954              /* Disable master interrupt with the last function interrupt */
    955              if (!(reg & 0xFE)) {
    956                  reg = 0;
    957              }
    958          
    959              connsys_bus_fn0_write_byte(func, reg, SDIO_CCCR_IENx, &ret);
    960              if (ret) {
    961                  return ret;
    962              }
    963          
    964              return 0;
    965          }
    966          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   connsys_bus_disable_func
        32   -- Indirect call
        32   -> connsys_bus_fn0_read_byte
        32   -> connsys_bus_fn0_write_byte
      40   connsys_bus_enable_func
        40   -- Indirect call
        40   -> connsys_bus_fn0_read_byte
        40   -> connsys_bus_fn0_write_byte
       0   connsys_bus_fn0_read_byte
      24   connsys_bus_fn0_write_byte
        24   -- Indirect call
       0   connsys_bus_get_bus
      40   connsys_bus_get_irq
        40   -- Indirect call
        40   -> connsys_bus_fn0_read_byte
        40   -> connsys_bus_fn0_write_byte
      32   connsys_bus_read_port
        32   -- Indirect call
        32   -> connsys_bus_read_port_dma
        32   -> connsys_bus_read_port_garbage
        32   -> connsys_bus_read_port_pio
       4   connsys_bus_read_port_dma
      16   connsys_bus_read_port_garbage
        16   -> connsys_bus_read_port_pio_garbage
      12   connsys_bus_read_port_pio
       0   connsys_bus_read_port_pio_garbage
       0   connsys_bus_readl
       0   connsys_bus_release_bus
      24   connsys_bus_release_irq
        24   -- Indirect call
        24   -> connsys_bus_fn0_read_byte
        24   -> connsys_bus_fn0_write_byte
      16   connsys_bus_set_block_size
        16   -> connsys_bus_fn0_write_byte
      40   connsys_bus_write_port
        40   -- Indirect call
        40   -> connsys_bus_write_port_dma
        40   -> connsys_bus_write_port_pio
        40   -> printf
       4   connsys_bus_write_port_dma
      16   connsys_bus_write_port_pio
        16   -> connsys_dump_cmd53_info
        16   -> printf
       8   connsys_bus_write_port_transfer
         0   -> connsys_bus_write_port_dma
         0   -> connsys_bus_write_port_pio
       4   connsys_bus_writel
      32   connsys_dump_cmd53_info
        32   -- Indirect call
      48   connsys_dump_tx_scatter_info
        48   -- Indirect call
      80   connsys_write_data
        80   -- Indirect call
        80   -> __aeabi_memcpy
        80   -> connsys_dump_cmd53_info
        80   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable56
       4  ??DataTable61
       4  ??DataTable61_1
       4  ??DataTable61_2
       4  ??DataTable61_3
       4  ??DataTable61_4
       4  ??DataTable61_5
       4  ??DataTable61_6
       4  ??DataTable61_7
       8  ?_0
      52  ?_1
      64  ?_10
      48  ?_11
      24  ?_12
       4  ?_13
      88  ?_14
       8  ?_15
       8  ?_16
      24  ?_17
     136  ?_18
      28  ?_19
      12  ?_2
      32  ?_20
      28  ?_21
      24  ?_22
      28  ?_23
      36  ?_24
      32  ?_25
      28  ?_26
      36  ?_27
      36  ?_28
      40  ?_29
      24  ?_3
      20  ?_30
      16  ?_31
      36  ?_32
      24  ?_4
      16  ?_5
      20  ?_6
      24  ?_7
      16  ?_8
      56  ?_9
     138  connsys_bus_disable_func
     230  connsys_bus_enable_func
      34  connsys_bus_fn0_read_byte
      68  connsys_bus_fn0_write_byte
       2  connsys_bus_get_bus
     210  connsys_bus_get_irq
     212  connsys_bus_read_port
     104  connsys_bus_read_port_dma
     120  connsys_bus_read_port_garbage
      68  connsys_bus_read_port_pio
      36  connsys_bus_read_port_pio_garbage
      48  connsys_bus_readl
       2  connsys_bus_release_bus
      78  connsys_bus_release_irq
      62  connsys_bus_set_block_size
     246  connsys_bus_write_port
      96  connsys_bus_write_port_dma
     100  connsys_bus_write_port_pio
      26  connsys_bus_write_port_transfer
      56  connsys_bus_writel
     206  connsys_dump_cmd53_info
     174  connsys_dump_tx_scatter_info
     590  connsys_write_data
      16  log_control_block_connsys
     248  -- Other

 
    16 bytes in section .data
    12 bytes in section .rodata
 4 254 bytes in section .text
 
 4 254 bytes of CODE  memory
    12 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: none
