###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       25/Jan/2017  17:35:20
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\net.c
#    Command line =  
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\net.c" -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_WIFI_TGN_VERIFY_ENABLE -D MTK_SMTCN_ENABLE -D
#        MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D SUPPORT_MBEDTLS -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-basic.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D MTK_MCS_ENABLE -D MTK_BLE_GPIO_SERVICE -D
#        __BT_DEBUG__ -lcN "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List" -lA
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List"
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj" --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\inc\" -I
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\service\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\dhcpd\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\src\ut_app\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\httpclient\inc\"
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List\net.lst
#    Object file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj\net.o
#
###############################################################################

C:\LEO\myGit\MTK IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\net.c
      1          /*
      2           *  TCP/IP or UDP/IP networking functions
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          
     22          #if !defined(MBEDTLS_CONFIG_FILE)
     23          #include "mbedtls/config.h"
     24          #else
     25          #include MBEDTLS_CONFIG_FILE
     26          #endif
     27          
     28          #if defined(MBEDTLS_NET_C)
     29          
     30          #include "mbedtls/net.h"
     31          
     32          #include <string.h>
     33          
     34          #if (defined(_WIN32) || defined(_WIN32_WCE)) && !defined(EFIX64) && \
     35              !defined(EFI32)
     36          
     37          #ifdef _WIN32_WINNT
     38          #undef _WIN32_WINNT
     39          #endif
     40          /* Enables getaddrinfo() & Co */
     41          #define _WIN32_WINNT 0x0501
     42          #include <ws2tcpip.h>
     43          
     44          #include <winsock2.h>
     45          #include <windows.h>
     46          
     47          #if defined(_MSC_VER)
     48          #if defined(_WIN32_WCE)
     49          #pragma comment( lib, "ws2.lib" )
     50          #else
     51          #pragma comment( lib, "ws2_32.lib" )
     52          #endif
     53          #endif /* _MSC_VER */
     54          
     55          #define read(fd,buf,len)        recv(fd,(char*)buf,(int) len,0)
     56          #define write(fd,buf,len)       send(fd,(char*)buf,(int) len,0)
     57          #define close(fd)               closesocket(fd)
     58          
     59          static int wsa_init_done = 0;
     60          
     61          #else /* ( _WIN32 || _WIN32_WCE ) && !EFIX64 && !EFI32 */
     62          
     63          //#include <sys/types.h>
     64          #ifdef SUPPORT_MBEDTLS   //MT7687 mbedTLS enable
     65          #include <sockets.h>
     66          #include <sockets_mbedtls.h>
     67          #include <inet.h>
     68          #else
     69          #include <sys/socket.h>
     70          #include <netinet/in.h>
     71          #include <arpa/inet.h>
     72          #include <sys/time.h>
     73          #endif /* SUPPORT_MBEDTLS */
     74          
     75          //#include <unistd.h>
     76          #include <signal.h>
     77          //#include <fcntl.h>
     78          #include <netdb.h>
     79          #include <errno.h>
     80          
     81          #endif /* ( _WIN32 || _WIN32_WCE ) && !EFIX64 && !EFI32 */
     82          
     83          /* Some MS functions want int and MSVC warns if we pass size_t,
     84           * but the standard fucntions use socklen_t, so cast only for MSVC */
     85          #if defined(_MSC_VER)
     86          #define MSVC_INT_CAST   (int)
     87          #else
     88          #define MSVC_INT_CAST
     89          #endif
     90          
     91          #include <stdlib.h>
     92          #include <stdio.h>
     93          
     94          #include <time.h>
     95          
     96          #include <stdint.h>
     97          
     98          /*
     99           * Prepare for using the sockets interface
    100           */
    101          static int net_prepare( void )
    102          {
    103          #if ( defined(_WIN32) || defined(_WIN32_WCE) ) && !defined(EFIX64) && \
    104              !defined(EFI32)
    105              WSADATA wsaData;
    106          
    107              if( wsa_init_done == 0 )
    108              {
    109                  if( WSAStartup( MAKEWORD(2,0), &wsaData ) != 0 )
    110                      return( MBEDTLS_ERR_NET_SOCKET_FAILED );
    111          
    112                  wsa_init_done = 1;
    113              }
    114          #else
    115          #if !defined(EFIX64) && !defined(EFI32)
    116              //signal( SIGPIPE, SIG_IGN );
    117          #endif
    118          #endif
    119              return( 0 );
    120          }
    121          
    122          /*
    123           * Initialize a context
    124           */
    125          void mbedtls_net_init( mbedtls_net_context *ctx )
    126          {
    127              ctx->fd = -1;
    128          }
    129          
    130          /*
    131           * Initiate a TCP connection with host:port and the given protocol
    132           */
    133          int mbedtls_net_connect( mbedtls_net_context *ctx, const char *host, const char *port, int proto )
    134          {
    135              int ret;
    136              struct addrinfo hints, *addr_list, *cur;
    137          
    138              if( ( ret = net_prepare() ) != 0 )
    139                  return( ret );
    140          
    141              /* Do name resolution with both IPv6 and IPv4 */
    142              memset( &hints, 0, sizeof( hints ) );
    143              hints.ai_family = AF_UNSPEC;
    144              hints.ai_socktype = proto == MBEDTLS_NET_PROTO_UDP ? SOCK_DGRAM : SOCK_STREAM;
    145              hints.ai_protocol = proto == MBEDTLS_NET_PROTO_UDP ? IPPROTO_UDP : IPPROTO_TCP;
    146          
    147              if( getaddrinfo( host, port, &hints, &addr_list ) != 0 )
    148                  return( MBEDTLS_ERR_NET_UNKNOWN_HOST );
    149          
    150              /* Try the sockaddrs until a connection succeeds */
    151              ret = MBEDTLS_ERR_NET_UNKNOWN_HOST;
    152              for( cur = addr_list; cur != NULL; cur = cur->ai_next )
    153              {
    154                  ctx->fd = (int) socket( cur->ai_family, cur->ai_socktype,
    155                                      cur->ai_protocol );
    156                  if( ctx->fd < 0 )
    157                  {
    158                      ret = MBEDTLS_ERR_NET_SOCKET_FAILED;
    159                      continue;
    160                  }
    161          
    162                  if( connect( ctx->fd, cur->ai_addr, MSVC_INT_CAST cur->ai_addrlen ) == 0 )
    163                  {
    164                      ret = 0;
    165                      break;
    166                  }
    167          
    168                  close( ctx->fd );
    169                  ret = MBEDTLS_ERR_NET_CONNECT_FAILED;
    170              }
    171          
    172              freeaddrinfo( addr_list );
    173          
    174              return( ret );
    175          }
    176          
    177          /*
    178           * Create a listening socket on bind_ip:port
    179           */
    180          int mbedtls_net_bind( mbedtls_net_context *ctx, const char *bind_ip, const char *port, int proto )
    181          {
    182              int n, ret;
    183              struct addrinfo hints, *addr_list, *cur;
    184          
    185              if( ( ret = net_prepare() ) != 0 )
    186                  return( ret );
    187          
    188              /* Bind to IPv6 and/or IPv4, but only in the desired protocol */
    189              memset( &hints, 0, sizeof( hints ) );
    190              hints.ai_family = AF_UNSPEC;
    191              hints.ai_socktype = proto == MBEDTLS_NET_PROTO_UDP ? SOCK_DGRAM : SOCK_STREAM;
    192              hints.ai_protocol = proto == MBEDTLS_NET_PROTO_UDP ? IPPROTO_UDP : IPPROTO_TCP;
    193              if( bind_ip == NULL )
    194                  hints.ai_flags = AI_PASSIVE;
    195          
    196              if( getaddrinfo( bind_ip, port, &hints, &addr_list ) != 0 )
    197                  return( MBEDTLS_ERR_NET_UNKNOWN_HOST );
    198          
    199              /* Try the sockaddrs until a binding succeeds */
    200              ret = MBEDTLS_ERR_NET_UNKNOWN_HOST;
    201              for( cur = addr_list; cur != NULL; cur = cur->ai_next )
    202              {
    203                  ctx->fd = (int) socket( cur->ai_family, cur->ai_socktype,
    204                                      cur->ai_protocol );
    205                  if( ctx->fd < 0 )
    206                  {
    207                      ret = MBEDTLS_ERR_NET_SOCKET_FAILED;
    208                      continue;
    209                  }
    210          
    211                  n = 1;
    212                  if( setsockopt( ctx->fd, SOL_SOCKET, SO_REUSEADDR,
    213                                  (const char *) &n, sizeof( n ) ) != 0 )
    214                  {
    215                      close( ctx->fd );
    216                      ret = MBEDTLS_ERR_NET_SOCKET_FAILED;
    217                      continue;
    218                  }
    219          
    220                  if( bind( ctx->fd, cur->ai_addr, MSVC_INT_CAST cur->ai_addrlen ) != 0 )
    221                  {
    222                      close( ctx->fd );
    223                      ret = MBEDTLS_ERR_NET_BIND_FAILED;
    224                      continue;
    225                  }
    226          
    227                  /* Listen only makes sense for TCP */
    228                  if( proto == MBEDTLS_NET_PROTO_TCP )
    229                  {
    230                      if( listen( ctx->fd, MBEDTLS_NET_LISTEN_BACKLOG ) != 0 )
    231                      {
    232                          close( ctx->fd );
    233                          ret = MBEDTLS_ERR_NET_LISTEN_FAILED;
    234                          continue;
    235                      }
    236                  }
    237          
    238                  /* I we ever get there, it's a success */
    239                  ret = 0;
    240                  break;
    241              }
    242          
    243              freeaddrinfo( addr_list );
    244          
    245              return( ret );
    246          
    247          }
    248          
    249          #if ( defined(_WIN32) || defined(_WIN32_WCE) ) && !defined(EFIX64) && \
    250              !defined(EFI32)
    251          /*
    252           * Check if the requested operation would be blocking on a non-blocking socket
    253           * and thus 'failed' with a negative return value.
    254           */
    255          static int net_would_block( const mbedtls_net_context *ctx )
    256          {
    257              ((void) ctx);
    258              return( WSAGetLastError() == WSAEWOULDBLOCK );
    259          }
    260          #else
    261          /*
    262           * Check if the requested operation would be blocking on a non-blocking socket
    263           * and thus 'failed' with a negative return value.
    264           *
    265           * Note: on a blocking socket this function always returns 0!
    266           */
    267          static int net_would_block( const mbedtls_net_context *ctx )
    268          {
    269              /*
    270               * Never return 'WOULD BLOCK' on a non-blocking socket
    271               */
    272              if( ( fcntl( ctx->fd, F_GETFL, 0 ) & O_NONBLOCK ) != O_NONBLOCK )
    273                  return( 0 );
    274          
    275              switch( errno )
    276              {
    277          #if defined EAGAIN
    278                  case EAGAIN:
    279          #endif
    280          #if defined EWOULDBLOCK && EWOULDBLOCK != EAGAIN
    281                  case EWOULDBLOCK:
    282          #endif
    283                      return( 1 );
    284              }
    285              return( 0 );
    286          }
    287          #endif /* ( _WIN32 || _WIN32_WCE ) && !EFIX64 && !EFI32 */
    288          
    289          /*
    290           * Accept a connection from a remote client
    291           */
    292          int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
    293                                  mbedtls_net_context *client_ctx,
    294                                  void *client_ip, size_t buf_size, size_t *ip_len )
    295          {
    296              int ret;
    297              int type;
    298          
    299              struct sockaddr_storage client_addr;
    300          
    301          #if defined(__socklen_t_defined) || defined(_SOCKLEN_T) ||  \
    302              defined(_SOCKLEN_T_DECLARED)
    303              socklen_t n = (socklen_t) sizeof( client_addr );
    304              socklen_t type_len = (socklen_t) sizeof( type );
    305          #else
    306              int n = (int) sizeof( client_addr );
    307              int type_len = (int) sizeof( type );
    308          #endif
    309          
    310              /* Is this a TCP or UDP socket? */
    311              if( getsockopt( bind_ctx->fd, SOL_SOCKET, SO_TYPE,
    312                              (void *) &type, &type_len ) != 0 ||
    313                  ( type != SOCK_STREAM && type != SOCK_DGRAM ) )
    314              {
    315                  return( MBEDTLS_ERR_NET_ACCEPT_FAILED );
    316              }
    317          
    318              if( type == SOCK_STREAM )
    319              {
    320                  /* TCP: actual accept() */
    321                  ret = client_ctx->fd = (int) accept( bind_ctx->fd,
    322                                                   (struct sockaddr *) &client_addr, &n );
    323              }
    324              else
    325              {
    326                  /* UDP: wait for a message, but keep it in the queue */
    327                  char buf[1] = { 0 };
    328          
    329                  ret = recvfrom( bind_ctx->fd, buf, sizeof( buf ), MSG_PEEK,
    330                                  (struct sockaddr *) &client_addr, &n );
    331          
    332          #if defined(_WIN32)
    333                  if( ret == SOCKET_ERROR &&
    334                      WSAGetLastError() == WSAEMSGSIZE )
    335                  {
    336                      /* We know buf is too small, thanks, just peeking here */
    337                      ret = 0;
    338                  }
    339          #endif
    340              }
    341          
    342              if( ret < 0 )
    343              {
    344                  if( net_would_block( bind_ctx ) != 0 )
    345                      return( MBEDTLS_ERR_SSL_WANT_READ );
    346          
    347                  return( MBEDTLS_ERR_NET_ACCEPT_FAILED );
    348              }
    349          
    350              /* UDP: hijack the listening socket to communicate with the client,
    351               * then bind a new socket to accept new connections */
    352              if( type != SOCK_STREAM )
    353              {
    354                  struct sockaddr_storage local_addr;
    355                  int one = 1;
    356          
    357                  if( connect( bind_ctx->fd, (struct sockaddr *) &client_addr, n ) != 0 )
    358                      return( MBEDTLS_ERR_NET_ACCEPT_FAILED );
    359          
    360                  client_ctx->fd = bind_ctx->fd;
    361                  bind_ctx->fd   = -1; /* In case we exit early */
    362          
    363                  n = sizeof( struct sockaddr_storage );
    364                  if( getsockname( client_ctx->fd,
    365                                   (struct sockaddr *) &local_addr, &n ) != 0 ||
    366                      ( bind_ctx->fd = (int) socket( local_addr.ss_family,
    367                                                     SOCK_DGRAM, IPPROTO_UDP ) ) < 0 ||
    368                      setsockopt( bind_ctx->fd, SOL_SOCKET, SO_REUSEADDR,
    369                                  (const char *) &one, sizeof( one ) ) != 0 )
    370                  {
    371                      return( MBEDTLS_ERR_NET_SOCKET_FAILED );
    372                  }
    373          
    374                  if( bind( bind_ctx->fd, (struct sockaddr *) &local_addr, n ) != 0 )
    375                  {
    376                      return( MBEDTLS_ERR_NET_BIND_FAILED );
    377                  }
    378              }
    379          
    380              if( client_ip != NULL )
    381              {
    382                  if( client_addr.ss_family == AF_INET )
    383                  {
    384                      struct sockaddr_in *addr4 = (struct sockaddr_in *) &client_addr;
    385                      *ip_len = sizeof( addr4->sin_addr.s_addr );
    386          
    387                      if( buf_size < *ip_len )
    388                          return( MBEDTLS_ERR_NET_BUFFER_TOO_SMALL );
    389          
    390                      memcpy( client_ip, &addr4->sin_addr.s_addr, *ip_len );
    391                  }
    392                  else
    393                  {
    394          #if LWIP_IPV6
    395                      struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *) &client_addr;
    396                      *ip_len = sizeof( addr6->sin6_addr.s6_addr );
    397          
    398                      if( buf_size < *ip_len )
    399                          return( MBEDTLS_ERR_NET_BUFFER_TOO_SMALL );
    400          
    401                      memcpy( client_ip, &addr6->sin6_addr.s6_addr, *ip_len);
    402          #endif
    403                  }
    404              }
    405          
    406              return( 0 );
    407          }
    408          
    409          /*
    410           * Set the socket blocking or non-blocking
    411           */
    412          int mbedtls_net_set_block( mbedtls_net_context *ctx )
    413          {
    414          #if ( defined(_WIN32) || defined(_WIN32_WCE) ) && !defined(EFIX64) && \
    415              !defined(EFI32)
    416              u_long n = 0;
    417              return( ioctlsocket( ctx->fd, FIONBIO, &n ) );
    418          #else
    419              return( fcntl( ctx->fd, F_SETFL, fcntl( ctx->fd, F_GETFL, 0 ) & ~O_NONBLOCK ) );
    420          #endif
    421          }
    422          
    423          int mbedtls_net_set_nonblock( mbedtls_net_context *ctx )
    424          {
    425          #if ( defined(_WIN32) || defined(_WIN32_WCE) ) && !defined(EFIX64) && \
    426              !defined(EFI32)
    427              u_long n = 1;
    428              return( ioctlsocket( ctx->fd, FIONBIO, &n ) );
    429          #else
    430              return( fcntl( ctx->fd, F_SETFL, fcntl( ctx->fd, F_GETFL, 0 ) | O_NONBLOCK ) );
    431          #endif
    432          }
    433          
    434          /*
    435           * Portable usleep helper
    436           */
    437          void mbedtls_net_usleep( unsigned long usec )
    438          {
    439          #if defined(_WIN32)
    440              Sleep( ( usec + 999 ) / 1000 );
    441          #else
    442              struct timeval tv;
    443              tv.tv_sec  = usec / 1000000;
    444          #if defined(__unix__) || defined(__unix) || \
    445              ( defined(__APPLE__) && defined(__MACH__) )
    446              tv.tv_usec = (suseconds_t) usec % 1000000;
    447          #else
    448              tv.tv_usec = usec % 1000000;
    449          #endif
    450              select( 0, NULL, NULL, NULL, &tv );
    451          #endif
    452          }
    453          
    454          /*
    455           * Read at most 'len' characters
    456           */
    457          int mbedtls_net_recv( void *ctx, unsigned char *buf, size_t len )
    458          {
    459              int ret;
    460              int fd = ((mbedtls_net_context *) ctx)->fd;
    461          
    462              if( fd < 0 )
    463                  return( MBEDTLS_ERR_NET_INVALID_CONTEXT );
    464          
    465              ret = (int) read( fd, buf, len );
    466          
    467              if( ret < 0 )
    468              {
    469                  if( net_would_block( ctx ) != 0 )
    470                      return( MBEDTLS_ERR_SSL_WANT_READ );
    471          
    472          #if ( defined(_WIN32) || defined(_WIN32_WCE) ) && !defined(EFIX64) && \
    473              !defined(EFI32)
    474                  if( WSAGetLastError() == WSAECONNRESET )
    475                      return( MBEDTLS_ERR_NET_CONN_RESET );
    476          #else
    477                  if( errno == EPIPE || errno == ECONNRESET )
    478                      return( MBEDTLS_ERR_NET_CONN_RESET );
    479          
    480                  if( errno == EINTR )
    481                      return( MBEDTLS_ERR_SSL_WANT_READ );
    482          #endif
    483          
    484                  return( MBEDTLS_ERR_NET_RECV_FAILED );
    485              }
    486          
    487              return( ret );
    488          }
    489          
    490          /*
    491           * Read at most 'len' characters, blocking for at most 'timeout' ms
    492           */
    493          int mbedtls_net_recv_timeout( void *ctx, unsigned char *buf, size_t len,
    494                                uint32_t timeout )
    495          {
    496              int ret;
    497              struct timeval tv;
    498              fd_set read_fds;
    499              int fd = ((mbedtls_net_context *) ctx)->fd;
    500          
    501              if( fd < 0 )
    502                  return( MBEDTLS_ERR_NET_INVALID_CONTEXT );
    503          
    504              FD_ZERO( &read_fds );
    505              FD_SET( fd, &read_fds );
    506          
    507              tv.tv_sec  = timeout / 1000;
    508              tv.tv_usec = ( timeout % 1000 ) * 1000;
    509          
    510              ret = select( fd + 1, &read_fds, NULL, NULL, timeout == 0 ? NULL : &tv );
    511          
    512              /* Zero fds ready means we timed out */
    513              if( ret == 0 )
    514                  return( MBEDTLS_ERR_SSL_TIMEOUT );
    515          
    516              if( ret < 0 )
    517              {
    518          #if ( defined(_WIN32) || defined(_WIN32_WCE) ) && !defined(EFIX64) && \
    519              !defined(EFI32)
    520                  if( WSAGetLastError() == WSAEINTR )
    521                      return( MBEDTLS_ERR_SSL_WANT_READ );
    522          #else
    523                  if( errno == EINTR )
    524                      return( MBEDTLS_ERR_SSL_WANT_READ );
    525          #endif
    526          
    527                  return( MBEDTLS_ERR_NET_RECV_FAILED );
    528              }
    529          
    530              /* This call will not block */
    531              return( mbedtls_net_recv( ctx, buf, len ) );
    532          }
    533          
    534          /*
    535           * Write at most 'len' characters
    536           */
    537          int mbedtls_net_send( void *ctx, const unsigned char *buf, size_t len )
    538          {
    539              int ret;
    540              int fd = ((mbedtls_net_context *) ctx)->fd;
    541          
    542              if( fd < 0 )
    543                  return( MBEDTLS_ERR_NET_INVALID_CONTEXT );
    544          
    545              ret = (int) write( fd, buf, len );
    546          
    547              if( ret < 0 )
    548              {
    549                  if( net_would_block( ctx ) != 0 )
    550                      return( MBEDTLS_ERR_SSL_WANT_WRITE );
    551          
    552          #if ( defined(_WIN32) || defined(_WIN32_WCE) ) && !defined(EFIX64) && \
    553              !defined(EFI32)
    554                  if( WSAGetLastError() == WSAECONNRESET )
    555                      return( MBEDTLS_ERR_NET_CONN_RESET );
    556          #else
    557                  if( errno == EPIPE || errno == ECONNRESET )
    558                      return( MBEDTLS_ERR_NET_CONN_RESET );
    559          
    560                  if( errno == EINTR )
    561                      return( MBEDTLS_ERR_SSL_WANT_WRITE );
    562          #endif
    563          
    564                  return( MBEDTLS_ERR_NET_SEND_FAILED );
    565              }
    566          
    567              return( ret );
    568          }
    569          
    570          /*
    571           * Gracefully close the connection
    572           */
    573          void mbedtls_net_free( mbedtls_net_context *ctx )
    574          {
    575              if( ctx->fd == -1 )
    576                  return;
    577          
    578              shutdown( ctx->fd, 2 );
    579              close( ctx->fd );
    580          
    581              ctx->fd = -1;
    582          }
    583          
    584          #endif /* MBEDTLS_NET_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      80   mbedtls_net_accept
        80   -> __aeabi_memcpy
        80   -> lwip_accept
        80   -> lwip_bind
        80   -> lwip_connect
        80   -> lwip_getsockname
        80   -> lwip_getsockopt
        80   -> lwip_recvfrom
        80   -> lwip_setsockopt
        80   -> lwip_socket
        80   -> net_would_block
      72   mbedtls_net_bind
        72   -> __aeabi_memset4
        72   -> lwip_bind
        72   -> lwip_close
        72   -> lwip_freeaddrinfo
        72   -> lwip_getaddrinfo
        72   -> lwip_listen
        72   -> lwip_setsockopt
        72   -> lwip_socket
        72   -> net_prepare
      64   mbedtls_net_connect
        64   -> __aeabi_memset4
        64   -> lwip_close
        64   -> lwip_connect
        64   -> lwip_freeaddrinfo
        64   -> lwip_getaddrinfo
        64   -> lwip_socket
        64   -> net_prepare
       8   mbedtls_net_free
         8   -> lwip_close
         8   -> lwip_shutdown
       0   mbedtls_net_init
       8   mbedtls_net_recv
         8   -> __aeabi_errno_addr
         8   -> lwip_read
         8   -> net_would_block
      40   mbedtls_net_recv_timeout
        40   -> __aeabi_errno_addr
        40   -> __aeabi_memset4
        40   -> lwip_select
        40   -> mbedtls_net_recv
       8   mbedtls_net_send
         8   -> __aeabi_errno_addr
         8   -> lwip_write
         8   -> net_would_block
       8   mbedtls_net_set_block
         0   -> lwip_fcntl
         8   -> lwip_fcntl
       8   mbedtls_net_set_nonblock
         0   -> lwip_fcntl
         8   -> lwip_fcntl
      16   mbedtls_net_usleep
        16   -> lwip_select
       0   net_prepare
       8   net_would_block
         8   -> __aeabi_errno_addr
         8   -> lwip_fcntl


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       1  ?_0
     298  mbedtls_net_accept
     236  mbedtls_net_bind
     160  mbedtls_net_connect
      32  mbedtls_net_free
       8  mbedtls_net_init
      84  mbedtls_net_recv
     166  mbedtls_net_recv_timeout
      84  mbedtls_net_send
      30  mbedtls_net_set_block
      30  mbedtls_net_set_nonblock
      36  mbedtls_net_usleep
       4  net_prepare
      38  net_would_block

 
     1 byte  in section .rodata
 1 222 bytes in section .text
 
 1 222 bytes of CODE  memory
     1 byte  of CONST memory

Errors: none
Warnings: 2
