###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       25/Jan/2017  17:34:45
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\bignum.c
#    Command line =  
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\bignum.c" -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_WIFI_TGN_VERIFY_ENABLE -D MTK_SMTCN_ENABLE -D
#        MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D SUPPORT_MBEDTLS -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-basic.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D MTK_MCS_ENABLE -D MTK_BLE_GPIO_SERVICE -D
#        __BT_DEBUG__ -lcN "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List" -lA
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List"
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj" --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\inc\" -I
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\service\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\dhcpd\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\src\ut_app\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\httpclient\inc\"
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List\bignum.lst
#    Object file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj\bignum.o
#
###############################################################################

C:\LEO\myGit\MTK IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\bignum.c
      1          /*
      2           *  Multi-precision integer library
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          /*
     22           *  This MPI implementation is based on:
     23           *
     24           *  http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf
     25           *  http://www.stillhq.com/extracted/gnupg-api/mbedtls_mpi/
     26           *  http://math.libtomcrypt.com/files/tommath.pdf
     27           */
     28          
     29          #if !defined(MBEDTLS_CONFIG_FILE)
     30          #include "mbedtls/config.h"
     31          #else
     32          #include MBEDTLS_CONFIG_FILE
     33          #endif
     34          
     35          #if defined(MBEDTLS_BIGNUM_C)
     36          
     37          #include "mbedtls/bignum.h"
     38          #include "mbedtls/bn_mul.h"
     39          
     40          #include <string.h>
     41          
     42          #if defined(MBEDTLS_PLATFORM_C)
     43          #include "mbedtls/platform.h"
     44          #else
     45          #include <stdio.h>
     46          #include <stdlib.h>
     47          #define mbedtls_printf     printf
     48          #define mbedtls_calloc    calloc
     49          #define mbedtls_free       free
     50          #endif
     51          
     52          /* Implementation that should never be optimized out by the compiler */
     53          static void mbedtls_zeroize( void *v, size_t n ) {
     54              volatile unsigned char *p = v; while( n-- ) *p++ = 0;
     55          }
     56          
     57          #define ciL    (sizeof(mbedtls_mpi_uint))         /* chars in limb  */
     58          #define biL    (ciL << 3)               /* bits  in limb  */
     59          #define biH    (ciL << 2)               /* half limb size */
     60          
     61          /*
     62           * Convert between bits/chars and number of limbs
     63           */
     64          #define BITS_TO_LIMBS(i)  (((i) + biL - 1) / biL)
     65          #define CHARS_TO_LIMBS(i) (((i) + ciL - 1) / ciL)
     66          
     67          /*
     68           * Initialize one MPI
     69           */
     70          void mbedtls_mpi_init( mbedtls_mpi *X )
     71          {
     72              if( X == NULL )
     73                  return;
     74          
     75              X->s = 1;
     76              X->n = 0;
     77              X->p = NULL;
     78          #ifdef MBEDTLS_MTK
     79              mbedtls_zeroize( X->limbs, MBEDTLS_MPI_MAX_STACK_LIMBS * ciL);
     80          #endif /* MBEDTLS_MTK */
     81          }
     82          
     83          /*
     84           * Unallocate one MPI
     85           */
     86          void mbedtls_mpi_free( mbedtls_mpi *X )
     87          {
     88              if( X == NULL )
     89                  return;
     90          
     91              if( X->p != NULL )
     92              {
     93                  mbedtls_zeroize( X->p, X->n * ciL );
     94          #ifdef MBEDTLS_MTK
     95                  if( X->n > MBEDTLS_MPI_MAX_STACK_LIMBS )
     96          #endif /* MBEDTLS_MTK */
     97                      mbedtls_free( X->p );
     98              }
     99          
    100              X->s = 1;
    101              X->n = 0;
    102              X->p = NULL;
    103          }
    104          
    105          /*
    106           * Enlarge to the specified number of limbs
    107           */
    108          int mbedtls_mpi_grow( mbedtls_mpi *X, size_t nblimbs )
    109          {
    110              mbedtls_mpi_uint *p;
    111          
    112              if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
    113                  return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
    114          
    115              if( X->n < nblimbs )
    116              {
    117          #ifdef MBEDTLS_MTK 
    118                 if(nblimbs <= MBEDTLS_MPI_MAX_STACK_LIMBS)
    119                  {
    120                  	X->p = X->limbs;
    121                  	X->n = nblimbs;
    122                  	return ( 0 );
    123                  }
    124          #endif /* MBEDTLS_MTK */
    125                  if( ( p = mbedtls_calloc( nblimbs, ciL ) ) == NULL )
    126                      return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
    127          
    128                  if( X->p != NULL )
    129                  {
    130                      memcpy( p, X->p, X->n * ciL );
    131                      mbedtls_zeroize( X->p, X->n * ciL );
    132          #ifdef MBEDTLS_MTK
    133                      if( X->n > MBEDTLS_MPI_MAX_STACK_LIMBS )
    134          #endif /* MBEDTLS_MTK */
    135                          mbedtls_free( X->p );
    136                  }
    137          
    138                  X->n = nblimbs;
    139                  X->p = p;
    140              }
    141          
    142              return( 0 );
    143          }
    144          
    145          /*
    146           * Resize down as much as possible,
    147           * while keeping at least the specified number of limbs
    148           */
    149          int mbedtls_mpi_shrink( mbedtls_mpi *X, size_t nblimbs )
    150          {
    151              mbedtls_mpi_uint *p;
    152              size_t i;
    153              /* Actually resize up in this case */
    154              if( X->n <= nblimbs )
    155                  return( mbedtls_mpi_grow( X, nblimbs ) );
    156          
    157          #ifdef MBEDTLS_MTK
    158              if( X->n <= MBEDTLS_MPI_MAX_STACK_LIMBS)
    159              {
    160                  X->n = nblimbs;
    161                  return ( 0 );
    162              }
    163          #endif /* MBEDTLS_MTK */
    164              for( i = X->n - 1; i > 0; i-- )
    165                  if( X->p[i] != 0 )
    166                      break;
    167              i++;
    168          
    169              if( i < nblimbs )
    170                  i = nblimbs;
    171          #ifdef MBEDTLS_MTK
    172              if( i <= MBEDTLS_MPI_MAX_STACK_LIMBS)
    173              {
    174              	p = X->limbs;
    175              }
    176              else
    177          #endif /* MBEDTLS_MTK */
    178              if( ( p = mbedtls_calloc( i, ciL ) ) == NULL )
    179                  return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
    180          
    181              if( X->p != NULL )
    182              {
    183                  memcpy( p, X->p, i * ciL );
    184                  mbedtls_zeroize( X->p, X->n * ciL );
    185                  mbedtls_free( X->p );
    186              }
    187          
    188              X->n = i;
    189              X->p = p;
    190          
    191              return( 0 );
    192          }
    193          
    194          /*
    195           * Copy the contents of Y into X
    196           */
    197          int mbedtls_mpi_copy( mbedtls_mpi *X, const mbedtls_mpi *Y )
    198          {
    199              int ret;
    200              size_t i;
    201          
    202              if( X == Y )
    203                  return( 0 );
    204          
    205              if( Y->p == NULL )
    206              {
    207                  mbedtls_mpi_free( X );
    208                  return( 0 );
    209              }
    210          
    211              for( i = Y->n - 1; i > 0; i-- )
    212                  if( Y->p[i] != 0 )
    213                      break;
    214              i++;
    215          
    216              X->s = Y->s;
    217          
    218              MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i ) );
    219          
    220              memset( X->p, 0, X->n * ciL );
    221              memcpy( X->p, Y->p, i * ciL );
    222          
    223          cleanup:
    224          
    225              return( ret );
    226          }
    227          
    228          /*
    229           * Swap the contents of X and Y
    230           */
    231          void mbedtls_mpi_swap( mbedtls_mpi *X, mbedtls_mpi *Y )
    232          {
    233              mbedtls_mpi T;
    234          
    235              memcpy( &T,  X, sizeof( mbedtls_mpi ) );
    236              memcpy(  X,  Y, sizeof( mbedtls_mpi ) );
    237              memcpy(  Y, &T, sizeof( mbedtls_mpi ) );
    238          }
    239          
    240          /*
    241           * Conditionally assign X = Y, without leaking information
    242           * about whether the assignment was made or not.
    243           * (Leaking information about the respective sizes of X and Y is ok however.)
    244           */
    245          int mbedtls_mpi_safe_cond_assign( mbedtls_mpi *X, const mbedtls_mpi *Y, unsigned char assign )
    246          {
    247              int ret = 0;
    248              size_t i;
    249          
    250              /* make sure assign is 0 or 1 in a time-constant manner */
    251              assign = (assign | (unsigned char)-assign) >> 7;
    252          
    253              MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, Y->n ) );
    254          
    255              X->s = X->s * ( 1 - assign ) + Y->s * assign;
    256          
    257              for( i = 0; i < Y->n; i++ )
    258                  X->p[i] = X->p[i] * ( 1 - assign ) + Y->p[i] * assign;
    259          
    260              for( ; i < X->n; i++ )
    261                  X->p[i] *= ( 1 - assign );
    262          
    263          cleanup:
    264              return( ret );
    265          }
    266          
    267          /*
    268           * Conditionally swap X and Y, without leaking information
    269           * about whether the swap was made or not.
    270           * Here it is not ok to simply swap the pointers, which whould lead to
    271           * different memory access patterns when X and Y are used afterwards.
    272           */
    273          int mbedtls_mpi_safe_cond_swap( mbedtls_mpi *X, mbedtls_mpi *Y, unsigned char swap )
    274          {
    275              int ret, s;
    276              size_t i;
    277              mbedtls_mpi_uint tmp;
    278          
    279              if( X == Y )
    280                  return( 0 );
    281          
    282              /* make sure swap is 0 or 1 in a time-constant manner */
    283              swap = (swap | (unsigned char)-swap) >> 7;
    284          
    285              MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, Y->n ) );
    286              MBEDTLS_MPI_CHK( mbedtls_mpi_grow( Y, X->n ) );
    287          
    288              s = X->s;
    289              X->s = X->s * ( 1 - swap ) + Y->s * swap;
    290              Y->s = Y->s * ( 1 - swap ) +    s * swap;
    291          
    292          
    293              for( i = 0; i < X->n; i++ )
    294              {
    295                  tmp = X->p[i];
    296                  X->p[i] = X->p[i] * ( 1 - swap ) + Y->p[i] * swap;
    297                  Y->p[i] = Y->p[i] * ( 1 - swap ) +     tmp * swap;
    298              }
    299          
    300          cleanup:
    301              return( ret );
    302          }
    303          
    304          /*
    305           * Set value from integer
    306           */
    307          int mbedtls_mpi_lset( mbedtls_mpi *X, mbedtls_mpi_sint z )
    308          {
    309              int ret;
    310          
    311              MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, 1 ) );
    312              memset( X->p, 0, X->n * ciL );
    313          
    314              X->p[0] = ( z < 0 ) ? -z : z;
    315              X->s    = ( z < 0 ) ? -1 : 1;
    316          
    317          cleanup:
    318          
    319              return( ret );
    320          }
    321          
    322          /*
    323           * Get a specific bit
    324           */
    325          int mbedtls_mpi_get_bit( const mbedtls_mpi *X, size_t pos )
    326          {
    327              if( X->n * biL <= pos )
    328                  return( 0 );
    329          
    330              return( ( X->p[pos / biL] >> ( pos % biL ) ) & 0x01 );
    331          }
    332          
    333          /*
    334           * Set a bit to a specific value of 0 or 1
    335           */
    336          int mbedtls_mpi_set_bit( mbedtls_mpi *X, size_t pos, unsigned char val )
    337          {
    338              int ret = 0;
    339              size_t off = pos / biL;
    340              size_t idx = pos % biL;
    341          
    342              if( val != 0 && val != 1 )
    343                  return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
    344          
    345              if( X->n * biL <= pos )
    346              {
    347                  if( val == 0 )
    348                      return( 0 );
    349          
    350                  MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, off + 1 ) );
    351              }
    352          
    353              X->p[off] &= ~( (mbedtls_mpi_uint) 0x01 << idx );
    354              X->p[off] |= (mbedtls_mpi_uint) val << idx;
    355          
    356          cleanup:
    357          
    358              return( ret );
    359          }
    360          
    361          /*
    362           * Return the number of less significant zero-bits
    363           */
    364          size_t mbedtls_mpi_lsb( const mbedtls_mpi *X )
    365          {
    366              size_t i, j, count = 0;
    367          
    368              for( i = 0; i < X->n; i++ )
    369                  for( j = 0; j < biL; j++, count++ )
    370                      if( ( ( X->p[i] >> j ) & 1 ) != 0 )
    371                          return( count );
    372          
    373              return( 0 );
    374          }
    375          
    376          /*
    377           * Return the number of bits
    378           */
    379          size_t mbedtls_mpi_bitlen( const mbedtls_mpi *X )
    380          {
    381              size_t i, j;
    382          
    383              if( X->n == 0 )
    384                  return( 0 );
    385          
    386              for( i = X->n - 1; i > 0; i-- )
    387                  if( X->p[i] != 0 )
    388                      break;
    389          
    390              for( j = biL; j > 0; j-- )
    391                  if( ( ( X->p[i] >> ( j - 1 ) ) & 1 ) != 0 )
    392                      break;
    393          
    394              return( ( i * biL ) + j );
    395          }
    396          
    397          /*
    398           * Return the total size in bytes
    399           */
    400          size_t mbedtls_mpi_size( const mbedtls_mpi *X )
    401          {
    402              return( ( mbedtls_mpi_bitlen( X ) + 7 ) >> 3 );
    403          }
    404          
    405          /*
    406           * Convert an ASCII character to digit value
    407           */
    408          static int mpi_get_digit( mbedtls_mpi_uint *d, int radix, char c )
    409          {
    410              *d = 255;
    411          
    412              if( c >= 0x30 && c <= 0x39 ) *d = c - 0x30;
    413              if( c >= 0x41 && c <= 0x46 ) *d = c - 0x37;
    414              if( c >= 0x61 && c <= 0x66 ) *d = c - 0x57;
    415          
    416              if( *d >= (mbedtls_mpi_uint) radix )
    417                  return( MBEDTLS_ERR_MPI_INVALID_CHARACTER );
    418          
    419              return( 0 );
    420          }
    421          
    422          /*
    423           * Import from an ASCII string
    424           */
    425          int mbedtls_mpi_read_string( mbedtls_mpi *X, int radix, const char *s )
    426          {
    427              int ret;
    428              size_t i, j, slen, n;
    429              mbedtls_mpi_uint d;
    430              mbedtls_mpi T;
    431          
    432              if( radix < 2 || radix > 16 )
    433                  return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
    434          
    435              mbedtls_mpi_init( &T );
    436          
    437              slen = strlen( s );
    438          
    439              if( radix == 16 )
    440              {
    441                  n = BITS_TO_LIMBS( slen << 2 );
    442          
    443                  MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, n ) );
    444                  MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
    445          
    446                  for( i = slen, j = 0; i > 0; i--, j++ )
    447                  {
    448                      if( i == 1 && s[i - 1] == '-' )
    449                      {
    450                          X->s = -1;
    451                          break;
    452                      }
    453          
    454                      MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i - 1] ) );
    455                      X->p[j / ( 2 * ciL )] |= d << ( ( j % ( 2 * ciL ) ) << 2 );
    456                  }
    457              }
    458              else
    459              {
    460                  MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
    461          
    462                  for( i = 0; i < slen; i++ )
    463                  {
    464                      if( i == 0 && s[i] == '-' )
    465                      {
    466                          X->s = -1;
    467                          continue;
    468                      }
    469          
    470                      MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i] ) );
    471                      MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T, X, radix ) );
    472          
    473                      if( X->s == 1 )
    474                      {
    475                          MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, &T, d ) );
    476                      }
    477                      else
    478                      {
    479                          MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( X, &T, d ) );
    480                      }
    481                  }
    482              }
    483          
    484          cleanup:
    485          
    486              mbedtls_mpi_free( &T );
    487          
    488              return( ret );
    489          }
    490          
    491          /*
    492           * Helper to write the digits high-order first
    493           */
    494          static int mpi_write_hlp( mbedtls_mpi *X, int radix, char **p )
    495          {
    496              int ret;
    497              mbedtls_mpi_uint r;
    498          
    499              if( radix < 2 || radix > 16 )
    500                  return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
    501          
    502              MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( &r, X, radix ) );
    503              MBEDTLS_MPI_CHK( mbedtls_mpi_div_int( X, NULL, X, radix ) );
    504          
    505              if( mbedtls_mpi_cmp_int( X, 0 ) != 0 )
    506                  MBEDTLS_MPI_CHK( mpi_write_hlp( X, radix, p ) );
    507          
    508              if( r < 10 )
    509                  *(*p)++ = (char)( r + 0x30 );
    510              else
    511                  *(*p)++ = (char)( r + 0x37 );
    512          
    513          cleanup:
    514          
    515              return( ret );
    516          }
    517          
    518          /*
    519           * Export into an ASCII string
    520           */
    521          int mbedtls_mpi_write_string( const mbedtls_mpi *X, int radix,
    522                                        char *buf, size_t buflen, size_t *olen )
    523          {
    524              int ret = 0;
    525              size_t n;
    526              char *p;
    527              mbedtls_mpi T;
    528          
    529              if( radix < 2 || radix > 16 )
    530                  return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
    531          
    532              n = mbedtls_mpi_bitlen( X );
    533              if( radix >=  4 ) n >>= 1;
    534              if( radix >= 16 ) n >>= 1;
    535              n += 3;
    536          
    537              if( buflen < n )
    538              {
    539                  *olen = n;
    540                  return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
    541              }
    542          
    543              p = buf;
    544              mbedtls_mpi_init( &T );
    545          
    546              if( X->s == -1 )
    547                  *p++ = '-';
    548          
    549              if( radix == 16 )
    550              {
    551                  int c;
    552                  size_t i, j, k;
    553          
    554                  for( i = X->n, k = 0; i > 0; i-- )
    555                  {
    556                      for( j = ciL; j > 0; j-- )
    557                      {
    558                          c = ( X->p[i - 1] >> ( ( j - 1 ) << 3) ) & 0xFF;
    559          
    560                          if( c == 0 && k == 0 && ( i + j ) != 2 )
    561                              continue;
    562          
    563                          *(p++) = "0123456789ABCDEF" [c / 16];
    564                          *(p++) = "0123456789ABCDEF" [c % 16];
    565                          k = 1;
    566                      }
    567                  }
    568              }
    569              else
    570              {
    571                  MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &T, X ) );
    572          
    573                  if( T.s == -1 )
    574                      T.s = 1;
    575          
    576                  MBEDTLS_MPI_CHK( mpi_write_hlp( &T, radix, &p ) );
    577              }
    578          
    579              *p++ = '\0';
    580              *olen = p - buf;
    581          
    582          cleanup:
    583          
    584              mbedtls_mpi_free( &T );
    585          
    586              return( ret );
    587          }
    588          
    589          #if defined(MBEDTLS_FS_IO)
    590          /*
    591           * Read X from an opened file
    592           */
    593          int mbedtls_mpi_read_file( mbedtls_mpi *X, int radix, FILE *fin )
    594          {
    595              mbedtls_mpi_uint d;
    596              size_t slen;
    597              char *p;
    598              /*
    599               * Buffer should have space for (short) label and decimal formatted MPI,
    600               * newline characters and '\0'
    601               */
    602              char s[ MBEDTLS_MPI_RW_BUFFER_SIZE ];
    603          
    604              memset( s, 0, sizeof( s ) );
    605              if( fgets( s, sizeof( s ) - 1, fin ) == NULL )
    606                  return( MBEDTLS_ERR_MPI_FILE_IO_ERROR );
    607          
    608              slen = strlen( s );
    609              if( slen == sizeof( s ) - 2 )
    610                  return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
    611          
    612              if( s[slen - 1] == '\n' ) { slen--; s[slen] = '\0'; }
    613              if( s[slen - 1] == '\r' ) { slen--; s[slen] = '\0'; }
    614          
    615              p = s + slen;
    616              while( --p >= s )
    617                  if( mpi_get_digit( &d, radix, *p ) != 0 )
    618                      break;
    619          
    620              return( mbedtls_mpi_read_string( X, radix, p + 1 ) );
    621          }
    622          
    623          /*
    624           * Write X into an opened file (or stdout if fout == NULL)
    625           */
    626          int mbedtls_mpi_write_file( const char *p, const mbedtls_mpi *X, int radix, FILE *fout )
    627          {
    628              int ret;
    629              size_t n, slen, plen;
    630              /*
    631               * Buffer should have space for (short) label and decimal formatted MPI,
    632               * newline characters and '\0'
    633               */
    634              char s[ MBEDTLS_MPI_RW_BUFFER_SIZE ];
    635          
    636              memset( s, 0, sizeof( s ) );
    637          
    638              MBEDTLS_MPI_CHK( mbedtls_mpi_write_string( X, radix, s, sizeof( s ) - 2, &n ) );
    639          
    640              if( p == NULL ) p = "";
    641          
    642              plen = strlen( p );
    643              slen = strlen( s );
    644              s[slen++] = '\r';
    645              s[slen++] = '\n';
    646          
    647              if( fout != NULL )
    648              {
    649                  if( fwrite( p, 1, plen, fout ) != plen ||
    650                      fwrite( s, 1, slen, fout ) != slen )
    651                      return( MBEDTLS_ERR_MPI_FILE_IO_ERROR );
    652              }
    653              else
    654                  mbedtls_printf( "%s%s", p, s );
    655          
    656          cleanup:
    657          
    658              return( ret );
    659          }
    660          #endif /* MBEDTLS_FS_IO */
    661          
    662          /*
    663           * Import X from unsigned binary data, big endian
    664           */
    665          int mbedtls_mpi_read_binary( mbedtls_mpi *X, const unsigned char *buf, size_t buflen )
    666          {
    667              int ret;
    668              size_t i, j, n;
    669          
    670              for( n = 0; n < buflen; n++ )
    671                  if( buf[n] != 0 )
    672                      break;
    673          
    674              MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, CHARS_TO_LIMBS( buflen - n ) ) );
    675              MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
    676          
    677              for( i = buflen, j = 0; i > n; i--, j++ )
    678                  X->p[j / ciL] |= ((mbedtls_mpi_uint) buf[i - 1]) << ((j % ciL) << 3);
    679          
    680          cleanup:
    681          
    682              return( ret );
    683          }
    684          
    685          /*
    686           * Export X into unsigned binary data, big endian
    687           */
    688          int mbedtls_mpi_write_binary( const mbedtls_mpi *X, unsigned char *buf, size_t buflen )
    689          {
    690              size_t i, j, n;
    691          
    692              n = mbedtls_mpi_size( X );
    693          
    694              if( buflen < n )
    695                  return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
    696          
    697              memset( buf, 0, buflen );
    698          
    699              for( i = buflen - 1, j = 0; n > 0; i--, j++, n-- )
    700                  buf[i] = (unsigned char)( X->p[j / ciL] >> ((j % ciL) << 3) );
    701          
    702              return( 0 );
    703          }
    704          
    705          /*
    706           * Left-shift: X <<= count
    707           */
    708          int mbedtls_mpi_shift_l( mbedtls_mpi *X, size_t count )
    709          {
    710              int ret;
    711              size_t i, v0, t1;
    712              mbedtls_mpi_uint r0 = 0, r1;
    713          
    714              v0 = count / (biL    );
    715              t1 = count & (biL - 1);
    716          
    717              i = mbedtls_mpi_bitlen( X ) + count;
    718          
    719              if( X->n * biL < i )
    720                  MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, BITS_TO_LIMBS( i ) ) );
    721          
    722              ret = 0;
    723          
    724              /*
    725               * shift by count / limb_size
    726               */
    727              if( v0 > 0 )
    728              {
    729                  for( i = X->n; i > v0; i-- )
    730                      X->p[i - 1] = X->p[i - v0 - 1];
    731          
    732                  for( ; i > 0; i-- )
    733                      X->p[i - 1] = 0;
    734              }
    735          
    736              /*
    737               * shift by count % limb_size
    738               */
    739              if( t1 > 0 )
    740              {
    741                  for( i = v0; i < X->n; i++ )
    742                  {
    743                      r1 = X->p[i] >> (biL - t1);
    744                      X->p[i] <<= t1;
    745                      X->p[i] |= r0;
    746                      r0 = r1;
    747                  }
    748              }
    749          
    750          cleanup:
    751          
    752              return( ret );
    753          }
    754          
    755          /*
    756           * Right-shift: X >>= count
    757           */
    758          int mbedtls_mpi_shift_r( mbedtls_mpi *X, size_t count )
    759          {
    760              size_t i, v0, v1;
    761              mbedtls_mpi_uint r0 = 0, r1;
    762          
    763              v0 = count /  biL;
    764              v1 = count & (biL - 1);
    765          
    766              if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
    767                  return mbedtls_mpi_lset( X, 0 );
    768          
    769              /*
    770               * shift by count / limb_size
    771               */
    772              if( v0 > 0 )
    773              {
    774                  for( i = 0; i < X->n - v0; i++ )
    775                      X->p[i] = X->p[i + v0];
    776          
    777                  for( ; i < X->n; i++ )
    778                      X->p[i] = 0;
    779              }
    780          
    781              /*
    782               * shift by count % limb_size
    783               */
    784              if( v1 > 0 )
    785              {
    786                  for( i = X->n; i > 0; i-- )
    787                  {
    788                      r1 = X->p[i - 1] << (biL - v1);
    789                      X->p[i - 1] >>= v1;
    790                      X->p[i - 1] |= r0;
    791                      r0 = r1;
    792                  }
    793              }
    794          
    795              return( 0 );
    796          }
    797          
    798          /*
    799           * Compare unsigned values
    800           */
    801          int mbedtls_mpi_cmp_abs( const mbedtls_mpi *X, const mbedtls_mpi *Y )
    802          {
    803              size_t i, j;
    804          
    805              for( i = X->n; i > 0; i-- )
    806                  if( X->p[i - 1] != 0 )
    807                      break;
    808          
    809              for( j = Y->n; j > 0; j-- )
    810                  if( Y->p[j - 1] != 0 )
    811                      break;
    812          
    813              if( i == 0 && j == 0 )
    814                  return( 0 );
    815          
    816              if( i > j ) return(  1 );
    817              if( j > i ) return( -1 );
    818          
    819              for( ; i > 0; i-- )
    820              {
    821                  if( X->p[i - 1] > Y->p[i - 1] ) return(  1 );
    822                  if( X->p[i - 1] < Y->p[i - 1] ) return( -1 );
    823              }
    824          
    825              return( 0 );
    826          }
    827          
    828          /*
    829           * Compare signed values
    830           */
    831          int mbedtls_mpi_cmp_mpi( const mbedtls_mpi *X, const mbedtls_mpi *Y )
    832          {
    833              size_t i, j;
    834          
    835              for( i = X->n; i > 0; i-- )
    836                  if( X->p[i - 1] != 0 )
    837                      break;
    838          
    839              for( j = Y->n; j > 0; j-- )
    840                  if( Y->p[j - 1] != 0 )
    841                      break;
    842          
    843              if( i == 0 && j == 0 )
    844                  return( 0 );
    845          
    846              if( i > j ) return(  X->s );
    847              if( j > i ) return( -Y->s );
    848          
    849              if( X->s > 0 && Y->s < 0 ) return(  1 );
    850              if( Y->s > 0 && X->s < 0 ) return( -1 );
    851          
    852              for( ; i > 0; i-- )
    853              {
    854                  if( X->p[i - 1] > Y->p[i - 1] ) return(  X->s );
    855                  if( X->p[i - 1] < Y->p[i - 1] ) return( -X->s );
    856              }
    857          
    858              return( 0 );
    859          }
    860          
    861          /*
    862           * Compare signed values
    863           */
    864          int mbedtls_mpi_cmp_int( const mbedtls_mpi *X, mbedtls_mpi_sint z )
    865          {
    866              mbedtls_mpi Y;
    867              mbedtls_mpi_uint p[1];
    868          
    869              *p  = ( z < 0 ) ? -z : z;
    870              Y.s = ( z < 0 ) ? -1 : 1;
    871              Y.n = 1;
    872              Y.p = p;
    873          
    874              return( mbedtls_mpi_cmp_mpi( X, &Y ) );
    875          }
    876          
    877          /*
    878           * Unsigned addition: X = |A| + |B|  (HAC 14.7)
    879           */
    880          int mbedtls_mpi_add_abs( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )
    881          {
    882              int ret;
    883              size_t i, j;
    884              mbedtls_mpi_uint *o, *p, c;
    885          
    886              if( X == B )
    887              {
    888                  const mbedtls_mpi *T = A; A = X; B = T;
    889              }
    890          
    891              if( X != A )
    892                  MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
    893          
    894              /*
    895               * X should always be positive as a result of unsigned additions.
    896               */
    897              X->s = 1;
    898          
    899              for( j = B->n; j > 0; j-- )
    900                  if( B->p[j - 1] != 0 )
    901                      break;
    902          
    903              MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
    904          
    905              o = B->p; p = X->p; c = 0;
    906          
    907              for( i = 0; i < j; i++, o++, p++ )
    908              {
    909                  *p +=  c; c  = ( *p <  c );
    910                  *p += *o; c += ( *p < *o );
    911              }
    912          
    913              while( c != 0 )
    914              {
    915                  if( i >= X->n )
    916                  {
    917                      MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
    918                      p = X->p + i;
    919                  }
    920          
    921                  *p += c; c = ( *p < c ); i++; p++;
    922              }
    923          
    924          cleanup:
    925          
    926              return( ret );
    927          }
    928          
    929          /*
    930           * Helper for mbedtls_mpi subtraction
    931           */
    932          static void mpi_sub_hlp( size_t n, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d )
    933          {
    934              size_t i;
    935              mbedtls_mpi_uint c, z;
    936          
    937              for( i = c = 0; i < n; i++, s++, d++ )
    938              {
    939                  z = ( *d <  c );     *d -=  c;
    940                  c = ( *d < *s ) + z; *d -= *s;
    941              }
    942          
    943              while( c != 0 )
    944              {
    945                  z = ( *d < c ); *d -= c;
    946                  c = z; i++; d++;
    947              }
    948          }
    949          
    950          /*
    951           * Unsigned subtraction: X = |A| - |B|  (HAC 14.9)
    952           */
    953          int mbedtls_mpi_sub_abs( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )
    954          {
    955              mbedtls_mpi TB;
    956              int ret;
    957              size_t n;
    958          
    959              if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
    960                  return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
    961          
    962              mbedtls_mpi_init( &TB );
    963          
    964              if( X == B )
    965              {
    966                  MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) );
    967                  B = &TB;
    968              }
    969          
    970              if( X != A )
    971                  MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
    972          
    973              /*
    974               * X should always be positive as a result of unsigned subtractions.
    975               */
    976              X->s = 1;
    977          
    978              ret = 0;
    979          
    980              for( n = B->n; n > 0; n-- )
    981                  if( B->p[n - 1] != 0 )
    982                      break;
    983          
    984              mpi_sub_hlp( n, B->p, X->p );
    985          
    986          cleanup:
    987          
    988              mbedtls_mpi_free( &TB );
    989          
    990              return( ret );
    991          }
    992          
    993          /*
    994           * Signed addition: X = A + B
    995           */
    996          int mbedtls_mpi_add_mpi( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )
    997          {
    998              int ret, s = A->s;
    999          
   1000              if( A->s * B->s < 0 )
   1001              {
   1002                  if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
   1003                  {
   1004                      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
   1005                      X->s =  s;
   1006                  }
   1007                  else
   1008                  {
   1009                      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
   1010                      X->s = -s;
   1011                  }
   1012              }
   1013              else
   1014              {
   1015                  MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
   1016                  X->s = s;
   1017              }
   1018          
   1019          cleanup:
   1020          
   1021              return( ret );
   1022          }
   1023          
   1024          /*
   1025           * Signed subtraction: X = A - B
   1026           */
   1027          int mbedtls_mpi_sub_mpi( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )
   1028          {
   1029              int ret, s = A->s;
   1030          
   1031              if( A->s * B->s > 0 )
   1032              {
   1033                  if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
   1034                  {
   1035                      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
   1036                      X->s =  s;
   1037                  }
   1038                  else
   1039                  {
   1040                      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
   1041                      X->s = -s;
   1042                  }
   1043              }
   1044              else
   1045              {
   1046                  MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
   1047                  X->s = s;
   1048              }
   1049          
   1050          cleanup:
   1051          
   1052              return( ret );
   1053          }
   1054          
   1055          /*
   1056           * Signed addition: X = A + b
   1057           */
   1058          int mbedtls_mpi_add_int( mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b )
   1059          {
   1060              mbedtls_mpi _B;
   1061              mbedtls_mpi_uint p[1];
   1062          
   1063              p[0] = ( b < 0 ) ? -b : b;
   1064              _B.s = ( b < 0 ) ? -1 : 1;
   1065              _B.n = 1;
   1066              _B.p = p;
   1067          
   1068              return( mbedtls_mpi_add_mpi( X, A, &_B ) );
   1069          }
   1070          
   1071          /*
   1072           * Signed subtraction: X = A - b
   1073           */
   1074          int mbedtls_mpi_sub_int( mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b )
   1075          {
   1076              mbedtls_mpi _B;
   1077              mbedtls_mpi_uint p[1];
   1078          
   1079              p[0] = ( b < 0 ) ? -b : b;
   1080              _B.s = ( b < 0 ) ? -1 : 1;
   1081              _B.n = 1;
   1082              _B.p = p;
   1083          
   1084              return( mbedtls_mpi_sub_mpi( X, A, &_B ) );
   1085          }
   1086          
   1087          /*
   1088           * Helper for mbedtls_mpi multiplication
   1089           */
   1090          static
   1091          #if defined(__APPLE__) && defined(__arm__)
   1092          /*
   1093           * Apple LLVM version 4.2 (clang-425.0.24) (based on LLVM 3.2svn)
   1094           * appears to need this to prevent bad ARM code generation at -O3.
   1095           */
   1096          __attribute__ ((noinline))
   1097          #endif
   1098          void mpi_mul_hlp( size_t i, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d, mbedtls_mpi_uint b )
   1099          {
   1100              mbedtls_mpi_uint c = 0, t = 0;
   1101          
   1102          #if defined(MULADDC_HUIT)
   1103              for( ; i >= 8; i -= 8 )
   1104              {
   1105                  MULADDC_INIT
   1106                  MULADDC_HUIT
   1107                  MULADDC_STOP
   1108              }
   1109          
   1110              for( ; i > 0; i-- )
   1111              {
   1112                  MULADDC_INIT
   1113                  MULADDC_CORE
   1114                  MULADDC_STOP
   1115              }
   1116          #else /* MULADDC_HUIT */
   1117              for( ; i >= 16; i -= 16 )
   1118              {
   1119                  MULADDC_INIT
   1120                  MULADDC_CORE   MULADDC_CORE
   1121                  MULADDC_CORE   MULADDC_CORE
   1122                  MULADDC_CORE   MULADDC_CORE
   1123                  MULADDC_CORE   MULADDC_CORE
   1124          
   1125                  MULADDC_CORE   MULADDC_CORE
   1126                  MULADDC_CORE   MULADDC_CORE
   1127                  MULADDC_CORE   MULADDC_CORE
   1128                  MULADDC_CORE   MULADDC_CORE
   1129                  MULADDC_STOP
   1130              }
   1131          
   1132              for( ; i >= 8; i -= 8 )
   1133              {
   1134                  MULADDC_INIT
   1135                  MULADDC_CORE   MULADDC_CORE
   1136                  MULADDC_CORE   MULADDC_CORE
   1137          
   1138                  MULADDC_CORE   MULADDC_CORE
   1139                  MULADDC_CORE   MULADDC_CORE
   1140                  MULADDC_STOP
   1141              }
   1142          
   1143              for( ; i > 0; i-- )
   1144              {
   1145                  MULADDC_INIT
   1146                  MULADDC_CORE
   1147                  MULADDC_STOP
   1148              }
   1149          #endif /* MULADDC_HUIT */
   1150          
   1151              t++;
   1152          
   1153              do {
   1154                  *d += c; c = ( *d < c ); d++;
   1155              }
   1156              while( c != 0 );
   1157          }
   1158          
   1159          /*
   1160           * Baseline multiplication: X = A * B  (HAC 14.12)
   1161           */
   1162          int mbedtls_mpi_mul_mpi( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )
   1163          {
   1164              int ret;
   1165              size_t i, j;
   1166              mbedtls_mpi TA, TB;
   1167          
   1168              mbedtls_mpi_init( &TA ); mbedtls_mpi_init( &TB );
   1169          
   1170              if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) ); A = &TA; }
   1171              if( X == B ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) ); B = &TB; }
   1172          
   1173              for( i = A->n; i > 0; i-- )
   1174                  if( A->p[i - 1] != 0 )
   1175                      break;
   1176          
   1177              for( j = B->n; j > 0; j-- )
   1178                  if( B->p[j - 1] != 0 )
   1179                      break;
   1180          
   1181              MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + j ) );
   1182              MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
   1183          
   1184              for( i++; j > 0; j-- )
   1185                  mpi_mul_hlp( i - 1, A->p, X->p + j - 1, B->p[j - 1] );
   1186          
   1187              X->s = A->s * B->s;
   1188          
   1189          cleanup:
   1190          
   1191              mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TA );
   1192          
   1193              return( ret );
   1194          }
   1195          
   1196          /*
   1197           * Baseline multiplication: X = A * b
   1198           */
   1199          int mbedtls_mpi_mul_int( mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_uint b )
   1200          {
   1201              mbedtls_mpi _B;
   1202              mbedtls_mpi_uint p[1];
   1203          
   1204              _B.s = 1;
   1205              _B.n = 1;
   1206              _B.p = p;
   1207              p[0] = b;
   1208          
   1209              return( mbedtls_mpi_mul_mpi( X, A, &_B ) );
   1210          }
   1211          
   1212          /*
   1213           * Division by mbedtls_mpi: A = Q * B + R  (HAC 14.20)
   1214           */
   1215          int mbedtls_mpi_div_mpi( mbedtls_mpi *Q, mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B )
   1216          {
   1217              int ret;
   1218              size_t i, n, t, k;
   1219              mbedtls_mpi X, Y, Z, T1, T2;
   1220          
   1221              if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
   1222                  return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );
   1223          
   1224              mbedtls_mpi_init( &X ); mbedtls_mpi_init( &Y ); mbedtls_mpi_init( &Z );
   1225              mbedtls_mpi_init( &T1 ); mbedtls_mpi_init( &T2 );
   1226          
   1227              if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
   1228              {
   1229                  if( Q != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_lset( Q, 0 ) );
   1230                  if( R != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, A ) );
   1231                  return( 0 );
   1232              }
   1233          
   1234              MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &X, A ) );
   1235              MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Y, B ) );
   1236              X.s = Y.s = 1;
   1237          
   1238              MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
   1239              MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &Z,  0 ) );
   1240              MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T1, 2 ) );
   1241              MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T2, 3 ) );
   1242          
   1243              k = mbedtls_mpi_bitlen( &Y ) % biL;
   1244              if( k < biL - 1 )
   1245              {
   1246                  k = biL - 1 - k;
   1247                  MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &X, k ) );
   1248                  MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, k ) );
   1249              }
   1250              else k = 0;
   1251          
   1252              n = X.n - 1;
   1253              t = Y.n - 1;
   1254              MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, biL * ( n - t ) ) );
   1255          
   1256              while( mbedtls_mpi_cmp_mpi( &X, &Y ) >= 0 )
   1257              {
   1258                  Z.p[n - t]++;
   1259                  MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &Y ) );
   1260              }
   1261              MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &Y, biL * ( n - t ) ) );
   1262          
   1263              for( i = n; i > t ; i-- )
   1264              {
   1265                  if( X.p[i] >= Y.p[t] )
   1266                      Z.p[i - t - 1] = ~0;
   1267                  else
   1268                  {
   1269          #if defined(MBEDTLS_HAVE_UDBL)
   1270                      mbedtls_t_udbl r;
   1271          
   1272                      r  = (mbedtls_t_udbl) X.p[i] << biL;
   1273                      r |= (mbedtls_t_udbl) X.p[i - 1];
   1274                      r /= Y.p[t];
   1275                      if( r > ( (mbedtls_t_udbl) 1 << biL ) - 1 )
   1276                          r = ( (mbedtls_t_udbl) 1 << biL ) - 1;
   1277          
   1278                      Z.p[i - t - 1] = (mbedtls_mpi_uint) r;
   1279          #else
   1280                      /*
   1281                       * __udiv_qrnnd_c, from gmp/longlong.h
   1282                       */
   1283                      mbedtls_mpi_uint q0, q1, r0, r1;
   1284                      mbedtls_mpi_uint d0, d1, d, m;
   1285          
   1286                      d  = Y.p[t];
   1287                      d0 = ( d << biH ) >> biH;
   1288                      d1 = ( d >> biH );
   1289          
   1290                      q1 = X.p[i] / d1;
   1291                      r1 = X.p[i] - d1 * q1;
   1292                      r1 <<= biH;
   1293                      r1 |= ( X.p[i - 1] >> biH );
   1294          
   1295                      m = q1 * d0;
   1296                      if( r1 < m )
   1297                      {
   1298                          q1--, r1 += d;
   1299                          while( r1 >= d && r1 < m )
   1300                              q1--, r1 += d;
   1301                      }
   1302                      r1 -= m;
   1303          
   1304                      q0 = r1 / d1;
   1305                      r0 = r1 - d1 * q0;
   1306                      r0 <<= biH;
   1307                      r0 |= ( X.p[i - 1] << biH ) >> biH;
   1308          
   1309                      m = q0 * d0;
   1310                      if( r0 < m )
   1311                      {
   1312                          q0--, r0 += d;
   1313                          while( r0 >= d && r0 < m )
   1314                              q0--, r0 += d;
   1315                      }
   1316                      r0 -= m;
   1317          
   1318                      Z.p[i - t - 1] = ( q1 << biH ) | q0;
   1319          #endif /* MBEDTLS_HAVE_UDBL && !64-bit Apple with Clang 5.0 */
   1320                  }
   1321          
   1322                  Z.p[i - t - 1]++;
   1323                  do
   1324                  {
   1325                      Z.p[i - t - 1]--;
   1326          
   1327                      MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
   1328                      T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
   1329                      T1.p[1] = Y.p[t];
   1330                      MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
   1331          
   1332                      MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T2, 0 ) );
   1333                      T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
   1334                      T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
   1335                      T2.p[2] = X.p[i];
   1336                  }
   1337                  while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
   1338          
   1339                  MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &Y, Z.p[i - t - 1] ) );
   1340                  MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1,  biL * ( i - t - 1 ) ) );
   1341                  MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &T1 ) );
   1342          
   1343                  if( mbedtls_mpi_cmp_int( &X, 0 ) < 0 )
   1344                  {
   1345                      MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &T1, &Y ) );
   1346                      MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1, biL * ( i - t - 1 ) ) );
   1347                      MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &X, &X, &T1 ) );
   1348                      Z.p[i - t - 1]--;
   1349                  }
   1350              }
   1351          
   1352              if( Q != NULL )
   1353              {
   1354                  MBEDTLS_MPI_CHK( mbedtls_mpi_copy( Q, &Z ) );
   1355                  Q->s = A->s * B->s;
   1356              }
   1357          
   1358              if( R != NULL )
   1359              {
   1360                  MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &X, k ) );
   1361                  X.s = A->s;
   1362                  MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, &X ) );
   1363          
   1364                  if( mbedtls_mpi_cmp_int( R, 0 ) == 0 )
   1365                      R->s = 1;
   1366              }
   1367          
   1368          cleanup:
   1369          
   1370              mbedtls_mpi_free( &X ); mbedtls_mpi_free( &Y ); mbedtls_mpi_free( &Z );
   1371              mbedtls_mpi_free( &T1 ); mbedtls_mpi_free( &T2 );
   1372          
   1373              return( ret );
   1374          }
   1375          
   1376          /*
   1377           * Division by int: A = Q * b + R
   1378           */
   1379          int mbedtls_mpi_div_int( mbedtls_mpi *Q, mbedtls_mpi *R, const mbedtls_mpi *A, mbedtls_mpi_sint b )
   1380          {
   1381              mbedtls_mpi _B;
   1382              mbedtls_mpi_uint p[1];
   1383          
   1384              p[0] = ( b < 0 ) ? -b : b;
   1385              _B.s = ( b < 0 ) ? -1 : 1;
   1386              _B.n = 1;
   1387              _B.p = p;
   1388          
   1389              return( mbedtls_mpi_div_mpi( Q, R, A, &_B ) );
   1390          }
   1391          
   1392          /*
   1393           * Modulo: R = A mod B
   1394           */
   1395          int mbedtls_mpi_mod_mpi( mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B )
   1396          {
   1397              int ret;
   1398          
   1399              if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
   1400                  return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
   1401          
   1402              MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( NULL, R, A, B ) );
   1403          
   1404              while( mbedtls_mpi_cmp_int( R, 0 ) < 0 )
   1405                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( R, R, B ) );
   1406          
   1407              while( mbedtls_mpi_cmp_mpi( R, B ) >= 0 )
   1408                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( R, R, B ) );
   1409          
   1410          cleanup:
   1411          
   1412              return( ret );
   1413          }
   1414          
   1415          /*
   1416           * Modulo: r = A mod b
   1417           */
   1418          int mbedtls_mpi_mod_int( mbedtls_mpi_uint *r, const mbedtls_mpi *A, mbedtls_mpi_sint b )
   1419          {
   1420              size_t i;
   1421              mbedtls_mpi_uint x, y, z;
   1422          
   1423              if( b == 0 )
   1424                  return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );
   1425          
   1426              if( b < 0 )
   1427                  return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
   1428          
   1429              /*
   1430               * handle trivial cases
   1431               */
   1432              if( b == 1 )
   1433              {
   1434                  *r = 0;
   1435                  return( 0 );
   1436              }
   1437          
   1438              if( b == 2 )
   1439              {
   1440                  *r = A->p[0] & 1;
   1441                  return( 0 );
   1442              }
   1443          
   1444              /*
   1445               * general case
   1446               */
   1447              for( i = A->n, y = 0; i > 0; i-- )
   1448              {
   1449                  x  = A->p[i - 1];
   1450                  y  = ( y << biH ) | ( x >> biH );
   1451                  z  = y / b;
   1452                  y -= z * b;
   1453          
   1454                  x <<= biH;
   1455                  y  = ( y << biH ) | ( x >> biH );
   1456                  z  = y / b;
   1457                  y -= z * b;
   1458              }
   1459          
   1460              /*
   1461               * If A is negative, then the current y represents a negative value.
   1462               * Flipping it to the positive side.
   1463               */
   1464              if( A->s < 0 && y != 0 )
   1465                  y = b - y;
   1466          
   1467              *r = y;
   1468          
   1469              return( 0 );
   1470          }
   1471          
   1472          /*
   1473           * Fast Montgomery initialization (thanks to Tom St Denis)
   1474           */
   1475          static void mpi_montg_init( mbedtls_mpi_uint *mm, const mbedtls_mpi *N )
   1476          {
   1477              mbedtls_mpi_uint x, m0 = N->p[0];
   1478              unsigned int i;
   1479          
   1480              x  = m0;
   1481              x += ( ( m0 + 2 ) & 4 ) << 1;
   1482          
   1483              for( i = biL; i >= 8; i /= 2 )
   1484                  x *= ( 2 - ( m0 * x ) );
   1485          
   1486              *mm = ~x + 1;
   1487          }
   1488          
   1489          /*
   1490           * Montgomery multiplication: A = A * B * R^-1 mod N  (HAC 14.36)
   1491           */
   1492          static void mpi_montmul( mbedtls_mpi *A, const mbedtls_mpi *B, const mbedtls_mpi *N, mbedtls_mpi_uint mm,
   1493                                   const mbedtls_mpi *T )
   1494          {
   1495              size_t i, n, m;
   1496              mbedtls_mpi_uint u0, u1, *d;
   1497          
   1498              memset( T->p, 0, T->n * ciL );
   1499          
   1500              d = T->p;
   1501              n = N->n;
   1502              m = ( B->n < n ) ? B->n : n;
   1503          
   1504              for( i = 0; i < n; i++ )
   1505              {
   1506                  /*
   1507                   * T = (T + u0*B + u1*N) / 2^biL
   1508                   */
   1509                  u0 = A->p[i];
   1510                  u1 = ( d[0] + u0 * B->p[0] ) * mm;
   1511          
   1512                  mpi_mul_hlp( m, B->p, d, u0 );
   1513                  mpi_mul_hlp( n, N->p, d, u1 );
   1514          
   1515                  *d++ = u0; d[n + 1] = 0;
   1516              }
   1517          
   1518              memcpy( A->p, d, ( n + 1 ) * ciL );
   1519          
   1520              if( mbedtls_mpi_cmp_abs( A, N ) >= 0 )
   1521                  mpi_sub_hlp( n, N->p, A->p );
   1522              else
   1523                  /* prevent timing attacks */
   1524                  mpi_sub_hlp( n, A->p, T->p );
   1525          }
   1526          
   1527          /*
   1528           * Montgomery reduction: A = A * R^-1 mod N
   1529           */
   1530          static void mpi_montred( mbedtls_mpi *A, const mbedtls_mpi *N, mbedtls_mpi_uint mm, const mbedtls_mpi *T )
   1531          {
   1532              mbedtls_mpi_uint z = 1;
   1533              mbedtls_mpi U;
   1534          
   1535              U.n = U.s = (int) z;
   1536              U.p = &z;
   1537          
   1538              mpi_montmul( A, &U, N, mm, T );
   1539          }
   1540          
   1541          /*
   1542           * Sliding-window exponentiation: X = A^E mod N  (HAC 14.85)
   1543           */
   1544          int mbedtls_mpi_exp_mod( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *E, const mbedtls_mpi *N, mbedtls_mpi *_RR )
   1545          {
   1546              int ret;
   1547              size_t wbits, wsize, one = 1;
   1548              size_t i, j, nblimbs;
   1549              size_t bufsize, nbits;
   1550              mbedtls_mpi_uint ei, mm, state;
   1551              mbedtls_mpi RR, T, Apos;
   1552          #ifdef MBEDTLS_MTK
   1553              mbedtls_mpi* W;
   1554          #else
   1555              mbedtls_mpi W[ 2 << MBEDTLS_MPI_WINDOW_SIZE ];
   1556          #endif
   1557              int neg;
   1558              if( mbedtls_mpi_cmp_int( N, 0 ) < 0 || ( N->p[0] & 1 ) == 0 )
   1559                  return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
   1560          
   1561              if( mbedtls_mpi_cmp_int( E, 0 ) < 0 )
   1562                  return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
   1563          
   1564              /*
   1565               * Init temps and window size
   1566               */
   1567          #ifdef MBEDTLS_MTK
   1568              if( (W = mbedtls_calloc((2 << MBEDTLS_MPI_WINDOW_SIZE), sizeof(mbedtls_mpi))) == NULL )
   1569              {
   1570              	return ( MBEDTLS_ERR_MPI_ALLOC_FAILED );
   1571              }
   1572          #else
   1573              memset( W, 0, sizeof( W ) );
   1574          #endif /* MBEDTLS_MTK */
   1575              mpi_montg_init( &mm, N );
   1576              mbedtls_mpi_init( &RR ); mbedtls_mpi_init( &T );
   1577              mbedtls_mpi_init( &Apos );
   1578          
   1579              i = mbedtls_mpi_bitlen( E );
   1580          
   1581              wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
   1582                      ( i >  79 ) ? 4 : ( i >  23 ) ? 3 : 1;
   1583          
   1584              if( wsize > MBEDTLS_MPI_WINDOW_SIZE )
   1585                  wsize = MBEDTLS_MPI_WINDOW_SIZE;
   1586          
   1587              j = N->n + 1;
   1588              MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
   1589              MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[1],  j ) );
   1590              MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T, j * 2 ) );
   1591          
   1592              /*
   1593               * Compensate for negative A (and correct at the end)
   1594               */
   1595              neg = ( A->s == -1 );
   1596              if( neg )
   1597              {
   1598                  MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Apos, A ) );
   1599                  Apos.s = 1;
   1600                  A = &Apos;
   1601              }
   1602          
   1603              /*
   1604               * If 1st call, pre-compute R^2 mod N
   1605               */
   1606              if( _RR == NULL || _RR->p == NULL )
   1607              {
   1608                  MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &RR, 1 ) );
   1609                  MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &RR, N->n * 2 * biL ) );
   1610                  MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &RR, &RR, N ) );
   1611          
   1612                  if( _RR != NULL )
   1613                      memcpy( _RR, &RR, sizeof( mbedtls_mpi ) );
   1614              }
   1615              else
   1616                  memcpy( &RR, _RR, sizeof( mbedtls_mpi ) );
   1617          
   1618              /*
   1619               * W[1] = A * R^2 * R^-1 mod N = A * R mod N
   1620               */
   1621              if( mbedtls_mpi_cmp_mpi( A, N ) >= 0 )
   1622                  MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &W[1], A, N ) );
   1623              else
   1624                  MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[1], A ) );
   1625          
   1626              mpi_montmul( &W[1], &RR, N, mm, &T );
   1627          
   1628              /*
   1629               * X = R^2 * R^-1 mod N = R mod N
   1630               */
   1631              MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &RR ) );
   1632              mpi_montred( X, N, mm, &T );
   1633          
   1634              if( wsize > 1 )
   1635              {
   1636                  /*
   1637                   * W[1 << (wsize - 1)] = W[1] ^ (wsize - 1)
   1638                   */
   1639                  j =  one << ( wsize - 1 );
   1640          
   1641                  MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[j], N->n + 1 ) );
   1642                  MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[j], &W[1]    ) );
   1643          
   1644                  for( i = 0; i < wsize - 1; i++ )
   1645                      mpi_montmul( &W[j], &W[j], N, mm, &T );
   1646          
   1647                  /*
   1648                   * W[i] = W[i - 1] * W[1]
   1649                   */
   1650                  for( i = j + 1; i < ( one << wsize ); i++ )
   1651                  {
   1652                      MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[i], N->n + 1 ) );
   1653                      MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[i], &W[i - 1] ) );
   1654          
   1655                      mpi_montmul( &W[i], &W[1], N, mm, &T );
   1656                  }
   1657              }
   1658          
   1659              nblimbs = E->n;
   1660              bufsize = 0;
   1661              nbits   = 0;
   1662              wbits   = 0;
   1663              state   = 0;
   1664          
   1665              while( 1 )
   1666              {
   1667                  if( bufsize == 0 )
   1668                  {
   1669                      if( nblimbs == 0 )
   1670                          break;
   1671          
   1672                      nblimbs--;
   1673          
   1674                      bufsize = sizeof( mbedtls_mpi_uint ) << 3;
   1675                  }
   1676          
   1677                  bufsize--;
   1678          
   1679                  ei = (E->p[nblimbs] >> bufsize) & 1;
   1680          
   1681                  /*
   1682                   * skip leading 0s
   1683                   */
   1684                  if( ei == 0 && state == 0 )
   1685                      continue;
   1686          
   1687                  if( ei == 0 && state == 1 )
   1688                  {
   1689                      /*
   1690                       * out of window, square X
   1691                       */
   1692                      mpi_montmul( X, X, N, mm, &T );
   1693                      continue;
   1694                  }
   1695          
   1696                  /*
   1697                   * add ei to current window
   1698                   */
   1699                  state = 2;
   1700          
   1701                  nbits++;
   1702                  wbits |= ( ei << ( wsize - nbits ) );
   1703          
   1704                  if( nbits == wsize )
   1705                  {
   1706                      /*
   1707                       * X = X^wsize R^-1 mod N
   1708                       */
   1709                      for( i = 0; i < wsize; i++ )
   1710                          mpi_montmul( X, X, N, mm, &T );
   1711          
   1712                      /*
   1713                       * X = X * W[wbits] R^-1 mod N
   1714                       */
   1715                      mpi_montmul( X, &W[wbits], N, mm, &T );
   1716          
   1717                      state--;
   1718                      nbits = 0;
   1719                      wbits = 0;
   1720                  }
   1721              }
   1722          
   1723              /*
   1724               * process the remaining bits
   1725               */
   1726              for( i = 0; i < nbits; i++ )
   1727              {
   1728                  mpi_montmul( X, X, N, mm, &T );
   1729          
   1730                  wbits <<= 1;
   1731          
   1732                  if( ( wbits & ( one << wsize ) ) != 0 )
   1733                      mpi_montmul( X, &W[1], N, mm, &T );
   1734              }
   1735          
   1736              /*
   1737               * X = A^E * R * R^-1 mod N = A^E mod N
   1738               */
   1739              mpi_montred( X, N, mm, &T );
   1740          
   1741              if( neg )
   1742              {
   1743                  X->s = -1;
   1744                  MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( X, N, X ) );
   1745              }
   1746          
   1747          cleanup:
   1748          
   1749              for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
   1750                  mbedtls_mpi_free( &W[i] );
   1751          
   1752              mbedtls_mpi_free( &W[1] ); mbedtls_mpi_free( &T ); mbedtls_mpi_free( &Apos );
   1753          
   1754              if( _RR == NULL || _RR->p == NULL )
   1755                  mbedtls_mpi_free( &RR );
   1756          #ifdef MBEDTLS_MTK
   1757              mbedtls_free(W);
   1758          #endif /* MBEDTLS_MTK */
   1759              return( ret );
   1760          }
   1761          
   1762          /*
   1763           * Greatest common divisor: G = gcd(A, B)  (HAC 14.54)
   1764           */
   1765          int mbedtls_mpi_gcd( mbedtls_mpi *G, const mbedtls_mpi *A, const mbedtls_mpi *B )
   1766          {
   1767              int ret;
   1768              size_t lz, lzt;
   1769              mbedtls_mpi TG, TA, TB;
   1770          
   1771              mbedtls_mpi_init( &TG ); mbedtls_mpi_init( &TA ); mbedtls_mpi_init( &TB );
   1772          
   1773              MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) );
   1774              MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) );
   1775          
   1776              lz = mbedtls_mpi_lsb( &TA );
   1777              lzt = mbedtls_mpi_lsb( &TB );
   1778          
   1779              if( lzt < lz )
   1780                  lz = lzt;
   1781          
   1782              MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, lz ) );
   1783              MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, lz ) );
   1784          
   1785              TA.s = TB.s = 1;
   1786          
   1787              while( mbedtls_mpi_cmp_int( &TA, 0 ) != 0 )
   1788              {
   1789                  MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, mbedtls_mpi_lsb( &TA ) ) );
   1790                  MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, mbedtls_mpi_lsb( &TB ) ) );
   1791                  if( mbedtls_mpi_cmp_mpi( &TA, &TB ) >= 0 )
   1792                  {
   1793                      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TA, &TA, &TB ) );
   1794                      MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, 1 ) );
   1795                  }
   1796                  else
   1797                  {
   1798                      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TB, &TB, &TA ) );
   1799                      MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, 1 ) );
   1800                  }
   1801              }
   1802          
   1803              MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &TB, lz ) );
   1804              MBEDTLS_MPI_CHK( mbedtls_mpi_copy( G, &TB ) );
   1805          
   1806          cleanup:
   1807          
   1808              mbedtls_mpi_free( &TG ); mbedtls_mpi_free( &TA ); mbedtls_mpi_free( &TB );
   1809          
   1810              return( ret );
   1811          }
   1812          
   1813          /*
   1814           * Fill X with size bytes of random.
   1815           *
   1816           * Use a temporary bytes representation to make sure the result is the same
   1817           * regardless of the platform endianness (useful when f_rng is actually
   1818           * deterministic, eg for tests).
   1819           */
   1820          int mbedtls_mpi_fill_random( mbedtls_mpi *X, size_t size,
   1821                               int (*f_rng)(void *, unsigned char *, size_t),
   1822                               void *p_rng )
   1823          {
   1824              int ret;
   1825              unsigned char buf[MBEDTLS_MPI_MAX_SIZE];
   1826          
   1827              if( size > MBEDTLS_MPI_MAX_SIZE )
   1828                  return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
   1829          
   1830              MBEDTLS_MPI_CHK( f_rng( p_rng, buf, size ) );
   1831              MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( X, buf, size ) );
   1832          
   1833          cleanup:
   1834              return( ret );
   1835          }
   1836          
   1837          /*
   1838           * Modular inverse: X = A^-1 mod N  (HAC 14.61 / 14.64)
   1839           */
   1840          int mbedtls_mpi_inv_mod( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *N )
   1841          {
   1842              int ret;
   1843              mbedtls_mpi G, TA, TU, U1, U2, TB, TV, V1, V2;
   1844          
   1845              if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 )
   1846                  return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
   1847          
   1848              mbedtls_mpi_init( &TA ); mbedtls_mpi_init( &TU ); mbedtls_mpi_init( &U1 ); mbedtls_mpi_init( &U2 );
   1849              mbedtls_mpi_init( &G ); mbedtls_mpi_init( &TB ); mbedtls_mpi_init( &TV );
   1850              mbedtls_mpi_init( &V1 ); mbedtls_mpi_init( &V2 );
   1851              MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, A, N ) );
   1852              if( mbedtls_mpi_cmp_int( &G, 1 ) != 0 )
   1853              {
   1854                  ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   1855                  goto cleanup;
   1856              }
   1857          
   1858              MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &TA, A, N ) );
   1859              MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TU, &TA ) );
   1860              MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, N ) );
   1861              MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TV, N ) );
   1862              MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &U1, 1 ) );
   1863              MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &U2, 0 ) );
   1864              MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &V1, 0 ) );
   1865              MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &V2, 1 ) );
   1866              do
   1867              {
   1868                  while( ( TU.p[0] & 1 ) == 0 )
   1869                  {
   1870                      MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TU, 1 ) );
   1871          
   1872                      if( ( U1.p[0] & 1 ) != 0 || ( U2.p[0] & 1 ) != 0 )
   1873                      {
   1874                          MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &U1, &U1, &TB ) );
   1875                          MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &TA ) );
   1876                      }
   1877          
   1878                      MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U1, 1 ) );
   1879                      MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U2, 1 ) );
   1880                  }
   1881          
   1882                  while( ( TV.p[0] & 1 ) == 0 )
   1883                  {
   1884                      MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TV, 1 ) );
   1885          
   1886                      if( ( V1.p[0] & 1 ) != 0 || ( V2.p[0] & 1 ) != 0 )
   1887                      {
   1888                          MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, &TB ) );
   1889                          MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &TA ) );
   1890                      }
   1891          
   1892                      MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V1, 1 ) );
   1893                      MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V2, 1 ) );
   1894                  }
   1895          
   1896                  if( mbedtls_mpi_cmp_mpi( &TU, &TV ) >= 0 )
   1897                  {
   1898                      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TU, &TU, &TV ) );
   1899                      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U1, &U1, &V1 ) );
   1900                      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &V2 ) );
   1901                  }
   1902                  else
   1903                  {
   1904                      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TV, &TV, &TU ) );
   1905                      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, &U1 ) );
   1906                      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &U2 ) );
   1907                  }
   1908              }
   1909              while( mbedtls_mpi_cmp_int( &TU, 0 ) != 0 );
   1910              while( mbedtls_mpi_cmp_int( &V1, 0 ) < 0 )
   1911                  MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, N ) );
   1912          
   1913              while( mbedtls_mpi_cmp_mpi( &V1, N ) >= 0 )
   1914                  MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, N ) );
   1915          
   1916              MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &V1 ) );
   1917          
   1918          cleanup:
   1919          
   1920              mbedtls_mpi_free( &TA ); mbedtls_mpi_free( &TU ); mbedtls_mpi_free( &U1 ); mbedtls_mpi_free( &U2 );
   1921              mbedtls_mpi_free( &G ); mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TV );
   1922              mbedtls_mpi_free( &V1 ); mbedtls_mpi_free( &V2 );
   1923          
   1924              return( ret );
   1925          }
   1926          
   1927          #if defined(MBEDTLS_GENPRIME)
   1928          
   1929          static const int small_prime[] =
   1930          {
   1931                  3,    5,    7,   11,   13,   17,   19,   23,
   1932                 29,   31,   37,   41,   43,   47,   53,   59,
   1933                 61,   67,   71,   73,   79,   83,   89,   97,
   1934                101,  103,  107,  109,  113,  127,  131,  137,
   1935                139,  149,  151,  157,  163,  167,  173,  179,
   1936                181,  191,  193,  197,  199,  211,  223,  227,
   1937                229,  233,  239,  241,  251,  257,  263,  269,
   1938                271,  277,  281,  283,  293,  307,  311,  313,
   1939                317,  331,  337,  347,  349,  353,  359,  367,
   1940                373,  379,  383,  389,  397,  401,  409,  419,
   1941                421,  431,  433,  439,  443,  449,  457,  461,
   1942                463,  467,  479,  487,  491,  499,  503,  509,
   1943                521,  523,  541,  547,  557,  563,  569,  571,
   1944                577,  587,  593,  599,  601,  607,  613,  617,
   1945                619,  631,  641,  643,  647,  653,  659,  661,
   1946                673,  677,  683,  691,  701,  709,  719,  727,
   1947                733,  739,  743,  751,  757,  761,  769,  773,
   1948                787,  797,  809,  811,  821,  823,  827,  829,
   1949                839,  853,  857,  859,  863,  877,  881,  883,
   1950                887,  907,  911,  919,  929,  937,  941,  947,
   1951                953,  967,  971,  977,  983,  991,  997, -103
   1952          };
   1953          
   1954          /*
   1955           * Small divisors test (X must be positive)
   1956           *
   1957           * Return values:
   1958           * 0: no small factor (possible prime, more tests needed)
   1959           * 1: certain prime
   1960           * MBEDTLS_ERR_MPI_NOT_ACCEPTABLE: certain non-prime
   1961           * other negative: error
   1962           */
   1963          static int mpi_check_small_factors( const mbedtls_mpi *X )
   1964          {
   1965              int ret = 0;
   1966              size_t i;
   1967              mbedtls_mpi_uint r;
   1968          
   1969              if( ( X->p[0] & 1 ) == 0 )
   1970                  return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
   1971          
   1972              for( i = 0; small_prime[i] > 0; i++ )
   1973              {
   1974                  if( mbedtls_mpi_cmp_int( X, small_prime[i] ) <= 0 )
   1975                      return( 1 );
   1976          
   1977                  MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( &r, X, small_prime[i] ) );
   1978          
   1979                  if( r == 0 )
   1980                      return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
   1981              }
   1982          
   1983          cleanup:
   1984              return( ret );
   1985          }
   1986          
   1987          /*
   1988           * Miller-Rabin pseudo-primality test  (HAC 4.24)
   1989           */
   1990          static int mpi_miller_rabin( const mbedtls_mpi *X,
   1991                                       int (*f_rng)(void *, unsigned char *, size_t),
   1992                                       void *p_rng )
   1993          {
   1994              int ret, count;
   1995              size_t i, j, k, n, s;
   1996              mbedtls_mpi W, R, T, A, RR;
   1997          
   1998              mbedtls_mpi_init( &W ); mbedtls_mpi_init( &R ); mbedtls_mpi_init( &T ); mbedtls_mpi_init( &A );
   1999              mbedtls_mpi_init( &RR );
   2000          
   2001              /*
   2002               * W = |X| - 1
   2003               * R = W >> lsb( W )
   2004               */
   2005              MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &W, X, 1 ) );
   2006              s = mbedtls_mpi_lsb( &W );
   2007              MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R, &W ) );
   2008              MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &R, s ) );
   2009          
   2010              i = mbedtls_mpi_bitlen( X );
   2011              /*
   2012               * HAC, table 4.4
   2013               */
   2014              n = ( ( i >= 1300 ) ?  2 : ( i >=  850 ) ?  3 :
   2015                    ( i >=  650 ) ?  4 : ( i >=  350 ) ?  8 :
   2016                    ( i >=  250 ) ? 12 : ( i >=  150 ) ? 18 : 27 );
   2017          
   2018              for( i = 0; i < n; i++ )
   2019              {
   2020                  /*
   2021                   * pick a random A, 1 < A < |X| - 1
   2022                   */
   2023                  MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
   2024          
   2025                  if( mbedtls_mpi_cmp_mpi( &A, &W ) >= 0 )
   2026                  {
   2027                      j = mbedtls_mpi_bitlen( &A ) - mbedtls_mpi_bitlen( &W );
   2028                      MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &A, j + 1 ) );
   2029                  }
   2030                  A.p[0] |= 3;
   2031          
   2032                  count = 0;
   2033                  do {
   2034                      MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
   2035          
   2036                      j = mbedtls_mpi_bitlen( &A );
   2037                      k = mbedtls_mpi_bitlen( &W );
   2038                      if (j > k) {
   2039                          MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &A, j - k ) );
   2040                      }
   2041          
   2042                      if (count++ > 30) {
   2043                          return MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   2044                      }
   2045          
   2046                  } while ( mbedtls_mpi_cmp_mpi( &A, &W ) >= 0 ||
   2047                            mbedtls_mpi_cmp_int( &A, 1 )  <= 0    );
   2048          
   2049                  /*
   2050                   * A = A^R mod |X|
   2051                   */
   2052                  MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &A, &A, &R, X, &RR ) );
   2053          
   2054                  if( mbedtls_mpi_cmp_mpi( &A, &W ) == 0 ||
   2055                      mbedtls_mpi_cmp_int( &A,  1 ) == 0 )
   2056                      continue;
   2057          
   2058                  j = 1;
   2059                  while( j < s && mbedtls_mpi_cmp_mpi( &A, &W ) != 0 )
   2060                  {
   2061                      /*
   2062                       * A = A * A mod |X|
   2063                       */
   2064                      MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T, &A, &A ) );
   2065                      MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &A, &T, X  ) );
   2066          
   2067                      if( mbedtls_mpi_cmp_int( &A, 1 ) == 0 )
   2068                          break;
   2069          
   2070                      j++;
   2071                  }
   2072          
   2073                  /*
   2074                   * not prime if A != |X| - 1 or A == 1
   2075                   */
   2076                  if( mbedtls_mpi_cmp_mpi( &A, &W ) != 0 ||
   2077                      mbedtls_mpi_cmp_int( &A,  1 ) == 0 )
   2078                  {
   2079                      ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   2080                      break;
   2081                  }
   2082              }
   2083          
   2084          cleanup:
   2085              mbedtls_mpi_free( &W ); mbedtls_mpi_free( &R ); mbedtls_mpi_free( &T ); mbedtls_mpi_free( &A );
   2086              mbedtls_mpi_free( &RR );
   2087          
   2088              return( ret );
   2089          }
   2090          
   2091          /*
   2092           * Pseudo-primality test: small factors, then Miller-Rabin
   2093           */
   2094          int mbedtls_mpi_is_prime( const mbedtls_mpi *X,
   2095                            int (*f_rng)(void *, unsigned char *, size_t),
   2096                            void *p_rng )
   2097          {
   2098              int ret;
   2099              mbedtls_mpi XX;
   2100          
   2101              XX.s = 1;
   2102              XX.n = X->n;
   2103              XX.p = X->p;
   2104          
   2105              if( mbedtls_mpi_cmp_int( &XX, 0 ) == 0 ||
   2106                  mbedtls_mpi_cmp_int( &XX, 1 ) == 0 )
   2107                  return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
   2108          
   2109              if( mbedtls_mpi_cmp_int( &XX, 2 ) == 0 )
   2110                  return( 0 );
   2111          
   2112              if( ( ret = mpi_check_small_factors( &XX ) ) != 0 )
   2113              {
   2114                  if( ret == 1 )
   2115                      return( 0 );
   2116          
   2117                  return( ret );
   2118              }
   2119          
   2120              return( mpi_miller_rabin( &XX, f_rng, p_rng ) );
   2121          }
   2122          
   2123          /*
   2124           * Prime number generation
   2125           */
   2126          int mbedtls_mpi_gen_prime( mbedtls_mpi *X, size_t nbits, int dh_flag,
   2127                             int (*f_rng)(void *, unsigned char *, size_t),
   2128                             void *p_rng )
   2129          {
   2130              int ret;
   2131              size_t k, n;
   2132              mbedtls_mpi_uint r;
   2133              mbedtls_mpi Y;
   2134          
   2135              if( nbits < 3 || nbits > MBEDTLS_MPI_MAX_BITS )
   2136                  return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
   2137          
   2138              mbedtls_mpi_init( &Y );
   2139          
   2140              n = BITS_TO_LIMBS( nbits );
   2141          
   2142              MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( X, n * ciL, f_rng, p_rng ) );
   2143          
   2144              k = mbedtls_mpi_bitlen( X );
   2145              if( k > nbits ) MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( X, k - nbits + 1 ) );
   2146          
   2147              mbedtls_mpi_set_bit( X, nbits-1, 1 );
   2148          
   2149              X->p[0] |= 1;
   2150          
   2151              if( dh_flag == 0 )
   2152              {
   2153                  while( ( ret = mbedtls_mpi_is_prime( X, f_rng, p_rng ) ) != 0 )
   2154                  {
   2155                      if( ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE )
   2156                          goto cleanup;
   2157          
   2158                      MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, X, 2 ) );
   2159                  }
   2160              }
   2161              else
   2162              {
   2163                  /*
   2164                   * An necessary condition for Y and X = 2Y + 1 to be prime
   2165                   * is X = 2 mod 3 (which is equivalent to Y = 2 mod 3).
   2166                   * Make sure it is satisfied, while keeping X = 3 mod 4
   2167                   */
   2168          
   2169                  X->p[0] |= 2;
   2170          
   2171                  MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( &r, X, 3 ) );
   2172                  if( r == 0 )
   2173                      MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, X, 8 ) );
   2174                  else if( r == 1 )
   2175                      MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, X, 4 ) );
   2176          
   2177                  /* Set Y = (X-1) / 2, which is X / 2 because X is odd */
   2178                  MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Y, X ) );
   2179                  MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &Y, 1 ) );
   2180          
   2181                  while( 1 )
   2182                  {
   2183                      /*
   2184                       * First, check small factors for X and Y
   2185                       * before doing Miller-Rabin on any of them
   2186                       */
   2187                      if( ( ret = mpi_check_small_factors(  X         ) ) == 0 &&
   2188                          ( ret = mpi_check_small_factors( &Y         ) ) == 0 &&
   2189                          ( ret = mpi_miller_rabin(  X, f_rng, p_rng  ) ) == 0 &&
   2190                          ( ret = mpi_miller_rabin( &Y, f_rng, p_rng  ) ) == 0 )
   2191                      {
   2192                          break;
   2193                      }
   2194          
   2195                      if( ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE )
   2196                          goto cleanup;
   2197          
   2198                      /*
   2199                       * Next candidates. We want to preserve Y = (X-1) / 2 and
   2200                       * Y = 1 mod 2 and Y = 2 mod 3 (eq X = 3 mod 4 and X = 2 mod 3)
   2201                       * so up Y by 6 and X by 12.
   2202                       */
   2203                      MBEDTLS_MPI_CHK( mbedtls_mpi_add_int(  X,  X, 12 ) );
   2204                      MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( &Y, &Y, 6  ) );
   2205                  }
   2206              }
   2207          
   2208          cleanup:
   2209          
   2210              mbedtls_mpi_free( &Y );
   2211          
   2212              return( ret );
   2213          }
   2214          
   2215          #endif /* MBEDTLS_GENPRIME */
   2216          
   2217          #if defined(MBEDTLS_SELF_TEST)
   2218          
   2219          #define GCD_PAIR_COUNT  3
   2220          
   2221          static const int gcd_pairs[GCD_PAIR_COUNT][3] =
   2222          {
   2223              { 693, 609, 21 },
   2224              { 1764, 868, 28 },
   2225              { 768454923, 542167814, 1 }
   2226          };
   2227          
   2228          /*
   2229           * Checkup routine
   2230           */
   2231          int mbedtls_mpi_self_test( int verbose )
   2232          {
   2233              int ret, i;
   2234              mbedtls_mpi A, E, N, X, Y, U, V;
   2235          
   2236              mbedtls_mpi_init( &A ); mbedtls_mpi_init( &E ); mbedtls_mpi_init( &N ); mbedtls_mpi_init( &X );
   2237              mbedtls_mpi_init( &Y ); mbedtls_mpi_init( &U ); mbedtls_mpi_init( &V );
   2238          
   2239              MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &A, 16,
   2240                  "EFE021C2645FD1DC586E69184AF4A31E" \
   2241                  "D5F53E93B5F123FA41680867BA110131" \
   2242                  "944FE7952E2517337780CB0DB80E61AA" \
   2243                  "E7C8DDC6C5C6AADEB34EB38A2F40D5E6" ) );
   2244          
   2245              MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &E, 16,
   2246                  "B2E7EFD37075B9F03FF989C7C5051C20" \
   2247                  "34D2A323810251127E7BF8625A4F49A5" \
   2248                  "F3E27F4DA8BD59C47D6DAABA4C8127BD" \
   2249                  "5B5C25763222FEFCCFC38B832366C29E" ) );
   2250          
   2251              MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &N, 16,
   2252                  "0066A198186C18C10B2F5ED9B522752A" \
   2253                  "9830B69916E535C8F047518A889A43A5" \
   2254                  "94B6BED27A168D31D4A52F88925AA8F5" ) );
   2255          
   2256              MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &X, &A, &N ) );
   2257          
   2258              MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &U, 16,
   2259                  "602AB7ECA597A3D6B56FF9829A5E8B85" \
   2260                  "9E857EA95A03512E2BAE7391688D264A" \
   2261                  "A5663B0341DB9CCFD2C4C5F421FEC814" \
   2262                  "8001B72E848A38CAE1C65F78E56ABDEF" \
   2263                  "E12D3C039B8A02D6BE593F0BBBDA56F1" \
   2264                  "ECF677152EF804370C1A305CAF3B5BF1" \
   2265                  "30879B56C61DE584A0F53A2447A51E" ) );
   2266          
   2267              if( verbose != 0 )
   2268                  mbedtls_printf( "  MPI test #1 (mul_mpi): " );
   2269          
   2270              if( mbedtls_mpi_cmp_mpi( &X, &U ) != 0 )
   2271              {
   2272                  if( verbose != 0 )
   2273                      mbedtls_printf( "failed\n" );
   2274          
   2275                  ret = 1;
   2276                  goto cleanup;
   2277              }
   2278          
   2279              if( verbose != 0 )
   2280                  mbedtls_printf( "passed\n" );
   2281          
   2282              MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( &X, &Y, &A, &N ) );
   2283          
   2284              MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &U, 16,
   2285                  "256567336059E52CAE22925474705F39A94" ) );
   2286          
   2287              MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &V, 16,
   2288                  "6613F26162223DF488E9CD48CC132C7A" \
   2289                  "0AC93C701B001B092E4E5B9F73BCD27B" \
   2290                  "9EE50D0657C77F374E903CDFA4C642" ) );
   2291          
   2292              if( verbose != 0 )
   2293                  mbedtls_printf( "  MPI test #2 (div_mpi): " );
   2294          
   2295              if( mbedtls_mpi_cmp_mpi( &X, &U ) != 0 ||
   2296                  mbedtls_mpi_cmp_mpi( &Y, &V ) != 0 )
   2297              {
   2298                  if( verbose != 0 )
   2299                      mbedtls_printf( "failed\n" );
   2300          
   2301                  ret = 1;
   2302                  goto cleanup;
   2303              }
   2304          
   2305              if( verbose != 0 )
   2306                  mbedtls_printf( "passed\n" );
   2307          
   2308              MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &X, &A, &E, &N, NULL ) );
   2309          
   2310              MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &U, 16,
   2311                  "36E139AEA55215609D2816998ED020BB" \
   2312                  "BD96C37890F65171D948E9BC7CBAA4D9" \
   2313                  "325D24D6A3C12710F10A09FA08AB87" ) );
   2314          
   2315              if( verbose != 0 )
   2316                  mbedtls_printf( "  MPI test #3 (exp_mod): " );
   2317          
   2318              if( mbedtls_mpi_cmp_mpi( &X, &U ) != 0 )
   2319              {
   2320                  if( verbose != 0 )
   2321                      mbedtls_printf( "failed\n" );
   2322          
   2323                  ret = 1;
   2324                  goto cleanup;
   2325              }
   2326          
   2327              if( verbose != 0 )
   2328                  mbedtls_printf( "passed\n" );
   2329          
   2330              MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &X, &A, &N ) );
   2331          
   2332              MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &U, 16,
   2333                  "003A0AAEDD7E784FC07D8F9EC6E3BFD5" \
   2334                  "C3DBA76456363A10869622EAC2DD84EC" \
   2335                  "C5B8A74DAC4D09E03B5E0BE779F2DF61" ) );
   2336          
   2337              if( verbose != 0 )
   2338                  mbedtls_printf( "  MPI test #4 (inv_mod): " );
   2339          
   2340              if( mbedtls_mpi_cmp_mpi( &X, &U ) != 0 )
   2341              {
   2342                  if( verbose != 0 )
   2343                      mbedtls_printf( "failed\n" );
   2344          
   2345                  ret = 1;
   2346                  goto cleanup;
   2347              }
   2348          
   2349              if( verbose != 0 )
   2350                  mbedtls_printf( "passed\n" );
   2351          
   2352              if( verbose != 0 )
   2353                  mbedtls_printf( "  MPI test #5 (simple gcd): " );
   2354          
   2355              for( i = 0; i < GCD_PAIR_COUNT; i++ )
   2356              {
   2357                  MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &X, gcd_pairs[i][0] ) );
   2358                  MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &Y, gcd_pairs[i][1] ) );
   2359          
   2360                  MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &A, &X, &Y ) );
   2361          
   2362                  if( mbedtls_mpi_cmp_int( &A, gcd_pairs[i][2] ) != 0 )
   2363                  {
   2364                      if( verbose != 0 )
   2365                          mbedtls_printf( "failed at %d\n", i );
   2366          
   2367                      ret = 1;
   2368                      goto cleanup;
   2369                  }
   2370              }
   2371          
   2372              if( verbose != 0 )
   2373                  mbedtls_printf( "passed\n" );
   2374          
   2375          cleanup:
   2376          
   2377              if( ret != 0 && verbose != 0 )
   2378                  mbedtls_printf( "Unexpected error, return code = %08X\n", ret );
   2379          
   2380              mbedtls_mpi_free( &A ); mbedtls_mpi_free( &E ); mbedtls_mpi_free( &N ); mbedtls_mpi_free( &X );
   2381              mbedtls_mpi_free( &Y ); mbedtls_mpi_free( &U ); mbedtls_mpi_free( &V );
   2382          
   2383              if( verbose != 0 )
   2384                  mbedtls_printf( "\n" );
   2385          
   2386              return( ret );
   2387          }
   2388          
   2389          #endif /* MBEDTLS_SELF_TEST */
   2390          
   2391          #endif /* MBEDTLS_BIGNUM_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   mbedtls_mpi_add_abs
        24   -> mbedtls_mpi_copy
        24   -> mbedtls_mpi_grow
      32   mbedtls_mpi_add_int
        32   -> mbedtls_mpi_add_mpi
      24   mbedtls_mpi_add_mpi
        24   -> mbedtls_mpi_add_abs
        24   -> mbedtls_mpi_cmp_abs
        24   -> mbedtls_mpi_sub_abs
       4   mbedtls_mpi_bitlen
       4   mbedtls_mpi_cmp_abs
      32   mbedtls_mpi_cmp_int
        32   -> mbedtls_mpi_cmp_mpi
       4   mbedtls_mpi_cmp_mpi
      24   mbedtls_mpi_copy
        24   -> __aeabi_memcpy4
        24   -> __aeabi_memset4
        24   -> mbedtls_mpi_free
        24   -> mbedtls_mpi_grow
      32   mbedtls_mpi_div_int
        32   -> mbedtls_mpi_div_mpi
     144   mbedtls_mpi_div_mpi
       144   -> mbedtls_mpi_add_mpi
       144   -> mbedtls_mpi_bitlen
       144   -> mbedtls_mpi_cmp_abs
       144   -> mbedtls_mpi_cmp_int
       144   -> mbedtls_mpi_cmp_mpi
       144   -> mbedtls_mpi_copy
       144   -> mbedtls_mpi_free
       144   -> mbedtls_mpi_grow
       144   -> mbedtls_mpi_init
       144   -> mbedtls_mpi_lset
       144   -> mbedtls_mpi_mul_int
       144   -> mbedtls_mpi_shift_l
       144   -> mbedtls_mpi_shift_r
       144   -> mbedtls_mpi_sub_mpi
     120   mbedtls_mpi_exp_mod
       120   -> __aeabi_memcpy4
       120   -> mbedtls_mpi_add_mpi
       120   -> mbedtls_mpi_bitlen
       120   -> mbedtls_mpi_cmp_int
       120   -> mbedtls_mpi_cmp_mpi
       120   -> mbedtls_mpi_copy
       120   -> mbedtls_mpi_free
       120   -> mbedtls_mpi_grow
       120   -> mbedtls_mpi_init
       120   -> mbedtls_mpi_lset
       120   -> mbedtls_mpi_mod_mpi
       120   -> mbedtls_mpi_shift_l
       120   -> mpi_montg_init
       120   -> mpi_montmul
       120   -> mpi_montred
       120   -> pvPortCalloc
       120   -> vPortFree
    1040   mbedtls_mpi_fill_random
      1040   -- Indirect call
      1040   -> mbedtls_mpi_read_binary
       8   mbedtls_mpi_free
         8   -> mbedtls_zeroize
         8   -> vPortFree
      80   mbedtls_mpi_gcd
        80   -> mbedtls_mpi_cmp_int
        80   -> mbedtls_mpi_cmp_mpi
        80   -> mbedtls_mpi_copy
        80   -> mbedtls_mpi_free
        80   -> mbedtls_mpi_init
        80   -> mbedtls_mpi_lsb
        80   -> mbedtls_mpi_shift_l
        80   -> mbedtls_mpi_shift_r
        80   -> mbedtls_mpi_sub_abs
       0   mbedtls_mpi_get_bit
      16   mbedtls_mpi_grow
        16   -> __aeabi_memcpy4
        16   -> mbedtls_zeroize
        16   -> pvPortCalloc
        16   -> vPortFree
       0   mbedtls_mpi_init
         0   -> mbedtls_zeroize
     200   mbedtls_mpi_inv_mod
       200   -> mbedtls_mpi_add_mpi
       200   -> mbedtls_mpi_cmp_int
       200   -> mbedtls_mpi_cmp_mpi
       200   -> mbedtls_mpi_copy
       200   -> mbedtls_mpi_free
       200   -> mbedtls_mpi_gcd
       200   -> mbedtls_mpi_init
       200   -> mbedtls_mpi_lset
       200   -> mbedtls_mpi_mod_mpi
       200   -> mbedtls_mpi_shift_r
       200   -> mbedtls_mpi_sub_mpi
       4   mbedtls_mpi_lsb
      16   mbedtls_mpi_lset
        16   -> __aeabi_memset4
        16   -> mbedtls_mpi_grow
      12   mbedtls_mpi_mod_int
      16   mbedtls_mpi_mod_mpi
        16   -> mbedtls_mpi_add_mpi
        16   -> mbedtls_mpi_cmp_int
        16   -> mbedtls_mpi_cmp_mpi
        16   -> mbedtls_mpi_div_mpi
        16   -> mbedtls_mpi_sub_mpi
      32   mbedtls_mpi_mul_int
        32   -> mbedtls_mpi_mul_mpi
      72   mbedtls_mpi_mul_mpi
        72   -> mbedtls_mpi_copy
        72   -> mbedtls_mpi_free
        72   -> mbedtls_mpi_grow
        72   -> mbedtls_mpi_init
        72   -> mbedtls_mpi_lset
        72   -> mpi_mul_hlp
      24   mbedtls_mpi_read_binary
        24   -> mbedtls_mpi_grow
        24   -> mbedtls_mpi_lset
      56   mbedtls_mpi_read_string
        56   -> mbedtls_mpi_add_int
        56   -> mbedtls_mpi_free
        56   -> mbedtls_mpi_grow
        56   -> mbedtls_mpi_init
        56   -> mbedtls_mpi_lset
        56   -> mbedtls_mpi_mul_int
        56   -> mbedtls_mpi_sub_int
        56   -> mpi_get_digit
        56   -> strlen
      24   mbedtls_mpi_safe_cond_assign
        24   -> mbedtls_mpi_grow
      24   mbedtls_mpi_safe_cond_swap
        24   -> mbedtls_mpi_grow
     176   mbedtls_mpi_self_test
       176   -- Indirect call
       176   -> mbedtls_mpi_cmp_int
       176   -> mbedtls_mpi_cmp_mpi
       176   -> mbedtls_mpi_div_mpi
       176   -> mbedtls_mpi_exp_mod
       176   -> mbedtls_mpi_free
       176   -> mbedtls_mpi_gcd
       176   -> mbedtls_mpi_init
       176   -> mbedtls_mpi_inv_mod
       176   -> mbedtls_mpi_lset
       176   -> mbedtls_mpi_mul_mpi
       176   -> mbedtls_mpi_read_string
      24   mbedtls_mpi_set_bit
        24   -> mbedtls_mpi_grow
      24   mbedtls_mpi_shift_l
        24   -> mbedtls_mpi_bitlen
        24   -> mbedtls_mpi_grow
      16   mbedtls_mpi_shift_r
         0   -> mbedtls_mpi_lset
      16   mbedtls_mpi_shrink
        16   -> __aeabi_memcpy4
         0   -> mbedtls_mpi_grow
        16   -> mbedtls_zeroize
        16   -> pvPortCalloc
        16   -> vPortFree
       8   mbedtls_mpi_size
         8   -> mbedtls_mpi_bitlen
      40   mbedtls_mpi_sub_abs
        40   -> mbedtls_mpi_cmp_abs
        40   -> mbedtls_mpi_copy
        40   -> mbedtls_mpi_free
        40   -> mbedtls_mpi_init
        40   -> mpi_sub_hlp
      32   mbedtls_mpi_sub_int
        32   -> mbedtls_mpi_sub_mpi
      24   mbedtls_mpi_sub_mpi
        24   -> mbedtls_mpi_add_abs
        24   -> mbedtls_mpi_cmp_abs
        24   -> mbedtls_mpi_sub_abs
      32   mbedtls_mpi_swap
        32   -> __aeabi_memcpy4
      24   mbedtls_mpi_write_binary
        24   -> __aeabi_memset
        24   -> mbedtls_mpi_size
      56   mbedtls_mpi_write_string
        56   -> mbedtls_mpi_bitlen
        56   -> mbedtls_mpi_copy
        56   -> mbedtls_mpi_free
        56   -> mbedtls_mpi_init
        56   -> mpi_write_hlp
       0   mbedtls_zeroize
       4   mpi_get_digit
       4   mpi_montg_init
      48   mpi_montmul
        48   -> __aeabi_memcpy4
        48   -> __aeabi_memset4
        48   -> mbedtls_mpi_cmp_abs
        48   -> mpi_mul_hlp
         0   -> mpi_sub_hlp
      40   mpi_montred
        40   -> mpi_montmul
      28   mpi_mul_hlp
      16   mpi_sub_hlp
      24   mpi_write_hlp
        24   -> mbedtls_mpi_cmp_int
        24   -> mbedtls_mpi_div_int
        24   -> mbedtls_mpi_mod_int
        24   -> mpi_write_hlp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable21
       4  ??DataTable21_1
      20  ?_0
     132  ?_1
      28  ?_10
      96  ?_11
      28  ?_12
     100  ?_13
      28  ?_14
      32  ?_15
      16  ?_16
      40  ?_17
       2  ?_18
     132  ?_2
     100  ?_3
     224  ?_4
      28  ?_5
       8  ?_6
       8  ?_7
      36  ?_8
      96  ?_9
      36  gcd_pairs
     168  mbedtls_mpi_add_abs
      48  mbedtls_mpi_add_int
      82  mbedtls_mpi_add_mpi
      66  mbedtls_mpi_bitlen
     116  mbedtls_mpi_cmp_abs
      48  mbedtls_mpi_cmp_int
     148  mbedtls_mpi_cmp_mpi
      96  mbedtls_mpi_copy
      48  mbedtls_mpi_div_int
     946  mbedtls_mpi_div_mpi
     972  mbedtls_mpi_exp_mod
      52  mbedtls_mpi_fill_random
      44  mbedtls_mpi_free
     266  mbedtls_mpi_gcd
      32  mbedtls_mpi_get_bit
     100  mbedtls_mpi_grow
      22  mbedtls_mpi_init
     654  mbedtls_mpi_inv_mod
      50  mbedtls_mpi_lsb
      60  mbedtls_mpi_lset
     118  mbedtls_mpi_mod_int
     100  mbedtls_mpi_mod_mpi
      26  mbedtls_mpi_mul_int
     224  mbedtls_mpi_mul_mpi
     106  mbedtls_mpi_read_binary
     270  mbedtls_mpi_read_string
     104  mbedtls_mpi_safe_cond_assign
     130  mbedtls_mpi_safe_cond_swap
     950  mbedtls_mpi_self_test
      90  mbedtls_mpi_set_bit
     162  mbedtls_mpi_shift_l
     140  mbedtls_mpi_shift_r
     120  mbedtls_mpi_shrink
      12  mbedtls_mpi_size
     116  mbedtls_mpi_sub_abs
      48  mbedtls_mpi_sub_int
      82  mbedtls_mpi_sub_mpi
      42  mbedtls_mpi_swap
      72  mbedtls_mpi_write_binary
     292  mbedtls_mpi_write_string
      18  mbedtls_zeroize
      60  mpi_get_digit
      46  mpi_montg_init
     170  mpi_montmul
      32  mpi_montred
    1988  mpi_mul_hlp
      70  mpi_sub_hlp
     110  mpi_write_hlp
      24  -- Other

 
      2 bytes in section .rodata
 10 936 bytes in section .text
 
 10 936 bytes of CODE  memory
      2 bytes of CONST memory

Errors: none
Warnings: none
