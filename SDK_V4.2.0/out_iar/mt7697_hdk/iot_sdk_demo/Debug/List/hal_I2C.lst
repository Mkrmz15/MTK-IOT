###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       25/Jan/2017  17:35:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\driver\chip\mt7687\src\common\hal_I2C.c
#    Command line =  
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\driver\chip\mt7687\src\common\hal_I2C.c" -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_WIFI_TGN_VERIFY_ENABLE -D MTK_SMTCN_ENABLE -D
#        MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D SUPPORT_MBEDTLS -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-basic.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D MTK_MCS_ENABLE -D MTK_BLE_GPIO_SERVICE -D
#        __BT_DEBUG__ -lcN "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List" -lA
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List"
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj" --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\inc\" -I
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\service\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\dhcpd\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\src\ut_app\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\httpclient\inc\"
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List\hal_I2C.lst
#    Object file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj\hal_I2C.o
#
###############################################################################

C:\LEO\myGit\MTK IOT\SDK_V4.2.0\driver\chip\mt7687\src\common\hal_I2C.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          /*
     36          ** $Log: hal_I2C.c $
     37          **
     38          ** 04 13 2015 leo.hung
     39          ** [DVT][I2C]
     40          ** 1. Fix build error.
     41          **
     42          ** 04 13 2015 leo.hung
     43          ** [DVT][I2C]
     44          ** 1. Update I2C DVT cases.
     45          **
     46          ** 03 24 2015 leo.hung
     47          ** [DVT]
     48          ** 1. Fix build error of r=1.
     49          **
     50          ** 12 16 2014 leo.hung
     51          ** [DVT][I2C]
     52          ** 1. Fix halI2CClearFIFO.
     53          **
     54          ** 11 24 2014 leo.hung
     55          ** [DVT][I2C][PWM]
     56          ** 1. Add Auto regression.
     57          ** 2. Add volatile to fix -Os error.
     58          **
     59          ** 11 24 2014 leo.hung
     60          ** [DVT][IrTx]
     61          ** 1. Add IrTx DVT.
     62          **
     63          ** 11 11 2014 leo.hung
     64          ** [DVT][I2C][PWM]
     65          ** 1. Update I2C DMA mode.
     66          ** 2. Replace PWM field access with bit offset access.
     67          **
     68          ** 11 10 2014 leo.hung
     69          ** [DVT][I2C]
     70          ** 1. Use CPU_FREQUENCY instead of hard code.
     71          **
     72          ** 11 03 2014 leo.hung
     73          ** [DVT][I2C]
     74          ** 1. Seperate I2C clock rate setting for FPGA and Chip.
     75          ** 2. Fix I2C DMA mode setting.
     76          **
     77          ** 10 29 2014 leo.hung
     78          ** [DVT][I2C]
     79          ** 1. Remove parameter ucGModeEn in halI2CMasterCtrl().
     80          **    Config General/Normal mode per transfer instead of init time.
     81          ** 2. Fix halI2CChkStatus() for slave address exist check.
     82          ** 3. Add I2C GDMA mode for Normal and General R/W.
     83          **
     84          ** 10 28 2014 leo.hung
     85          ** [DVT][I2C]
     86          ** 1. Add transfer status check.
     87          ** 2. Add I2C interrupt check.
     88          **
     89          ** 10 27 2014 leo.hung
     90          ** [DVT]
     91          ** 1. Update I2C.
     92          **
     93          ** 10 27 2014 leo.hung
     94          ** [DVT]
     95          ** 1. Update I2C.
     96          **
     97          ** 10 23 2014 leo.hung
     98          ** [DVT]
     99          ** 1. Update I2C.
    100          **
    101          **
    102          */
    103          
    104          /*******************************************************************************
    105          *                         C O M P I L E R   F L A G S
    106          ********************************************************************************
    107          */
    108          
    109          
    110          /*******************************************************************************
    111          *                    E X T E R N A L   R E F E R E N C E S
    112          ********************************************************************************
    113          */
    114          #include "hal_i2c_master.h"
    115          #if defined(HAL_I2C_MASTER_MODULE_ENABLED)
    116          #include <stdio.h>
    117          #include <string.h>
    118          #include "type_def.h"
    119          #include "top.h"
    120          #include "hal_I2C.h"
    121          #include "dma_sw.h"
    122          #include "hal_log.h"
    123          #include "hal_gpt.h"
    124          #include "debug.h"
    125          #include "hal_nvic_internal.h"
    126          
    127          /*******************************************************************************
    128          *                              C O N S T A N T S
    129          ********************************************************************************
    130          */
    131          #define I2C_RW_POLLING    1
    132          
    133          /*******************************************************************************
    134          *                             D A T A   T Y P E S
    135          ********************************************************************************
    136          */
    137          
    138          
    139          /*******************************************************************************
    140          *                            P U B L I C   D A T A
    141          ********************************************************************************
    142          */
    143          
    144          
    145          /*
    146          ========================================================================
    147          Routine Description:
    148          
    149          Note:
    150          ========================================================================
    151          */
    152          #define I2C_ENABLE_POLLING_TIMEOUT
    153          
    154          #ifdef I2C_ENABLE_POLLING_TIMEOUT
    155          #define I2C_POLLING_TIMEOUT_VALUE (131072)  /* Unit:32k. (131072 * 1 / 32k) = 4s */
    156          
    157          static void i2c_master_wait_transaction_finish(IOT_I2C_TypeDef *pI2CTypeDef, uint8_t ucIdx, uint8_t ucI2CIdx, uint8_t is_tx)
    158          {
    159              uint32_t gpt_start_count, gpt_current_count, gpt_duration_count;
    160              hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_32K, &gpt_start_count);
    161              /* polling till transaction finish */
    162              while (1) {
    163                  uint32_t saved_mask;
    164                  saved_mask = save_and_set_interrupt_mask();
    165                  if (1 == is_tx) {
    166                      if (!((!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) && ucIdx < 0xF0)) {
    167                          restore_interrupt_mask(saved_mask);
    168                          break;
    169                      }
    170                  } else {
    171                      if (!((!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))))) {
    172                          restore_interrupt_mask(saved_mask);
    173                          break;
    174                      }
    175                  }
    176                  hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_32K, &gpt_current_count);
    177                  hal_gpt_get_duration_count(gpt_start_count, gpt_current_count, &gpt_duration_count);
    178                  if (I2C_POLLING_TIMEOUT_VALUE < gpt_duration_count) {
    179                      log_hal_error("[I2C%d][is_tx = %d]:polling tiemout!\r\n", ucI2CIdx, is_tx);
    180                      ASSERT(0);
    181                  }
    182                  restore_interrupt_mask(saved_mask);
    183              }
    184          }
    185          #endif
    186          P_IOT_I2C_TypeDef halI2CGetBaseAddr(UINT8 ucI2CIdx)
    187          {
    188              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    189          
    190              if (0 == ucI2CIdx) {
    191                  pI2CTypeDef = (IOT_I2C_TypeDef *)IOT_I2C0_MM_PAD_CON0;
    192              } else if (1 == ucI2CIdx) {
    193                  pI2CTypeDef = (IOT_I2C_TypeDef *)IOT_I2C1_MM_PAD_CON0;
    194              }
    195          
    196              return pI2CTypeDef;
    197          }
    198          
    199          
    200          ENUM_HAL_RET_T halI2CClearFIFO(UINT8 ucI2CIdx, UINT8 ucRxClr, UINT8 ucTxClr)
    201          {
    202              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    203              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    204              UINT32 u4Val = 0;
    205          
    206              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    207              //if (NULL == pI2CTypeDef)
    208              //{
    209              //    return HAL_RET_FAIL;
    210              //}
    211          
    212              u4Val = (pI2CTypeDef->MM_FIFO_CON0);
    213          
    214              if (ucRxClr) {
    215                  u4Val |= (0x1 << I2C_MM_RX_FIFO_CLR_OFFSET);
    216              }
    217          
    218              if (ucTxClr) {
    219                  u4Val |= (0x1 << I2C_MM_TX_FIFO_CLR_OFFSET);
    220              }
    221          
    222              (pI2CTypeDef->MM_FIFO_CON0) |= u4Val;
    223          
    224              return ret;
    225          }
    226          
    227          /*
    228           * ucSCLDRVHEn:
    229           * ucSDADRVHEn:     MM_PAD_CON0[6:5] can decide driving or pulling high of SDA and SCL.
    230           *                  Setting to driving high can reduce some latency, but it is different with spec.
    231           *                  Should NOT enable for normal case.
    232           * ucIntClkSyncEn:  Set MM_PAD_CON[7] to 1 to enable the internal clock synchronization of SDA and SCL inputs.
    233           *                  The glitch is not so many when enabling, but the latency with 2 internal clock cycle will be induced.
    234           * ucDeglitchCnt:   Enable the deglitch circuit by setting MM_PAD_CON[4:0] to non-zero value.
    235           */
    236          ENUM_HAL_RET_T halI2CInit(UINT8 ucI2CIdx, UINT8 ucSCLDRVHEn, UINT8 ucSDADRVHEn, UINT8 ucIntClkSyncEn, UINT8 ucDeglitchCnt)
    237          {
    238              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    239              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    240          
    241              // Sanity check
    242              if (ucDeglitchCnt & (~I2C_DE_CNT_MASK)) {
    243                  return HAL_RET_FAIL;
    244              }
    245          
    246              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    247              //if (NULL == pI2CTypeDef)
    248              //{
    249              //    return HAL_RET_FAIL;
    250              //}
    251          
    252              if (ucSCLDRVHEn) {
    253                  (pI2CTypeDef->MM_PAD_CON0) |= BIT(I2C_SCL_DRVH_EN_OFFSET);
    254              } else {
    255                  (pI2CTypeDef->MM_PAD_CON0) &= (~BIT(I2C_SCL_DRVH_EN_OFFSET));
    256              }
    257          
    258              if (ucSDADRVHEn) {
    259                  (pI2CTypeDef->MM_PAD_CON0) |= BIT(I2C_SDA_DRVH_EN_OFFSET);
    260              } else {
    261                  (pI2CTypeDef->MM_PAD_CON0) &= (~BIT(I2C_SDA_DRVH_EN_OFFSET));
    262              }
    263          
    264              if (ucIntClkSyncEn) {
    265                  (pI2CTypeDef->MM_PAD_CON0) |= BIT(I2C_CLK_SYNC_EN_OFFSET);
    266              } else {
    267                  (pI2CTypeDef->MM_PAD_CON0) &= (~BIT(I2C_CLK_SYNC_EN_OFFSET));
    268              }
    269          
    270              (pI2CTypeDef->MM_PAD_CON0) &= (~I2C_DE_CNT_MASK);
    271              (pI2CTypeDef->MM_PAD_CON0) |= (ucDeglitchCnt << I2C_DE_CNT_OFFSET);
    272          
    273              halI2CClearFIFO(ucI2CIdx, 1, 1);
    274          
    275          
    276              return ret;
    277          }
    278          
    279          /*
    280           * MM_CON0 should be set correctly according to the I2C protocol.
    281           * MM_CON0[15] is used to enable the master function.
    282           * MM_CON0[14] should be 0 in normal usage.
    283           * Then setting MM_CNT_VAL_PHL and MM_CNT_VAL_PHH decide the bit rate of I2C in standard mode or fast mode.
    284           *
    285           * Note: General Mode / Normal Mode is configured per transfer.
    286           */
    287          ENUM_HAL_RET_T halI2CMasterCtrl(UINT8 ucI2CIdx, ENUM_I2C_CLK_T eFrequency)
    288          {
    289              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    290              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    291              UINT32 u4Val = 0;
    292              UINT8 ucPhase1Adj = 0;
    293              UINT32 u4OperFreq = 0;
    294              UINT16 u2PhaseVal = 0;
    295          
    296              // sanity check
    297              if (eFrequency >= I2C_CLK_NUM) {
    298                  return HAL_RET_FAIL;
    299              }
    300          
    301              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    302              //if (NULL == pI2CTypeDef)
    303              //{
    304              //    return HAL_RET_FAIL;
    305              //}
    306          
    307              // Enable I2C transfer W   I2C_BASE + 0x270    [15]    MASTER_EN   1'b1    Set 1 to enable master mode
    308              //                                             [14]    MM_GMODE    1'b0    Set 0 to disable general mode (normal mode)
    309              //                                             [13]    MM_HS_EN    1'b0    Set 0 to disable HS mode
    310              //                                             [12]    MM_TB_EN    1'b0    Set 0 to disable Ten-Bit mode
    311              //                                             [11]    MCU_SEL 1'b0    Set 0 to select DSP I/F
    312              u4Val = (pI2CTypeDef->MM_CON0);
    313              u4Val |= BIT(I2C_MASTER_EN_OFFSET);
    314              u4Val &= (~BIT(I2C_MM_GMODE_OFFSET));
    315              u4Val &= (~BIT(I2C_MM_HS_EN_OFFSET));
    316              u4Val &= (~BIT(I2C_MM_TB_EN_OFFSET));
    317              u4Val &= (~BIT(I2C_MCU_SEL_OFFSET));
    318              (pI2CTypeDef->MM_CON0) = u4Val;
    319          
    320              // Clock rate(Frequency) selection
    321              // Sum of phase0,1,2,3 = 'Bus clock' / 'I2C clock rate'
    322              // Count from 0x0
    323              // Phase1 adjust value
    324              //1. Output register
    325              ucPhase1Adj = 1;
    326              u4Val = (pI2CTypeDef->MM_PAD_CON0);
    327              if (u4Val & BIT(I2C_CLK_SYNC_EN_OFFSET)) {
    328                  // 2. Sync enable
    329                  ucPhase1Adj += 1;
    330              }
    331              // 3. de-glitch (n+4)
    332              ucPhase1Adj += (((u4Val & I2C_DE_CNT_MASK) >> I2C_DE_CNT_OFFSET) + 4);
    333          
    334              // FPGA use 30MHz as I2C operation frequence
    335              // Confirmed with DE, 30M is 30*1000*1000 instead of 30*1024*1024
    336          
    337              u4OperFreq = top_xtal_freq_get(); // CPU_FREQUENCY;
    338              switch (eFrequency) {
    339                  case I2C_CLK_50K:
    340                      // 50KHz
    341                      // 800 = (40000 / 50)
    342                      u2PhaseVal = ((u4OperFreq / (50 * 1000)) / 4) - 1; // Count from 0
    343          
    344                      // Set the value of phase1/0
    345                      // pI2CTypeDef->MM_CNT_VAL_PHL = 0x0000BFC7; // sync disable, de-glitch=3
    346                      // Set the value of phase3/2
    347                      // pI2CTypeDef->MM_CNT_VAL_PHH = 0x0000C7C7;
    348                      break;
    349                  case I2C_CLK_100K:
    350                      // 100KHz
    351                      // 400 = (40000 / 100)
    352                      u2PhaseVal = ((u4OperFreq / (100 * 1000)) / 4) - 1; // Count from 0
    353          
    354                      // Set the value of phase1/0
    355                      // pI2CTypeDef->MM_CNT_VAL_PHL = 0x00005B63; // sync disable, de-glitch=3
    356                      // Set the value of phase3/2
    357                      // pI2CTypeDef->MM_CNT_VAL_PHH = 0x00006363;
    358                      break;
    359                  case I2C_CLK_200K:
    360                      // 200KHz
    361                      // 200 = (40000 / 200)
    362                      u2PhaseVal = ((u4OperFreq / (200 * 1000)) / 4) - 1; // Count from 0
    363          
    364                      // Set the value of phase1/0
    365                      // pI2CTypeDef->MM_CNT_VAL_PHL = 0x00002931; // sync disable, de-glitch=3
    366                      // Set the value of phase3/2
    367                      // pI2CTypeDef->MM_CNT_VAL_PHH = 0x00003131;
    368          
    369                      break;
    370                  case I2C_CLK_300K:
    371                      // 300KHz
    372                      // 300 = (40000 / 300)
    373                      u2PhaseVal = ((u4OperFreq / (300 * 1000)) / 4) - 1; // Count from 0
    374          
    375                      // Set the value of phase1/0
    376                      // pI2CTypeDef->MM_CNT_VAL_PHL = 0x00002931; // sync disable, de-glitch=3
    377                      // Set the value of phase3/2
    378                      // pI2CTypeDef->MM_CNT_VAL_PHH = 0x00003131;
    379          
    380                      break;
    381                  case I2C_CLK_400K:
    382                      // 400KHz
    383                      // 100 = (40000 / 400)
    384                      u2PhaseVal = ((u4OperFreq / (400 * 1000)) / 4) - 1; // Count from 0
    385          
    386                      // Set the value of phase1/0
    387                      // pI2CTypeDef->MM_CNT_VAL_PHL = 0x00001018; // sync disable, de-glitch=3
    388                      // Set the value of phase3/2
    389                      // pI2CTypeDef->MM_CNT_VAL_PHH = 0x00001818;
    390                      break;
    391                  default:
    392                      return HAL_RET_FAIL;
    393                      //break;
    394              }
    395              // Set the value of phase1/0
    396              pI2CTypeDef->MM_CNT_VAL_PHL = (((u2PhaseVal - ucPhase1Adj) << I2C_MM_CNTPHASE_VAL1_OFFSET) | (u2PhaseVal << I2C_MM_CNTPHASE_VAL0_OFFSET));
    397              // Set the value of phase3/2
    398              pI2CTypeDef->MM_CNT_VAL_PHH = ((u2PhaseVal << I2C_MM_CNTPHASE_VAL3_OFFSET) | (u2PhaseVal << I2C_MM_CNTPHASE_VAL2_OFFSET));
    399          
    400              return ret;
    401          }
    402          
    403          /*
    404           *
    405           */
    406          UINT8 halI2CGetFIFOSpace(UINT8 WPtr, UINT8 RPtr)
    407          {
    408          
    409              if (WPtr == RPtr) {
    410                  return I2C_FIFO_MAX_LEN;
    411              } else if ((WPtr & BITS(0, 2)) == (RPtr & BITS(0, 2))) {
    412                  return 0;
    413              }
    414          
    415              WPtr &= BITS(0, 2);
    416              RPtr &= BITS(0, 2);
    417          
    418              if (WPtr > RPtr) {
    419                  return (I2C_FIFO_MAX_LEN - (WPtr - RPtr));
    420              } else {
    421                  return (RPtr - WPtr);
    422              }
    423          }
    424          
    425          /*
    426           * return remaining space length of Tx FIFO
    427           */
    428          UINT8 halI2CTxFIFOSpace(IOT_I2C_TypeDef *pI2CTypeDef)
    429          {
    430          #if 0
    431              UINT8   ucLen = 0;
    432          #endif
    433              UINT8   ucTxWPtr = 0;
    434              UINT8   ucTxRPtr = 0;
    435              UINT32  u4Val = 0;
    436          
    437              u4Val = (pI2CTypeDef->MM_FIFO_PTR);
    438              ucTxWPtr = (u4Val & I2C_MM_TX_FIFO_WPTR_MASK) >> I2C_MM_TX_FIFO_WPTR_OFFSET;
    439              ucTxRPtr = (u4Val & I2C_MM_TX_FIFO_RPTR_MASK) >> I2C_MM_TX_FIFO_RPTR_OFFSET;
    440          
    441              //printf("[%s]ucTxWPtr=%u, ucTxRPtr=%u\n", __FUNCTION__, ucTxWPtr, ucTxRPtr);
    442              return halI2CGetFIFOSpace(ucTxWPtr, ucTxRPtr);
    443          #if 0
    444              if (ucTxWPtr == ucTxRPtr) {
    445                  return I2C_FIFO_MAX_LEN;
    446              } else if ((ucTxWPtr & BITS(0, 2)) == (ucTxRPtr & BITS(0, 2))) {
    447                  return 0;
    448              }
    449          
    450              ucTxWPtr &= BITS(0, 2);
    451              ucTxRPtr &= BITS(0, 2);
    452          
    453              if (ucTxWPtr > ucTxRPtr) {
    454                  ucLen = I2C_FIFO_MAX_LEN - (ucTxWPtr - ucTxRPtr);
    455              } else {
    456                  ucLen = ucTxRPtr - ucTxWPtr;
    457              }
    458              //printf("---len=%u\n", ucLen);
    459          
    460              return ucLen;
    461          #endif
    462          }
    463          
    464          /*
    465           * return remaining space length of Rx FIFO
    466           */
    467          UINT8 halI2CRxFIFOSpace(IOT_I2C_TypeDef *pI2CTypeDef)
    468          {
    469          #if 0
    470              UINT8   ucLen = 0;
    471          #endif
    472              UINT8   ucRxWPtr = 0;
    473              UINT8   ucRxRPtr = 0;
    474              UINT32  u4Val = 0;
    475          
    476              u4Val = (pI2CTypeDef->MM_FIFO_PTR);
    477              ucRxWPtr = (u4Val & I2C_MM_RX_FIFO_WPTR_MASK) >> I2C_MM_RX_FIFO_WPTR_OFFSET;
    478              ucRxRPtr = (u4Val & I2C_MM_RX_FIFO_RPTR_MASK) >> I2C_MM_RX_FIFO_RPTR_OFFSET;
    479              return halI2CGetFIFOSpace(ucRxWPtr, ucRxRPtr);
    480          #if 0
    481              if (ucRxWPtr == ucRxRPtr) {
    482                  return I2C_FIFO_MAX_LEN;
    483              } else if ((ucRxWPtr & BITS(0, 2)) == (ucRxRPtr & BITS(0, 2))) {
    484                  return 0;
    485              }
    486          
    487              ucRxWPtr &= BITS(0, 2);
    488              ucRxRPtr &= BITS(0, 2);
    489          
    490              if (ucRxWPtr > ucRxRPtr) {
    491                  ucLen = I2C_FIFO_MAX_LEN - (ucRxWPtr - ucRxRPtr);
    492              } else {
    493                  ucLen = ucRxRPtr - ucRxWPtr;
    494              }
    495          
    496              return ucLen;
    497          #endif
    498          }
    499          
    500          UINT16 halI2CGetFIFOStatus(UINT8 ucI2CIdx)
    501          {
    502              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    503          
    504              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    505              //if (NULL == pI2CTypeDef)
    506              //{
    507              //    return HAL_RET_FAIL;
    508              //}
    509          
    510              return (pI2CTypeDef->MM_FIFO_STATUS);
    511          }
    512          
    513          /*
    514           * a. Read MM_STATUS[2]. The I2C master circuit is ready for preparing the next trigger if the value is 1.
    515           * b. Write the TX data into the memory or MM_FIFO_DATA according the value of DMA_CON0.
    516           * c. Set a value of MM_ID_CON0 to decide which slave you want to write.
    517           * d. Set MM_PACK_CON0[0] to 0 for write.
    518           * e. Set MM_CON0[0] to 1 to trigger the master to write data to slave.
    519           * f. After setting MM_CON0[0] to 1, the value of MM_STATUS[2] will become 0.
    520           *    Waiting an interrupt or the value of MM_STATUS[2] to 1 to check the TX transfer is over.
    521           */
    522          /*
    523           * ucSlaveAddress[6:0] indicate 7-bit address, bit7 is un-used
    524           */
    525          ENUM_HAL_RET_T halI2CNormalWrite(UINT8 ucI2CIdx, UINT8 ucSlaveAddress, const UINT8 *pucTxData, UINT16 u2Length)
    526          {
    527              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    528              UINT8 ucIdx = 0;
    529              UINT8 ucTxLen = 0;
    530              UINT16 u2Residual = u2Length;
    531              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    532          
    533              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    534              //if (NULL == pI2CTypeDef)
    535              //{
    536              //    return HAL_RET_FAIL;
    537              //}
    538          
    539              // Sanity check
    540              if (!pucTxData) {
    541                  return HAL_RET_FAIL;
    542              }
    543          
    544              // General mode Disable
    545              (pI2CTypeDef->MM_CON0) &= (~BIT(I2C_MM_GMODE_OFFSET));
    546          
    547          
    548              // a. Read MM_STATUS[2]. The I2C master circuit is ready for preparing the next trigger if the value is 1.
    549              if (!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
    550                  printf("[%s](!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET)))\n", __FUNCTION__);
    551                  log_hal_error("[I2C][Normal_Write]  not ready.\r\n");
    552                  return HAL_RET_FAIL;
    553              }
    554          
    555              // b. Write the TX data into the memory or MM_FIFO_DATA according the value of DMA_CON0.
    556              ucTxLen = halI2CTxFIFOSpace(pI2CTypeDef);
    557              if (ucTxLen > u2Length) {
    558                  ucTxLen = u2Length;
    559              }
    560              for (ucIdx = 0; ucIdx < ucTxLen; ucIdx++) {
    561                  (pI2CTypeDef->MM_FIFO_DATA) = (*pucTxData);
    562                  pucTxData++;
    563              }
    564              u2Residual = u2Residual - ucTxLen;
    565          
    566              // c. Set a value of MM_ID_CON0 to decide which slave you want to write.
    567              (pI2CTypeDef->MM_ID_CON0) &= (~I2C_MM_SLAVE_ID_MASK);
    568              (pI2CTypeDef->MM_ID_CON0) |= ((ucSlaveAddress & (I2C_MM_SLAVE_ID_MASK)) << I2C_MM_SLAVE_ID_OFFSET);
    569          
    570              // d. Set MM_PACK_CON0[0] to 0 for write.
    571              (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(I2C_MM_PACK_RW_OFFSET));
    572          
    573              // e. Set MM_CON0[0] to 1 to trigger the master to write data to slave.
    574              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_START_EN_OFFSET);
    575          
    576          //#if (1 != I2C_FIFO_DVT)
    577              while (u2Residual) {
    578                  if (((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
    579                      // Tx transfer already terminated while Tx data not complete send out.
    580                      log_hal_error("[I2C][Normal_Write] return before complete;length=%d.\r\n", u2Length);
    581                      return HAL_RET_FAIL;
    582                  }
    583                  ucTxLen = halI2CTxFIFOSpace(pI2CTypeDef);
    584                  if (0 == ucTxLen) {
    585                      continue;
    586                  }
    587          
    588                  if (ucTxLen > u2Residual) {
    589                      ucTxLen = u2Residual;
    590                  }
    591          
    592                  for (ucIdx = 0; ucIdx < ucTxLen; ucIdx++) {
    593          #if 0
    594                      printf("WPTR=%u, RPTR=%u, ucTxLen=%u\n", (((pI2CTypeDef->MM_FIFO_PTR) & I2C_MM_TX_FIFO_WPTR_MASK) >> I2C_MM_TX_FIFO_WPTR_OFFSET),
    595                             (((pI2CTypeDef->MM_FIFO_PTR) & I2C_MM_TX_FIFO_RPTR_MASK) >> I2C_MM_TX_FIFO_RPTR_OFFSET),
    596                             ucTxLen);
    597          #endif
    598                      (pI2CTypeDef->MM_FIFO_DATA) = (*pucTxData);
    599                      pucTxData++;
    600                  }
    601                  u2Residual = u2Residual - ucTxLen;
    602              }
    603          //#endif //#if (1 != I2C_FIFO_DVT)
    604          
    605          #if I2C_RW_POLLING
    606              // f. After setting MM_CON0[0] to 1, the value of MM_STATUS[2] will become 0.
    607              //    Waiting an interrupt or the value of MM_STATUS[2] to 1 to check the TX transfer is over.
    608          #ifndef I2C_ENABLE_POLLING_TIMEOUT
    609              do {
    610                  // busy waiting
    611              } while ((!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) && ucIdx < 0xF0);
    612          #else
    613              i2c_master_wait_transaction_finish(pI2CTypeDef, ucIdx, ucI2CIdx, 1);
    614          #endif
    615          #endif
    616          
    617              if (I2C_TRANS_STATUS_OK != halI2CChkStatus(ucI2CIdx, 1, (1 + u2Length))) {
    618                  log_hal_error("[I2C][Normal_Write] error_status = %d.\r\n", halI2CChkStatus(ucI2CIdx, 1, (1 + u2Length)));
    619                  return HAL_RET_FAIL;
    620              }
    621          
    622              return ret;
    623          }
    624          
    625          
    626          /*
    627           * a. Read MM_STATUS[2] as 1.
    628           * b. Set MM_ID_CON0 and MM_ID_CON1 for slave address.
    629           * c. Set MM_PACK_CON0[0] to 1 for read.
    630           * d. Set the MM_CNT_BYTE_VAL_PK0 to decide how many data to be read.
    631           * e. Set MM_CON0[0] to 1
    632           * f. wait RX transfer over by interrupt or polling the value of MM_STATUS[2].
    633           */
    634          ENUM_HAL_RET_T halI2CNormalRead(UINT8 ucI2CIdx, UINT8 ucSlaveAddress, PUINT8 pucRxData, UINT16 u2Length)
    635          {
    636              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    637              UINT16  u2RetriveLen = 0;
    638              UINT16  u2Residual = u2Length;
    639              UINT8   ucRxBufIdx = 0;
    640              UINT16  u2Idx = 0;
    641              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    642          
    643              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    644              //if (NULL == pI2CTypeDef)
    645              //{
    646              //    printf("[%s](NULL == pI2CTypeDef)\n", __FUNCTION__);
    647              //    return HAL_RET_FAIL;
    648              //}
    649          
    650              if (NULL == pucRxData) {
    651                  return HAL_RET_FAIL;
    652              }
    653          
    654              // General mode Disable
    655              (pI2CTypeDef->MM_CON0) &= (~BIT(I2C_MM_GMODE_OFFSET));
    656          
    657              // a. Read MM_STATUS[2] as 1.
    658              if (!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
    659                  printf("[%s](!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET)))\n", __FUNCTION__);
    660                  log_hal_error("[I2C][Normal_Read]  not ready.\r\n");
    661                  return HAL_RET_FAIL;
    662              }
    663          
    664              // b. Set MM_ID_CON0 and MM_ID_CON1 for slave address.
    665              (pI2CTypeDef->MM_ID_CON0) &= (~I2C_MM_SLAVE_ID_MASK);
    666              (pI2CTypeDef->MM_ID_CON0) |= ((ucSlaveAddress & (I2C_MM_SLAVE_ID_MASK)) << I2C_MM_SLAVE_ID_OFFSET);
    667          
    668              // c. Set MM_PACK_CON0[0] to 1 for read.
    669              (pI2CTypeDef->MM_PACK_CON0) |= BIT(I2C_MM_PACK_RW_OFFSET);
    670          
    671              // d. Set the MM_CNT_BYTE_VAL_PK0 to decide how many data to be read.
    672              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK0) = u2Length;
    673          
    674              // e. Set MM_CON0[0] to 1
    675              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_START_EN_OFFSET);
    676          
    677              if (pucRxData) {
    678                  while (u2Residual) {
    679                      if ((((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) && ((pI2CTypeDef->MM_ACK_VAL) & 0x1)) {
    680                          log_hal_error("[I2C][Normal_Read] return before complete;length=%d\r\n", u2Length);
    681                          return HAL_RET_FAIL;
    682                          // Rx transfer already terminated while not get enough data.
    683                          // for example, an ack error happened. so we need also check
    684                          // if ack happened.
    685                      }
    686          
    687                      u2RetriveLen = (I2C_FIFO_MAX_LEN - halI2CRxFIFOSpace(pI2CTypeDef));
    688                      if (0 == u2RetriveLen) {
    689                          continue;
    690                      }
    691                      if (u2RetriveLen > u2Residual) {
    692                          u2RetriveLen = u2Residual;
    693                      }
    694                      for (u2Idx = 0; u2Idx < u2RetriveLen; u2Idx++) {
    695          #if 0
    696                          printf("WPTR=%u, RPTR=%u, u2RetriveLen=%u\n", (((pI2CTypeDef->MM_FIFO_PTR) & I2C_MM_RX_FIFO_WPTR_MASK) >> I2C_MM_RX_FIFO_WPTR_OFFSET),
    697                                 (((pI2CTypeDef->MM_FIFO_PTR) & I2C_MM_RX_FIFO_RPTR_MASK) >> I2C_MM_RX_FIFO_RPTR_OFFSET),
    698                                 u2RetriveLen);
    699          #endif
    700          
    701                          pucRxData[ucRxBufIdx] = (pI2CTypeDef->MM_FIFO_DATA);
    702                          ucRxBufIdx++;
    703                      }
    704                      u2Residual = u2Residual - u2RetriveLen;
    705                  }
    706              }
    707          
    708          #if I2C_RW_POLLING
    709              // f. wait RX transfer over by interrupt or polling the value of MM_STATUS[2].
    710          #ifndef I2C_ENABLE_POLLING_TIMEOUT
    711              do {
    712                  // busy waiting
    713              } while ((!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))));
    714          #else
    715              i2c_master_wait_transaction_finish(pI2CTypeDef, 0, ucI2CIdx, 0);
    716          
    717          #endif
    718          #endif // #if I2C_RW_POLLING
    719          
    720          #if 0
    721              printf("[halI2CNormalRead]\n------------\n");
    722              if (pucRxData) {
    723                  for (u2Idx = 0; u2Idx < u2Length; u2Idx++) {
    724                      printf("0x%02X ", pucRxData[u2Idx]);
    725                      if (0 == ((u2Idx + 1) & 0x7)) {
    726                          printf("\n");
    727                      }
    728                  }
    729              }
    730              printf("\n------------\n");
    731          #endif
    732          
    733              if (I2C_TRANS_STATUS_OK != halI2CChkStatus(ucI2CIdx, 1, 1)) {
    734                  log_hal_error("[I2C][Normal_Read] error_status = %d.\r\n", halI2CChkStatus(ucI2CIdx, 1, 1));
    735                  return HAL_RET_FAIL;
    736              }
    737          
    738              return ret;
    739          }
    740          
    741          #define I2C_GM_RX_LOG 0
    742          
    743          /*
    744             ucPkt0/1/2RW:    0: write
    745                              1: read
    746           */
    747          ENUM_HAL_RET_T halI2CGeneralRW(UINT8 ucI2CIdx,
    748                                         UINT8 ucSlaveAddress,
    749                                         PUINT8 pucTxData,
    750                                         PUINT8 pucRxData,
    751                                         UINT8 ucPktNum,
    752                                         UINT8 ucPkt0RW,
    753                                         UINT16 u2Pkt0Len,
    754                                         UINT8 ucPkt1RW,
    755                                         UINT16 u2Pkt1Len,
    756                                         UINT8 ucPkt2RW,
    757                                         UINT16 u2Pkt2Len)
    758          {
    759              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    760              UINT16  u2Idx = 0;
    761              UINT16  u2TxLen = 0;
    762              UINT16  u2TxResidual = 0;
    763              UINT16  u2RxLen = 0;
    764              UINT16  u2RxResidual = 0;
    765              UINT16  u2RxBufIdx = 0;
    766              UINT16  u2AckLen = 0;
    767              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    768          #if (1 == I2C_GM_RX_LOG)
    769              UINT16  u2RxLogLen = 0;
    770          #endif
    771          
    772              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    773              //if (NULL == pI2CTypeDef)
    774              //{
    775              //    return HAL_RET_FAIL;
    776              //}
    777          
    778              // Sanity check
    779              if (ucPktNum > I2C_PKT_MAX_NUM) {
    780                  return HAL_RET_FAIL;
    781              }
    782          
    783              if ((!pucTxData) || (!pucRxData)) {
    784                  return HAL_RET_FAIL;
    785              }
    786          
    787              // General mode enable
    788              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_GMODE_OFFSET);
    789          
    790              // a. Read MM_STATUS[2]. The I2C master circuit is ready for preparing the next trigger if the value is 1.
    791              if (!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
    792                  printf("[%s](!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET)))\n", __FUNCTION__);
    793                  log_hal_error("[I2C][General_RW]  not ready.\r\n");
    794                  return HAL_RET_FAIL;
    795              }
    796          
    797              // b. Set a value of MM_ID_CON0 to decide which slave you want to write.
    798              (pI2CTypeDef->MM_ID_CON0) &= (~I2C_MM_SLAVE_ID_MASK);
    799              (pI2CTypeDef->MM_ID_CON0) |= ((ucSlaveAddress & (I2C_MM_SLAVE_ID_MASK)) << I2C_MM_SLAVE_ID_OFFSET);
    800          
    801              // c. Set MM_PACK_CON0[5:4] packet number.
    802              (pI2CTypeDef->MM_PACK_CON0) &= ~(I2C_MM_PACK_VAL_MASK);
    803              (pI2CTypeDef->MM_PACK_CON0) |= ((ucPktNum - 1) << I2C_MM_PACK_VAL_OFFSET);
    804          
    805              // d. Set the MM_CNT_BYTE_VAL_PK0/1/2 to decide data length.
    806              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK0) = u2Pkt0Len;
    807              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK1) = u2Pkt1Len;
    808              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK2) = u2Pkt2Len;
    809          
    810              // e. Set each PKT's R/W mode
    811              if (ucPktNum) {
    812                  if (ucPkt0RW) {
    813                      // read
    814                      u2RxResidual += u2Pkt0Len;
    815                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(0);
    816                  } else {
    817                      // write
    818                      u2TxResidual += u2Pkt0Len;
    819                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(0));
    820                  }
    821                  ucPktNum--;
    822              }
    823              if (ucPktNum) {
    824                  if (ucPkt1RW) {
    825                      // read
    826                      u2RxResidual += u2Pkt1Len;
    827                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(1);
    828                  } else {
    829                      // write
    830                      u2TxResidual += u2Pkt1Len;
    831                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(1));
    832                  }
    833                  ucPktNum--;
    834              }
    835              if (ucPktNum) {
    836                  if (ucPkt2RW) {
    837                      // read
    838                      u2RxResidual += u2Pkt2Len;
    839                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(2);
    840                  } else {
    841                      // write
    842                      u2TxResidual += u2Pkt2Len;
    843                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(2));
    844                  }
    845                  ucPktNum--;
    846              }
    847          #if (1 == I2C_GM_RX_LOG)
    848              u2RxLogLen = u2RxResidual;
    849          #endif
    850              u2AckLen = ucPktNum + u2TxResidual;
    851          
    852          
    853              // f. Write the TX data into the memory or MM_FIFO_DATA according the value of DMA_CON0.
    854              u2TxLen = halI2CTxFIFOSpace(pI2CTypeDef);
    855              if (u2TxLen > u2TxResidual) {
    856                  u2TxLen = u2TxResidual;
    857              }
    858              for (u2Idx = 0; u2Idx < u2TxLen; u2Idx++) {
    859                  (pI2CTypeDef->MM_FIFO_DATA) = (*pucTxData);
    860                  pucTxData++;
    861              }
    862              u2TxResidual = u2TxResidual - u2TxLen;
    863          
    864              // g. Set MM_CON0[0] to 1 to trigger the master to write data to slave.
    865              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_START_EN_OFFSET);
    866          
    867              while (u2TxResidual || u2RxResidual) {
    868                  //if ((0 != u2TxResidual) && ((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET)))
    869                  if (((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
    870                      // Tx transfer already terminated while Tx data not complete send out.
    871                      // Rx transfer already terminated while not get enough data.
    872                      return HAL_RET_FAIL;
    873                  }
    874                  u2RxLen = (I2C_FIFO_MAX_LEN - halI2CRxFIFOSpace(pI2CTypeDef));
    875                  u2TxLen = halI2CTxFIFOSpace(pI2CTypeDef);
    876                  if ((0 == u2RxLen) && (0 == u2TxLen)) {
    877                      continue;
    878                  }
    879                  // Tx
    880                  if (u2TxLen > u2TxResidual) {
    881                      u2TxLen = u2TxResidual;
    882                  }
    883          
    884                  for (u2Idx = 0; u2Idx < u2TxLen; u2Idx++) {
    885                      (pI2CTypeDef->MM_FIFO_DATA) = (*pucTxData);
    886                      pucTxData++;
    887                  }
    888                  u2TxResidual = u2TxResidual - u2TxLen;
    889          
    890                  // Rx
    891                  if (u2RxLen > u2RxResidual) {
    892                      u2RxLen = u2RxResidual;
    893                  }
    894                  for (u2Idx = 0; u2Idx < u2RxLen; u2Idx++) {
    895                      pucRxData[u2RxBufIdx] = (pI2CTypeDef->MM_FIFO_DATA);
    896                      u2RxBufIdx++;
    897                  }
    898                  u2RxResidual = u2RxResidual - u2RxLen;
    899          
    900              }
    901          
    902          #if I2C_RW_POLLING // only for debug 
    903              // h. After setting MM_CON0[0] to 1, the value of MM_STATUS[2] will become 0.
    904              //    Waiting an interrupt or the value of MM_STATUS[2] to 1 to check the TX transfer is over.
    905          #ifndef I2C_ENABLE_POLLING_TIMEOUT
    906              do {
    907                  // busy waiting
    908          
    909              } while ((!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))));
    910          #else
    911              i2c_master_wait_transaction_finish(pI2CTypeDef, 0, ucI2CIdx, 0);
    912          #endif
    913          #endif // only for debug 
    914          
    915          #if (1 == I2C_GM_RX_LOG)
    916              printf("[%s] Rx FiFo\n------------\n", __FUNCTION__);
    917              if (pucRxData) {
    918                  for (u2Idx = 0; u2Idx < u2RxLogLen; u2Idx++) {
    919                      printf("0x%02X ", pucRxData[u2Idx]);
    920                      if (0 == ((u2Idx + 1) & 0x7)) {
    921                          printf("\n");
    922                      }
    923                  }
    924              }
    925              printf("\n------------\n");
    926          #endif
    927          
    928              if (I2C_TRANS_STATUS_OK != halI2CChkStatus(ucI2CIdx, ucPktNum, u2AckLen)) {
    929                  return HAL_RET_FAIL;
    930              }
    931          
    932              return ret;
    933          }
    934          
    935          /*
    936           * [Arbitration]
    937           * MM_STATUS[1] will become 1 to indicate that there is arbitration lose in the transfer before.
    938           * The data of TX may not be write out correctly or the data of RX may not be read correctly when arbitration lose.
    939           * Write MM_STATUS[1] as 1 to clear the value of this bit.
    940           *
    941           * [ACK bit map]
    942           * The MM_PACK_CON0[0] in standard/fast mode or MM_PACK_CON0[1] in high speed mode should be 0 to indicate the slave exist on the bus outside.
    943           * If the value is 1, the transfer will stop after the slave address has transmitted, because there is no slave to give an acknowledge bit.
    944           *
    945           * [FIFO status]
    946           * MM_FIFO_STATUS should also be checked after transfer when using FIFO mode.
    947           * There are overflow, underflow, full, and empty flags of each TX or RX FIFO.
    948           * Write MM_FIFO_CON0[1] or MM_FIFO_CON0[0] as 1 to clear the related FIFO status of TX FIFO or RX FIFO.
    949           *
    950           * ucPktNum:    Normal mode: alwasy 1
    951           *              General mode: according to pkt number 1 ~ 3
    952           * ucAckLen:    RECEIVED ack number including "slave address" and "Tx data".
    953           *              NOT including "Ack for Rx data" which is SENT by master.
    954           */
    955          ENUM_I2C_TRANS_STATUS_T halI2CChkStatus(UINT8 ucI2CIdx, UINT8 ucPktNum, UINT8 ucAckLen)
    956          {
    957              ENUM_I2C_TRANS_STATUS_T ret = I2C_TRANS_STATUS_OK;
    958              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    959              UINT32 u4Val = 0;
    960              UINT8 ucAckCheckLen = 0;
    961              UINT8 ucPktAckVal = 0;
    962              UINT8 i = 0;
    963          
    964              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    965              //if (NULL == pI2CTypeDef)
    966              //{
    967              //    return I2C_TRANS_STATUS_FAIL;
    968              //}
    969          
    970              // [Arbitration]
    971              if ((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_ARB_HAD_LOSE_OFFSET)) {
    972                  // Arbitration lose
    973                  return I2C_TRANS_STATUS_ARBITRATE;
    974              }
    975          
    976              // [ACK bit map]
    977              u4Val = (pI2CTypeDef->MM_ACK_VAL);
    978              ucPktAckVal = (u4Val >> (I2C_ACK_PKT0_OFFSET));
    979          
    980              // Check slave address exist
    981              for (i = 0; i < ucPktNum; i++) {
    982                  if (ucPktAckVal & (0x1 << i)) {
    983                      return I2C_TRANS_STATUS_SLAVE_NOT_EXIST;
    984                  }
    985              }
    986          
    987              // Check ACK for data
    988              // Only last 8 received ACK are recorded
    989              ucAckCheckLen = ucAckLen;
    990              if (ucAckLen > 8) {
    991                  ucAckCheckLen = 8;
    992              }
    993              for (i = 0; i < ucAckCheckLen; i++) {
    994                  if (u4Val & (0x1 << i)) {
    995                      return I2C_TRANS_STATUS_NACK;
    996                  }
    997              }
    998          
    999              // [FIFO status]
   1000              // Success Tx/Rx transfer should complete with Tx/Rx FIFO EMPTY
   1001              if (0x11 != halI2CGetFIFOStatus(ucI2CIdx)) {
   1002                  return I2C_TRANS_STATUS_FIFO_FLOW;
   1003              }
   1004          
   1005              return ret;
   1006          }
   1007          
   1008          ENUM_I2C_TRANS_STATUS_T halI2CGetBusyStatus(UINT8 ucI2CIdx)
   1009          {
   1010              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
   1011              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
   1012              //if (NULL == pI2CTypeDef)
   1013              //{
   1014              //    return I2C_TRANS_STATUS_FAIL;
   1015              //}
   1016              return (ENUM_I2C_TRANS_STATUS_T)((pI2CTypeDef->MM_STATUS) & BIT(I2C_BUS_BUSY_OFFSET));
   1017          }
   1018          /*
   1019           * I2C module build-in DMA is NOT supported in MT7687.
   1020           * Leverage GDMA to do I2C+DMA access.
   1021           */
   1022          ENUM_HAL_RET_T halI2CGDMACtrl(UINT8 ucI2CIdx, UINT8 ucGDMAIdx, UINT8 ucTxMode, UINT16 u2Len, const UINT8 *pucMemAddr)
   1023          {
   1024              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
   1025              IOT_I2C_HALF_GDMA_TypeDef *pI2CHalfGDMATypeDef = NULL;
   1026              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
   1027              UINT32 u4Val = 0;
   1028          
   1029              // Sanity Check
   1030              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
   1031              if (NULL == pI2CTypeDef) {
   1032          //        return HAL_RET_FAIL;
   1033              }
   1034              // I2C MUST use half channel DMA
   1035              if ((ucGDMAIdx < 3) || (ucGDMAIdx > 12)) {
   1036                  return HAL_RET_FAIL;
   1037              }
   1038          
   1039          
   1040              /* set GDMA PDN */
   1041              DMA_Clock_Enable(ucGDMAIdx);
   1042          
   1043          
   1044          
   1045              pI2CHalfGDMATypeDef = (IOT_I2C_HALF_GDMA_TypeDef *)(CM4_DMA_BASE + (ucGDMAIdx * 0x100) + I2C_GDMA_DMAN_WPPT_OFFSET);
   1046          
   1047              /* Set DMA limiter to slowdown DMA. Avoid DMA and I2C handshake error */
   1048              (pI2CHalfGDMATypeDef->DMAn_LIMITER) = 0x80;
   1049          
   1050              // Set GDMA transfer count W   GDMA_BASE + 0x0N10  [15:0]  LEN USER_DEFINED    Unit is byte
   1051              (pI2CHalfGDMATypeDef->DMAn_COUNT) = (((pI2CHalfGDMATypeDef->DMAn_COUNT) & (~BITS(0, 15))) | u2Len);
   1052          
   1053              // Set GDMA source address	W	GDMA_BASE + 0x0N2C	[31:0]	PGMADDR	USER_DEFINED	The address in memory
   1054              (pI2CHalfGDMATypeDef->DMAn_PGMADDR) = (UINT32)(pucMemAddr);
   1055          
   1056              // Set GDMA configurations W   GDMA_BASE + 0x0N14
   1057              u4Val = (pI2CHalfGDMATypeDef->DMAn_CON);
   1058              if (0 == ucI2CIdx) {
   1059                  // [25:20] MAS 6'd2 or 6'd4    Set 6'd2/6'd4 for I2C-1/2 TX respectively
   1060                  // [25:20] MAS 6'd3 or 6'd5    Set 6'd3/6'd5 for I2C-1/2 RX respectively
   1061                  if (1 == ucTxMode) {
   1062                      // Tx
   1063                      u4Val = (u4Val & (~BITS(20, 25))) | (0x2 << 20);
   1064                      u4Val = (u4Val & (~BIT(18)));
   1065                  } else {
   1066                      // Rx
   1067                      u4Val = (u4Val & (~BITS(20, 25))) | (0x3 << 20);
   1068                      u4Val = (u4Val | BIT(18));
   1069                  }
   1070              } else if (1 == ucI2CIdx) {
   1071                  // [25:20] MAS 6'd2 or 6'd4    Set 6'd2/6'd4 for I2C-1/2 TX respectively
   1072                  // [25:20] MAS 6'd3 or 6'd5    Set 6'd3/6'd5 for I2C-1/2 RX respectively
   1073                  if (1 == ucTxMode) {
   1074                      // Tx
   1075                      u4Val = (u4Val & (~BITS(20, 25))) | (0x4 << 20);
   1076                  } else {
   1077                      // Rx
   1078                      u4Val = (u4Val & (~BITS(20, 25))) | (0x5 << 20);
   1079                  }
   1080              }
   1081          
   1082              if (1 == ucTxMode) {
   1083                  // Tx
   1084                  // [18]    DIR 1'b0    Set 0 for Read (RAM to I2C) I2C Tx
   1085                  u4Val = (u4Val & (~BIT(18)));
   1086          
   1087                  //[3] DINC    1'b0    Set 0 to disable incremental address
   1088                  u4Val = (u4Val & (~BIT(3)));
   1089                  //[2] SINC    1'b1    Set 1 to enable incremental address
   1090                  u4Val = (u4Val | BIT(2));
   1091              } else {
   1092                  // Rx
   1093                  // [18]    DIR 1'b1    Set 1 for Write (I2C to RAM) I2C Rx
   1094                  u4Val = (u4Val | BIT(18));
   1095          
   1096                  //[3] DINC    1'b1    Set 1 to enable incremental address
   1097                  u4Val = (u4Val | BIT(3));
   1098                  //[2] SINC    1'b0    Set 0 to disable incremental address
   1099                  u4Val = (u4Val & (~BIT(2)));
   1100              }
   1101          
   1102              // [17]    WPEN    1'b0    Set 0 to disable wrapping
   1103              u4Val = (u4Val & (~BIT(17)));
   1104              // [15]    ITEN    1'b0    Set 0 to disable interrupt
   1105              u4Val = (u4Val & (~BIT(15)));
   1106              // [10:8]  BURST   3'b000  Set 0 for single-byte burst
   1107              u4Val = (u4Val & (~BITS(8, 10)));
   1108              // [5] B2W 1'b0    Set 0 to disable
   1109              u4Val = (u4Val & (~BIT(5)));
   1110              // [4] DREQ    1'b1    Set 1 to enable HW handshake
   1111              u4Val = (u4Val | BIT(4));
   1112              // [1:0]   SIZE    2'b00   Set 0 for single-byte transfer
   1113              u4Val = (u4Val & (~BITS(0, 1)));
   1114              (pI2CHalfGDMATypeDef->DMAn_CON) = u4Val;
   1115          
   1116          
   1117              // Enable GDMA W   GDMA_BASE + 0x0N18  [15]    STR 1'b0    Set 0 to reset DMA transfer
   1118              //             W   GDMA_BASE + 0x0N18  [15]    STR 1'b1    Set 1 to start DMA transfer
   1119              u4Val = (pI2CHalfGDMATypeDef->DMAn_START);
   1120              (pI2CHalfGDMATypeDef->DMAn_START) = (u4Val & (~BIT(15)));
   1121              (pI2CHalfGDMATypeDef->DMAn_START) = (u4Val | BIT(15));
   1122          
   1123          
   1124              return ret;
   1125          }
   1126          
   1127          
   1128          ENUM_HAL_RET_T halI2CGDMANormalWrite(UINT8 ucI2CIdx, UINT8 ucGDMAIdx, UINT8 ucSlaveAddress, const UINT8 *pucTxData, UINT16 u2Length)
   1129          {
   1130              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
   1131              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
   1132          
   1133              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
   1134              //if (NULL == pI2CTypeDef)
   1135              //{
   1136              //    return HAL_RET_FAIL;
   1137              // }
   1138          
   1139              // Sanity check
   1140              if (!pucTxData) {
   1141                  return HAL_RET_FAIL;
   1142              }
   1143          
   1144              // General mode Disable
   1145              (pI2CTypeDef->MM_CON0) &= (~BIT(I2C_MM_GMODE_OFFSET));
   1146          
   1147          
   1148              // a. Read MM_STATUS[2]. The I2C master circuit is ready for preparing the next trigger if the value is 1.
   1149              if (!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
   1150                  log_hal_error("[I2C][DMA_Write] busy;length=%d.\r\n", u2Length);
   1151                  return HAL_RET_FAIL;
   1152              }
   1153              // b. Configure GDMA for Tx data.
   1154              halI2CGDMACtrl(ucI2CIdx, ucGDMAIdx, 1, u2Length, pucTxData);
   1155          
   1156              // c. Set a value of MM_ID_CON0 to decide which slave you want to write.
   1157              (pI2CTypeDef->MM_ID_CON0) &= (~I2C_MM_SLAVE_ID_MASK);
   1158              (pI2CTypeDef->MM_ID_CON0) |= ((ucSlaveAddress & (I2C_MM_SLAVE_ID_MASK)) << I2C_MM_SLAVE_ID_OFFSET);
   1159          
   1160              // d. Set MM_PACK_CON0[0] to 0 for write.
   1161              (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(I2C_MM_PACK_RW_OFFSET));
   1162          
   1163              // e. Set MM_CON0[0] to 1 to trigger the master to write data to slave.
   1164              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_START_EN_OFFSET);
   1165          
   1166              return ret;
   1167          }
   1168          
   1169          ENUM_HAL_RET_T halI2CGDMANormalRead(UINT8 ucI2CIdx, UINT8 ucGDMAIdx, UINT8 ucSlaveAddress, PUINT8 pucRxData, UINT16 u2Length)
   1170          {
   1171              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
   1172              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
   1173          
   1174              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
   1175              //if (NULL == pI2CTypeDef)
   1176              //{
   1177              //    printf("[%s](NULL == pI2CTypeDef)\n", __FUNCTION__);
   1178              //    return HAL_RET_FAIL;
   1179              //}
   1180          
   1181              if (NULL == pucRxData) {
   1182                  return HAL_RET_FAIL;
   1183              }
   1184          
   1185              // General mode Disable
   1186              (pI2CTypeDef->MM_CON0) &= (~BIT(I2C_MM_GMODE_OFFSET));
   1187          
   1188              // a. Read MM_STATUS[2] as 1.
   1189              if (!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
   1190                  printf("[%s](!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET)))\n", __FUNCTION__);
   1191                  log_hal_error("[I2C][DMA_Read] busy;length=%d.\r\n", u2Length);
   1192                  return HAL_RET_FAIL;
   1193              }
   1194          
   1195              // b. Set MM_ID_CON0 and MM_ID_CON1 for slave address.
   1196              (pI2CTypeDef->MM_ID_CON0) &= (~I2C_MM_SLAVE_ID_MASK);
   1197              (pI2CTypeDef->MM_ID_CON0) |= ((ucSlaveAddress & (I2C_MM_SLAVE_ID_MASK)) << I2C_MM_SLAVE_ID_OFFSET);
   1198          
   1199              // c. Set MM_PACK_CON0[0] to 1 for read.
   1200              (pI2CTypeDef->MM_PACK_CON0) |= BIT(I2C_MM_PACK_RW_OFFSET);
   1201          
   1202              // d. Set the MM_CNT_BYTE_VAL_PK0 to decide how many data to be read.
   1203              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK0) = u2Length;
   1204          
   1205              // Configure GDMA for Rx data.
   1206              halI2CGDMACtrl(ucI2CIdx, ucGDMAIdx, 0, u2Length, pucRxData);
   1207          
   1208              // e. Set MM_CON0[0] to 1
   1209              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_START_EN_OFFSET);
   1210          
   1211              return ret;
   1212          }
   1213          
   1214          ENUM_HAL_RET_T halI2CGDMAGeneralRW(UINT8 ucI2CIdx,
   1215                                             UINT8 ucTxGDMAIdx,
   1216                                             UINT8 ucRxGDMAIdx,
   1217                                             UINT8 ucSlaveAddress,
   1218                                             PUINT8 pucTxData,
   1219                                             PUINT8 pucRxData,
   1220                                             UINT8 ucPktNum,
   1221                                             UINT8 ucPkt0RW,
   1222                                             UINT16 u2Pkt0Len,
   1223                                             UINT8 ucPkt1RW,
   1224                                             UINT16 u2Pkt1Len,
   1225                                             UINT8 ucPkt2RW,
   1226                                             UINT16 u2Pkt2Len)
   1227          {
   1228              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
   1229          
   1230              UINT16  u2TxResidual = 0;
   1231              UINT16  u2RxResidual = 0;
   1232          
   1233              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
   1234          
   1235              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
   1236              //if (NULL == pI2CTypeDef)
   1237              //{
   1238              //    return HAL_RET_FAIL;
   1239              //}
   1240          
   1241              // Sanity check
   1242              if (ucPktNum > I2C_PKT_MAX_NUM) {
   1243                  return HAL_RET_FAIL;
   1244              }
   1245          
   1246              if ((!pucTxData) || (!pucRxData)) {
   1247                  return HAL_RET_FAIL;
   1248              }
   1249          
   1250              // General mode enable
   1251              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_GMODE_OFFSET);
   1252          
   1253              // a. Read MM_STATUS[2]. The I2C master circuit is ready for preparing the next trigger if the value is 1.
   1254              if (!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
   1255                  printf("[%s](!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET)))\n", __FUNCTION__);
   1256                  log_hal_error("[I2C][DMA_RW]  not ready.\r\n");
   1257                  return HAL_RET_FAIL;
   1258              }
   1259          
   1260              // b. Set a value of MM_ID_CON0 to decide which slave you want to write.
   1261              (pI2CTypeDef->MM_ID_CON0) &= (~I2C_MM_SLAVE_ID_MASK);
   1262              (pI2CTypeDef->MM_ID_CON0) |= ((ucSlaveAddress & (I2C_MM_SLAVE_ID_MASK)) << I2C_MM_SLAVE_ID_OFFSET);
   1263          
   1264              // c. Set MM_PACK_CON0[5:4] packet number.
   1265              (pI2CTypeDef->MM_PACK_CON0) &= ~(I2C_MM_PACK_VAL_MASK);
   1266              (pI2CTypeDef->MM_PACK_CON0) |= ((ucPktNum - 1) << I2C_MM_PACK_VAL_OFFSET);
   1267          
   1268              // d. Set the MM_CNT_BYTE_VAL_PK0/1/2 to decide data length.
   1269              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK0) = u2Pkt0Len;
   1270              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK1) = u2Pkt1Len;
   1271              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK2) = u2Pkt2Len;
   1272          
   1273              // e. Set each PKT's R/W mode
   1274              if (ucPktNum) {
   1275                  if (ucPkt0RW) {
   1276                      // read
   1277                      u2RxResidual += u2Pkt0Len;
   1278                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(0);
   1279                  } else {
   1280                      // write
   1281                      u2TxResidual += u2Pkt0Len;
   1282                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(0));
   1283                  }
   1284                  ucPktNum--;
   1285              }
   1286              if (ucPktNum) {
   1287                  if (ucPkt1RW) {
   1288                      // read
   1289                      u2RxResidual += u2Pkt1Len;
   1290                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(1);
   1291                  } else {
   1292                      // write
   1293                      u2TxResidual += u2Pkt1Len;
   1294                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(1));
   1295                  }
   1296                  ucPktNum--;
   1297              }
   1298              if (ucPktNum) {
   1299                  if (ucPkt2RW) {
   1300                      // read
   1301                      u2RxResidual += u2Pkt2Len;
   1302                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(2);
   1303                  } else {
   1304                      // write
   1305                      u2TxResidual += u2Pkt2Len;
   1306                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(2));
   1307                  }
   1308                  ucPktNum--;
   1309              }
   1310          
   1311              if (u2TxResidual > 0) {
   1312                  // Configure GDMA for Tx data.
   1313                  halI2CGDMACtrl(ucI2CIdx, ucTxGDMAIdx, 1, u2TxResidual, pucTxData);
   1314              }
   1315          
   1316              if (u2RxResidual > 0) {
   1317                  // Configure GDMA for Rx data.
   1318                  halI2CGDMACtrl(ucI2CIdx, ucRxGDMAIdx, 0, u2RxResidual, pucRxData);
   1319              }
   1320              // g. Set MM_CON0[0] to 1 to trigger the master to write data to slave.
   1321              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_START_EN_OFFSET);
   1322          
   1323              return ret;
   1324          }
   1325          
   1326          
   1327          #if (WIFI_BUILD_OPTION == 1)
   1328          // Only for DVT, NOT for release
   1329          // GDMA length < I2C Tx length
   1330          ENUM_HAL_RET_T halI2CGDMAGeneralRW_DVT_DEBUG(UINT8 ucI2CIdx,
   1331                  UINT8 ucTxGDMAIdx,
   1332                  UINT8 ucRxGDMAIdx,
   1333                  UINT8 ucSlaveAddress,
   1334                  PUINT8 pucTxData,
   1335                  PUINT8 pucRxData,
   1336                  UINT8 ucPktNum,
   1337                  UINT8 ucPkt0RW,
   1338                  UINT16 u2Pkt0Len,
   1339                  UINT8 ucPkt1RW,
   1340                  UINT16 u2Pkt1Len,
   1341                  UINT8 ucPkt2RW,
   1342                  UINT16 u2Pkt2Len)
   1343          {
   1344              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
   1345          
   1346              UINT16  u2TxResidual = 0;
   1347              UINT16  u2RxResidual = 0;
   1348          
   1349              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
   1350          
   1351              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
   1352              //if (NULL == pI2CTypeDef)
   1353              //{
   1354              //    return HAL_RET_FAIL;
   1355              //}
   1356          
   1357              // Sanity check
   1358              if (ucPktNum > I2C_PKT_MAX_NUM) {
   1359                  return HAL_RET_FAIL;
   1360              }
   1361          
   1362              if ((!pucTxData) || (!pucRxData)) {
   1363                  return HAL_RET_FAIL;
   1364              }
   1365          
   1366              // General mode enable
   1367              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_GMODE_OFFSET);
   1368          
   1369              // a. Read MM_STATUS[2]. The I2C master circuit is ready for preparing the next trigger if the value is 1.
   1370              if (!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
   1371                  return HAL_RET_FAIL;
   1372              }
   1373          
   1374              // b. Set a value of MM_ID_CON0 to decide which slave you want to write.
   1375              (pI2CTypeDef->MM_ID_CON0) &= (~I2C_MM_SLAVE_ID_MASK);
   1376              (pI2CTypeDef->MM_ID_CON0) |= ((ucSlaveAddress & (I2C_MM_SLAVE_ID_MASK)) << I2C_MM_SLAVE_ID_OFFSET);
   1377          
   1378              // c. Set MM_PACK_CON0[5:4] packet number.
   1379              (pI2CTypeDef->MM_PACK_CON0) &= ~(I2C_MM_PACK_VAL_MASK);
   1380              (pI2CTypeDef->MM_PACK_CON0) |= ((ucPktNum - 1) << I2C_MM_PACK_VAL_OFFSET);
   1381          
   1382              // d. Set the MM_CNT_BYTE_VAL_PK0/1/2 to decide data length.
   1383              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK0) = u2Pkt0Len;
   1384              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK1) = u2Pkt1Len;
   1385              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK2) = u2Pkt2Len;
   1386          
   1387              // e. Set each PKT's R/W mode
   1388              if (ucPktNum) {
   1389                  if (ucPkt0RW) {
   1390                      // read
   1391                      u2RxResidual += u2Pkt0Len;
   1392                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(0);
   1393                  } else {
   1394                      // write
   1395                      u2TxResidual += u2Pkt0Len;
   1396                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(0));
   1397                  }
   1398                  ucPktNum--;
   1399              }
   1400              if (ucPktNum) {
   1401                  if (ucPkt1RW) {
   1402                      // read
   1403                      u2RxResidual += u2Pkt1Len;
   1404                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(1);
   1405                  } else {
   1406                      // write
   1407                      u2TxResidual += u2Pkt1Len;
   1408                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(1));
   1409                  }
   1410                  ucPktNum--;
   1411              }
   1412              if (ucPktNum) {
   1413                  if (ucPkt2RW) {
   1414                      // read
   1415                      u2RxResidual += u2Pkt2Len;
   1416                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(2);
   1417                  } else {
   1418                      // write
   1419                      u2TxResidual += u2Pkt2Len;
   1420                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(2));
   1421                  }
   1422                  ucPktNum--;
   1423              }
   1424          
   1425              if (u2TxResidual > 0) {
   1426                  // Configure GDMA for Tx data.
   1427                  halI2CGDMACtrl(ucI2CIdx, ucTxGDMAIdx, 1, (u2TxResidual >> 1), pucTxData);
   1428              }
   1429              if (u2RxResidual > 0) {
   1430                  // Configure GDMA for Rx data.
   1431                  halI2CGDMACtrl(ucI2CIdx, ucRxGDMAIdx, 0, (u2RxResidual >> 1), pucRxData);
   1432              }
   1433              // g. Set MM_CON0[0] to 1 to trigger the master to write data to slave.
   1434              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_START_EN_OFFSET);
   1435          
   1436              return ret;
   1437          }
   1438          #endif // #if (WIFI_BUILD_OPTION == 1)
   1439          
   1440          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   halI2CChkStatus
        24   -> halI2CGetBaseAddr
        24   -> halI2CGetFIFOStatus
      16   halI2CClearFIFO
        16   -> halI2CGetBaseAddr
      24   halI2CGDMACtrl
        24   -> DMA_Clock_Enable
        24   -> halI2CGetBaseAddr
      40   halI2CGDMAGeneralRW
        40   -> halI2CGDMACtrl
        40   -> halI2CGetBaseAddr
        40   -> log_hal_error_internal
        40   -> printf
      32   halI2CGDMANormalRead
        32   -> halI2CGDMACtrl
        32   -> halI2CGetBaseAddr
        32   -> log_hal_error_internal
        32   -> printf
      32   halI2CGDMANormalWrite
        32   -> halI2CGDMACtrl
        32   -> halI2CGetBaseAddr
        32   -> log_hal_error_internal
      48   halI2CGeneralRW
        48   -> halI2CChkStatus
        48   -> halI2CGetBaseAddr
        48   -> halI2CRxFIFOSpace
        48   -> halI2CTxFIFOSpace
        48   -> i2c_master_wait_transaction_finish
        48   -> log_hal_error_internal
        48   -> printf
       0   halI2CGetBaseAddr
       8   halI2CGetBusyStatus
         8   -> halI2CGetBaseAddr
       0   halI2CGetFIFOSpace
       8   halI2CGetFIFOStatus
         8   -> halI2CGetBaseAddr
      24   halI2CInit
        24   -> halI2CClearFIFO
        24   -> halI2CGetBaseAddr
      16   halI2CMasterCtrl
        16   -> halI2CGetBaseAddr
        16   -> top_xtal_freq_get
      40   halI2CNormalRead
        40   -> halI2CChkStatus
        40   -> halI2CGetBaseAddr
        40   -> halI2CRxFIFOSpace
        40   -> i2c_master_wait_transaction_finish
        40   -> log_hal_error_internal
        40   -> printf
      40   halI2CNormalWrite
        40   -> halI2CChkStatus
        40   -> halI2CGetBaseAddr
        40   -> halI2CTxFIFOSpace
        40   -> i2c_master_wait_transaction_finish
        40   -> log_hal_error_internal
        40   -> printf
       0   halI2CRxFIFOSpace
         0   -> halI2CGetFIFOSpace
       0   halI2CTxFIFOSpace
         0   -> halI2CGetFIFOSpace
      48   i2c_master_wait_transaction_finish
        48   -> hal_gpt_get_duration_count
        48   -> hal_gpt_get_free_run_count
        48   -> log_hal_error_internal
        48   -> printf
        48   -> restore_interrupt_mask
        48   -> save_and_set_interrupt_mask


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
       4  ??DataTable23_8
      40  ?_0
      40  ?_1
      32  ?_10
      36  ?_11
      36  ?_12
      28  ?_13
      72  ?_2
      68  ?_3
      36  ?_4
      56  ?_5
      44  ?_6
      36  ?_7
      56  ?_8
      40  ?_9
     106  halI2CChkStatus
      38  halI2CClearFIFO
     160  halI2CGDMACtrl
     386  halI2CGDMAGeneralRW
     160  halI2CGDMANormalRead
     138  halI2CGDMANormalWrite
     538  halI2CGeneralRW
      24  halI2CGetBaseAddr
      14  halI2CGetBusyStatus
      60  halI2CGetFIFOSpace
      12  halI2CGetFIFOStatus
     122  halI2CInit
     156  halI2CMasterCtrl
     302  halI2CNormalRead
     340  halI2CNormalWrite
      12  halI2CRxFIFOSpace
      16  halI2CTxFIFOSpace
     132  i2c_master_wait_transaction_finish
     160  -- Other

 
 3 532 bytes in section .text
 
 3 532 bytes of CODE memory

Errors: none
Warnings: none
