###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       25/Jan/2017  17:35:28
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\sha256.c
#    Command line =  
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\sha256.c" -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_WIFI_TGN_VERIFY_ENABLE -D MTK_SMTCN_ENABLE -D
#        MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D SUPPORT_MBEDTLS -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-basic.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D MTK_MCS_ENABLE -D MTK_BLE_GPIO_SERVICE -D
#        __BT_DEBUG__ -lcN "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List" -lA
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List"
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj" --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\inc\" -I
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\service\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\dhcpd\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\src\ut_app\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\httpclient\inc\"
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List\sha256.lst
#    Object file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj\sha256.o
#
###############################################################################

C:\LEO\myGit\MTK IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\sha256.c
      1          /*
      2           *  FIPS-180-2 compliant SHA-256 implementation
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          /*
     22           *  The SHA-256 Secure Hash Standard was published by NIST in 2002.
     23           *
     24           *  http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf
     25           */
     26          
     27          #if !defined(MBEDTLS_CONFIG_FILE)
     28          #include "mbedtls/config.h"
     29          #else
     30          #include MBEDTLS_CONFIG_FILE
     31          #endif
     32          
     33          #if defined(MBEDTLS_SHA256_C)
     34          
     35          #include "mbedtls/sha256.h"
     36          
     37          #if defined(MBEDTLS_THREADING_C) && defined(MBEDTLS_SHA256_ALT)
     38          #include "mbedtls/threading.h"
     39          #endif
     40          
     41          #include <string.h>
     42          
     43          #if defined(MBEDTLS_SELF_TEST)
     44          #if defined(MBEDTLS_PLATFORM_C)
     45          #include "mbedtls/platform.h"
     46          #else
     47          #include <stdio.h>
     48          #define mbedtls_printf printf
     49          #endif /* MBEDTLS_PLATFORM_C */
     50          #endif /* MBEDTLS_SELF_TEST */
     51          
     52          #if !defined(MBEDTLS_SHA256_ALT)
     53          
     54          /* Implementation that should never be optimized out by the compiler */
     55          static void mbedtls_zeroize( void *v, size_t n ) {
     56              volatile unsigned char *p = v; while( n-- ) *p++ = 0;
     57          }
     58          
     59          /*
     60           * 32-bit integer manipulation macros (big endian)
     61           */
     62          #ifndef GET_UINT32_BE
     63          #define GET_UINT32_BE(n,b,i)                            \
     64          do {                                                    \
     65              (n) = ( (uint32_t) (b)[(i)    ] << 24 )             \
     66                  | ( (uint32_t) (b)[(i) + 1] << 16 )             \
     67                  | ( (uint32_t) (b)[(i) + 2] <<  8 )             \
     68                  | ( (uint32_t) (b)[(i) + 3]       );            \
     69          } while( 0 )
     70          #endif
     71          
     72          #ifndef PUT_UINT32_BE
     73          #define PUT_UINT32_BE(n,b,i)                            \
     74          do {                                                    \
     75              (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \
     76              (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \
     77              (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \
     78              (b)[(i) + 3] = (unsigned char) ( (n)       );       \
     79          } while( 0 )
     80          #endif
     81          
     82          void mbedtls_sha256_init( mbedtls_sha256_context *ctx )
     83          {
     84              memset( ctx, 0, sizeof( mbedtls_sha256_context ) );
     85          }
     86          
     87          void mbedtls_sha256_free( mbedtls_sha256_context *ctx )
     88          {
     89              if( ctx == NULL )
     90                  return;
     91          
     92              mbedtls_zeroize( ctx, sizeof( mbedtls_sha256_context ) );
     93          }
     94          
     95          void mbedtls_sha256_clone( mbedtls_sha256_context *dst,
     96                                     const mbedtls_sha256_context *src )
     97          {
     98              *dst = *src;
     99          }
    100          
    101          /*
    102           * SHA-256 context setup
    103           */
    104          void mbedtls_sha256_starts( mbedtls_sha256_context *ctx, int is224 )
    105          {
    106              ctx->total[0] = 0;
    107              ctx->total[1] = 0;
    108          
    109              if( is224 == 0 )
    110              {
    111                  /* SHA-256 */
    112                  ctx->state[0] = 0x6A09E667;
    113                  ctx->state[1] = 0xBB67AE85;
    114                  ctx->state[2] = 0x3C6EF372;
    115                  ctx->state[3] = 0xA54FF53A;
    116                  ctx->state[4] = 0x510E527F;
    117                  ctx->state[5] = 0x9B05688C;
    118                  ctx->state[6] = 0x1F83D9AB;
    119                  ctx->state[7] = 0x5BE0CD19;
    120              }
    121              else
    122              {
    123                  /* SHA-224 */
    124                  ctx->state[0] = 0xC1059ED8;
    125                  ctx->state[1] = 0x367CD507;
    126                  ctx->state[2] = 0x3070DD17;
    127                  ctx->state[3] = 0xF70E5939;
    128                  ctx->state[4] = 0xFFC00B31;
    129                  ctx->state[5] = 0x68581511;
    130                  ctx->state[6] = 0x64F98FA7;
    131                  ctx->state[7] = 0xBEFA4FA4;
    132              }
    133          
    134              ctx->is224 = is224;
    135          }
    136          
    137          #if !defined(MBEDTLS_SHA256_PROCESS_ALT)
    138          static const uint32_t K[] =
    139          {
    140              0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
    141              0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
    142              0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
    143              0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
    144              0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
    145              0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
    146              0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
    147              0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
    148              0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
    149              0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
    150              0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
    151              0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
    152              0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
    153              0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
    154              0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
    155              0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2,
    156          };
    157          
    158          #define  SHR(x,n) ((x & 0xFFFFFFFF) >> n)
    159          #define ROTR(x,n) (SHR(x,n) | (x << (32 - n)))
    160          
    161          #define S0(x) (ROTR(x, 7) ^ ROTR(x,18) ^  SHR(x, 3))
    162          #define S1(x) (ROTR(x,17) ^ ROTR(x,19) ^  SHR(x,10))
    163          
    164          #define S2(x) (ROTR(x, 2) ^ ROTR(x,13) ^ ROTR(x,22))
    165          #define S3(x) (ROTR(x, 6) ^ ROTR(x,11) ^ ROTR(x,25))
    166          
    167          #define F0(x,y,z) ((x & y) | (z & (x | y)))
    168          #define F1(x,y,z) (z ^ (x & (y ^ z)))
    169          
    170          #define R(t)                                    \
    171          (                                               \
    172              W[t] = S1(W[t -  2]) + W[t -  7] +          \
    173                     S0(W[t - 15]) + W[t - 16]            \
    174          )
    175          
    176          #define P(a,b,c,d,e,f,g,h,x,K)                  \
    177          {                                               \
    178              temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    179              temp2 = S2(a) + F0(a,b,c);                  \
    180              d += temp1; h = temp1 + temp2;              \
    181          }
    182          
    183          void mbedtls_sha256_process( mbedtls_sha256_context *ctx, const unsigned char data[64] )
    184          {
    185              uint32_t temp1, temp2, W[64];
    186              uint32_t A[8];
    187              unsigned int i;
    188          
    189              for( i = 0; i < 8; i++ )
    190                  A[i] = ctx->state[i];
    191          
    192          #if defined(MBEDTLS_SHA256_SMALLER)
    193              for( i = 0; i < 64; i++ )
    194              {
    195                  if( i < 16 )
    196                      GET_UINT32_BE( W[i], data, 4 * i );
    197                  else
    198                      R( i );
    199          
    200                  P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], W[i], K[i] );
    201          
    202                  temp1 = A[7]; A[7] = A[6]; A[6] = A[5]; A[5] = A[4]; A[4] = A[3];
    203                  A[3] = A[2]; A[2] = A[1]; A[1] = A[0]; A[0] = temp1;
    204              }
    205          #else /* MBEDTLS_SHA256_SMALLER */
    206              for( i = 0; i < 16; i++ )
    207                  GET_UINT32_BE( W[i], data, 4 * i );
    208          
    209              for( i = 0; i < 16; i += 8 )
    210              {
    211                  P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], W[i+0], K[i+0] );
    212                  P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], W[i+1], K[i+1] );
    213                  P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], W[i+2], K[i+2] );
    214                  P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], W[i+3], K[i+3] );
    215                  P( A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], W[i+4], K[i+4] );
    216                  P( A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], W[i+5], K[i+5] );
    217                  P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], W[i+6], K[i+6] );
    218                  P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], W[i+7], K[i+7] );
    219              }
    220          
    221              for( i = 16; i < 64; i += 8 )
    222              {
    223                  P( A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], R(i+0), K[i+0] );
    224                  P( A[7], A[0], A[1], A[2], A[3], A[4], A[5], A[6], R(i+1), K[i+1] );
    225                  P( A[6], A[7], A[0], A[1], A[2], A[3], A[4], A[5], R(i+2), K[i+2] );
    226                  P( A[5], A[6], A[7], A[0], A[1], A[2], A[3], A[4], R(i+3), K[i+3] );
    227                  P( A[4], A[5], A[6], A[7], A[0], A[1], A[2], A[3], R(i+4), K[i+4] );
    228                  P( A[3], A[4], A[5], A[6], A[7], A[0], A[1], A[2], R(i+5), K[i+5] );
    229                  P( A[2], A[3], A[4], A[5], A[6], A[7], A[0], A[1], R(i+6), K[i+6] );
    230                  P( A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[0], R(i+7), K[i+7] );
    231              }
    232          #endif /* MBEDTLS_SHA256_SMALLER */
    233          
    234              for( i = 0; i < 8; i++ )
    235                  ctx->state[i] += A[i];
    236          }
    237          #endif /* !MBEDTLS_SHA256_PROCESS_ALT */
    238          
    239          /*
    240           * SHA-256 process buffer
    241           */
    242          void mbedtls_sha256_update( mbedtls_sha256_context *ctx, const unsigned char *input,
    243                              size_t ilen )
    244          {
    245              size_t fill;
    246              uint32_t left;
    247          
    248              if( ilen == 0 )
    249                  return;
    250          
    251              left = ctx->total[0] & 0x3F;
    252              fill = 64 - left;
    253          
    254              ctx->total[0] += (uint32_t) ilen;
    255              ctx->total[0] &= 0xFFFFFFFF;
    256          
    257              if( ctx->total[0] < (uint32_t) ilen )
    258                  ctx->total[1]++;
    259          
    260              if( left && ilen >= fill )
    261              {
    262                  memcpy( (void *) (ctx->buffer + left), input, fill );
    263                  mbedtls_sha256_process( ctx, ctx->buffer );
    264                  input += fill;
    265                  ilen  -= fill;
    266                  left = 0;
    267              }
    268          
    269              while( ilen >= 64 )
    270              {
    271                  mbedtls_sha256_process( ctx, input );
    272                  input += 64;
    273                  ilen  -= 64;
    274              }
    275          
    276              if( ilen > 0 )
    277                  memcpy( (void *) (ctx->buffer + left), input, ilen );
    278          }
    279          
    280          static const unsigned char sha256_padding[64] =
    281          {
    282           0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    283              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    284              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    285              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    286          };
    287          
    288          /*
    289           * SHA-256 final digest
    290           */
    291          void mbedtls_sha256_finish( mbedtls_sha256_context *ctx, unsigned char output[32] )
    292          {
    293              uint32_t last, padn;
    294              uint32_t high, low;
    295              unsigned char msglen[8];
    296          
    297              high = ( ctx->total[0] >> 29 )
    298                   | ( ctx->total[1] <<  3 );
    299              low  = ( ctx->total[0] <<  3 );
    300          
    301              PUT_UINT32_BE( high, msglen, 0 );
    302              PUT_UINT32_BE( low,  msglen, 4 );
    303          
    304              last = ctx->total[0] & 0x3F;
    305              padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    306          
    307              mbedtls_sha256_update( ctx, sha256_padding, padn );
    308              mbedtls_sha256_update( ctx, msglen, 8 );
    309          
    310              PUT_UINT32_BE( ctx->state[0], output,  0 );
    311              PUT_UINT32_BE( ctx->state[1], output,  4 );
    312              PUT_UINT32_BE( ctx->state[2], output,  8 );
    313              PUT_UINT32_BE( ctx->state[3], output, 12 );
    314              PUT_UINT32_BE( ctx->state[4], output, 16 );
    315              PUT_UINT32_BE( ctx->state[5], output, 20 );
    316              PUT_UINT32_BE( ctx->state[6], output, 24 );
    317          
    318              if( ctx->is224 == 0 )
    319                  PUT_UINT32_BE( ctx->state[7], output, 28 );
    320          }
    321          
    322          #else
    323          void mbedtls_sha256_init( mbedtls_sha256_context *ctx )
    324          {
    325              memset( ctx, 0, sizeof(mbedtls_sha256_context) );
    326          }
    327          
    328          void mbedtls_sha256_free( mbedtls_sha256_context *ctx )
    329          {
    330              if( ctx == NULL )
    331                  return;
    332              memset( ctx, 0, sizeof(mbedtls_sha256_context) );
    333          }
    334          void mbedtls_sha256_clone( mbedtls_sha256_context *dst,
    335                                   const mbedtls_sha256_context *src )
    336          {
    337              *dst = *src;
    338          }
    339          
    340          void mbedtls_sha256_starts( mbedtls_sha256_context *ctx, int is224 )
    341          {
    342              int ret;
    343          
    344              if( is224 == 1 ) {
    345                  do {
    346                      ret = (int)hal_sha224_init( ctx );
    347                      if( ret == -100 )
    348                          delay_ms(1);
    349                  } while( ret == -100 );
    350              }else{
    351                  do {
    352                      ret = (int)hal_sha256_init( ctx );
    353                      if( ret == -100 )
    354                          delay_ms(1);
    355                  } while( ret == -100 );
    356              }
    357          }
    358          
    359          
    360          void mbedtls_sha256_update( mbedtls_sha256_context *ctx, const unsigned char *input, size_t ilen )
    361          {
    362              int ret;
    363          
    364              do {
    365                  ret = (int)hal_sha256_append(ctx, input, ilen);
    366                  if( ret == -100 )
    367                      delay_ms(1);
    368              } while( ret == -100 );
    369          }
    370          
    371          void mbedtls_sha256_finish( mbedtls_sha256_context *ctx, unsigned char output[32] )
    372          {
    373              int ret;
    374          
    375              do {
    376                  ret = (int)hal_sha256_end( ctx, (uint8_t*)output);
    377                  if( ret == -100 )
    378                      delay_ms(1);
    379              } while( ret == -100 );
    380          }
    381          
    382          void mbedtls_sha256_process( mbedtls_sha256_context *ctx, const unsigned char data[64] )
    383          {
    384          #if 0
    385              int ret;
    386          
    387              ctx->block = data;
    388              ctx->block_length = 64;
    389          
    390              do {
    391                  ret = (int)crypt_sha256_hash( ctx );
    392                  if( ret == -100 )
    393                      delay_ms(1);
    394              } while( ret == -100 );
    395          #else
    396          	unsigned char output[32] = {0};
    397          
    398          	mbedtls_sha256_starts(ctx, 0);
    399          	mbedtls_sha256_update(ctx, data, 64);
    400          	mbedtls_sha256_finish(ctx, output);
    401          #endif
    402          }
    403          
    404          
    405          #endif /* !MBEDTLS_SHA256_ALT */
    406          
    407          /*
    408           * output = SHA-256( input buffer )
    409           */
    410          void mbedtls_sha256( const unsigned char *input, size_t ilen,
    411                       unsigned char output[32], int is224 )
    412          {
    413              mbedtls_sha256_context ctx;
    414          
    415              mbedtls_sha256_init( &ctx );
    416              mbedtls_sha256_starts( &ctx, is224 );
    417              mbedtls_sha256_update( &ctx, input, ilen );
    418              mbedtls_sha256_finish( &ctx, output );
    419              mbedtls_sha256_free( &ctx );
    420          }
    421          
    422          #if defined(MBEDTLS_SELF_TEST)
    423          /*
    424           * FIPS-180-2 test vectors
    425           */
    426          static const unsigned char sha256_test_buf[3][57] =
    427          {
    428              { "abc" },
    429              { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" },
    430              { "" }
    431          };
    432          
    433          static const int sha256_test_buflen[3] =
    434          {
    435              3, 56, 1000
    436          };
    437          
    438          static const unsigned char sha256_test_sum[6][32] =
    439          {
    440              /*
    441               * SHA-224 test vectors
    442               */
    443              { 0x23, 0x09, 0x7D, 0x22, 0x34, 0x05, 0xD8, 0x22,
    444                0x86, 0x42, 0xA4, 0x77, 0xBD, 0xA2, 0x55, 0xB3,
    445                0x2A, 0xAD, 0xBC, 0xE4, 0xBD, 0xA0, 0xB3, 0xF7,
    446                0xE3, 0x6C, 0x9D, 0xA7 },
    447              { 0x75, 0x38, 0x8B, 0x16, 0x51, 0x27, 0x76, 0xCC,
    448                0x5D, 0xBA, 0x5D, 0xA1, 0xFD, 0x89, 0x01, 0x50,
    449                0xB0, 0xC6, 0x45, 0x5C, 0xB4, 0xF5, 0x8B, 0x19,
    450                0x52, 0x52, 0x25, 0x25 },
    451              { 0x20, 0x79, 0x46, 0x55, 0x98, 0x0C, 0x91, 0xD8,
    452                0xBB, 0xB4, 0xC1, 0xEA, 0x97, 0x61, 0x8A, 0x4B,
    453                0xF0, 0x3F, 0x42, 0x58, 0x19, 0x48, 0xB2, 0xEE,
    454                0x4E, 0xE7, 0xAD, 0x67 },
    455          
    456              /*
    457               * SHA-256 test vectors
    458               */
    459              { 0xBA, 0x78, 0x16, 0xBF, 0x8F, 0x01, 0xCF, 0xEA,
    460                0x41, 0x41, 0x40, 0xDE, 0x5D, 0xAE, 0x22, 0x23,
    461                0xB0, 0x03, 0x61, 0xA3, 0x96, 0x17, 0x7A, 0x9C,
    462                0xB4, 0x10, 0xFF, 0x61, 0xF2, 0x00, 0x15, 0xAD },
    463              { 0x24, 0x8D, 0x6A, 0x61, 0xD2, 0x06, 0x38, 0xB8,
    464                0xE5, 0xC0, 0x26, 0x93, 0x0C, 0x3E, 0x60, 0x39,
    465                0xA3, 0x3C, 0xE4, 0x59, 0x64, 0xFF, 0x21, 0x67,
    466                0xF6, 0xEC, 0xED, 0xD4, 0x19, 0xDB, 0x06, 0xC1 },
    467              { 0xCD, 0xC7, 0x6E, 0x5C, 0x99, 0x14, 0xFB, 0x92,
    468                0x81, 0xA1, 0xC7, 0xE2, 0x84, 0xD7, 0x3E, 0x67,
    469                0xF1, 0x80, 0x9A, 0x48, 0xA4, 0x97, 0x20, 0x0E,
    470                0x04, 0x6D, 0x39, 0xCC, 0xC7, 0x11, 0x2C, 0xD0 }
    471          };
    472          
    473          /*
    474           * Checkup routine
    475           */
    476          int mbedtls_sha256_self_test( int verbose )
    477          {
    478              int i, j, k, buflen, ret = 0;
    479              unsigned char buf[1024];
    480              unsigned char sha256sum[32];
    481              mbedtls_sha256_context ctx;
    482          
    483              mbedtls_sha256_init( &ctx );
    484          
    485              for( i = 0; i < 6; i++ )
    486              {
    487                  j = i % 3;
    488                  k = i < 3;
    489          
    490                  if( verbose != 0 )
    491                      mbedtls_printf( "  SHA-%d test #%d: ", 256 - k * 32, j + 1 );
    492          
    493                  mbedtls_sha256_starts( &ctx, k );
    494          
    495                  if( j == 2 )
    496                  {
    497                      memset( buf, 'a', buflen = 1000 );
    498          
    499                      for( j = 0; j < 1000; j++ )
    500                          mbedtls_sha256_update( &ctx, buf, buflen );
    501                  }
    502                  else
    503                      mbedtls_sha256_update( &ctx, sha256_test_buf[j],
    504                                           sha256_test_buflen[j] );
    505          
    506                  mbedtls_sha256_finish( &ctx, sha256sum );
    507          
    508                  if( memcmp( sha256sum, sha256_test_sum[i], 32 - k * 4 ) != 0 )
    509                  {
    510                      if( verbose != 0 )
    511                          mbedtls_printf( "failed\n" );
    512          
    513                      ret = 1;
    514                      goto exit;
    515                  }
    516          
    517                  if( verbose != 0 )
    518                      mbedtls_printf( "passed\n" );
    519              }
    520          
    521              if( verbose != 0 )
    522                  mbedtls_printf( "\n" );
    523          
    524          exit:
    525              mbedtls_sha256_free( &ctx );
    526          
    527              return( ret );
    528          }
    529          
    530          #endif /* MBEDTLS_SELF_TEST */
    531          
    532          #endif /* MBEDTLS_SHA256_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     128   mbedtls_sha256
       128   -> mbedtls_sha256_finish
       128   -> mbedtls_sha256_free
       128   -> mbedtls_sha256_init
       128   -> mbedtls_sha256_starts
       128   -> mbedtls_sha256_update
       0   mbedtls_sha256_clone
         0   -> __aeabi_memcpy4
      24   mbedtls_sha256_finish
        24   -> mbedtls_sha256_update
       0   mbedtls_sha256_free
         0   -> mbedtls_zeroize
       0   mbedtls_sha256_init
         0   -> __aeabi_memset4
     352   mbedtls_sha256_process
    1200   mbedtls_sha256_self_test
      1200   -- Indirect call
      1200   -> __aeabi_memset4
      1200   -> mbedtls_sha256_finish
      1200   -> mbedtls_sha256_free
      1200   -> mbedtls_sha256_init
      1200   -> mbedtls_sha256_starts
      1200   -> mbedtls_sha256_update
      1200   -> memcmp
       0   mbedtls_sha256_starts
      24   mbedtls_sha256_update
         0   -> __aeabi_memcpy
        24   -> __aeabi_memcpy
        24   -> mbedtls_sha256_process
       0   mbedtls_zeroize


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      20  ?_0
       8  ?_1
       8  ?_2
       2  ?_3
     256  K
      54  mbedtls_sha256
       6  mbedtls_sha256_clone
     276  mbedtls_sha256_finish
      10  mbedtls_sha256_free
       8  mbedtls_sha256_init
    2050  mbedtls_sha256_process
     296  mbedtls_sha256_self_test
     112  mbedtls_sha256_starts
     116  mbedtls_sha256_update
      18  mbedtls_zeroize
      64  sha256_padding
     172  sha256_test_buf
      12  sha256_test_buflen
     192  sha256_test_sum
      28  -- Other

 
     2 bytes in section .rodata
 3 778 bytes in section .text
 
 3 778 bytes of CODE  memory
     2 bytes of CONST memory

Errors: none
Warnings: none
