###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       25/Jan/2017  17:35:28
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\sha1.c
#    Command line =  
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\sha1.c" -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_WIFI_TGN_VERIFY_ENABLE -D MTK_SMTCN_ENABLE -D
#        MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D SUPPORT_MBEDTLS -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-basic.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D MTK_MCS_ENABLE -D MTK_BLE_GPIO_SERVICE -D
#        __BT_DEBUG__ -lcN "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List" -lA
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List"
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj" --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\inc\" -I
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\service\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\dhcpd\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\src\ut_app\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\httpclient\inc\"
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List\sha1.lst
#    Object file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj\sha1.o
#
###############################################################################

C:\LEO\myGit\MTK IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\sha1.c
      1          /*
      2           *  FIPS-180-1 compliant SHA-1 implementation
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          /*
     22           *  The SHA-1 standard was published by NIST in 1993.
     23           *
     24           *  http://www.itl.nist.gov/fipspubs/fip180-1.htm
     25           */
     26          
     27          #if !defined(MBEDTLS_CONFIG_FILE)
     28          #include "mbedtls/config.h"
     29          #else
     30          #include MBEDTLS_CONFIG_FILE
     31          #endif
     32          
     33          #if defined(MBEDTLS_SHA1_C)
     34          
     35          #include "mbedtls/sha1.h"
     36          
     37          #if defined(MBEDTLS_THREADING_C) && defined(MBEDTLS_SHA1_ALT)
     38          #include "mbedtls/threading.h"
     39          #endif
     40          
     41          #include <string.h>
     42          
     43          #if defined(MBEDTLS_SELF_TEST)
     44          #if defined(MBEDTLS_PLATFORM_C)
     45          #include "mbedtls/platform.h"
     46          #else
     47          #include <stdio.h>
     48          #define mbedtls_printf printf
     49          #endif /* MBEDTLS_PLATFORM_C */
     50          #endif /* MBEDTLS_SELF_TEST */
     51          
     52          #if !defined(MBEDTLS_SHA1_ALT)
     53          
     54          /* Implementation that should never be optimized out by the compiler */
     55          static void mbedtls_zeroize( void *v, size_t n ) {
     56              volatile unsigned char *p = v; while( n-- ) *p++ = 0;
     57          }
     58          
     59          /*
     60           * 32-bit integer manipulation macros (big endian)
     61           */
     62          #ifndef GET_UINT32_BE
     63          #define GET_UINT32_BE(n,b,i)                            \
     64          {                                                       \
     65              (n) = ( (uint32_t) (b)[(i)    ] << 24 )             \
     66                  | ( (uint32_t) (b)[(i) + 1] << 16 )             \
     67                  | ( (uint32_t) (b)[(i) + 2] <<  8 )             \
     68                  | ( (uint32_t) (b)[(i) + 3]       );            \
     69          }
     70          #endif
     71          
     72          #ifndef PUT_UINT32_BE
     73          #define PUT_UINT32_BE(n,b,i)                            \
     74          {                                                       \
     75              (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \
     76              (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \
     77              (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \
     78              (b)[(i) + 3] = (unsigned char) ( (n)       );       \
     79          }
     80          #endif
     81          
     82          void mbedtls_sha1_init( mbedtls_sha1_context *ctx )
     83          {
     84              memset( ctx, 0, sizeof( mbedtls_sha1_context ) );
     85          }
     86          
     87          void mbedtls_sha1_free( mbedtls_sha1_context *ctx )
     88          {
     89              if( ctx == NULL )
     90                  return;
     91          
     92              mbedtls_zeroize( ctx, sizeof( mbedtls_sha1_context ) );
     93          }
     94          
     95          void mbedtls_sha1_clone( mbedtls_sha1_context *dst,
     96                                   const mbedtls_sha1_context *src )
     97          {
     98              *dst = *src;
     99          }
    100          
    101          /*
    102           * SHA-1 context setup
    103           */
    104          void mbedtls_sha1_starts( mbedtls_sha1_context *ctx )
    105          {
    106              ctx->total[0] = 0;
    107              ctx->total[1] = 0;
    108          
    109              ctx->state[0] = 0x67452301;
    110              ctx->state[1] = 0xEFCDAB89;
    111              ctx->state[2] = 0x98BADCFE;
    112              ctx->state[3] = 0x10325476;
    113              ctx->state[4] = 0xC3D2E1F0;
    114          }
    115          
    116          #if !defined(MBEDTLS_SHA1_PROCESS_ALT)
    117          void mbedtls_sha1_process( mbedtls_sha1_context *ctx, const unsigned char data[64] )
    118          {
    119              uint32_t temp, W[16], A, B, C, D, E;
    120          
    121              GET_UINT32_BE( W[ 0], data,  0 );
    122              GET_UINT32_BE( W[ 1], data,  4 );
    123              GET_UINT32_BE( W[ 2], data,  8 );
    124              GET_UINT32_BE( W[ 3], data, 12 );
    125              GET_UINT32_BE( W[ 4], data, 16 );
    126              GET_UINT32_BE( W[ 5], data, 20 );
    127              GET_UINT32_BE( W[ 6], data, 24 );
    128              GET_UINT32_BE( W[ 7], data, 28 );
    129              GET_UINT32_BE( W[ 8], data, 32 );
    130              GET_UINT32_BE( W[ 9], data, 36 );
    131              GET_UINT32_BE( W[10], data, 40 );
    132              GET_UINT32_BE( W[11], data, 44 );
    133              GET_UINT32_BE( W[12], data, 48 );
    134              GET_UINT32_BE( W[13], data, 52 );
    135              GET_UINT32_BE( W[14], data, 56 );
    136              GET_UINT32_BE( W[15], data, 60 );
    137          
    138          #define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))
    139          
    140          #define R(t)                                            \
    141          (                                                       \
    142              temp = W[( t -  3 ) & 0x0F] ^ W[( t - 8 ) & 0x0F] ^ \
    143                     W[( t - 14 ) & 0x0F] ^ W[  t       & 0x0F],  \
    144              ( W[t & 0x0F] = S(temp,1) )                         \
    145          )
    146          
    147          #define P(a,b,c,d,e,x)                                  \
    148          {                                                       \
    149              e += S(a,5) + F(b,c,d) + K + x; b = S(b,30);        \
    150          }
    151          
    152              A = ctx->state[0];
    153              B = ctx->state[1];
    154              C = ctx->state[2];
    155              D = ctx->state[3];
    156              E = ctx->state[4];
    157          
    158          #define F(x,y,z) (z ^ (x & (y ^ z)))
    159          #define K 0x5A827999
    160          
    161              P( A, B, C, D, E, W[0]  );
    162              P( E, A, B, C, D, W[1]  );
    163              P( D, E, A, B, C, W[2]  );
    164              P( C, D, E, A, B, W[3]  );
    165              P( B, C, D, E, A, W[4]  );
    166              P( A, B, C, D, E, W[5]  );
    167              P( E, A, B, C, D, W[6]  );
    168              P( D, E, A, B, C, W[7]  );
    169              P( C, D, E, A, B, W[8]  );
    170              P( B, C, D, E, A, W[9]  );
    171              P( A, B, C, D, E, W[10] );
    172              P( E, A, B, C, D, W[11] );
    173              P( D, E, A, B, C, W[12] );
    174              P( C, D, E, A, B, W[13] );
    175              P( B, C, D, E, A, W[14] );
    176              P( A, B, C, D, E, W[15] );
    177              P( E, A, B, C, D, R(16) );
    178              P( D, E, A, B, C, R(17) );
    179              P( C, D, E, A, B, R(18) );
    180              P( B, C, D, E, A, R(19) );
    181          
    182          #undef K
    183          #undef F
    184          
    185          #define F(x,y,z) (x ^ y ^ z)
    186          #define K 0x6ED9EBA1
    187          
    188              P( A, B, C, D, E, R(20) );
    189              P( E, A, B, C, D, R(21) );
    190              P( D, E, A, B, C, R(22) );
    191              P( C, D, E, A, B, R(23) );
    192              P( B, C, D, E, A, R(24) );
    193              P( A, B, C, D, E, R(25) );
    194              P( E, A, B, C, D, R(26) );
    195              P( D, E, A, B, C, R(27) );
    196              P( C, D, E, A, B, R(28) );
    197              P( B, C, D, E, A, R(29) );
    198              P( A, B, C, D, E, R(30) );
    199              P( E, A, B, C, D, R(31) );
    200              P( D, E, A, B, C, R(32) );
    201              P( C, D, E, A, B, R(33) );
    202              P( B, C, D, E, A, R(34) );
    203              P( A, B, C, D, E, R(35) );
    204              P( E, A, B, C, D, R(36) );
    205              P( D, E, A, B, C, R(37) );
    206              P( C, D, E, A, B, R(38) );
    207              P( B, C, D, E, A, R(39) );
    208          
    209          #undef K
    210          #undef F
    211          
    212          #define F(x,y,z) ((x & y) | (z & (x | y)))
    213          #define K 0x8F1BBCDC
    214          
    215              P( A, B, C, D, E, R(40) );
    216              P( E, A, B, C, D, R(41) );
    217              P( D, E, A, B, C, R(42) );
    218              P( C, D, E, A, B, R(43) );
    219              P( B, C, D, E, A, R(44) );
    220              P( A, B, C, D, E, R(45) );
    221              P( E, A, B, C, D, R(46) );
    222              P( D, E, A, B, C, R(47) );
    223              P( C, D, E, A, B, R(48) );
    224              P( B, C, D, E, A, R(49) );
    225              P( A, B, C, D, E, R(50) );
    226              P( E, A, B, C, D, R(51) );
    227              P( D, E, A, B, C, R(52) );
    228              P( C, D, E, A, B, R(53) );
    229              P( B, C, D, E, A, R(54) );
    230              P( A, B, C, D, E, R(55) );
    231              P( E, A, B, C, D, R(56) );
    232              P( D, E, A, B, C, R(57) );
    233              P( C, D, E, A, B, R(58) );
    234              P( B, C, D, E, A, R(59) );
    235          
    236          #undef K
    237          #undef F
    238          
    239          #define F(x,y,z) (x ^ y ^ z)
    240          #define K 0xCA62C1D6
    241          
    242              P( A, B, C, D, E, R(60) );
    243              P( E, A, B, C, D, R(61) );
    244              P( D, E, A, B, C, R(62) );
    245              P( C, D, E, A, B, R(63) );
    246              P( B, C, D, E, A, R(64) );
    247              P( A, B, C, D, E, R(65) );
    248              P( E, A, B, C, D, R(66) );
    249              P( D, E, A, B, C, R(67) );
    250              P( C, D, E, A, B, R(68) );
    251              P( B, C, D, E, A, R(69) );
    252              P( A, B, C, D, E, R(70) );
    253              P( E, A, B, C, D, R(71) );
    254              P( D, E, A, B, C, R(72) );
    255              P( C, D, E, A, B, R(73) );
    256              P( B, C, D, E, A, R(74) );
    257              P( A, B, C, D, E, R(75) );
    258              P( E, A, B, C, D, R(76) );
    259              P( D, E, A, B, C, R(77) );
    260              P( C, D, E, A, B, R(78) );
    261              P( B, C, D, E, A, R(79) );
    262          
    263          #undef K
    264          #undef F
    265          
    266              ctx->state[0] += A;
    267              ctx->state[1] += B;
    268              ctx->state[2] += C;
    269              ctx->state[3] += D;
    270              ctx->state[4] += E;
    271          }
    272          #endif /* !MBEDTLS_SHA1_PROCESS_ALT */
    273          
    274          /*
    275           * SHA-1 process buffer
    276           */
    277          void mbedtls_sha1_update( mbedtls_sha1_context *ctx, const unsigned char *input, size_t ilen )
    278          {
    279              size_t fill;
    280              uint32_t left;
    281          
    282              if( ilen == 0 )
    283                  return;
    284          
    285              left = ctx->total[0] & 0x3F;
    286              fill = 64 - left;
    287          
    288              ctx->total[0] += (uint32_t) ilen;
    289              ctx->total[0] &= 0xFFFFFFFF;
    290          
    291              if( ctx->total[0] < (uint32_t) ilen )
    292                  ctx->total[1]++;
    293          
    294              if( left && ilen >= fill )
    295              {
    296                  memcpy( (void *) (ctx->buffer + left), input, fill );
    297                  mbedtls_sha1_process( ctx, ctx->buffer );
    298                  input += fill;
    299                  ilen  -= fill;
    300                  left = 0;
    301              }
    302          
    303              while( ilen >= 64 )
    304              {
    305                  mbedtls_sha1_process( ctx, input );
    306                  input += 64;
    307                  ilen  -= 64;
    308              }
    309          
    310              if( ilen > 0 )
    311                  memcpy( (void *) (ctx->buffer + left), input, ilen );
    312          }
    313          
    314          static const unsigned char sha1_padding[64] =
    315          {
    316           0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    317              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    318              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    319              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    320          };
    321          
    322          /*
    323           * SHA-1 final digest
    324           */
    325          void mbedtls_sha1_finish( mbedtls_sha1_context *ctx, unsigned char output[20] )
    326          {
    327              uint32_t last, padn;
    328              uint32_t high, low;
    329              unsigned char msglen[8];
    330          
    331              high = ( ctx->total[0] >> 29 )
    332                   | ( ctx->total[1] <<  3 );
    333              low  = ( ctx->total[0] <<  3 );
    334          
    335              PUT_UINT32_BE( high, msglen, 0 );
    336              PUT_UINT32_BE( low,  msglen, 4 );
    337          
    338              last = ctx->total[0] & 0x3F;
    339              padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    340          
    341              mbedtls_sha1_update( ctx, sha1_padding, padn );
    342              mbedtls_sha1_update( ctx, msglen, 8 );
    343          
    344              PUT_UINT32_BE( ctx->state[0], output,  0 );
    345              PUT_UINT32_BE( ctx->state[1], output,  4 );
    346              PUT_UINT32_BE( ctx->state[2], output,  8 );
    347              PUT_UINT32_BE( ctx->state[3], output, 12 );
    348              PUT_UINT32_BE( ctx->state[4], output, 16 );
    349          }
    350          
    351          #else
    352          
    353          void mbedtls_sha1_init( mbedtls_sha1_context *ctx )
    354          {
    355              memset(ctx, 0, sizeof(mbedtls_sha1_context));
    356          }
    357          
    358          void mbedtls_sha1_free( mbedtls_sha1_context *ctx )
    359          {
    360              memset( ctx, 0, sizeof(mbedtls_sha1_context) );
    361          }
    362          
    363          void mbedtls_sha1_clone( mbedtls_sha1_context *dst,
    364                                   const mbedtls_sha1_context *src )
    365          {
    366              *dst = *src;
    367          }
    368          
    369          void mbedtls_sha1_starts( mbedtls_sha1_context *ctx )
    370          {
    371              int ret;
    372          
    373              do {
    374                  ret = (int)hal_sha1_init( ctx );
    375                  if( ret == -100 )
    376                      delay_ms(1);
    377              } while(ret == -100 );
    378          }
    379          
    380          void mbedtls_sha1_update( mbedtls_sha1_context *ctx, const unsigned char *input, size_t ilen )
    381          {
    382              int ret;
    383          
    384              do {
    385                  ret = (int)hal_sha1_append( ctx, (uint8_t*)input, (uint32_t)ilen );
    386                  if( ret == -100 )
    387                      delay_ms(1);
    388              } while( ret == -100 );
    389          }
    390          
    391          void mbedtls_sha1_finish( mbedtls_sha1_context *ctx, unsigned char output[20] )
    392          {
    393              int ret;
    394          
    395              do {
    396                  ret = (int)hal_sha1_end( ctx, (uint8_t*)output );
    397                  if( ret == -100)
    398                      delay_ms(1);
    399              } while( ret == -100 );
    400          }
    401          
    402          void mbedtls_sha1_process( mbedtls_sha1_context *ctx, const unsigned char data[64] )
    403          {
    404          #if 0
    405              int ret;
    406              ctx->block = data;
    407              ctx->block_length = 64;
    408          
    409              do {
    410                  ret = (int)crypt_sha1_hash( ctx );
    411                  if( ret == -100 )
    412                      delay_ms(1);
    413              } while( ret == -100 );
    414          #else
    415          	unsigned char output[20] = {0};
    416          
    417          	mbedtls_sha1_starts(ctx);
    418          	mbedtls_sha1_update(ctx, data, 64);
    419          	mbedtls_sha1_finish(ctx, output);
    420          #endif
    421          }
    422          
    423          #endif /* !MBEDTLS_SHA1_ALT */
    424          
    425          /*
    426           * output = SHA-1( input buffer )
    427           */
    428          void mbedtls_sha1( const unsigned char *input, size_t ilen, unsigned char output[20] )
    429          {
    430              mbedtls_sha1_context ctx;
    431          
    432              mbedtls_sha1_init( &ctx );
    433              mbedtls_sha1_starts( &ctx );
    434              mbedtls_sha1_update( &ctx, input, ilen );
    435              mbedtls_sha1_finish( &ctx, output );
    436              mbedtls_sha1_free( &ctx );
    437          }
    438          
    439          #if defined(MBEDTLS_SELF_TEST)
    440          /*
    441           * FIPS-180-1 test vectors
    442           */
    443          static const unsigned char sha1_test_buf[3][57] =
    444          {
    445              { "abc" },
    446              { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" },
    447              { "" }
    448          };
    449          
    450          static const int sha1_test_buflen[3] =
    451          {
    452              3, 56, 1000
    453          };
    454          
    455          static const unsigned char sha1_test_sum[3][20] =
    456          {
    457              { 0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E,
    458                0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D },
    459              { 0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E, 0xBA, 0xAE,
    460                0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5, 0xE5, 0x46, 0x70, 0xF1 },
    461              { 0x34, 0xAA, 0x97, 0x3C, 0xD4, 0xC4, 0xDA, 0xA4, 0xF6, 0x1E,
    462                0xEB, 0x2B, 0xDB, 0xAD, 0x27, 0x31, 0x65, 0x34, 0x01, 0x6F }
    463          };
    464          
    465          /*
    466           * Checkup routine
    467           */
    468          int mbedtls_sha1_self_test( int verbose )
    469          {
    470              int i, j, buflen, ret = 0;
    471              unsigned char buf[1024];
    472              unsigned char sha1sum[20];
    473              mbedtls_sha1_context ctx;
    474          
    475              mbedtls_sha1_init( &ctx );
    476          
    477              /*
    478               * SHA-1
    479               */
    480              for( i = 0; i < 3; i++ )
    481              {
    482                  if( verbose != 0 )
    483                      mbedtls_printf( "  SHA-1 test #%d: ", i + 1 );
    484          
    485                  mbedtls_sha1_starts( &ctx );
    486          
    487                  if( i == 2 )
    488                  {
    489                      memset( buf, 'a', buflen = 1000 );
    490          
    491                      for( j = 0; j < 1000; j++ )
    492                          mbedtls_sha1_update( &ctx, buf, buflen );
    493                  }
    494                  else
    495                      mbedtls_sha1_update( &ctx, sha1_test_buf[i],
    496                                         sha1_test_buflen[i] );
    497          
    498                  mbedtls_sha1_finish( &ctx, sha1sum );
    499          
    500                  if( memcmp( sha1sum, sha1_test_sum[i], 20 ) != 0 )
    501                  {
    502                      if( verbose != 0 )
    503                          mbedtls_printf( "failed\n" );
    504          
    505                      ret = 1;
    506                      goto exit;
    507                  }
    508          
    509                  if( verbose != 0 )
    510                      mbedtls_printf( "passed\n" );
    511              }
    512          
    513              if( verbose != 0 )
    514                  mbedtls_printf( "\n" );
    515          
    516          exit:
    517              mbedtls_sha1_free( &ctx );
    518          
    519              return( ret );
    520          }
    521          
    522          #endif /* MBEDTLS_SELF_TEST */
    523          
    524          #endif /* MBEDTLS_SHA1_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     112   mbedtls_sha1
       112   -> mbedtls_sha1_finish
       112   -> mbedtls_sha1_free
       112   -> mbedtls_sha1_init
       112   -> mbedtls_sha1_starts
       112   -> mbedtls_sha1_update
       0   mbedtls_sha1_clone
         0   -> __aeabi_memcpy4
      24   mbedtls_sha1_finish
        24   -> mbedtls_sha1_update
       0   mbedtls_sha1_free
         0   -> mbedtls_zeroize
       0   mbedtls_sha1_init
         0   -> __aeabi_memset4
      96   mbedtls_sha1_process
    1168   mbedtls_sha1_self_test
      1168   -- Indirect call
      1168   -> __aeabi_memset4
      1168   -> mbedtls_sha1_finish
      1168   -> mbedtls_sha1_free
      1168   -> mbedtls_sha1_init
      1168   -> mbedtls_sha1_starts
      1168   -> mbedtls_sha1_update
      1168   -> memcmp
       0   mbedtls_sha1_starts
      24   mbedtls_sha1_update
         0   -> __aeabi_memcpy
        24   -> __aeabi_memcpy
        24   -> mbedtls_sha1_process
       0   mbedtls_zeroize


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
      20  ?_0
       8  ?_1
       8  ?_2
       2  ?_3
      50  mbedtls_sha1
       6  mbedtls_sha1_clone
     204  mbedtls_sha1_finish
      10  mbedtls_sha1_free
       8  mbedtls_sha1_init
    4328  mbedtls_sha1_process
     256  mbedtls_sha1_self_test
      28  mbedtls_sha1_starts
     116  mbedtls_sha1_update
      18  mbedtls_zeroize
      64  sha1_padding
     172  sha1_test_buf
      12  sha1_test_buflen
      60  sha1_test_sum
      24  -- Other

 
     2 bytes in section .rodata
 5 436 bytes in section .text
 
 5 436 bytes of CODE  memory
     2 bytes of CONST memory

Errors: none
Warnings: none
