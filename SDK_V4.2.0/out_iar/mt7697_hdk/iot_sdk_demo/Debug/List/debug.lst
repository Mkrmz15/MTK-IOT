###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       25/Jan/2017  17:34:53
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\debug.c
#    Command line =  
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\debug.c" -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_WIFI_TGN_VERIFY_ENABLE -D MTK_SMTCN_ENABLE -D
#        MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D SUPPORT_MBEDTLS -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-basic.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D MTK_MCS_ENABLE -D MTK_BLE_GPIO_SERVICE -D
#        __BT_DEBUG__ -lcN "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List" -lA
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List"
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj" --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\inc\" -I
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\service\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\dhcpd\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\src\ut_app\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\httpclient\inc\"
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List\debug.lst
#    Object file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj\debug.o
#
###############################################################################

C:\LEO\myGit\MTK IOT\SDK_V4.2.0\middleware\third_party\mbedtls\library\debug.c
      1          /*
      2           *  Debugging routines
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          
     22          #if !defined(MBEDTLS_CONFIG_FILE)
     23          #include "mbedtls/config.h"
     24          #else
     25          #include MBEDTLS_CONFIG_FILE
     26          #endif
     27          
     28          #if defined(MBEDTLS_DEBUG_C)
     29          
     30          #include "mbedtls/debug.h"
     31          
     32          #include <stdarg.h>
     33          #include <stdio.h>
     34          #include <string.h>
     35          
     36          #if defined(MBEDTLS_PLATFORM_C)
     37          #include "mbedtls/platform.h"
     38          #else
     39          #include <stdlib.h>
     40          #define mbedtls_calloc      calloc
     41          #define mbedtls_free        free
     42          #define mbedtls_snprintf    snprintf
     43          #endif
     44          
     45          #if ( defined(__ARMCC_VERSION) || defined(_MSC_VER) ) && !defined(inline)
     46          #define inline __inline
     47          #endif
     48          
     49          #define DEBUG_BUF_SIZE      512
     50          
     51          static int debug_threshold = 0;
     52          
     53          void mbedtls_debug_set_threshold( int threshold )
     54          {
     55              debug_threshold = threshold;
     56          }
     57          
     58          /*
     59           * All calls to f_dbg must be made via this function
     60           */
     61          static inline void debug_send_line( const mbedtls_ssl_context *ssl, int level,
     62                                              const char *file, int line,
     63                                              const char *str )
     64          {
     65              /*
     66               * If in a threaded environment, we need a thread identifier.
     67               * Since there is no portable way to get one, use the address of the ssl
     68               * context instead, as it shouldn't be shared between threads.
     69               */
     70          #if defined(MBEDTLS_THREADING_C)
     71              char idstr[20 + DEBUG_BUF_SIZE]; /* 0x + 16 nibbles + ': ' */
     72              mbedtls_snprintf( idstr, sizeof( idstr ), "%p: %s", ssl, str );
     73              ssl->conf->f_dbg( ssl->conf->p_dbg, level, file, line, idstr );
     74          #else
     75              ssl->conf->f_dbg( ssl->conf->p_dbg, level, file, line, str );
     76          #endif
     77          }
     78          
     79          void mbedtls_debug_print_msg( const mbedtls_ssl_context *ssl, int level,
     80                                        const char *file, int line,
     81                                        const char *format, ... )
     82          {
     83              va_list argp;
     84              char str[DEBUG_BUF_SIZE];
     85              int ret;
     86          
     87              if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || level > debug_threshold )
     88                  return;
     89          
     90              va_start( argp, format );
     91          #if defined(_WIN32)
     92          #if defined(_TRUNCATE)
     93              ret = _vsnprintf_s( str, DEBUG_BUF_SIZE, _TRUNCATE, format, argp );
     94          #else
     95              ret = _vsnprintf( str, DEBUG_BUF_SIZE, format, argp );
     96              if( ret < 0 || (size_t) ret == DEBUG_BUF_SIZE )
     97              {
     98                  str[DEBUG_BUF_SIZE-1] = '\0';
     99                  ret = -1;
    100              }
    101          #endif
    102          #else
    103              ret = vsnprintf( str, DEBUG_BUF_SIZE, format, argp );
    104          #endif
    105              va_end( argp );
    106          
    107              if( ret >= 0 && ret < DEBUG_BUF_SIZE - 1 )
    108              {
    109                  str[ret]     = '\n';
    110                  str[ret + 1] = '\0';
    111              }
    112          
    113              debug_send_line( ssl, level, file, line, str );
    114          }
    115          
    116          void mbedtls_debug_print_ret( const mbedtls_ssl_context *ssl, int level,
    117                                const char *file, int line,
    118                                const char *text, int ret )
    119          {
    120              char str[DEBUG_BUF_SIZE];
    121          
    122              if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || level > debug_threshold )
    123                  return;
    124          
    125              /*
    126               * With non-blocking I/O and examples that just retry immediately,
    127               * the logs would be quickly flooded with WANT_READ, so ignore that.
    128               * Don't ignore WANT_WRITE however, since is is usually rare.
    129               */
    130              if( ret == MBEDTLS_ERR_SSL_WANT_READ )
    131                  return;
    132          
    133              mbedtls_snprintf( str, sizeof( str ), "%s() returned %d (-0x%04x)\n",
    134                        text, ret, -ret );
    135          
    136              debug_send_line( ssl, level, file, line, str );
    137          }
    138          
    139          void mbedtls_debug_print_buf( const mbedtls_ssl_context *ssl, int level,
    140                                const char *file, int line, const char *text,
    141                                const unsigned char *buf, size_t len )
    142          {
    143              char str[DEBUG_BUF_SIZE];
    144              char txt[17];
    145              size_t i, idx = 0;
    146          
    147              if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || level > debug_threshold )
    148                  return;
    149          
    150              mbedtls_snprintf( str + idx, sizeof( str ) - idx, "dumping '%s' (%u bytes)\n",
    151                        text, (unsigned int) len );
    152          
    153              debug_send_line( ssl, level, file, line, str );
    154          
    155              idx = 0;
    156              memset( txt, 0, sizeof( txt ) );
    157              for( i = 0; i < len; i++ )
    158              {
    159                  if( i >= 4096 )
    160                      break;
    161          
    162                  if( i % 16 == 0 )
    163                  {
    164                      if( i > 0 )
    165                      {
    166                          mbedtls_snprintf( str + idx, sizeof( str ) - idx, "  %s\n", txt );
    167                          debug_send_line( ssl, level, file, line, str );
    168          
    169                          idx = 0;
    170                          memset( txt, 0, sizeof( txt ) );
    171                      }
    172          
    173                      idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, "%04x: ",
    174                                       (unsigned int) i );
    175          
    176                  }
    177          
    178                  idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, " %02x",
    179                                   (unsigned int) buf[i] );
    180                  txt[i % 16] = ( buf[i] > 31 && buf[i] < 127 ) ? buf[i] : '.' ;
    181              }
    182          
    183              if( len > 0 )
    184              {
    185                  for( /* i = i */; i % 16 != 0; i++ )
    186                      idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, "   " );
    187          
    188                  mbedtls_snprintf( str + idx, sizeof( str ) - idx, "  %s\n", txt );
    189                  debug_send_line( ssl, level, file, line, str );
    190              }
    191          }
    192          
    193          #if defined(MBEDTLS_ECP_C)
    194          void mbedtls_debug_print_ecp( const mbedtls_ssl_context *ssl, int level,
    195                                const char *file, int line,
    196                                const char *text, const mbedtls_ecp_point *X )
    197          {
    198              char str[DEBUG_BUF_SIZE];
    199          
    200              if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || level > debug_threshold )
    201                  return;
    202          
    203              mbedtls_snprintf( str, sizeof( str ), "%s(X)", text );
    204              mbedtls_debug_print_mpi( ssl, level, file, line, str, &X->X );
    205          
    206              mbedtls_snprintf( str, sizeof( str ), "%s(Y)", text );
    207              mbedtls_debug_print_mpi( ssl, level, file, line, str, &X->Y );
    208          }
    209          #endif /* MBEDTLS_ECP_C */
    210          
    211          #if defined(MBEDTLS_BIGNUM_C)
    212          void mbedtls_debug_print_mpi( const mbedtls_ssl_context *ssl, int level,
    213                                const char *file, int line,
    214                                const char *text, const mbedtls_mpi *X )
    215          {
    216              char str[DEBUG_BUF_SIZE];
    217              int j, k, zeros = 1;
    218              size_t i, n, idx = 0;
    219          
    220              if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || X == NULL || level > debug_threshold )
    221                  return;
    222          
    223              for( n = X->n - 1; n > 0; n-- )
    224                  if( X->p[n] != 0 )
    225                      break;
    226          
    227              for( j = ( sizeof(mbedtls_mpi_uint) << 3 ) - 1; j >= 0; j-- )
    228                  if( ( ( X->p[n] >> j ) & 1 ) != 0 )
    229                      break;
    230          
    231              mbedtls_snprintf( str + idx, sizeof( str ) - idx, "value of '%s' (%d bits) is:\n",
    232                        text, (int) ( ( n * ( sizeof(mbedtls_mpi_uint) << 3 ) ) + j + 1 ) );
    233          
    234              debug_send_line( ssl, level, file, line, str );
    235          
    236              idx = 0;
    237              for( i = n + 1, j = 0; i > 0; i-- )
    238              {
    239                  if( zeros && X->p[i - 1] == 0 )
    240                      continue;
    241          
    242                  for( k = sizeof( mbedtls_mpi_uint ) - 1; k >= 0; k-- )
    243                  {
    244                      if( zeros && ( ( X->p[i - 1] >> ( k << 3 ) ) & 0xFF ) == 0 )
    245                          continue;
    246                      else
    247                          zeros = 0;
    248          
    249                      if( j % 16 == 0 )
    250                      {
    251                          if( j > 0 )
    252                          {
    253                              mbedtls_snprintf( str + idx, sizeof( str ) - idx, "\n" );
    254                              debug_send_line( ssl, level, file, line, str );
    255                              idx = 0;
    256                          }
    257                      }
    258          
    259                      idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, " %02x", (unsigned int)
    260                                       ( X->p[i - 1] >> ( k << 3 ) ) & 0xFF );
    261          
    262                      j++;
    263                  }
    264          
    265              }
    266          
    267              if( zeros == 1 )
    268                  idx += mbedtls_snprintf( str + idx, sizeof( str ) - idx, " 00" );
    269          
    270              mbedtls_snprintf( str + idx, sizeof( str ) - idx, "\n" );
    271              debug_send_line( ssl, level, file, line, str );
    272          }
    273          #endif /* MBEDTLS_BIGNUM_C */
    274          
    275          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    276          static void debug_print_pk( const mbedtls_ssl_context *ssl, int level,
    277                                      const char *file, int line,
    278                                      const char *text, const mbedtls_pk_context *pk )
    279          {
    280              size_t i;
    281              mbedtls_pk_debug_item items[MBEDTLS_PK_DEBUG_MAX_ITEMS];
    282              char name[16];
    283          
    284              memset( items, 0, sizeof( items ) );
    285          
    286              if( mbedtls_pk_debug( pk, items ) != 0 )
    287              {
    288                  debug_send_line( ssl, level, file, line,
    289                                    "invalid PK context\n" );
    290                  return;
    291              }
    292          
    293              for( i = 0; i < MBEDTLS_PK_DEBUG_MAX_ITEMS; i++ )
    294              {
    295                  if( items[i].type == MBEDTLS_PK_DEBUG_NONE )
    296                      return;
    297          
    298                  mbedtls_snprintf( name, sizeof( name ), "%s%s", text, items[i].name );
    299                  name[sizeof( name ) - 1] = '\0';
    300          
    301                  if( items[i].type == MBEDTLS_PK_DEBUG_MPI )
    302                      mbedtls_debug_print_mpi( ssl, level, file, line, name, items[i].value );
    303                  else
    304          #if defined(MBEDTLS_ECP_C)
    305                  if( items[i].type == MBEDTLS_PK_DEBUG_ECP )
    306                      mbedtls_debug_print_ecp( ssl, level, file, line, name, items[i].value );
    307                  else
    308          #endif
    309                      debug_send_line( ssl, level, file, line,
    310                                        "should not happen\n" );
    311              }
    312          }
    313          
    314          static void debug_print_line_by_line( const mbedtls_ssl_context *ssl, int level,
    315                                                const char *file, int line, const char *text )
    316          {
    317              char str[DEBUG_BUF_SIZE];
    318              const char *start, *cur;
    319          
    320              start = text;
    321              for( cur = text; *cur != '\0'; cur++ )
    322              {
    323                  if( *cur == '\n' )
    324                  {
    325                      size_t len = cur - start + 1;
    326                      if( len > DEBUG_BUF_SIZE - 1 )
    327                          len = DEBUG_BUF_SIZE - 1;
    328          
    329                      memcpy( str, start, len );
    330                      str[len] = '\0';
    331          
    332                      debug_send_line( ssl, level, file, line, str );
    333          
    334                      start = cur + 1;
    335                  }
    336              }
    337          }
    338          
    339          void mbedtls_debug_print_crt( const mbedtls_ssl_context *ssl, int level,
    340                                const char *file, int line,
    341                                const char *text, const mbedtls_x509_crt *crt )
    342          {
    343              char str[DEBUG_BUF_SIZE];
    344              int i = 0;
    345          
    346              if( ssl->conf == NULL || ssl->conf->f_dbg == NULL || crt == NULL || level > debug_threshold )
    347                  return;
    348          
    349              while( crt != NULL )
    350              {
    351                  char buf[1024];
    352          
    353                  mbedtls_snprintf( str, sizeof( str ), "%s #%d:\n", text, ++i );
    354                  debug_send_line( ssl, level, file, line, str );
    355          
    356                  mbedtls_x509_crt_info( buf, sizeof( buf ) - 1, "", crt );
    357                  debug_print_line_by_line( ssl, level, file, line, buf );
    358          
    359                  debug_print_pk( ssl, level, file, line, "crt->", &crt->pk );
    360          
    361                  crt = crt->next;
    362              }
    363          }
    364          #endif /* MBEDTLS_X509_CRT_PARSE_C */
    365          
    366          #endif /* MBEDTLS_DEBUG_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     544   debug_print_line_by_line
       544   -> __aeabi_memcpy
       544   -> debug_send_line
      96   debug_print_pk
        96   -> __aeabi_memset4
        96   -> debug_send_line
        96   -> mbedtls_debug_print_mpi
        96   -> mbedtls_pk_debug
        96   -> snprintf
     560   debug_send_line
       560   -- Indirect call
       560   -> snprintf
     576   mbedtls_debug_print_buf
       576   -> __aeabi_memset4
       576   -> debug_send_line
       576   -> snprintf
    1576   mbedtls_debug_print_crt
      1576   -> debug_print_line_by_line
      1576   -> debug_print_pk
      1576   -> debug_send_line
      1576   -> mbedtls_x509_crt_info
      1576   -> snprintf
     560   mbedtls_debug_print_mpi
       560   -> debug_send_line
       560   -> snprintf
     536   mbedtls_debug_print_msg
       536   -> debug_send_line
       536   -> vsnprintf
     544   mbedtls_debug_print_ret
       544   -> debug_send_line
       544   -> snprintf
       0   mbedtls_debug_set_threshold


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       8  ?_0
      28  ?_1
      20  ?_10
       8  ?_11
      20  ?_12
      12  ?_13
       1  ?_14
       8  ?_15
      28  ?_2
       8  ?_3
       8  ?_4
       8  ?_5
       4  ?_6
      32  ?_7
       2  ?_8
       4  ?_9
     100  debug_print_line_by_line
     176  debug_print_pk
      58  debug_send_line
       4  debug_threshold
     314  mbedtls_debug_print_buf
     174  mbedtls_debug_print_crt
     374  mbedtls_debug_print_mpi
      90  mbedtls_debug_print_msg
      88  mbedtls_debug_print_ret
       8  mbedtls_debug_set_threshold

 
     4 bytes in section .bss
    11 bytes in section .rodata
 1 590 bytes in section .text
 
 1 590 bytes of CODE  memory
    11 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
