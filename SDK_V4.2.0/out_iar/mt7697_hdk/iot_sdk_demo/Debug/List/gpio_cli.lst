###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       25/Jan/2017  17:35:01
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\driver\board\mt76x7_hdk\util\src\gpio_cli.c
#    Command line =  
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\driver\board\mt76x7_hdk\util\src\gpio_cli.c" -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_WIFI_TGN_VERIFY_ENABLE -D MTK_SMTCN_ENABLE -D
#        MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D SUPPORT_MBEDTLS -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-basic.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D MTK_MCS_ENABLE -D MTK_BLE_GPIO_SERVICE -D
#        __BT_DEBUG__ -lcN "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List" -lA
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List"
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj" --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\inc\" -I
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\service\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\dhcpd\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\src\ut_app\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\httpclient\inc\"
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List\gpio_cli.lst
#    Object file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj\gpio_cli.o
#
###############################################################################

C:\LEO\myGit\MTK IOT\SDK_V4.2.0\driver\board\mt76x7_hdk\util\src\gpio_cli.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          #include <stdlib.h>
     36          #include <string.h>
     37          #include <stdio.h>
     38          
     39          #include "toi.h"
     40          #include "hal_gpio.h"
     41          #include "gpio_cli.h"
     42          
     43          #define GPIO_IOT_MODE0_ADD 0x81023020
     44          #define GPIO_IOT_PULL_UP0_ADD 0x8300B000
     45          #define GPIO_IOT_PULL_DOWN0_ADD 0x8300B030
     46          
     47          hal_gpio_status_t hal_iot_gpio_get_pinmux(hal_gpio_pin_t pin_number, uint8_t *function_index)
     48          {
     49              uint32_t no;
     50              uint32_t remainder;
     51              uint32_t temp;
     52          
     53              /* get the register number corresponding to the pin as one register can control 8 pins*/
     54              no = pin_number / 8;
     55          
     56              /* get the bit offset within the register as one register can control 8 pins*/
     57              remainder = pin_number % 8;
     58          
     59              temp = *(volatile unsigned int *)(GPIO_IOT_MODE0_ADD + (no * 0x4));
     60          
     61              temp &= (0xF << ( 4 * remainder ));
     62              *function_index = (temp >> ( 4 * remainder ));
     63              return HAL_GPIO_STATUS_OK;
     64          }
     65          
     66          
     67          hal_gpio_status_t hal_iot_gpio_get_pull(hal_gpio_pin_t pin_number, uint8_t *pull_state)
     68          {
     69              uint8_t no;
     70              uint8_t remainder;
     71              uint32_t temp1, temp2;
     72          
     73              /* get the register number corresponding to the pin as one register can control 8 pins*/
     74              no = pin_number / 32;
     75          
     76              /* get the bit offset within the register as one register can control 8 pins*/
     77              remainder = pin_number % 32;
     78          
     79              temp1 = *(volatile unsigned int *)( GPIO_IOT_PULL_UP0_ADD + (no * 0x10) );
     80              temp1 &= (0x1 << remainder );
     81              temp1 = (temp1 >> remainder);
     82          
     83              temp2 = *(volatile unsigned int *)( GPIO_IOT_PULL_DOWN0_ADD + (no * 0x10) );
     84              temp2 &= (0x1 << remainder);
     85              temp2 = (temp2 >> remainder);
     86              if (0 == temp1 && 0 == temp2) {
     87                  *pull_state = 2;
     88              } else if (1 == temp1) {
     89                  *pull_state = 1;
     90          
     91              } else if (1 == temp2) {
     92                  *pull_state = 0;
     93              }
     94          
     95              return HAL_GPIO_STATUS_OK;
     96          }
     97          
     98          
     99          
    100          static unsigned char gpio_set_pull(uint8_t len, char *param[])
    101          {
    102              uint8_t type;
    103              uint8_t config_index[2];
    104          
    105              if ( 2 != len) {
    106                  cli_putln();
    107                  cli_puts("parameter error\n");
    108                  cli_putln();
    109                  return 1;
    110              }
    111          
    112              config_index[0] = toi(param[0], &type);       //  pin
    113              config_index[1] = toi(param[1], &type);       //  pull stat
    114          
    115          
    116              if ((config_index[0] >= 72) || (config_index[1] > 2) ) {
    117                  cli_putln();
    118                  cli_puts("parameter error\n");
    119                  cli_putln();
    120                  return 3;
    121              }
    122          
    123              /* set pull */
    124              if (2 == config_index[1]) {
    125                  hal_gpio_disable_pull((hal_gpio_pin_t)config_index[0]);
    126              } else if (1 == config_index[1]) {
    127                  hal_gpio_pull_up((hal_gpio_pin_t)config_index[0]);
    128              } else if (0 == config_index[1]) {
    129                  hal_gpio_pull_down((hal_gpio_pin_t)config_index[0]);
    130              }
    131          
    132              cli_putln();
    133              cli_puts("configure done\r\n");
    134              cli_puts("0: pull down\r\n1: pull up\r\n2: disable pull\r\n");
    135              cli_putln();
    136              return 0;
    137          }
    138          
    139          
    140          
    141          
    142          static unsigned char gpio_set_od(uint8_t len, char *param[])
    143          {
    144              uint8_t type;
    145              uint8_t config_index[2];
    146          
    147              if ( 2 != len) {
    148                  cli_putln();
    149                  cli_puts("parameter error\n");
    150                  cli_putln();
    151                  return 1;
    152              }
    153          
    154              config_index[0] = toi(param[0], &type);       //  pin
    155              config_index[1] = toi(param[1], &type);      //  output data
    156          
    157              if ((config_index[0] >= 72) || (config_index[1] > 1) ) {
    158                  cli_putln();
    159                  cli_puts("parameter error\n");
    160                  return 3;
    161              }
    162          
    163              /* set pinmux */
    164              hal_gpio_set_output((hal_gpio_pin_t)config_index[0], (hal_gpio_data_t)config_index[1]);
    165          
    166              cli_putln();
    167              cli_puts("configure done\n");
    168              cli_putln();
    169              return 0;
    170          }
    171          
    172          
    173          
    174          static unsigned char gpio_set_dir(uint8_t len, char *param[])
    175          {
    176              uint8_t type;
    177              uint8_t config_index[2];
    178          
    179              if ( 2 != len) {
    180                  cli_putln();
    181                  cli_puts("parameter error\n");
    182                  return 1;
    183              }
    184          
    185              config_index[0] = toi(param[0], &type);        //  pin
    186              config_index[1] = toi(param[1], &type);        //  dir
    187          
    188              if ((config_index[0] >= 72) || (config_index[1] > 1) ) {
    189                  cli_putln();
    190                  cli_puts("parameter error\n");
    191                  cli_putln();
    192                  return 3;
    193              }
    194          
    195              /* set pinmux */
    196              hal_gpio_set_direction((hal_gpio_pin_t)config_index[0], (hal_gpio_direction_t)config_index[1]);
    197          
    198              cli_putln();
    199              cli_puts("configure done\n");
    200              cli_putln();
    201              return 0;
    202          }
    203          
    204          
    205          
    206          static unsigned char gpio_set_mode(uint8_t len, char *param[])
    207          {
    208              uint8_t type;
    209              uint8_t config_index[2];
    210          
    211              if ( 2 != len) {
    212                  cli_putln();
    213                  cli_puts("parameter error\n");
    214                  cli_putln();
    215                  return 1;
    216              }
    217          
    218              config_index[0] = toi(param[0], &type);           //  pin
    219              config_index[1] = toi(param[1], &type);           //  mode
    220          
    221              if ((config_index[0] >= 72) || (config_index[1] > 15) ) {
    222                  cli_putln();
    223                  cli_puts("parameter error\n");
    224                  cli_putln();
    225                  return 2;
    226              }
    227          
    228              /* set pinmux */
    229              hal_pinmux_set_function((hal_gpio_pin_t)config_index[0], config_index[1]);
    230          
    231              cli_putln();
    232              cli_puts("configure done\n");
    233              cli_putln();
    234              return 0;
    235          }
    236          
    237          
    238          static unsigned char gpio_set(uint8_t len, char *param[])
    239          {
    240              uint8_t type;
    241              uint8_t config_index[7];
    242          
    243              if ( 5 != len) {
    244                  cli_putln();
    245                  cli_puts("parameter error\n");
    246                  return 1;
    247              }
    248          
    249              config_index[0] = toi(param[0], &type);       //  pin
    250              config_index[1] = toi(param[1], &type);       //  mode
    251              config_index[2] = toi(param[2], &type);       //  dir
    252              config_index[3] = toi(param[3], &type);       //  pull
    253              config_index[4] = toi(param[4], &type);       //  od
    254          
    255              if ((config_index[0] > 72) || (config_index[1] > 15) || (config_index[2] > 1) || (config_index[3] > 2) || (config_index[4] > 1) ) {
    256                  cli_putln();
    257                  cli_puts("parameter error\n");
    258                  cli_putln();
    259                  return 3;
    260              }
    261          
    262              /* set pinmux */
    263              hal_pinmux_set_function((hal_gpio_pin_t)config_index[0], config_index[1]);
    264          
    265              /*set direction */
    266              hal_gpio_set_direction((hal_gpio_pin_t)config_index[0], (hal_gpio_direction_t)config_index[2]);
    267          
    268              /*set direction
    269                config_index[3] =
    270                                  2: disable pull
    271                                  0: pull down
    272                                  1: pull up
    273              */
    274              if (config_index[3] == 2) { /*disabl pull*/
    275                  hal_gpio_disable_pull((hal_gpio_pin_t)config_index[0]);
    276              } else if (1 == config_index[3]) {
    277                  hal_gpio_pull_up((hal_gpio_pin_t)config_index[0]);
    278              } else if (0 == config_index[3]) {
    279                  hal_gpio_pull_down((hal_gpio_pin_t)config_index[0]);
    280              }
    281          
    282              /*set output data */
    283              hal_gpio_set_output((hal_gpio_pin_t)config_index[0], (hal_gpio_data_t)config_index[4]);
    284              cli_putln();
    285              cli_puts("configure done\n");
    286              cli_putln();
    287              return 0;
    288          }
    289          
    290          static unsigned char gpio_get(uint8_t len, char *param[])
    291          {
    292          
    293              hal_gpio_data_t input_gpio_data = HAL_GPIO_DATA_LOW;
    294              hal_gpio_data_t output_gpio_data = HAL_GPIO_DATA_LOW;
    295              hal_gpio_direction_t gpio_dir;
    296              uint8_t i, gpio_function_index, pull;
    297          
    298              cli_putln();
    299              cli_puts("PIN:[mode][dir][pull][output][input]\n");
    300              cli_putln();
    301          
    302              for (i = 0; i < 73; i ++) {
    303                  hal_iot_gpio_get_pinmux((hal_gpio_pin_t)i, &gpio_function_index);
    304          
    305                  hal_gpio_get_direction((hal_gpio_pin_t)i, &gpio_dir);
    306                  if (HAL_GPIO_DIRECTION_OUTPUT == gpio_dir) {
    307                      hal_gpio_get_output((hal_gpio_pin_t)i, &output_gpio_data);
    308                  } else {
    309                      hal_gpio_get_input((hal_gpio_pin_t)i, &input_gpio_data);
    310                  }
    311          
    312                  hal_iot_gpio_get_pull((hal_gpio_pin_t)i, &pull);
    313                  printf("%-6d%-6d%-6d%-6d%-7d%d\n", i, gpio_function_index, gpio_dir, pull, output_gpio_data, input_gpio_data);
    314                  cli_putln();
    315              }
    316          
    317              cli_puts("done\r\n");
    318              cli_puts("0: pull down\r\n1: pull up\r\n2: disable pull\r\n");
    319              return 0;
    320          }
    321          
    322          
    323          cmd_t gpio_cli_cmds[] = {
    324              { "get", "get configurations of all pins", gpio_get, NULL },
    325              { "set", "set serveral configurations of one pins", gpio_set, NULL },
    326              { "set_mode", "set serveral configurations of one pins", gpio_set_mode, NULL },
    327              { "set_dir", "set serveral configurations of one pins", gpio_set_dir, NULL },
    328              { "set_pull", "set serveral configurations of one pins", gpio_set_pull, NULL },
    329              { "set_od", "set serveral configurations of one pins", gpio_set_od, NULL },
    330              { NULL, NULL, NULL, NULL }
    331          };

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   gpio_get
        32   -> cli_putln
        32   -> cli_puts
        32   -> hal_gpio_get_direction
        32   -> hal_gpio_get_input
        32   -> hal_gpio_get_output
        32   -> hal_iot_gpio_get_pinmux
        32   -> hal_iot_gpio_get_pull
        32   -> printf
      32   gpio_set
        32   -> cli_putln
        32   -> cli_puts
        32   -> hal_gpio_disable_pull
        32   -> hal_gpio_pull_down
        32   -> hal_gpio_pull_up
        32   -> hal_gpio_set_direction
        32   -> hal_gpio_set_output
        32   -> hal_pinmux_set_function
        32   -> toi
      16   gpio_set_dir
        16   -> cli_putln
        16   -> cli_puts
        16   -> hal_gpio_set_direction
        16   -> toi
      16   gpio_set_mode
        16   -> cli_putln
        16   -> cli_puts
        16   -> hal_pinmux_set_function
        16   -> toi
      16   gpio_set_od
        16   -> cli_putln
        16   -> cli_puts
        16   -> hal_gpio_set_output
        16   -> toi
      16   gpio_set_pull
        16   -> cli_putln
        16   -> cli_puts
        16   -> hal_gpio_disable_pull
        16   -> hal_gpio_pull_down
        16   -> hal_gpio_pull_up
        16   -> toi
       0   hal_iot_gpio_get_pinmux
       8   hal_iot_gpio_get_pull


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ?_0
      32  ?_1
      44  ?_10
      16  ?_11
      40  ?_12
      24  ?_13
       8  ?_14
       4  ?_2
      40  ?_3
      12  ?_4
       8  ?_5
      12  ?_6
       8  ?_7
      20  ?_8
      20  ?_9
     112  gpio_cli_cmds
     162  gpio_get
     218  gpio_set
     102  gpio_set_dir
     106  gpio_set_mode
     102  gpio_set_od
     140  gpio_set_pull
      38  hal_iot_gpio_get_pinmux
      84  hal_iot_gpio_get_pull

 
   112 bytes in section .data
   120 bytes in section .rodata
 1 132 bytes in section .text
 
 1 132 bytes of CODE  memory
   120 bytes of CONST memory
   112 bytes of DATA  memory

Errors: none
Warnings: none
