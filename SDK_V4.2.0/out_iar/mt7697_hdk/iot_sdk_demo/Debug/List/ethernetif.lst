###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       25/Jan/2017  17:34:58
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\lwip\ports\ethernetif.c
#    Command line =  
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\middleware\third_party\lwip\ports\ethernetif.c" -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_WIFI_TGN_VERIFY_ENABLE -D MTK_SMTCN_ENABLE -D
#        MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D SUPPORT_MBEDTLS -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-basic.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D MTK_MCS_ENABLE -D MTK_BLE_GPIO_SERVICE -D
#        __BT_DEBUG__ -lcN "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List" -lA
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List"
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj" --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\inc\" -I
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\service\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\dhcpd\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\src\ut_app\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\httpclient\inc\"
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List\ethernetif.lst
#    Object file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj\ethernetif.o
#
###############################################################################

C:\LEO\myGit\MTK IOT\SDK_V4.2.0\middleware\third_party\lwip\ports\ethernetif.c
      1          /**
      2           * @file
      3           * Ethernet Interface Skeleton
      4           *
      5           */
      6          
      7          /*
      8           * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
      9           * All rights reserved.
     10           *
     11           * Redistribution and use in source and binary forms, with or without modification,
     12           * are permitted provided that the following conditions are met:
     13           *
     14           * 1. Redistributions of source code must retain the above copyright notice,
     15           *    this list of conditions and the following disclaimer.
     16           * 2. Redistributions in binary form must reproduce the above copyright notice,
     17           *    this list of conditions and the following disclaimer in the documentation
     18           *    and/or other materials provided with the distribution.
     19           * 3. The name of the author may not be used to endorse or promote products
     20           *    derived from this software without specific prior written permission.
     21           *
     22           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
     23           * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     24           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
     25           * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     26           * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
     27           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     28           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     29           * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     30           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
     31           * OF SUCH DAMAGE.
     32           *
     33           * This file is part of the lwIP TCP/IP stack.
     34           *
     35           * Author: Adam Dunkels <adam@sics.se>
     36           *
     37           */
     38          
     39          /*
     40           * This file is a skeleton for developing Ethernet network interface
     41           * drivers for lwIP. Add code to the low_level functions and do a
     42           * search-and-replace for the word "ethernetif" to replace it with
     43           * something that better describes your network interface.
     44           */
     45          #include <stdio.h>
     46          #include <string.h>
     47          
     48          #include "lwip/opt.h"
     49          #include <stdint.h>
     50          #include "lwip/def.h"
     51          #include "lwip/mem.h"
     52          #include "lwip/pbuf.h"
     53          #include "lwip/sys.h"
     54          #include <lwip/stats.h>
     55          #include <lwip/snmp.h>
     56          #include <lwip/sockets.h>
     57          #include <lwip/tcpip.h>
     58          #include <lwip/dhcp.h>
     59          #include "netif/etharp.h"
     60          //#include "netif/ppp_oe.h"   //2015-7-21 bing.luo delete on@132599
     61          #include "ethernetif.h"
     62          #include "net_task.h"
     63          #include "type_def.h"
     64          #include "connsys_util.h"
     65          #include "connsys_driver.h"
     66          #include "inband_queue.h"
     67          #include "mt_cmd_fmt.h"
     68          #include "lwip/ethip6.h"
     69          #if defined(MTK_HAL_LOWPOWER_ENABLE)
     70          #include "hal_lp.h"
     71          #endif
     72          #include "syslog.h"
     73          #include "wifi_scan.h"
     74          #if (CFG_WIFI_HIF_GDMA_EN == 1)
     75          #include "hal_gdma.h"
     76          #endif
     77          #include "lwip/netif.h"
     78          #include "os_util.h"
     79          int32_t pkt_lock_init(struct os_time *timeout_value);
     80          
     81          /* Sanity check the configuration. */
     82          #define ALIGN_4BYTE(size)       (((size+3)/4) * 4)
     83          
     84          #ifndef IS_ALIGN_4
     85          #define IS_ALIGN_4(_value)      (((_value) & 0x3) ? FALSE : TRUE)
     86          #define IS_NOT_ALIGN_4(_value)  (((_value) & 0x3) ? TRUE : FALSE)
     87          #endif /* IS_ALIGN_4 */
     88          
     89          #ifndef IS_NOT_ALIGN_4
     90          #define IS_NOT_ALIGN_4(_value)  (((_value) & 0x3) ? TRUE : FALSE)
     91          #endif /* IS_NOT_ALIGN_4 */
     92          
     93          
     94          
     95          #if defined(MTK_BSP_LOOPBACK_ENABLE)
     96          #include "debug.h"
     97          unsigned int g_loopback_start = 0;
     98          unsigned int loopback_start() { return g_loopback_start;}
     99          void loopback_start_set(unsigned int start) { g_loopback_start = start; }
    100          #endif // MTK_BSP_LOOPBACK_ENABLE
    101          
    102          /* Define those to better describe your network interface. Note: only 2-byte allowed */
    103          #define IFNAME00 's'
    104          #define IFNAME01 't'
    105          #define IFNAME10 'a'
    106          #define IFNAME11 'p'
    107          #define IFNAME20 'l'
    108          #define IFNAME21 'o'
    109          
    110          static int g_lwip_eapol_rx_socket = -1;
    111          static int g_lwip_eapol_rx_socket_second = -1;
    112          
    113          struct netif sta_if, ap_if;//modified by Yong Chang
    114          
    115          /**
    116           * Helper struct to hold private data used to operate your ethernet interface.
    117           * Keeping the ethernet address of the MAC in this struct is not necessary
    118           * as it is already kept in the struct netif.
    119           * But this is only an example, anyway...
    120           */
    121          struct ethernetif {
    122            struct eth_addr *ethaddr;
    123            /* Add whatever per-interface state that is needed here. */
    124          };
    125          
    126          /* Forward declarations. */
    127          void  ethernetif_input(struct netif *netif, int port);
    128          void ethernetif_intr_enhance_mode_allocate_pkt_callback(
    129                                      unsigned int allocate_len,
    130                                      void** pkt_ptr,
    131                                      unsigned char** payload_ptr);
    132          void ethernetif_free_pkt(void *pkt_ptr);
    133          uint8_t enqueue_bottom_half_from_isr(int32_t port, PNETFUNC func);
    134          
    135          void inband_handle_func(void* pkt_ptr, unsigned char *payload, unsigned int len);
    136          
    137          #if 0
    138          static void InterruptSimulator( void *pvParameters )
    139          {
    140             /*
    141              *  There is no real way of simulating an interrupt.
    142              *  Make sure other tasks can run.
    143              */
    144          
    145             do
    146             {
    147                vTaskDelay(3*configTICK_RATE_HZ);
    148             }
    149             while (1);
    150          }
    151          #endif
    152          
    153          void register_eapol_rx_socket(int eapol_rx_socket)
    154          {
    155          	LOG_I(lwip, "%s\n", __FUNCTION__);
    156          
    157          	if (eapol_rx_socket >= 0)
    158          	g_lwip_eapol_rx_socket = eapol_rx_socket;
    159          	g_lwip_eapol_rx_socket_second = -1;
    160          }
    161          
    162          void unregister_eapol_rx_socket()
    163          {
    164              LOG_I(lwip, "%s\n", __FUNCTION__);
    165              if (g_lwip_eapol_rx_socket >= 0)
    166                  close(g_lwip_eapol_rx_socket);
    167              g_lwip_eapol_rx_socket = -1;
    168          }
    169          
    170          
    171          void register_eapol_rx_socket_dual_intf(int eapol_rx_socket, int eapol_rx_socket_second)
    172          {
    173              LOG_I(lwip, "%s\n", __FUNCTION__);
    174              if (eapol_rx_socket >= 0)
    175                  g_lwip_eapol_rx_socket = eapol_rx_socket;
    176          
    177              if (eapol_rx_socket_second >= 0)
    178                  g_lwip_eapol_rx_socket_second = eapol_rx_socket_second;
    179          }
    180          
    181          void unregister_eapol_rx_socket_dual_intf(int eapol_rx_socket, int eapol_rx_socket_second)
    182          {
    183              LOG_I(lwip, "%s\n", __FUNCTION__);
    184              if (eapol_rx_socket >= 0)
    185                  close(eapol_rx_socket);
    186              g_lwip_eapol_rx_socket = -1;
    187          
    188              if (eapol_rx_socket_second >= 0)
    189                  close(eapol_rx_socket_second);
    190              g_lwip_eapol_rx_socket_second = -1;
    191          }
    192          
    193          
    194          void low_level_set_mac_addr(struct netif *netif, uint8_t *mac_addr)
    195          {
    196              /* set MAC hardware address length */
    197              netif->hwaddr_len = ETHARP_HWADDR_LEN;
    198          
    199              /* set MAC hardware address */
    200              memcpy(netif->hwaddr, mac_addr, ETHARP_HWADDR_LEN);
    201          }
    202          
    203          /**
    204           * Find a network interface by searching for its name
    205           *
    206           * @param name the name of the netif (like netif->name) NOT plus concatenated number
    207           * in ascii representation (e.g. 'en0')
    208           */
    209          struct netif *
    210          netif_find_name(char *name)
    211          {
    212            struct netif *netif;
    213          
    214            if (name == NULL) {
    215              return NULL;
    216            }
    217          
    218            for(netif = netif_list; netif != NULL; netif = netif->next) {
    219              if (name[0] == netif->name[0] &&
    220                 name[1] == netif->name[1]) {
    221                LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
    222                return netif;
    223              }
    224            }
    225            LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
    226            return NULL;
    227          }
    228          
    229          
    230          
    231          int low_level_get_sta_mac_addr(unsigned char *mac_addr)
    232          {
    233              char name[3];
    234              struct netif *netif = NULL;
    235          
    236              name[0] = IFNAME00;
    237              name[1] = IFNAME01;
    238          
    239              netif = netif_find_name(name);
    240              if (netif)
    241              {
    242                  memcpy(mac_addr, netif->hwaddr, ETHARP_HWADDR_LEN);
    243              }
    244              else
    245              {
    246                  return -1;
    247              }
    248          
    249              return 0;
    250          }
    251          
    252          int low_level_get_ap_mac_addr(unsigned char *mac_addr)
    253          {
    254              char name[3];
    255              struct netif *netif = NULL;
    256          
    257              name[0] = IFNAME10;
    258              name[1] = IFNAME11;
    259          
    260              netif = netif_find_name(name);
    261              if (netif)
    262              {
    263                  memcpy(mac_addr, netif->hwaddr, ETHARP_HWADDR_LEN);
    264              }
    265              else
    266              {
    267                  return -1;
    268              }
    269          
    270              //snowpin test
    271              LOG_I(lwip, "%s - %02x:%02x:%02x:%02x:%02x:%02x\n",
    272                  __FUNCTION__, mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
    273              //snowpin test
    274          
    275              return 0;
    276          }
    277          
    278          
    279          
    280          /**
    281           * In this function, the hardware should be initialized.
    282           * Called from ethernetif_init().
    283           *
    284           * @param netif the already initialized lwip network interface structure
    285           *        for this ethernetif
    286           */
    287          static void
    288          low_level_init1(struct netif *netif)
    289          {
    290          #if 0 // init MAC address in upper layer
    291            /* set MAC hardware address length */
    292            netif->hwaddr_len = ETHARP_HWADDR_LEN;
    293          
    294            /* set MAC hardware address */
    295            netif->hwaddr[0] = 0x00;
    296            netif->hwaddr[1] = 0x0c;
    297            netif->hwaddr[2] = 0x43;
    298            netif->hwaddr[3] = 0x76;
    299            netif->hwaddr[4] = 0x62;
    300            netif->hwaddr[5] = 0x02;
    301          #endif
    302          
    303            /* maximum transfer unit */
    304            netif->mtu = 1500;
    305          
    306            /* device capabilities */
    307            /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
    308            netif->flags = NETIF_FLAG_IGMP | NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
    309          
    310            /* Do whatever else is needed to initialize interface. */
    311          }
    312          
    313          static void
    314          low_level_init2(struct netif *netif)
    315          {
    316          #if 0 // init MAC address in upper layer
    317            /* set MAC hardware address length */
    318            netif->hwaddr_len = ETHARP_HWADDR_LEN;
    319          
    320            /* set MAC hardware address */
    321            netif->hwaddr[0] = 0x00;
    322            netif->hwaddr[1] = 0x0c;
    323            netif->hwaddr[2] = 0x43;
    324            netif->hwaddr[3] = 0x76;
    325            netif->hwaddr[4] = 0x62;
    326            netif->hwaddr[5] = 0x04;
    327          #endif
    328          
    329            /* maximum transfer unit */
    330            netif->mtu = 1500;
    331          
    332            /* device capabilities */
    333            /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
    334            netif->flags = NETIF_FLAG_IGMP | NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
    335          
    336            /* Do whatever else is needed to initialize interface. */
    337          }
    338          
    339          
    340          /**
    341           * This function should do the actual transmission of the packet. The packet is
    342           * contained in the pbuf that is passed to the function. This pbuf
    343           * might be chained.
    344           *
    345           * @param netif the lwip network interface structure for this ethernetif
    346           * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
    347           * @return ERR_OK if the packet could be sent
    348           *         an err_t value if the packet couldn't be sent
    349           *
    350           * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
    351           *       strange results. You might consider waiting for space in the DMA queue
    352           *       to become availale since the stack doesn't retry to send a packet
    353           *       dropped because of memory failure (except for the TCP timers).
    354           */
    355          #if 0
    356          static int low_level_output(struct netif *netif, struct pbuf *p)
    357          {
    358              struct pbuf *q;
    359              u32_t total_len = 0;
    360              int ret = ERR_OK;
    361              int connsys_ret = CONNSYS_STATUS_SUCCESS;
    362              u32_t pbuf_num = 0;
    363              unsigned char *pBuffer = NULL;
    364              unsigned char *pBuffer_4byte_align = NULL;
    365              unsigned char *pTmp = NULL;
    366              taskENTER_CRITICAL();
    367          
    368          
    369              for(q = p; q != NULL; q = q->next) {
    370                  total_len = total_len + (q->len);
    371                  pbuf_num = pbuf_num + 1;
    372                  DBG_CONNSYS(CONNSYS_DBG_TX_Q1,("==>low_level_output, q->len = %u\n",
    373                      (unsigned int)q->len));
    374              }
    375              DBG_CONNSYS(CONNSYS_DBG_TX_Q1,("==>low_level_output, pbuf_num = %u, total_len = %u\n",
    376                  (unsigned int)pbuf_num, (unsigned int)total_len));
    377          
    378              if (pbuf_num > 1)
    379              {
    380                  /* concate pbuf_chain into single buffer */
    381                  u32_t allocate_len = total_len +
    382                      CFG_CONNSYS_IOT_TX_ZERO_COPY_PAD_LEN +
    383                      WIFI_HIF_TX_BYTE_CNT_LEN;
    384          
    385                  u32_t payload_offset = sizeof(INIT_HIF_TX_HEADER_T);
    386          
    387          #if (CFG_CONNSYS_IOT_TX_ZERO_COPY_EN == 1)
    388                  payload_offset += CFG_CONNSYS_IOT_TX_ZERO_COPY_PAD_LEN;
    389          #endif
    390          
    391                  if (IS_NOT_ALIGN_4(total_len))
    392                      allocate_len += 4;
    393          
    394                  pBuffer = os_malloc(allocate_len);
    395                  if (NULL == pBuffer)
    396                  {
    397                      LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
    398                      DBG_CONNSYS(CONNSYS_DBG_TX_Q1,("==>low_level_output, out of memory\n"));
    399                      taskEXIT_CRITICAL();
    400                      return ERR_MEM;
    401                  }
    402                  pBuffer_4byte_align = (unsigned char *)((unsigned int)pBuffer & (~0x3UL));
    403                  pTmp = pBuffer_4byte_align + payload_offset;
    404          
    405                  for(q = p; q != NULL; q = q->next) {
    406                      memcpy(pTmp, q->payload, q->len);
    407                      pTmp += (q->len);
    408                  }
    409          
    410                  if (netif == &ap_if)
    411                  {
    412                      connsys_ret = connsys_util_low_level_output(pBuffer_4byte_align, total_len, IOT_PACKET_TYPE_INF_1_IDX);
    413                  }
    414                  else
    415                  {
    416                      connsys_ret = connsys_util_low_level_output(pBuffer_4byte_align, total_len, IOT_PACKET_TYPE_INF_0_IDX);
    417                  }
    418                  os_free(pBuffer);
    419              }
    420              else
    421              {
    422          #if CFG_CONNSYS_TXD_PAD_SIZE
    423                  pbuf_header(p, CFG_CONNSYS_TXD_PAD_SIZE);
    424          #endif
    425          
    426                  if (netif == &ap_if)
    427                  {
    428                      connsys_ret = connsys_util_low_level_output(p->payload, total_len, IOT_PACKET_TYPE_INF_1_IDX);
    429                  }
    430                  else
    431                  {
    432                      connsys_ret = connsys_util_low_level_output(p->payload, total_len, IOT_PACKET_TYPE_INF_0_IDX);
    433                  }
    434              }
    435          
    436              if (connsys_ret == CONNSYS_STATUS_FAIL)
    437                  ret = ERR_BUF;
    438          
    439            LINK_STATS_INC(link.xmit);
    440            taskEXIT_CRITICAL();
    441            return ret;
    442          }
    443          #endif
    444          
    445          static int32_t low_level_output_scatter(struct netif *netif, struct pbuf *p)
    446          {
    447              P_HIF_TX_HEADER_PORT1_T p_txd;
    448              int32_t ret = CONNSYS_STATUS_SUCCESS;
    449              int connsys_ret = CONNSYS_STATUS_SUCCESS;
    450              struct pbuf *q;
    451              int32_t inf_num;
    452              uint32_t total_len = 0;
    453              connsys_tx_scatter_info_t tx_info;
    454              signed int flow_control_status;
    455          #if (CONNSYS_DEBUG_MODE_EN == 1)
    456              static uint32_t tx_sequence = 0;
    457          #endif
    458          
    459          #ifdef MTK_WIFI_REPEATER_ENABLE
    460              int    i = 0;
    461              struct eth_hdr *ethhdr;
    462              struct etharp_hdr *hdr;
    463          
    464              int      sndAllInf = 0;
    465              unsigned char op_mode = WIFI_MODE_STA_ONLY;
    466          
    467              ethhdr = (struct eth_hdr *)p->payload;
    468              // Check if OpMode is Repeater Mode. Broadcast to all interfaces only at Repeater Mode.
    469              if (__g_wpa_supplicant_api.wpa_supplicant_entry_op_mode_get)
    470              {
    471                  __g_wpa_supplicant_api.wpa_supplicant_entry_op_mode_get(&op_mode);
    472                  if (op_mode == WIFI_MODE_REPEATER)
    473                  {
    474                     sndAllInf = (memcmp(&(ethhdr->dest.addr), "\xff\xff\xff\xff\xff\xff", 6) == 0)?1:0;
    475                  }
    476              }
    477          
    478              for (i=0; i<=sndAllInf; i++)
    479              {
    480                  total_len = 0;
    481                  // Change Source Mac for Ether/Arp packets if it is need
    482                  if (op_mode == WIFI_MODE_REPEATER)
    483                  {
    484                      if ( sndAllInf && (i==sndAllInf) )
    485                      {
    486                          if (   (memcmp(&ethhdr->src, (struct eth_addr*)(sta_if.hwaddr), 6)==0)
    487                              || (memcmp(&ethhdr->src, (struct eth_addr*)(ap_if.hwaddr), 6)==0)
    488                             )
    489                          {
    490                             //LOG_I(lwip, "src - %2x:%2x:%2x:%2x:%2x:%2x, dest - %2x:%2x:%2x:%2x:%2x:%2x, sndAllInf(%d)\n", ethhdr->src.addr[0], ethhdr->src.addr[1], ethhdr->src.addr[2], ethhdr->src.addr[3], ethhdr->src.addr[4], ethhdr->src.addr[5], ethhdr->dest.addr[0], ethhdr->dest.addr[1], ethhdr->dest.addr[2], ethhdr->dest.addr[3], ethhdr->dest.addr[4], ethhdr->dest.addr[5], sndAllInf);
    491                              netif = (netif == &ap_if)?&sta_if:&ap_if;
    492                              ETHADDR16_COPY(&ethhdr->src, (struct eth_addr*)(netif->hwaddr));
    493                              if ( ethhdr->type == PP_HTONS(ETHTYPE_ARP) )
    494                             {
    495                                 hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
    496                                 #if ETHARP_SUPPORT_VLAN
    497                                   if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
    498                                     hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
    499                                   }
    500                                 #endif /* ETHARP_SUPPORT_VLAN */
    501                                 ETHADDR16_COPY(&(hdr->shwaddr), (struct eth_addr*)(netif->hwaddr));
    502                             }
    503                          }
    504                      }
    505                      // Check if this remote STA mac belong to this AP
    506                      else if ( (__g_wpa_supplicant_api.get_ap_sta) && (__g_wpa_supplicant_api.get_ap_sta((char *)&(ethhdr->dest.addr))) )
    507                      {
    508                          netif = &ap_if;
    509                          if (memcmp(&ethhdr->src, (struct eth_addr*)(sta_if.hwaddr), 6)==0)
    510                          {
    511                              ETHADDR16_COPY(&ethhdr->src, (struct eth_addr*)(netif->hwaddr));
    512                          }
    513                          LOG_I(lwip,"Change netif to ap_if : src - %2x:%2x:%2x:%2x:%2x:%2x, dest - %2x:%2x:%2x:%2x:%2x:%2x\n", ethhdr->src.addr[0], ethhdr->src.addr[1], ethhdr->src.addr[2], ethhdr->src.addr[3], ethhdr->src.addr[4], ethhdr->src.addr[5],ethhdr->dest.addr[0], ethhdr->dest.addr[1], ethhdr->dest.addr[2], ethhdr->dest.addr[3], ethhdr->dest.addr[4], ethhdr->dest.addr[5]);
    514                      }
    515                  }
    516          #endif
    517          
    518          #if (CONNSYS_DEBUG_MODE_EN == 1)
    519              if (CONNSYS_TEST_DEBUG(CONNSYS_DBG_TX_Q1))
    520              {
    521                  LOG_I(lwip, "== TX Start ==  tx_sequence: %u\n", (unsigned int)tx_sequence);
    522              }
    523              tx_sequence++;
    524          #endif
    525          
    526              memset(&tx_info, 0, sizeof(connsys_tx_scatter_info_t));
    527              if (netif == &ap_if)
    528              {
    529                  inf_num = IOT_PACKET_TYPE_INF_1_IDX;
    530              }
    531              else
    532              {
    533                  inf_num = IOT_PACKET_TYPE_INF_0_IDX;
    534              }
    535              //LOG_I(lwip, "sendto inf_num(%d)...%s-%d\n",inf_num,__FUNCTION__,__LINE__);
    536              for(q = p; q != NULL; q = q->next) {
    537                  if (tx_info.buf_num >= MAX_TX_BUF)
    538                  {
    539                      LOG_E(lwip, "ERROR! ==> low_level_output_scatter, buf_num exceed MAX_TX_BUF\n");
    540                      LOG_E(lwip, "tx_info.buf_num = %u, MAX_TX_BUF = %u\n",
    541                          (unsigned int)tx_info.buf_num,
    542                          (unsigned int)MAX_TX_BUF);
    543                      connsys_dump_tx_scatter_info(&tx_info);
    544                      return ERR_BUF;
    545                  }
    546                  
    547                  total_len = total_len + (q->len);
    548                  tx_info.buff[tx_info.buf_num].buf_ptr = q->payload;
    549                  tx_info.buff[tx_info.buf_num].buf_len= q->len;
    550          
    551          #if (CONNSYS_DEBUG_MODE_EN == 1)
    552                  DBG_CONNSYS(CONNSYS_DBG_TX_Q1,("pbuf chain len[%u]: %u\n",
    553                      (unsigned int)tx_info.buf_num,
    554                      (unsigned int)q->len));
    555          #endif
    556          
    557                  tx_info.buf_num ++;
    558              }
    559          #if (CFG_CONNSYS_IOT_TX_ZERO_COPY_EN == 1)
    560          #ifdef MTK_MINISUPP_ENABLE
    561              if (__g_wpa_supplicant_api.get_sta_qos_bit) {
    562                  tx_info.fg_wmm = __g_wpa_supplicant_api.get_sta_qos_bit(inf_num, (char *)p->payload);
    563              }
    564              if (tx_info.fg_wmm == 1)
    565                  tx_info.reserved_headroom_len = connsys_get_headroom_offset(CONNSYS_HEADROOM_OFFSET_QOS); //EXTRA_HEADROOM_LEN_FOR_QOS_ENABLE;
    566              else
    567                  tx_info.reserved_headroom_len = connsys_get_headroom_offset(CONNSYS_HEADROOM_OFFSET_NON_QOS); // EXTRA_HEADROOM_LEN_FOR_NON_QOS;
    568          #endif
    569          #else
    570              tx_info.reserved_headroom_len = 0;
    571          #endif
    572              tx_info.tx_len = sizeof(INIT_HIF_TX_HEADER_T)
    573                                  + tx_info.reserved_headroom_len
    574                                  + total_len;
    575          
    576              tx_info.real_tx_len = ALIGN_4BYTE(tx_info.tx_len);
    577          
    578              p_txd = (P_HIF_TX_HEADER_PORT1_T)&tx_info.txd;
    579              p_txd->u2TxByteCount = tx_info.tx_len;
    580              p_txd->u2PQ_ID = P1_Q1;
    581              p_txd->ucPktTypeID = PKT_ID_CMD;
    582              p_txd->ucPacketOffset = tx_info.reserved_headroom_len;
    583          
    584              if (inf_num == IOT_PACKET_TYPE_INF_1_IDX)
    585                  p_txd->ucReserved = IOT_PACKET_TYPE_INF_1;
    586              else
    587                  p_txd->ucReserved = IOT_PACKET_TYPE_INF_0;
    588          
    589          
    590              if (CONNSYS_TEST_DEBUG(CONNSYS_DBG_TX_Q1))
    591              {
    592                  connsys_dump_tx_scatter_info(&tx_info);
    593              }
    594          
    595          #if (CFG_CONNSYS_TRX_BALANCE_EN == 1)
    596              if (g_balance_ctr.balance_en == TRUE)
    597              {
    598                  if (connsys_balance_check_tx_yield())
    599                  {
    600                      vTaskPrioritySet(NULL, (TCPIP_THREAD_PRIO - 1));
    601                      vTaskPrioritySet((TaskHandle_t)g_balance_ctr.rx_handle, TCPIP_THREAD_PRIO);
    602                  }
    603                  else
    604                  {
    605                      vTaskPrioritySet(NULL, TCPIP_THREAD_PRIO);
    606                      vTaskPrioritySet((TaskHandle_t)g_balance_ctr.rx_handle, (TCPIP_THREAD_PRIO - 1));
    607                  }
    608              }
    609          #endif
    610          
    611              flow_control_status =
    612                  connsys_tx_flow_control_check_and_update_tx(WIFI_HIF_TX_PORT_IDX, tx_info.real_tx_len);
    613          
    614              if (flow_control_status == CONNSYS_STATUS_SUCCESS)
    615              {
    616                  connsys_ret = connsys_write_data(&tx_info);
    617              }
    618              else
    619              {
    620                  int query_limit = 1;
    621                  while(query_limit--){
    622                      connsys_tx_query_whisr();
    623                      flow_control_status =
    624                          connsys_tx_flow_control_check_and_update_tx(WIFI_HIF_TX_PORT_IDX, tx_info.real_tx_len);
    625                      if(flow_control_status == CONNSYS_STATUS_SUCCESS)
    626                          break;
    627                  }
    628                  
    629                  if(CONNSYS_STATUS_SUCCESS == flow_control_status){
    630                      connsys_ret = connsys_write_data(&tx_info);
    631                  }else{
    632                      connsys_ret = CONNSYS_STATUS_FAIL;
    633                  }
    634              }
    635          
    636              if (connsys_ret == CONNSYS_STATUS_FAIL)
    637                  ret = ERR_BUF;
    638              else
    639                  LINK_STATS_INC(link.xmit);
    640          
    641          #if (CFG_CONNSYS_TRX_BALANCE_EN == 1)
    642              connsys_balance_clear_tx_wait();
    643          #endif
    644          
    645          #if (CONNSYS_DEBUG_MODE_EN == 1)
    646              DBG_CONNSYS(CONNSYS_DBG_TX_Q1,("== TX End ==\n"));
    647          #endif
    648          
    649          #ifdef MTK_WIFI_REPEATER_ENABLE
    650          }
    651          #endif
    652              return ret;
    653          }
    654          
    655          uint8_t lwip_advance_pkt_hdr(void *pkt, int16_t len)
    656          {
    657              return pbuf_header((struct pbuf *)pkt, -(s16_t)len);
    658          }
    659          
    660          struct mt76x7_connsys_ops lwip_connsys_ops = {
    661              .enqueue_bottom_half    = &enqueue_bottom_half_from_isr,
    662              .alloc                  = &ethernetif_intr_enhance_mode_allocate_pkt_callback,
    663              .free                   = &ethernetif_free_pkt,
    664              .advance_pkt_hdr        = &lwip_advance_pkt_hdr,
    665              .deliver_inband         = &connsys_deliver_inband,
    666              .deliver_tcpip          = &lwip_deliver_tcpip,
    667          };
    668          
    669          void ethernetif_init_callback(void)
    670          {
    671              inband_queue_register_callback(inband_handle_func);
    672              connsys_ops = &lwip_connsys_ops;
    673          
    674              //pkt_lock_init(NULL);
    675          }
    676          
    677          /**
    678           * Should be called at the beginning of the program to set up the
    679           * network interface. It calls the function low_level_init() to do the
    680           * actual setup of the hardware.
    681           *
    682           * This function should be passed as a parameter to netif_add().
    683           *
    684           * @param netif the lwip network interface structure for this ethernetif
    685           * @return ERR_OK if the loopif is initialized
    686           *         ERR_MEM if private data couldn't be allocated
    687           *         any other err_t on error
    688           */
    689          err_t
    690          ethernetif_init1(struct netif *netif)
    691          {
    692            struct ethernetif *ethernetif;
    693          
    694            LWIP_ASSERT("netif != NULL", (netif != NULL));
    695          
    696            LOG_I(lwip, "=> %s\n", __FUNCTION__);
    697          
    698            ethernetif = mem_malloc(sizeof(struct ethernetif));
    699            if (ethernetif == NULL) {
    700              LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
    701              return ERR_MEM;
    702            }
    703          
    704            LOG_I(lwip, "%s : malloc ok : %p\n", __FUNCTION__, ethernetif);
    705          #if LWIP_NETIF_HOSTNAME
    706            /* Initialize interface hostname */
    707            netif->hostname = "lwip";
    708          #endif /* LWIP_NETIF_HOSTNAME */
    709          
    710            /*
    711             * Initialize the snmp variables and counters inside the struct netif.
    712             * The last argument should be replaced with your link speed, in units
    713             * of bits per second.
    714             */
    715            NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
    716          
    717            netif->state = ethernetif;
    718            netif->name[0] = IFNAME00;
    719            netif->name[1] = IFNAME01;
    720            /* We directly use etharp_output() here to save a function call.
    721             * You can instead declare your own function an call etharp_output()
    722             * from it if you have to do some checks before sending (e.g. if link
    723             * is available...) */
    724            netif->output = etharp_output;
    725            #if LWIP_IPV6
    726            netif->output_ip6 = ethip6_output;
    727            #endif /* LWIP_IPV6 */
    728            netif->linkoutput = (netif_linkoutput_fn)low_level_output_scatter;
    729          
    730            ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
    731          
    732            /* initialize the hardware */
    733            low_level_init1(netif);
    734          
    735          #if 0
    736            /* Create a task that simulates an interrupt in a real system.  This will
    737            block waiting for packets, then send a message to the uIP task when data
    738            is available. */
    739          
    740            LOG_I(lwip, "Create RX task\n\r");
    741            xTaskCreate(InterruptSimulator, "RX", 400, (void *)netif, 3, NULL );
    742          #endif
    743            return ERR_OK;
    744          }
    745          
    746          err_t
    747          ethernetif_init2(struct netif *netif)
    748          {
    749            struct ethernetif *ethernetif;
    750          
    751            LWIP_ASSERT("netif != NULL", (netif != NULL));
    752          
    753            LOG_I(lwip, "=> %s\n", __FUNCTION__);
    754          
    755            ethernetif = mem_malloc(sizeof(struct ethernetif));
    756            if (ethernetif == NULL) {
    757              LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
    758              return ERR_MEM;
    759            }
    760          
    761            LOG_I(lwip, "%s : malloc ok : %p\n", __FUNCTION__, ethernetif);
    762          #if LWIP_NETIF_HOSTNAME
    763            /* Initialize interface hostname */
    764            netif->hostname = "lwip";
    765          #endif /* LWIP_NETIF_HOSTNAME */
    766          
    767            /*
    768             * Initialize the snmp variables and counters inside the struct netif.
    769             * The last argument should be replaced with your link speed, in units
    770             * of bits per second.
    771             */
    772            NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
    773          
    774            netif->state = ethernetif;
    775            netif->name[0] = IFNAME10;
    776            netif->name[1] = IFNAME11;
    777            /* We directly use etharp_output() here to save a function call.
    778             * You can instead declare your own function an call etharp_output()
    779             * from it if you have to do some checks before sending (e.g. if link
    780             * is available...) */
    781            netif->output = etharp_output;
    782            #if LWIP_IPV6
    783            netif->output_ip6 = ethip6_output;
    784            #endif /* LWIP_IPV6 */
    785            netif->linkoutput = (netif_linkoutput_fn)low_level_output_scatter;
    786          
    787            ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
    788          
    789            /* initialize the hardware */
    790            low_level_init2(netif);
    791          
    792          #if 0
    793            /* Create a task that simulates an interrupt in a real system.  This will
    794            block waiting for packets, then send a message to the uIP task when data
    795            is available. */
    796          
    797            LOG_I(lwip, "Create RX task\n\r");
    798            xTaskCreate(InterruptSimulator, "RX", 400, (void *)netif, 3, NULL );
    799          #endif
    800            return ERR_OK;
    801          }
    802          
    803          int ethernet_raw_pkt_sender(unsigned char *buf, unsigned int len, struct netif *netif)
    804          {
    805              struct pbuf *p;
    806              int ret = 0;
    807          
    808              p = pbuf_alloc(PBUF_RAW_TX, len, PBUF_POOL);
    809              if (p == NULL)
    810              {
    811                  LOG_E(lwip, "%s pbuf_alloc fail\n\r", __FUNCTION__);
    812                  return -1;
    813              }
    814              memcpy(p->payload, buf, len);
    815          
    816              ret = low_level_output_scatter(netif, p);
    817              pbuf_free(p);
    818              return ret;
    819          }
    820          
    821          void ethernetif_intr_enhance_mode_allocate_pkt_callback(
    822                                      unsigned int allocate_len,
    823                                      void** pkt_ptr,
    824                                      unsigned char** payload_ptr)
    825          {
    826              struct pbuf *p;
    827          
    828              /* We allocate a pbuf chain of pbufs from the pool. */
    829          #if (CFG_CONNSYS_TRX_BALANCE_EN == 1)
    830          
    831              if (g_balance_ctr.balance_en == TRUE)
    832              {
    833                  if (connsys_balance_check_rx_yield())
    834                  {
    835                      vTaskPrioritySet(NULL, (TCPIP_THREAD_PRIO - 1));
    836                      if (g_balance_ctr.tx_handle)
    837                          vTaskPrioritySet((TaskHandle_t)g_balance_ctr.tx_handle, TCPIP_THREAD_PRIO);
    838                  }
    839                  else
    840                  {
    841                      vTaskPrioritySet(NULL, TCPIP_THREAD_PRIO);
    842                  }
    843                  p = pbuf_alloc(PBUF_RAW, (ssize_t)allocate_len, PBUF_POOL);
    844          
    845                  if (p)
    846                  {
    847                      (*pkt_ptr) = p;
    848                      (*payload_ptr) = p->payload;
    849                  }
    850                  else
    851                  {
    852                      (*pkt_ptr) = NULL;
    853                      (*payload_ptr) = NULL;
    854                      vTaskPrioritySet(NULL, (TCPIP_THREAD_PRIO - 1));
    855                      if (g_balance_ctr.tx_handle)
    856                          vTaskPrioritySet((TaskHandle_t)g_balance_ctr.tx_handle, TCPIP_THREAD_PRIO);
    857                  }
    858              }
    859              else
    860              {
    861                  p = pbuf_alloc(PBUF_RAW, (ssize_t)allocate_len, PBUF_POOL);
    862                  if (p)
    863                  {
    864                      (*pkt_ptr) = p;
    865                      (*payload_ptr) = p->payload;
    866                      vTaskPrioritySet(NULL, TCPIP_THREAD_PRIO);
    867                  }
    868                  else
    869                  {
    870                      (*pkt_ptr) = NULL;
    871                      (*payload_ptr) = NULL;
    872                      vTaskPrioritySet(NULL, TCPIP_THREAD_PRIO - 1);
    873                  }
    874              }
    875          #else
    876              p = pbuf_alloc(PBUF_RAW, (ssize_t)allocate_len, PBUF_POOL);
    877              if (p)
    878              {
    879                  (*pkt_ptr) = p;
    880                  (*payload_ptr) = p->payload;
    881                  //vTaskPrioritySet(NULL, TCPIP_THREAD_PRIO);
    882              }
    883              else
    884              {
    885                  (*pkt_ptr) = NULL;
    886                  (*payload_ptr) = NULL;
    887                  //vTaskPrioritySet(NULL, (TCPIP_THREAD_PRIO - 1));
    888              }
    889          #endif /* (CFG_CONNSYS_TRX_BALANCE_EN == 1) */
    890          }
    891          
    892          
    893          void
    894          ethernetif_intr_enhance_mode_dispatch(struct pbuf *p, struct netif *netif)
    895          {
    896            //struct ethernetif *ethernetif;
    897          
    898            struct eth_hdr *ethhdr;
    899          
    900            //ethernetif = netif->state;
    901            /* move received packet into a new pbuf */
    902          
    903            /* no packet could be read, silently ignore this */
    904            if (p == NULL) return;
    905            /* points to packet payload, which starts with an Ethernet header */
    906            ethhdr = p->payload;
    907          
    908            switch (htons(ethhdr->type)) {
    909            /* IP or ARP packet? */
    910            case ETHTYPE_IP:
    911          #if LWIP_IPV6
    912            case ETHTYPE_IPV6:
    913          #endif
    914            case ETHTYPE_ARP:
    915          #if PPPOE_SUPPORT
    916            /* PPPoE packet? */
    917            case ETHTYPE_PPPOEDISC:
    918            case ETHTYPE_PPPOE:
    919          #endif /* PPPOE_SUPPORT */
    920              /* full packet send to tcpip_thread to process */
    921              if (netif->input(p, netif) != ERR_OK)
    922               { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
    923                 pbuf_free(p);
    924                 p = NULL;
    925               }
    926              break;
    927          #if 1 // for wpa_supplicant eapol packets
    928            case 0x888E:
    929          #ifndef RELAY
    930              if((p->len > 12) && (g_lwip_eapol_rx_socket >= 0) && (g_lwip_eapol_rx_socket_second >= 0)) {
    931                      struct sockaddr_in    to;
    932                      ssize_t               len;
    933          
    934                      LOG_I(lwip,"<<Dual interface RX EAPOL (Len=%d)>>\n", p->len);
    935          
    936                      to.sin_family      = PF_INET;
    937                      to.sin_addr.s_addr = htonl((127 << 24) | 1);
    938          
    939                      if ((IFNAME10 == netif->name[0]) && (IFNAME11 == netif->name[1])) {
    940                          to.sin_port = htons(66);
    941                          LOG_I(lwip,"send to AP socket[%d]...\n", g_lwip_eapol_rx_socket);
    942                          len = lwip_sendto(g_lwip_eapol_rx_socket, p->payload, p->len, 0, (struct sockaddr *)&to, sizeof(to));
    943                      } else {
    944                          to.sin_port = htons(76);
    945                          LOG_I(lwip,"send to STA socket[%d]...\n", g_lwip_eapol_rx_socket_second);
    946                          len = lwip_sendto(g_lwip_eapol_rx_socket_second, p->payload, p->len, 0, (struct sockaddr *)&to, sizeof(to));
    947                      }
    948          
    949                      if (len != p->len)
    950                          LOG_E(lwip,"Dual interface eapol-rx relay sendto failed!\n");
    951              }//dual interface
    952              else if ((p->len > 12) && (g_lwip_eapol_rx_socket >= 0))
    953              {
    954                  struct sockaddr_in    to;
    955                  ssize_t               len;
    956          
    957                  LOG_I(lwip, "<<RX EAPOL (Len=%d)>>\n", p->len);
    958          
    959                  to.sin_family      = PF_INET;
    960                  to.sin_addr.s_addr = htonl((127 << 24) | 1);
    961          
    962                  to.sin_port        = htons(66);
    963                  LOG_I(lwip, "send to socket[%d]...\n", g_lwip_eapol_rx_socket);
    964                  len = lwip_sendto(g_lwip_eapol_rx_socket, p->payload, p->len, 0, (struct sockaddr *)&to, sizeof(to));
    965          
    966                  if (len != p->len)
    967                      LOG_E(lwip, "Single interface eapol-rx relay sendto failed!\n");
    968              }
    969          
    970              pbuf_free(p);
    971              p = NULL;
    972          #else
    973              if (p->len > 0) {
    974                  // TODO: relay
    975              }
    976          #endif
    977              break;
    978          #endif
    979            default:
    980              pbuf_free(p);
    981              p = NULL;
    982              break;
    983            }
    984          }
    985          
    986          #define MAX_CONNSYS_RX_ZERO_CP_PKT_CONTENT 128
    987          
    988          PKT_HANDLE_RESULT_T lwip_deliver_tcpip(void* pkt, uint8_t *payload, uint32_t len, int inf)
    989          {
    990              struct pbuf *p = (struct pbuf *) pkt;
    991              struct netif *netif = &sta_if;
    992          
    993              if(p != NULL){
    994                  int i;
    995          
    996                  if (inf == 1)
    997                      netif = &ap_if;
    998          
    999                  LINK_STATS_INC(link.recv);
   1000                  ethernetif_intr_enhance_mode_dispatch(p, netif);
   1001          
   1002                  return PKT_HANDLE_NON_COMPLETE;
   1003              }else{
   1004                  LOG_E(lwip, "%s pbuf NULL\n\r", __FUNCTION__);
   1005                  LINK_STATS_INC(link.memerr);
   1006                  LINK_STATS_INC(link.drop);
   1007                  return PKT_HANDLE_COMPLETE;
   1008              }
   1009          }
   1010          
   1011          
   1012          void inband_handle_func(void* pkt_ptr, unsigned char *payload, unsigned int len)
   1013          {
   1014              struct pbuf *p = (struct pbuf *) pkt_ptr;
   1015          
   1016              inband_queue_handler(pkt_ptr, payload, len);
   1017              pbuf_free(p);
   1018              pkt_ptr = NULL;
   1019          }
   1020          
   1021          void ethernetif_free_pkt(void *pkt_ptr)
   1022          {
   1023              pbuf_free((struct pbuf*)pkt_ptr);
   1024          }
   1025          
   1026          uint8_t enqueue_bottom_half_from_isr(int32_t port, PNETFUNC func)
   1027          {
   1028              return NetJobAddFromISR(func, 0, 0);    
   1029          }
   1030          
   1031          void ethernetif_init(sta_ip_mode_t sta_ip_mode,
   1032                               uint8_t *sta_mac_addr,
   1033                               uint8_t *ap_mac_addr,
   1034                               ip4_addr_t *sta_ip_addr, ip4_addr_t *sta_net_mask, ip4_addr_t *sta_gw,
   1035                               ip4_addr_t *ap_ip_addr, ip4_addr_t *ap_net_mask, ip4_addr_t *ap_gw,
   1036                               uint8_t opmode)
   1037          {
   1038              uint8_t sta_mac_address[6];
   1039              uint8_t ap_mac_address[6];
   1040          
   1041              /* for patch and fw download */
   1042              ethernetif_init_callback();
   1043          
   1044              memset(&sta_if, 0, sizeof(sta_if));
   1045              memset(&ap_if,  0, sizeof(ap_if));
   1046          
   1047              // Note: *MUST* first add AP, then STA interface, to make STA the first
   1048              //       interface in the link-list: STA -> AP -> NULL.
   1049              if (0 > wifi_config_get_mac_address(WIFI_PORT_STA, (uint8_t *)&sta_mac_address) ||
   1050                  0 > wifi_config_get_mac_address(WIFI_PORT_AP, (uint8_t *)&ap_mac_address)) {
   1051                  LOG_E(lwip, "get mac fail\n\r");
   1052                  return;
   1053              }
   1054          
   1055              netif_add(&ap_if, ap_ip_addr, ap_net_mask, ap_gw, NULL,
   1056                        ethernetif_init2, tcpip_input);
   1057              netif_add(&sta_if, sta_ip_addr, sta_net_mask, sta_gw,
   1058                        NULL, ethernetif_init1, tcpip_input);
   1059          
   1060              low_level_set_mac_addr(&ap_if,  ap_mac_address);
   1061              low_level_set_mac_addr(&sta_if, sta_mac_address);
   1062          
   1063              //netif_set_default(&sta_if);
   1064              netif_set_up(&sta_if);
   1065              netif_set_up(&ap_if);
   1066          
   1067              //install default route
   1068              switch (opmode) {
   1069                  case WIFI_MODE_AP_ONLY:
   1070                      netif_set_default(&ap_if);
   1071                      netif_set_link_down(&sta_if);
   1072                      break;
   1073                  case WIFI_MODE_STA_ONLY:
   1074                      netif_set_default(&sta_if);
   1075                      netif_set_link_down(&ap_if);
   1076                      break;
   1077                  case WIFI_MODE_REPEATER:
   1078                      netif_set_default(&sta_if);
   1079                      break;
   1080              }
   1081          }
   1082          
   1083          void lwip_tcpip_init(lwip_tcpip_config_t *tcpip_config, uint8_t opmode)
   1084          {
   1085              lwip_socket_init();
   1086              tcpip_init(NULL, NULL);
   1087              ethernetif_init(STA_IP_MODE_DHCP,
   1088                              NULL,
   1089                              NULL,
   1090                              &tcpip_config->sta_addr,
   1091                              &tcpip_config->sta_mask,
   1092                              &tcpip_config->sta_gateway,
   1093                              &tcpip_config->ap_addr,
   1094                              &tcpip_config->ap_mask,
   1095                              &tcpip_config->ap_gateway,
   1096                              opmode);
   1097          }
   1098          
   1099          
   1100          static int lwip_get_netif_name(netif_type_t netif_type, char *name)
   1101          {
   1102              struct netif *netif = NULL;
   1103          
   1104              if (name == NULL) {
   1105                  return 0;
   1106              }
   1107          
   1108              for (netif = netif_list; netif != NULL; netif = netif->next) {
   1109                  if (netif_type == NETIF_TYPE_AP &&
   1110                          IFNAME10 == netif->name[0] &&
   1111                          IFNAME11 == netif->name[1]) {
   1112                      name[0] = IFNAME10;
   1113                      name[1] = IFNAME11;
   1114                      name[2] = '0' + netif->num;
   1115                      return 1;
   1116                  } else if (netif_type == NETIF_TYPE_STA &&
   1117                             IFNAME00 == netif->name[0] &&
   1118                             IFNAME01 == netif->name[1]) {
   1119                      name[0] = IFNAME00;
   1120                      name[1] = IFNAME01;
   1121                      name[2] = '0' + netif->num;
   1122                      return 1;
   1123                  } else if (netif_type == NETIF_TYPE_LOOPBACK &&
   1124                             IFNAME20 == netif->name[0] &&
   1125                             IFNAME21 == netif->name[1]) {
   1126                      name[0] = IFNAME20;
   1127                      name[1] = IFNAME21;
   1128                      name[2] = '0' + netif->num;
   1129                      return 1;
   1130                  }
   1131              }
   1132          
   1133              return 0;
   1134          }
   1135          
   1136          struct netif *netif_find_by_type(netif_type_t netif_type)
   1137          {
   1138              char name[4] = {0};
   1139          
   1140              if (lwip_get_netif_name(netif_type, (char *)name) == 1) {
   1141                  LOG_I(lwip, "name=%s\n\r", name);
   1142                  return netif_find(name);
   1143              } else {
   1144                  return NULL;
   1145              }
   1146          }
   1147          
   1148          void tcpip_stack_init(tcpip_config_t *tcpip_config, uint8_t opmode)
   1149          {
   1150              lwip_socket_init();
   1151              tcpip_init(NULL, NULL);
   1152              ethernetif_init(tcpip_config->sta_ip_mode,
   1153                              tcpip_config->sta_mac_addr,
   1154                              tcpip_config->ap_mac_addr,
   1155                              &tcpip_config->sta_addr,
   1156                              &tcpip_config->sta_mask,
   1157                              &tcpip_config->sta_gateway,
   1158                              &tcpip_config->ap_addr,
   1159                              &tcpip_config->ap_mask,
   1160                              &tcpip_config->ap_gateway,
   1161                              opmode);
   1162          }
   1163          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   enqueue_bottom_half_from_isr
         8   -> NetJobAddFromISR
      32   ethernet_raw_pkt_sender
        32   -- Indirect call
        32   -> __aeabi_memcpy
        32   -> low_level_output_scatter
        32   -> pbuf_alloc
        32   -> pbuf_free
       0   ethernetif_free_pkt
         0   -> pbuf_free
      48   ethernetif_init
        48   -- Indirect call
        48   -> __aeabi_memset4
        48   -> ethernetif_init_callback
        48   -> low_level_set_mac_addr
        48   -> netif_add
        48   -> netif_set_default
        48   -> netif_set_link_down
        48   -> netif_set_up
        48   -> wifi_config_get_mac_address
      32   ethernetif_init1
        32   -- Indirect call
        32   -> low_level_init1
        32   -> mem_malloc
        32   -> printf
      32   ethernetif_init2
        32   -- Indirect call
        32   -> low_level_init2
        32   -> mem_malloc
        32   -> printf
       8   ethernetif_init_callback
         8   -> inband_queue_register_callback
      16   ethernetif_intr_enhance_mode_allocate_pkt_callback
        16   -> pbuf_alloc
      48   ethernetif_intr_enhance_mode_dispatch
        48   -- Indirect call
        48   -> lwip_htonl
        48   -> lwip_htons
        48   -> lwip_sendto
        48   -> pbuf_free
       8   inband_handle_func
         8   -> inband_queue_handler
         0   -> pbuf_free
      48   low_level_get_ap_mac_addr
        48   -- Indirect call
        48   -> __aeabi_memcpy
        48   -> netif_find_name
      16   low_level_get_sta_mac_addr
        16   -> __aeabi_memcpy
        16   -> netif_find_name
       0   low_level_init1
       0   low_level_init2
     176   low_level_output_scatter
       176   -- Indirect call
       176   -> __aeabi_memcpy
       176   -> __aeabi_memset4
       176   -> connsys_dump_tx_scatter_info
       176   -> connsys_get_headroom_offset
       176   -> connsys_tx_flow_control_check_and_update_tx
       176   -> connsys_tx_query_whisr
       176   -> connsys_write_data
       176   -> memcmp
       176   -> printf
       0   low_level_set_mac_addr
         0   -> __aeabi_memcpy
       0   lwip_advance_pkt_hdr
         0   -> pbuf_header
      16   lwip_deliver_tcpip
        16   -- Indirect call
        16   -> ethernetif_intr_enhance_mode_dispatch
       8   lwip_get_netif_name
      40   lwip_tcpip_init
        40   -> ethernetif_init
        40   -> tcpip_init
      24   netif_find_by_type
        24   -- Indirect call
        24   -> lwip_get_netif_name
        24   -> netif_find
       4   netif_find_name
      24   register_eapol_rx_socket
        24   -- Indirect call
      24   register_eapol_rx_socket_dual_intf
        24   -- Indirect call
      40   tcpip_stack_init
        40   -> ethernetif_init
        40   -> tcpip_init
      16   unregister_eapol_rx_socket
        16   -- Indirect call
        16   -> lwip_close
      24   unregister_eapol_rx_socket_dual_intf
        24   -- Indirect call
        24   -> lwip_close


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable44
       4  ??DataTable54
       4  ??DataTable54_1
       4  ??DataTable54_10
       4  ??DataTable54_11
       4  ??DataTable54_12
       4  ??DataTable54_13
       4  ??DataTable54_14
       4  ??DataTable54_2
       4  ??DataTable54_3
       4  ??DataTable54_4
       4  ??DataTable54_5
       4  ??DataTable54_6
       4  ??DataTable54_7
       4  ??DataTable54_8
       4  ??DataTable54_9
       4  ?_0
      36  ?_1
      16  ?_10
      80  ?_11
       8  ?_12
      24  ?_13
      24  ?_14
      40  ?_15
      28  ?_16
      28  ?_17
      48  ?_18
      24  ?_19
       8  ?_2
      24  ?_20
      48  ?_21
      16  ?_22
      16  ?_23
       4  ?_24
      12  ?_25
      88  ?_3
      36  ?_4
      64  ?_5
      40  ?_6
      24  ?_7
      16  ?_8
      40  ?_9
      16  enqueue_bottom_half_from_isr
      86  ethernet_raw_pkt_sender
       4  ethernetif_free_pkt
     218  ethernetif_init
     138  ethernetif_init1
     138  ethernetif_init2
      22  ethernetif_init_callback
      38  ethernetif_intr_enhance_mode_allocate_pkt_callback
     440  ethernetif_intr_enhance_mode_dispatch
       8  g_lwip_eapol_rx_socket
          g_lwip_eapol_rx_socket_second
      18  inband_handle_func
     102  low_level_get_ap_mac_addr
      50  low_level_get_sta_mac_addr
      14  low_level_init1
      14  low_level_init2
     804  low_level_output_scatter
      12  low_level_set_mac_addr
       8  lwip_advance_pkt_hdr
      24  lwip_connsys_ops
      76  lwip_deliver_tcpip
     140  lwip_get_netif_name
      62  lwip_tcpip_init
      58  netif_find_by_type
      50  netif_find_name
      46  register_eapol_rx_socket
      50  register_eapol_rx_socket_dual_intf
      68  tcpip_stack_init
     140  tx_sequence
          sta_if
          ap_if
      46  unregister_eapol_rx_socket
      62  unregister_eapol_rx_socket_dual_intf
     348  -- Other

 
   140 bytes in section .bss
    32 bytes in section .data
     8 bytes in section .rodata
 3 980 bytes in section .text
 
 3 980 bytes of CODE  memory
     8 bytes of CONST memory
   172 bytes of DATA  memory

Errors: none
Warnings: 8
