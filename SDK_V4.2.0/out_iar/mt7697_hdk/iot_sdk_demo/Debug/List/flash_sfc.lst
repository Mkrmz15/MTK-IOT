###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       25/Jan/2017  17:34:59
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\driver\chip\mt7687\src\common\flash_sfc.c
#    Command line =  
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\driver\chip\mt7687\src\common\flash_sfc.c" -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_WIFI_TGN_VERIFY_ENABLE -D MTK_SMTCN_ENABLE -D
#        MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D SUPPORT_MBEDTLS -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-basic.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D MTK_MCS_ENABLE -D MTK_BLE_GPIO_SERVICE -D
#        __BT_DEBUG__ -lcN "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List" -lA
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List"
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj" --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\inc\" -I
#        "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\service\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\CMSIS\Include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\dhcpd\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\wifi\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk_demo\src\ut_app\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\"
#        -I "C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\project\mt7697_hdk\apps\iot_sdk_demo\EWARM\..\..\..\..\..\middleware\third_party\httpclient\inc\"
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\List\flash_sfc.lst
#    Object file  =  
#        C:\LEO\myGit\MTK
#        IOT\SDK_V4.2.0\out_iar\mt7697_hdk\iot_sdk_demo\Debug\Obj\flash_sfc.o
#
###############################################################################

C:\LEO\myGit\MTK IOT\SDK_V4.2.0\driver\chip\mt7687\src\common\flash_sfc.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          /****************************************************************************
     36              Module Name:
     37              Flash
     38          
     39              Abstract:
     40              Flash related access function.
     41          
     42              Revision History:
     43              Who         When            What
     44              --------    ----------      ------------------------------------------
     45          ***************************************************************************/
     46          #include "hal_flash.h"
     47          
     48          #ifdef HAL_FLASH_MODULE_ENABLED
     49          #include <stdio.h>
     50          #include <string.h>
     51          #include <assert.h>
     52          #include "type_def.h"
     53          #include "mt7687.h"
     54          
     55          #include "flash_sfc.h"
     56          #include "spi_flash.h"
     57          #include "nvic.h"
     58          #include "hal_cache.h"
     59          #include "hal_flash.h"
     60          #include "hal_gpt.h"
     61          #include "hal_log.h"
     62          #include "nvic.h"
     63          #include "hal_nvic_internal.h"
     64          #include "memory_attribute.h"
     65          #include "bsp_flash_config.h"
     66          
     67          #define PAGE_BUFFER_SIZE      (64)
     68          #define SF_DAL_FLAG_BUSY()    (NOR_FLASH_BUSY)
     69          #define SF_DAL_FLAG_SUS()     (NOR_FLASH_SUSPENDED)
     70          #define ust_get_duration(a,b) ((a>b)?(b+(0xFFFFFFFF-a)+0x1):(b-a))
     71          
     72          SF_DRV_STATE sf_drvier_status = SF_DRV_NOT_READY;
     73          #define FLASH_DADA_MAX_LEN  (128)
     74          bool NOR_FLASH_BUSY = false;
     75          bool NOR_FLASH_SUSPENDED = false;
     76          
     77          uint32_t gucFlashSFCMode;
     78          static int sf_Mutex = 1;
     79          extern SF_TYPT support_flash_id;
     80          extern int gd_write_sr2_1;
     81          
     82          uint32_t suspend_time;
     83          uint32_t resume_suspend_on_ready;
     84          uint32_t resume_suspend_on_checkready;
     85          
     86          ATTR_TEXT_IN_TCM uint32_t gpt_get_current_time(void)
     87          {
     88              uint32_t counter = 0;
     89              hal_gpt_status_t ret;
     90              ret = hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_32K, &counter);
     91              if (ret != HAL_GPT_STATUS_OK) {
     92                  assert(0);
     93              }
     94              return counter;
     95          }
     96          
     97          ATTR_TEXT_IN_TCM void SF_DAL_FLAG_BUSY_SET(void)
     98          {
     99              NOR_FLASH_BUSY = true;
    100          }
    101          ATTR_TEXT_IN_TCM void SF_DAL_FLAG_BUSY_CLR(void)
    102          {
    103              NOR_FLASH_BUSY = false;
    104          }
    105          ATTR_TEXT_IN_TCM void SF_DAL_FLAG_SUS_SET(void)
    106          {
    107              NOR_FLASH_SUSPENDED = true;
    108          }
    109          ATTR_TEXT_IN_TCM void SF_DAL_FLAG_SUS_CLR(void)
    110          {
    111              NOR_FLASH_SUSPENDED = false;
    112          }
    113          
    114          int32_t get_sf_lock(void)
    115          {
    116              uint32_t savedMask;
    117              savedMask = save_and_set_interrupt_mask();
    118              if (sf_Mutex == 1) {
    119                  sf_Mutex--;
    120                  restore_interrupt_mask(savedMask);
    121                  return 0;
    122              } else if (sf_Mutex == 0) {
    123                  restore_interrupt_mask(savedMask);
    124                  return -2;
    125              } else {
    126                  restore_interrupt_mask(savedMask);
    127                  assert(0);
    128                  return -1;
    129              }
    130          }
    131          
    132          void free_sf_lock(void)
    133          {
    134              uint32_t savedMask;
    135              savedMask = save_and_set_interrupt_mask();
    136              if (sf_Mutex == 0) {
    137                  sf_Mutex++;
    138                  restore_interrupt_mask(savedMask);
    139              } else {
    140                  restore_interrupt_mask(savedMask);
    141                  assert(0);
    142              }
    143          }
    144          
    145          void retrieve_sf_lock(void)
    146          {
    147              int32_t Result;
    148              do { /* polling lock become avaliable */
    149                  Result = get_sf_lock();
    150              } while (Result != 0);
    151          }
    152          
    153          /*****************************************************************
    154          Description : relieve FDM synchronization lock.
    155          Input       :
    156          Output      : None
    157          ******************************************************************/
    158          void release_sf_lock(void)
    159          {
    160              free_sf_lock();
    161          }
    162          
    163          
    164          ATTR_TEXT_IN_TCM int32_t flash_sfc_config(uint8_t mode)
    165          {
    166              INT32 ret = 0;
    167              gpt_get_current_time();   // init gpt one time to avoid put more GPT code in RAM
    168              if (customer_flash_register() != NULL) {
    169              	   //configured external flash
    170                  support_flash_id = SF_TYPE_CUSTOMER;
    171              }
    172              flash_check_device();
    173          
    174              return ret;
    175          }
    176          
    177          void hal_flash_direct_read(void *absolute_address, uint8_t *buffer, uint32_t length)
    178          {
    179              retrieve_sf_lock();
    180              memcpy(buffer, absolute_address, length);
    181              release_sf_lock();
    182          }
    183          
    184          ATTR_TEXT_IN_TCM int32_t flash_sfc_read(uint32_t address, uint32_t length, uint8_t *buffer)
    185          {
    186              INT32 ret = 0;
    187              UINT32 u4Redidual = length;
    188              UINT32 u4ReadLen = 0;
    189          
    190              retrieve_sf_lock();
    191              while (FLASH_DADA_MAX_LEN <= u4Redidual) {
    192                  u4ReadLen = FLASH_DADA_MAX_LEN;
    193                  if (FLASH_MODE_SPI == gucFlashSFCMode) {
    194                      flash_read(buffer, address, u4ReadLen);
    195                  } else if (FLASH_MODE_QPI == gucFlashSFCMode) {
    196                      flash_fast_read(buffer, address, u4ReadLen, 1 /* dummy_cycle, 4bit * 2cycle == 1byte */);
    197                  }
    198          
    199                  buffer = buffer + u4ReadLen;
    200                  address = address + u4ReadLen;
    201                  u4Redidual = u4Redidual - u4ReadLen;
    202              }
    203          
    204              if (FLASH_MODE_SPI == gucFlashSFCMode) {
    205                  flash_read(buffer, address, u4Redidual);
    206              } else if (FLASH_MODE_QPI == gucFlashSFCMode) {
    207                  flash_fast_read(buffer, address, u4Redidual, 1 /* dummy_cycle, 4bit * 2cycle == 1byte */);
    208              }
    209              sf_drvier_status = SF_DRV_READY;
    210              release_sf_lock();
    211              return ret;
    212          }
    213          
    214          
    215          int32_t flash_sfc_write(uint32_t address, uint32_t length, const uint8_t *buffer)
    216          {
    217              INT32 ret = 0;
    218          
    219              retrieve_sf_lock();
    220          #ifdef HAL_CACHE_MODULE_ENABLED
    221              hal_cache_invalidate_all_cache_lines();
    222              hal_cache_disable();
    223          #endif
    224              ret = flash_write(buffer, address, length);
    225              sf_drvier_status = SF_DRV_READY;
    226          #ifdef HAL_CACHE_MODULE_ENABLED
    227              hal_cache_enable();
    228          #endif
    229              release_sf_lock();
    230              return ret;
    231          }
    232          
    233          ATTR_TEXT_IN_TCM int32_t flash_sfc_erase(uint32_t address, uint32_t type)
    234          {
    235              INT32 ret = 0;
    236              retrieve_sf_lock();
    237          #ifdef HAL_CACHE_MODULE_ENABLED
    238              hal_cache_invalidate_all_cache_lines();
    239              hal_cache_disable();
    240          #endif
    241              flash_write_enable();
    242              flash_unprotect();
    243          
    244              if (HAL_FLASH_BLOCK_4K == type) {
    245                  if ((address & 0xFFF) != 0) {
    246          #ifdef HAL_CACHE_MODULE_ENABLED
    247                     hal_cache_enable();
    248          #endif
    249                     release_sf_lock();
    250                     return (ret = -3);
    251                  }
    252                  ret = flash_erase_page(address);
    253              } else if (HAL_FLASH_BLOCK_32K == type) {
    254                  if ((address & 0x7FFF) != 0) {
    255          #ifdef HAL_CACHE_MODULE_ENABLED
    256                     hal_cache_enable();
    257          #endif
    258                     release_sf_lock();
    259                     return (ret = -3);
    260                  }
    261                  ret = flash_erase_sector_32k(address);
    262              } else if (HAL_FLASH_BLOCK_64K == type) {
    263                  if ((address & 0xFFFF) != 0) {
    264          #ifdef HAL_CACHE_MODULE_ENABLED
    265                     hal_cache_enable();
    266          #endif
    267                     release_sf_lock();
    268                     return (ret = -3);
    269                  }
    270                  ret = flash_erase_sector(address);
    271              }
    272          
    273          #ifdef HAL_CACHE_MODULE_ENABLED
    274              hal_cache_enable();
    275          #endif
    276              release_sf_lock();
    277              return ret;
    278          }
    279          
    280          
    281          ATTR_TEXT_IN_TCM void Flash_ReturnReady(void)
    282          {
    283              uint8_t sr = 0;
    284              uint32_t savedMask = 0;
    285          
    286              if (sf_drvier_status == SF_DRV_NOT_READY) {
    287                  //assert(0);
    288                  //return;
    289              }
    290          
    291              // No Suspend Conditions
    292              // 1. For those deivces that do not support program-suspend (buffer length < 32 bytes).
    293              // 2. Serial Flash Unit Test: Erase/Program w/o suspend.
    294              // 3. NOR_NO_SUSPEND is defiend.
    295              if ((PAGE_BUFFER_SIZE < 16) && (sf_drvier_status >= SF_DRV_PROGRAMMING)) {
    296                  while (1) {
    297                      if (flash_read_sr(&sr) < 0) {
    298                          assert(0);
    299                      }
    300                      if (0 == (sr & SR_WIP)) {
    301                          break;
    302                      }
    303                  }
    304              }
    305          
    306              savedMask = save_and_set_interrupt_mask();
    307              if ((!SF_DAL_FLAG_SUS()) && SF_DAL_FLAG_BUSY()) {
    308                  if (flash_read_sr(&sr) < 0) {
    309                      //read SR failed
    310                      assert(0);
    311                  }
    312          
    313                  // if flash is busy, suspend any on-going operations
    314                  if (0 != (sr & FLASH_STATUS_BUSY)) {
    315                      // 1. Issue suspend command
    316                      flash_suspend_Winbond();
    317                      // 2. wait for device ready
    318                      while (1) {
    319                          if (flash_read_sr(&sr) < 0) {
    320                              //read SR failed
    321                              assert(0);
    322                          }
    323                          if (0 == (sr & SR_WIP)) {
    324                              break;
    325                          }
    326                      }
    327                      SF_DAL_FLAG_SUS_SET();
    328          
    329                  } else {
    330                      SF_DAL_FLAG_BUSY_CLR();
    331                  }
    332              }
    333              restore_interrupt_mask(savedMask);
    334          }
    335          
    336          ATTR_TEXT_IN_TCM int32_t SF_DAL_CheckDeviceReady(void *MTDData, uint32_t BlockIndex)
    337          {
    338              int32_t result;
    339              uint32_t savedMask = 0;
    340              uint8_t status_busy, status_suspend;
    341              uint8_t sr = 0;
    342              uint8_t sr1 = 0;
    343          
    344              if (flash_read_sr(&sr) < 0) {
    345                  assert(0);
    346              } else {
    347                  status_busy = sr;
    348              }
    349          
    350              if (flash_read_sr2(&sr1) < 0) {
    351                  assert(0);
    352              } else {
    353                  status_suspend = sr1;
    354              }
    355          
    356              /* ensure that the status check is atomic */
    357              savedMask = save_and_set_interrupt_mask();
    358          
    359              if (0 == (status_busy & FLASH_STATUS_BUSY)) {
    360                  uint8_t check_status = (0x80 | 0x40); //defualt is MXIC
    361          
    362                  if (support_flash_id == SF_TYPE_WINBOND || support_flash_id == SF_TYPE_GD) {
    363                      //windbond is s15(0x80)
    364                      check_status = 0x80;
    365                      if (gd_write_sr2_1 == 0x31) {
    366                          //GD25Q32CSIG  it's s15 & s10 bit
    367                          check_status |= 0x84;
    368                      }
    369                      
    370                  } else if (support_flash_id == SF_TYPE_MXIC) {
    371                      //mxic is WSP & WSE of security status regist(0x04 and 0x08)
    372                      check_status = (0x80 | 0x40);
    373                  } else if (support_flash_id == SF_TYPE_MICRON) {
    374                      //mxic is WSP & WSE of security status regist(0x04 and 0x08)
    375                      check_status = 0x42;     //bit7: erase susspend      bit2: program suspend
    376                  } else if (support_flash_id == SF_TYPE_CUSTOMER) {
    377                      //customer flash
    378                      check_status = customer_flash_suspend_bit();
    379                  }
    380          
    381                  // erase suspended or program suspended
    382                  if ((0 != (status_suspend & check_status)) ||  // check suspend flags
    383                          ((0 == check_status) && SF_DAL_FLAG_SUS())) { //devices that do not have suspend flags => check driver flag
    384                      assert(SF_DAL_FLAG_BUSY());
    385          
    386                      // issue resume command
    387                      flash_resume_Winbond();
    388                      SF_DAL_FLAG_SUS_CLR();
    389                      result =  -121;  //FS_FLASH_ERASE_BUSY;
    390                  } else { // flash is neither busy nor suspendeds
    391                      SF_DAL_FLAG_BUSY_CLR();
    392                      /********************************************//**
    393                       * If an interrupt comes during program/erase, in Flash_ReturnReady(), the device may deny the
    394                       * "Suspend Erase/Program" command because the device is near/already ready. However,
    395                       * NOR_FLASH_SUSPENDED is still be set to true.
    396                       *
    397                       * In such case, after back to erase/program operation, CheckDeviceReady will reach here
    398                       * because flash is not busy and not erase suspended (but with NOR_FLASH_SUSPENDED = true). If NOR_FLASH_SUSPENDED
    399                       * is not set to false here, next time when an interrupt comes during erase/program
    400                       * operation, Flash_ReturnReady() will be misleaded by wrong NOR_FLASH_SUSPENDED and return
    401                       * to IRQ handler directly even if flash is still erasing/programing, leading to an execution
    402                       * error!
    403                       ***********************************************/
    404                      SF_DAL_FLAG_SUS_CLR();
    405                      result = 0;   //FS_NO_ERROR;
    406                  }
    407              } else {
    408                  result = -121;   //FS_FLASH_ERASE_BUSY;
    409              }
    410          
    411              restore_interrupt_mask(savedMask);
    412              return result;
    413          }
    414          
    415          
    416          ATTR_TEXT_IN_TCM int32_t SF_DAL_CheckReadyAndResume(void *MTDData, uint32_t addr, uint8_t data)
    417          {
    418              uint32_t          savedMask;
    419              int32_t           result = 0;   //RESULT_FLASH_BUSY;    // default result is busy
    420              uint8_t           check_data;
    421              uint16_t          status_busy = 0;
    422              uint8_t           sr = 0;
    423          
    424              // Read device status
    425              if (flash_read_sr(&sr) < 0) {
    426                  assert(0);
    427              } else {
    428                  status_busy = sr;
    429              }
    430          
    431              savedMask = save_and_set_interrupt_mask();
    432          
    433              // Flash is suspended due to interrupt => Resume
    434              if (SF_DAL_FLAG_SUS()) {
    435                  assert(SF_DAL_FLAG_BUSY());
    436                  flash_resume_Winbond();
    437                  SF_DAL_FLAG_SUS_CLR();
    438                  restore_interrupt_mask(savedMask);
    439              }
    440              // Flash is not suspended and ready => Validate programmed data
    441              else  if (0 == (status_busy & FLASH_STATUS_BUSY)) {
    442                  SF_DAL_FLAG_BUSY_CLR();
    443                  // Compare last programmed byte
    444                  check_data = *(volatile uint8_t *)addr;
    445                  if (check_data == data) {
    446                      result = 1;    //RESULT_FLASH_DONE;
    447                  } else {
    448                      result = -1;   //RESULT_FLASH_FAIL;
    449                  }
    450              }
    451              restore_interrupt_mask(savedMask);
    452          
    453              return result;
    454          }
    455          
    456          #ifdef OTP_FEATURE_SUPPORT
    457          ATTR_TEXT_IN_TCM int SF_DAL_OTPAccess(void *MTDData, int accesstype, uint32_t Offset, void *Buffer, uint32_t Length)
    458          {
    459              switch (accesstype) {
    460                  case OTP_READ:
    461                      if (support_flash_id	== SF_TYPE_WINBOND) {
    462                          return SF_OTPRead_WINBOND(Offset, Buffer, Length);
    463                      } else if (support_flash_id == SF_TYPE_MXIC) {
    464                          log_hal_info("Not support OTP!\r\n");
    465                      }
    466                      break;
    467                  case OTP_WRITE:
    468                      if (support_flash_id	== SF_TYPE_WINBOND) {
    469                          return SF_OTPWrite_WINBOND(Offset, Buffer, Length);
    470                      } else if (support_flash_id == SF_TYPE_MXIC) {
    471                          log_hal_info("Not support OTP!\r\n");
    472                      }
    473                      break;
    474                  case OTP_LOCK:
    475                      if (support_flash_id	== SF_TYPE_WINBOND) {
    476                          return SF_OTPLock_WINBOND();
    477                      } else if (support_flash_id == SF_TYPE_MXIC) {
    478                          log_hal_info("Not support OTP!\r\n");
    479                      }
    480                      break;
    481                  default:
    482                      break;
    483              }
    484          
    485              return -1;
    486          }
    487          
    488          ATTR_TEXT_IN_TCM int SF_DAL_OTPQueryLength(void *MTDData, uint32_t *Length)
    489          {
    490              if (support_flash_id == SF_TYPE_WINBOND) {
    491                  *Length = 768;
    492              } else if (support_flash_id	== SF_TYPE_MXIC) {
    493                  log_hal_info("Not support OTP!\r\n");
    494              } else {
    495                  log_hal_info("Invalid Flash!\r\n");
    496                  return -1;
    497              }
    498              return -1;
    499          }
    500          #endif
    501          
    502          #endif
    503          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Flash_ReturnReady
        16   -> SF_DAL_FLAG_BUSY_CLR
        16   -> SF_DAL_FLAG_SUS_SET
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> flash_read_sr
        16   -> flash_suspend_Winbond
        16   -> restore_interrupt_mask
        16   -> save_and_set_interrupt_mask
      24   SF_DAL_CheckDeviceReady
        24   -> SF_DAL_FLAG_BUSY_CLR
        24   -> SF_DAL_FLAG_SUS_CLR
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> customer_flash_suspend_bit
        24   -> flash_read_sr
        24   -> flash_read_sr2
        24   -> flash_resume_Winbond
        24   -> restore_interrupt_mask
        24   -> save_and_set_interrupt_mask
      32   SF_DAL_CheckReadyAndResume
        32   -> SF_DAL_FLAG_BUSY_CLR
        32   -> SF_DAL_FLAG_SUS_CLR
        32   -> __aeabi_assert
        32   -> __iar_EmptyStepPoint
        32   -> flash_read_sr
        32   -> flash_resume_Winbond
        32   -> restore_interrupt_mask
        32   -> save_and_set_interrupt_mask
       0   SF_DAL_FLAG_BUSY_CLR
       0   SF_DAL_FLAG_BUSY_SET
       0   SF_DAL_FLAG_SUS_CLR
       0   SF_DAL_FLAG_SUS_SET
       8   flash_sfc_config
         8   -> customer_flash_register
         8   -> flash_check_device
         8   -> gpt_get_current_time
      16   flash_sfc_erase
        16   -> flash_erase_page
        16   -> flash_erase_sector
        16   -> flash_erase_sector_32k
        16   -> flash_unprotect
        16   -> flash_write_enable
        16   -> hal_cache_disable
        16   -> hal_cache_enable
        16   -> hal_cache_invalidate_all_cache_lines
        16   -> release_sf_lock
        16   -> retrieve_sf_lock
      24   flash_sfc_read
        24   -> flash_fast_read
        24   -> flash_read
        24   -> release_sf_lock
        24   -> retrieve_sf_lock
      16   flash_sfc_write
        16   -> flash_write
        16   -> hal_cache_disable
        16   -> hal_cache_enable
        16   -> hal_cache_invalidate_all_cache_lines
        16   -> release_sf_lock
        16   -> retrieve_sf_lock
       8   free_sf_lock
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         0   -> restore_interrupt_mask
         8   -> restore_interrupt_mask
         8   -> save_and_set_interrupt_mask
       8   get_sf_lock
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> restore_interrupt_mask
         8   -> save_and_set_interrupt_mask
       8   gpt_get_current_time
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> hal_gpt_get_free_run_count
      16   hal_flash_direct_read
        16   -> __aeabi_memcpy
         0   -> release_sf_lock
        16   -> retrieve_sf_lock
       0   release_sf_lock
         0   -> free_sf_lock
       8   retrieve_sf_lock
         8   -> get_sf_lock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       2  ?_0
      76  ?_1
      20  ?_2
     124  Flash_ReturnReady
       2  NOR_FLASH_BUSY
          NOR_FLASH_SUSPENDED
     226  SF_DAL_CheckDeviceReady
     144  SF_DAL_CheckReadyAndResume
       8  SF_DAL_FLAG_BUSY_CLR
       8  SF_DAL_FLAG_BUSY_SET
       8  SF_DAL_FLAG_SUS_CLR
       8  SF_DAL_FLAG_SUS_SET
      28  flash_sfc_config
     106  flash_sfc_erase
     104  flash_sfc_read
      50  flash_sfc_write
      46  free_sf_lock
      64  get_sf_lock
      36  gpt_get_current_time
      28  hal_flash_direct_read
       2  release_sf_lock
       4  resume_suspend_on_checkready
       4  resume_suspend_on_ready
      12  retrieve_sf_lock
       4  sf_Mutex
       8  sf_drvier_status
          gucFlashSFCMode
       4  suspend_time

 
  14 bytes in section .bss
  12 bytes in section .data
 916 bytes in section .ramTEXT
   2 bytes in section .rodata
 218 bytes in section .text
 
 1 134 bytes of CODE  memory
     2 bytes of CONST memory
    26 bytes of DATA  memory

Errors: none
Warnings: none
