###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:49
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\wifi_service\combo\src\wifi_profile.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EWCEDB.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\wifi_service\combo\src\wifi_profile.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\wifi_profile.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\wifi_profile.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\wifi_service\combo\src\wifi_profile.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          #include <stdio.h>
     36          #include <string.h>
     37          #include <stdlib.h>
     38          #include "type_def.h"
     39          #include "connsys_driver.h"
     40          #include "connsys_util.h"
     41          #include "wifi_scan.h"
     42          #include "wifi_api.h"
     43          #include "wifi_inband.h"
     44          #include "os.h"
     45          #include "os_util.h"
     46          #include "nvdm.h"
     47          #include "get_profile_string.h"
     48          #include "timer.h"
     49          #include "syslog.h"
     50          #include "wifi_profile.h"
     51          #include "cli.h"
     52          #include "connsys_profile.h"
     53          #include "misc.h"
     54          
     55          #ifdef MTK_WIFI_ROM_ENABLE
     56          #include "security_interface.h"
     57          #endif
     58          
     59          /**
     60           * @brief judge whether the opmode is valid
     61           */
     62          bool wifi_is_opmode_valid(uint8_t mode)
     63          {
     64              return (mode <= WIFI_MODE_P2P_ONLY);
     65          }
     66          
     67          /**
     68           * @brief judge whether the port is valid
     69           */
     70          bool wifi_is_port_valid(uint8_t port)
     71          {
     72              return (port <= WIFI_PORT_AP);
     73          }
     74          
     75          /**
     76           * @brief judge whether the band is valid
     77           */
     78          bool wifi_is_band_valid(uint8_t band)
     79          {
     80              return (band <= WIFI_BAND_5_G);
     81          }
     82          
     83          /**
     84           * @brief judge whether the bandwidth is valid
     85           */
     86          bool wifi_is_bandwidth_valid(uint8_t bandwidth)
     87          {
     88              return (bandwidth <= WIFI_IOT_COMMAND_CONFIG_BANDWIDTH_2040MHZ);
     89          }
     90          
     91          /**
     92           * @brief judge whether the auth mode is valid
     93           */
     94          bool wifi_is_auth_mode_valid(uint8_t auth_mode)
     95          {
     96              return (auth_mode <= WIFI_AUTH_MODE_WPA_PSK_WPA2_PSK);
     97          }
     98          
     99          /**
    100           * @brief judge whether the encrypt type is valid
    101           */
    102          bool wifi_is_encrypt_type_valid(uint8_t encrypt_type)
    103          {
    104          #ifdef WAPI_SUPPORT
    105              return (encrypt_type <= WIFI_ENCRYPT_TYPE_ENCRYPT_SMS4_ENABLED);
    106          #else
    107              return (encrypt_type <= WIFI_ENCRYPT_TYPE_GROUP_WEP104_ENABLED);
    108          #endif
    109          }
    110          
    111          /**
    112           * @brief judge whether the power save mode is valid
    113           */
    114          bool wifi_is_ps_mode_valid(uint8_t ps_mode)
    115          {
    116              return (ps_mode <= 2);
    117          }
    118          
    119          #ifdef MTK_WIFI_PROFILE_ENABLE
    120          int32_t wifi_profile_set_opmode(uint8_t mode)
    121          {
    122              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    123          
    124              if (!wifi_is_opmode_valid(mode)) {
    125                  LOG_E(wifi, "mode is invalid: %d", mode);
    126                  return WIFI_ERR_PARA_INVALID;
    127              }
    128          
    129              sprintf(buf, "%d", mode);
    130          
    131              if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_COMMON, "OpMode",
    132                      NVDM_DATA_ITEM_TYPE_STRING,
    133                      (uint8_t *)buf, os_strlen(buf))) {
    134                  return WIFI_FAIL;
    135              }
    136          
    137              return WIFI_SUCC;
    138          }
    139          
    140          int32_t wifi_profile_get_opmode(uint8_t *mode)
    141          {
    142              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    143              uint32_t len = sizeof(buf);
    144          
    145              if (NULL == mode) {
    146                  LOG_E(wifi, "mode is null");
    147                  return WIFI_ERR_PARA_INVALID;
    148              }
    149          
    150              if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_COMMON, "OpMode", (uint8_t *)buf, &len)) {
    151                  return WIFI_FAIL;
    152              }
    153          
    154              *mode = atoi(buf);
    155              return WIFI_SUCC;
    156          }
    157          
    158          
    159          int32_t wifi_profile_set_channel(uint8_t port, uint8_t channel)
    160          {
    161              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    162          
    163              sprintf(buf, "%d", channel);
    164          
    165              if (port == WIFI_PORT_AP) {
    166                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "Channel",
    167                          NVDM_DATA_ITEM_TYPE_STRING,
    168                          (uint8_t *)buf, os_strlen(buf))) {
    169                      return WIFI_FAIL;
    170                  }
    171              } else if (port == WIFI_PORT_STA) {
    172                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "Channel",
    173                          NVDM_DATA_ITEM_TYPE_STRING,
    174                          (uint8_t *)buf, os_strlen(buf))) {
    175                      return WIFI_FAIL;
    176                  }
    177              } else {
    178                  LOG_E(wifi, "port is invalid: %d", port);
    179                  return WIFI_ERR_PARA_INVALID;
    180              }
    181              return WIFI_SUCC;
    182          }
    183          
    184          int32_t wifi_profile_get_channel(uint8_t port, uint8_t *channel)
    185          {
    186              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    187              uint32_t len = sizeof(buf);
    188          
    189              if (NULL == channel) {
    190                  return WIFI_ERR_PARA_INVALID;
    191              }
    192          
    193              if (port == WIFI_PORT_AP) {
    194                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "Channel", (uint8_t *)buf, &len)) {
    195                      return WIFI_FAIL;
    196                  }
    197              } else if (port == WIFI_PORT_STA) {
    198                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "Channel", (uint8_t *)buf, &len)) {
    199                      return WIFI_FAIL;
    200                  }
    201              } else {
    202                  LOG_E(wifi, "port is invalid: %d", port);
    203                  return WIFI_ERR_PARA_INVALID;
    204              }
    205          
    206              *channel = atoi(buf);
    207              return WIFI_SUCC;
    208          }
    209          
    210          int32_t wifi_profile_set_bandwidth(uint8_t port, uint8_t bandwidth)
    211          {
    212              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    213          
    214              if (!wifi_is_bandwidth_valid(bandwidth)) {
    215                  LOG_E(wifi, "bandwidth is invalid: %d", bandwidth);
    216                  return WIFI_ERR_PARA_INVALID;
    217              }
    218          
    219              sprintf(buf, "%d", bandwidth);
    220          
    221              if (port == WIFI_PORT_AP) {
    222                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "BW",
    223                          NVDM_DATA_ITEM_TYPE_STRING,
    224                          (uint8_t *)buf, os_strlen(buf))) {
    225                      return WIFI_FAIL;
    226                  }
    227              } else if (port == WIFI_PORT_STA) {
    228                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "BW",
    229                          NVDM_DATA_ITEM_TYPE_STRING,
    230                          (uint8_t *)buf, os_strlen(buf))) {
    231                      return WIFI_FAIL;
    232                  }
    233              } else {
    234                  LOG_E(wifi, "port is invalid: %d", port);
    235                  return WIFI_ERR_PARA_INVALID;
    236              }
    237              return WIFI_SUCC;
    238          }
    239          
    240          
    241          int32_t wifi_profile_get_bandwidth(uint8_t port, uint8_t *bandwidth)
    242          {
    243              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    244              uint32_t len = sizeof(buf);
    245          
    246              if (NULL == bandwidth) {
    247                  LOG_E(wifi, "bandwidth is null");
    248                  return WIFI_ERR_PARA_INVALID;
    249              }
    250          
    251              if (port == WIFI_PORT_AP) {
    252                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "BW", (uint8_t *)buf, &len)) {
    253                      return WIFI_FAIL;
    254                  }
    255              } else if (port == WIFI_PORT_STA) {
    256                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "BW", (uint8_t *)buf, &len)) {
    257                      return WIFI_FAIL;
    258                  }
    259              } else {
    260                  LOG_E(wifi, "port is invalid: %d", port);
    261                  return WIFI_ERR_PARA_INVALID;
    262              }
    263          
    264              *bandwidth = atoi(buf);
    265              return WIFI_SUCC;
    266          }
    267          
    268          int32_t wifi_profile_get_mac_address(uint8_t port, uint8_t *address)
    269          {
    270              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    271              uint32_t len = sizeof(buf);
    272          
    273              if (!wifi_is_port_valid(port)) {
    274                  LOG_E(wifi, "port is invalid: %d", port);
    275                  return WIFI_ERR_PARA_INVALID;
    276              }
    277              if (NULL == address) {
    278                  LOG_E(wifi, "address is null");
    279                  return WIFI_ERR_PARA_INVALID;
    280              }
    281          
    282          #ifdef MTK_WIFI_REPEATER_ENABLE
    283              uint8_t mode;
    284              if (wifi_profile_get_opmode(&mode) < 0) {
    285                  return WIFI_FAIL;
    286              }
    287              if ((mode == WIFI_MODE_REPEATER) && (port == WIFI_PORT_AP)) {
    288                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "MacAddr", (uint8_t *)buf, &len)) {
    289                      return WIFI_FAIL;
    290                  }
    291              } else {
    292                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "MacAddr", (uint8_t *)buf, &len)) {
    293                      return WIFI_FAIL;
    294                  }
    295              }
    296          #else
    297              /* Use STA MAC/IP as AP MAC/IP for the time being, due to N9 dual interface not ready yet */
    298              if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "MacAddr", (uint8_t *)buf, &len)) {
    299                  return WIFI_FAIL;
    300              }
    301          #endif
    302          
    303              wifi_conf_get_mac_from_str((char *)address, buf);
    304              return WIFI_SUCC;
    305          }
    306          
    307          
    308          int32_t wifi_profile_set_mac_address(uint8_t port, uint8_t *address)
    309          {
    310              if (!wifi_is_port_valid(port)) {
    311                  LOG_E(wifi, "port is invalid: %d", port);
    312                  return WIFI_ERR_PARA_INVALID;
    313              }
    314              if (address == NULL) {
    315                  LOG_E(wifi, "mac address is null.");
    316                  return WIFI_ERR_PARA_INVALID;
    317              }
    318          
    319              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    320          
    321              sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x",
    322                      address[0], address[1], address[2], address[3], address[4], address[5]);
    323          
    324              if (port == WIFI_PORT_AP) {
    325                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "MacAddr",
    326                          NVDM_DATA_ITEM_TYPE_STRING,
    327                          (uint8_t *)buf, os_strlen(buf))) {
    328                      return WIFI_FAIL;
    329                  }
    330              } else {
    331                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "MacAddr",
    332                          NVDM_DATA_ITEM_TYPE_STRING,
    333                          (uint8_t *)buf, os_strlen(buf))) {
    334                      return WIFI_FAIL;
    335                  }
    336              }
    337          
    338              return WIFI_SUCC;
    339          }
    340          
    341          
    342          int32_t wifi_profile_set_ssid(uint8_t port, uint8_t *ssid , uint8_t ssid_length)
    343          {
    344              if (!wifi_is_port_valid(port)) {
    345                  LOG_E(wifi, "port is invalid: %d", port);
    346                  return WIFI_ERR_PARA_INVALID;
    347              }
    348              if (ssid_length > WIFI_MAX_LENGTH_OF_SSID) {
    349                  LOG_I(wifi, "incorrect length(=%d)", ssid_length);
    350                  return WIFI_ERR_PARA_INVALID;
    351              }
    352              if (NULL == ssid) {
    353                  LOG_E(wifi, "ssid is null.");
    354                  return WIFI_ERR_PARA_INVALID;
    355              }
    356          
    357              char ssid_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    358              char ssid_len_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    359          
    360              os_memcpy(ssid_buf, ssid, ssid_length);
    361              ssid_buf[ssid_length] = '\0';
    362              printf("----------------------------update ssid \n");
    363          
    364              /***add by Pengfei, optimize PMK calculate at boot up***/
    365             {
    366                  uint8_t pmk_info[WIFI_MAX_LENGTH_OF_SSID+WIFI_LENGTH_PASSPHRASE+WIFI_LENGTH_PMK] = {0};
    367                  uint8_t buf_passphrase[WIFI_LENGTH_PASSPHRASE] = {0};
    368                  uint8_t passphrase_length = 0;
    369                  uint8_t psk[WIFI_LENGTH_PMK];
    370                  if (wifi_profile_get_wpa_psk_key(port, buf_passphrase, &passphrase_length) < 0) {
    371                      return WIFI_FAIL;
    372                  }
    373          
    374          #ifdef MTK_MINISUPP_ENABLE
    375                  if (__g_wpa_supplicant_api.cal_pmk) {
    376                      if (__g_wpa_supplicant_api.cal_pmk(buf_passphrase, ssid, ssid_length, psk) < 0) {
    377                          LOG_E(wifi, "callback cal_pmk is not ready");
    378                          return WIFI_FAIL;
    379                      }
    380                  }
    381          #endif /* MTK_MINISUPP_ENABLE */
    382          
    383          #ifdef MTK_WIFI_ROM_ENABLE
    384                  char pmk[40];
    385          
    386                  CalculatePmk((char *)buf_passphrase, ssid, ssid_length,(unsigned char *) pmk);
    387                  os_memcpy(psk,pmk,32);
    388          #endif
    389          
    390                  os_memcpy(pmk_info, ssid, ssid_length);
    391                  os_memcpy(pmk_info+WIFI_MAX_LENGTH_OF_SSID, buf_passphrase, passphrase_length);
    392                  os_memcpy(pmk_info+WIFI_MAX_LENGTH_OF_SSID+WIFI_LENGTH_PASSPHRASE, psk, WIFI_LENGTH_PMK);
    393                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "PMK_INFO", NVDM_DATA_ITEM_TYPE_STRING,
    394                                      (uint8_t *)pmk_info, WIFI_MAX_LENGTH_OF_SSID+WIFI_LENGTH_PASSPHRASE+WIFI_LENGTH_PMK)) {
    395                      return WIFI_FAIL;
    396                  }
    397              }
    398          
    399              sprintf(ssid_len_buf, "%d", ssid_length);
    400              if (port == WIFI_PORT_AP) {
    401                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "Ssid",
    402                          NVDM_DATA_ITEM_TYPE_STRING,
    403                          (uint8_t *)ssid_buf, os_strlen(ssid_buf))) {
    404                      return WIFI_FAIL;
    405                  }
    406                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "SsidLen",
    407                          NVDM_DATA_ITEM_TYPE_STRING,
    408                          (uint8_t *)ssid_len_buf, os_strlen(ssid_len_buf))) {
    409                      return WIFI_FAIL;
    410                  }
    411              } else {
    412                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "Ssid",
    413                          NVDM_DATA_ITEM_TYPE_STRING,
    414                          (uint8_t *)ssid_buf, os_strlen(ssid_buf))) {
    415                      return WIFI_FAIL;
    416                  }
    417                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "SsidLen",
    418                          NVDM_DATA_ITEM_TYPE_STRING,
    419                          (uint8_t *)ssid_len_buf, os_strlen(ssid_len_buf))) {
    420                      return WIFI_FAIL;
    421                  }
    422              }
    423              return WIFI_SUCC;
    424          }
    425          
    426          
    427          
    428          int32_t wifi_profile_get_ssid(uint8_t port, uint8_t *ssid, uint8_t *ssid_length)
    429          {
    430              char buf[WIFI_PROFILE_BUFFER_LENGTH];
    431              uint32_t len;
    432          
    433              if (!wifi_is_port_valid(port)) {
    434                  LOG_E(wifi, "port is invalid: %d", port);
    435                  return WIFI_ERR_PARA_INVALID;
    436              }
    437              if (NULL == ssid_length) {
    438                  LOG_E(wifi, "ssid_length is null.");
    439                  return WIFI_ERR_PARA_INVALID;
    440              }
    441              if (NULL == ssid) {
    442                  LOG_E(wifi, "ssid is null.");
    443                  return WIFI_ERR_PARA_INVALID;
    444              }
    445          
    446              if (port == WIFI_PORT_AP) {
    447                  os_memset(buf, 0, WIFI_PROFILE_BUFFER_LENGTH);
    448                  len = sizeof(buf);
    449                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "Ssid", (uint8_t *)buf, &len)) {
    450                      return WIFI_FAIL;
    451                  }
    452                  strcpy((char *)ssid, buf);
    453          
    454                  os_memset(buf, 0, WIFI_PROFILE_BUFFER_LENGTH);
    455                  len = sizeof(buf);
    456                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "SsidLen", (uint8_t *)buf, &len)) {
    457                      return WIFI_FAIL;
    458                  }
    459                  *ssid_length = atoi(buf);
    460                  return WIFI_SUCC;
    461              } else {
    462                  os_memset(buf, 0, WIFI_PROFILE_BUFFER_LENGTH);
    463                  len = sizeof(buf);
    464                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "Ssid", (uint8_t *)buf, &len)) {
    465                      return WIFI_FAIL;
    466                  }
    467                  strcpy((char *)ssid, buf);
    468          
    469                  os_memset(buf, 0, WIFI_PROFILE_BUFFER_LENGTH);
    470                  len = sizeof(buf);
    471                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "SsidLen", (uint8_t *)buf, &len)) {
    472                      return WIFI_FAIL;
    473                  }
    474                  *ssid_length = atoi(buf);
    475                  return WIFI_SUCC;
    476              }
    477          }
    478          
    479          int32_t wifi_profile_commit_setting(char *profile_section)
    480          {
    481              return WIFI_SUCC;
    482          }
    483          
    484          int32_t wifi_profile_get_profile(uint8_t port, wifi_profile_t *profile)
    485          {
    486              return WIFI_SUCC;
    487          }
    488          
    489          int32_t wifi_profile_set_wireless_mode(uint8_t port, wifi_phy_mode_t mode)
    490          {
    491              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    492          
    493              if (!wifi_is_port_valid(port)) {
    494                  LOG_E(wifi, "port is invalid: %d", port);
    495                  return WIFI_ERR_PARA_INVALID;
    496              }
    497          
    498              int32_t support_5g = 0;
    499              support_5g = wifi_5g_support();
    500              if (((WIFI_PHY_11A == mode) || (WIFI_PHY_11ABG_MIXED == mode) ||(WIFI_PHY_11ABGN_MIXED == mode) || (WIFI_PHY_11AN_MIXED == mode))
    501                   && (support_5g < 0)) {
    502                   LOG_E(wifi, "Chip doesn't support 5G.");
    503                   return WIFI_ERR_NOT_SUPPORT;
    504              }
    505          
    506              sprintf(buf, "%d", mode);
    507          
    508              if (port == WIFI_PORT_AP) {
    509                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "WirelessMode",
    510                          NVDM_DATA_ITEM_TYPE_STRING,
    511                          (uint8_t *)buf, os_strlen(buf))) {
    512                      return WIFI_FAIL;
    513                  }
    514              } else {
    515                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "WirelessMode",
    516                          NVDM_DATA_ITEM_TYPE_STRING,
    517                          (uint8_t *)buf, os_strlen(buf))) {
    518                      return WIFI_FAIL;
    519                  }
    520              }
    521              return WIFI_SUCC;
    522          }
    523          
    524          
    525          int32_t wifi_profile_get_wireless_mode(uint8_t port, wifi_phy_mode_t *mode)
    526          {
    527              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    528              uint32_t len = sizeof(buf);
    529          
    530              if (!wifi_is_port_valid(port)) {
    531                  LOG_E(wifi, "port is invalid: %d", port);
    532                  return WIFI_ERR_PARA_INVALID;
    533              }
    534              if (NULL == mode) {
    535                  LOG_E(wifi, "mode is null");
    536                  return WIFI_ERR_PARA_INVALID;
    537              }
    538          
    539              if (port == WIFI_PORT_AP) {
    540                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "WirelessMode", (uint8_t *)buf, &len)) {
    541                      return WIFI_FAIL;
    542                  }
    543              } else {
    544                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "WirelessMode", (uint8_t *)buf, &len)) {
    545                      return WIFI_FAIL;
    546                  }
    547              }
    548          
    549              *mode = (wifi_phy_mode_t)atoi(buf);
    550              return WIFI_SUCC;
    551          }
    552          
    553          int32_t wifi_profile_set_security_mode(uint8_t port, wifi_auth_mode_t auth_mode, wifi_encrypt_type_t encrypt_type)
    554          {
    555              char auth_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    556              char encrypt_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    557          
    558              if (!wifi_is_port_valid(port)) {
    559                  LOG_E(wifi, "port is invalid: %d", port);
    560                  return WIFI_ERR_PARA_INVALID;
    561              }
    562              if (!wifi_is_auth_mode_valid(auth_mode)) {
    563                  LOG_E(wifi, "auth_mode is invalid: %d", auth_mode);
    564                  return WIFI_ERR_PARA_INVALID;
    565              }
    566              if (!wifi_is_encrypt_type_valid(encrypt_type)) {
    567                  LOG_E(wifi, "encrypt_type is invalid: %d", encrypt_type);
    568                  return WIFI_ERR_PARA_INVALID;
    569              }
    570          
    571              sprintf(auth_buf, "%d", auth_mode);
    572              sprintf(encrypt_buf, "%d", encrypt_type);
    573          
    574              if (port == WIFI_PORT_AP) {
    575                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "AuthMode",
    576                          NVDM_DATA_ITEM_TYPE_STRING,
    577                          (uint8_t *)auth_buf, os_strlen(auth_buf))) {
    578                      return WIFI_FAIL;
    579                  }
    580                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "EncrypType",
    581                          NVDM_DATA_ITEM_TYPE_STRING,
    582                          (uint8_t *)encrypt_buf, os_strlen(encrypt_buf))) {
    583                      return WIFI_FAIL;
    584                  }
    585              } else {
    586                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "AuthMode",
    587                          NVDM_DATA_ITEM_TYPE_STRING,
    588                          (uint8_t *)auth_buf, os_strlen(auth_buf))) {
    589                      return WIFI_FAIL;
    590                  }
    591                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "EncrypType",
    592                          NVDM_DATA_ITEM_TYPE_STRING,
    593                          (uint8_t *)encrypt_buf, os_strlen(encrypt_buf))) {
    594                      return WIFI_FAIL;
    595                  }
    596              }
    597              return WIFI_SUCC;
    598          }
    599          
    600          int32_t wifi_profile_get_security_mode(uint8_t port, wifi_auth_mode_t *auth_mode, wifi_encrypt_type_t *encrypt_type)
    601          {
    602              char auth_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    603              char encypt_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    604              uint32_t auth_buf_len = sizeof(auth_buf);
    605              uint32_t encypt_buf_len = sizeof(encypt_buf);
    606          
    607              if (!wifi_is_port_valid(port)) {
    608                  LOG_E(wifi, "port is invalid: %d", port);
    609                  return WIFI_ERR_PARA_INVALID;
    610              }
    611              if (NULL == auth_mode || NULL == encrypt_type) {
    612                  LOG_E(wifi, "null input pointer");
    613                  return WIFI_ERR_PARA_INVALID;
    614              }
    615          
    616              if (port == WIFI_PORT_AP) {
    617                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "AuthMode", (uint8_t *)auth_buf, &auth_buf_len)) {
    618                      return WIFI_FAIL;
    619                  }
    620                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "EncrypType", (uint8_t *)encypt_buf, &encypt_buf_len)) {
    621                      return WIFI_FAIL;
    622                  }
    623              } else {
    624                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "AuthMode", (uint8_t *)auth_buf, &auth_buf_len)) {
    625                      return WIFI_FAIL;
    626                  }
    627                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "EncrypType", (uint8_t *)encypt_buf, &encypt_buf_len)) {
    628                      return WIFI_FAIL;
    629                  }
    630              }
    631          
    632              *auth_mode = (wifi_auth_mode_t)atoi(auth_buf);
    633              *encrypt_type = (wifi_encrypt_type_t)atoi(encypt_buf);
    634              return WIFI_SUCC;
    635          }
    636          
    637          
    638          int32_t wifi_profile_set_wpa_psk_key(uint8_t port, uint8_t *passphrase, uint8_t passphrase_length)
    639          {
    640              char pass_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    641              char pass_len_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    642          
    643              if (!wifi_is_port_valid(port)) {
    644                  LOG_E(wifi, "port is invalid: %d", port);
    645                  return WIFI_ERR_PARA_INVALID;
    646              }
    647              if (passphrase == NULL) {
    648                  LOG_E(wifi, "passphrase is null.");
    649                  return WIFI_ERR_PARA_INVALID;
    650              }
    651              if ((passphrase_length < 8) || (passphrase_length > WIFI_LENGTH_PASSPHRASE)) {
    652                  LOG_E(wifi, "incorrect length(=%d)", passphrase_length);
    653                  return WIFI_ERR_PARA_INVALID;
    654              }
    655              if (passphrase_length == WIFI_LENGTH_PASSPHRASE) {
    656                  for (uint8_t index = 0; index < WIFI_LENGTH_PASSPHRASE; index++) {
    657                      if (!hex_isdigit(passphrase[index])) {
    658                          LOG_E(wifi, "length(=%d) but the strings are not hex strings!", passphrase_length);
    659                          return WIFI_ERR_PARA_INVALID;
    660                      }
    661                  }
    662              }
    663          
    664              sprintf(pass_len_buf, "%d", passphrase_length);
    665              os_memcpy(pass_buf, passphrase, passphrase_length);
    666              pass_buf[passphrase_length] = '\0';
    667          
    668              /***add by Pengfei, optimize PMK calculate at boot up***/
    669              if (WIFI_PORT_STA == port) {
    670                  uint8_t pmk_info[WIFI_MAX_LENGTH_OF_SSID+WIFI_LENGTH_PASSPHRASE+WIFI_LENGTH_PMK] = {0};
    671                  uint8_t ssid[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    672                  uint8_t ssid_length = 0;
    673                  uint8_t psk[WIFI_LENGTH_PMK];
    674                  if (wifi_profile_get_ssid(port, ssid, &ssid_length) < 0) {
    675                      return WIFI_FAIL;
    676                  }
    677          
    678          #ifdef MTK_MINISUPP_ENABLE
    679                  if (__g_wpa_supplicant_api.cal_pmk) {
    680                      if (__g_wpa_supplicant_api.cal_pmk(passphrase, ssid, ssid_length, psk) < 0) {
    681                          LOG_E(wifi, "passphrase length is 64.");
    682                      }
    683                  }
    684          #endif /* MTK_MINISUPP_ENABLE */
    685          
    686                  os_memcpy(pmk_info, ssid, ssid_length);
    687                  os_memcpy(pmk_info+WIFI_MAX_LENGTH_OF_SSID, passphrase, passphrase_length);
    688                  os_memcpy(pmk_info+WIFI_MAX_LENGTH_OF_SSID+WIFI_LENGTH_PASSPHRASE, psk, WIFI_LENGTH_PMK);
    689                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "PMK_INFO", NVDM_DATA_ITEM_TYPE_STRING,
    690                                      (uint8_t *)pmk_info, WIFI_MAX_LENGTH_OF_SSID+WIFI_LENGTH_PASSPHRASE+WIFI_LENGTH_PMK)) {
    691                      return WIFI_FAIL;
    692                  }
    693          
    694              }
    695          
    696              if (port == WIFI_PORT_AP) {
    697                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "WpaPskLen",
    698                          NVDM_DATA_ITEM_TYPE_STRING,
    699                          (uint8_t *)pass_len_buf, os_strlen(pass_len_buf))) {
    700                      return WIFI_FAIL;
    701                  }
    702                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "WpaPsk",
    703                          NVDM_DATA_ITEM_TYPE_STRING,
    704                          (uint8_t *)pass_buf, os_strlen(pass_buf))) {
    705                      return WIFI_FAIL;
    706                  }
    707              } else {
    708                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "WpaPskLen",
    709                          NVDM_DATA_ITEM_TYPE_STRING,
    710                          (uint8_t *)pass_len_buf, os_strlen(pass_len_buf))) {
    711                      return WIFI_FAIL;
    712                  }
    713                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "WpaPsk",
    714                          NVDM_DATA_ITEM_TYPE_STRING,
    715                          (uint8_t *)pass_buf, os_strlen(pass_buf))) {
    716                      return WIFI_FAIL;
    717                  }
    718              }
    719              return WIFI_SUCC;
    720          }
    721          
    722          
    723          int32_t wifi_profile_get_wpa_psk_key(uint8_t port, uint8_t *passphrase, uint8_t *passphrase_length)
    724          {
    725              char pass_len_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    726              char pass_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    727              uint32_t pass_len_buf_size = sizeof(pass_len_buf);
    728              uint32_t pass_buf_size = sizeof(pass_buf);
    729          
    730              if (!wifi_is_port_valid(port)) {
    731                  LOG_E(wifi, "port is invalid: %d", port);
    732                  return WIFI_ERR_PARA_INVALID;
    733              }
    734              if (NULL == passphrase || NULL == passphrase_length) {
    735                  LOG_E(wifi, "null input pointer");
    736                  return WIFI_ERR_PARA_INVALID;
    737              }
    738          
    739              if (port == WIFI_PORT_AP) {
    740                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "WpaPskLen", (uint8_t *)pass_len_buf, &pass_len_buf_size)) {
    741                      return WIFI_FAIL;
    742                  }
    743                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "WpaPsk", (uint8_t *)pass_buf, &pass_buf_size)) {
    744                      return WIFI_FAIL;
    745                  }
    746              } else {
    747                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "WpaPskLen", (uint8_t *)pass_len_buf, &pass_len_buf_size)) {
    748                      return WIFI_FAIL;
    749                  }
    750                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "WpaPsk", (uint8_t *)pass_buf, &pass_buf_size)) {
    751                      return WIFI_FAIL;
    752                  }
    753              }
    754          
    755              if ((strlen(pass_len_buf) == 0) || (strlen(pass_buf) == 0)) {
    756                  *passphrase_length = 0;
    757                  passphrase[0] = '\0';
    758                  return WIFI_SUCC;
    759              }
    760          
    761              *passphrase_length = atoi(pass_len_buf);
    762              if (*passphrase_length > WIFI_LENGTH_PASSPHRASE) {
    763                  LOG_E(wifi, "passphrase_length is too big: %d", *passphrase_length);
    764                  return WIFI_FAIL;
    765              }
    766          
    767              os_memcpy(passphrase, pass_buf, *passphrase_length);
    768              return WIFI_SUCC;
    769          }
    770          
    771          
    772          int32_t wifi_profile_set_pmk(uint8_t port, uint8_t *pmk)
    773          {
    774              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    775          
    776              if (!wifi_is_port_valid(port)) {
    777                  LOG_E(wifi, "port is invalid: %d", port);
    778                  return WIFI_ERR_PARA_INVALID;
    779              }
    780              if (NULL == pmk) {
    781                  LOG_E(wifi, "pmk is null");
    782                  return WIFI_ERR_PARA_INVALID;
    783              }
    784          
    785              char *buf_ptr = buf;
    786              for (int i = 0; i < WIFI_LENGTH_PMK; i++) {
    787                  sprintf(buf_ptr, "%02x", pmk[i]);
    788                  buf_ptr += 2;
    789              }
    790              *buf_ptr = '\0';
    791          
    792              if (port == WIFI_PORT_AP) {
    793                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "PMK",
    794                          NVDM_DATA_ITEM_TYPE_STRING,
    795                          (uint8_t *)buf, os_strlen(buf))) {
    796                      return WIFI_FAIL;
    797                  }
    798              } else {
    799                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "PMK",
    800                          NVDM_DATA_ITEM_TYPE_STRING,
    801                          (uint8_t *)buf, os_strlen(buf))) {
    802                      return WIFI_FAIL;
    803                  }
    804              }
    805              return WIFI_SUCC;
    806          }
    807          
    808          
    809          int32_t wifi_profile_get_pmk(uint8_t port, uint8_t *pmk)
    810          {
    811              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    812              uint32_t len = sizeof(buf);
    813          
    814              if (!wifi_is_port_valid(port)) {
    815                  LOG_E(wifi, "port is invalid: %d", port);
    816                  return WIFI_ERR_PARA_INVALID;
    817              }
    818              if (NULL == pmk) {
    819                  LOG_E(wifi, "pmk is null");
    820                  return WIFI_ERR_PARA_INVALID;
    821              }
    822          
    823              if (port == WIFI_PORT_AP) {
    824                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "PMK", (uint8_t *)buf, &len)) {
    825                      return WIFI_FAIL;
    826                  }
    827              } else {
    828                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "PMK", (uint8_t *)buf, &len)) {
    829                      return WIFI_FAIL;
    830                  }
    831              }
    832          
    833              if (os_strlen(buf) == 0) {
    834                  os_memset(pmk, 0, WIFI_LENGTH_PMK);
    835                  return WIFI_SUCC;
    836              } else if (os_strlen(buf) != (WIFI_LENGTH_PMK * 2)) {
    837                  LOG_E(wifi, "pmk integrity check fail");
    838                  return WIFI_FAIL;
    839              }
    840          
    841              char segment[3];
    842              for (int i = 0; i < WIFI_LENGTH_PMK; i++) {
    843                  os_memset(segment, 0, 3);
    844                  os_memcpy(segment, (buf + (i * 2)), 2);
    845                  segment[2] = '\0';
    846                  pmk[i] = (int)strtol(segment, NULL, 16);
    847              }
    848              return WIFI_SUCC;
    849          }
    850          
    851          int32_t wifi_profile_set_wep_key(uint8_t port, wifi_wep_key_t *wep_keys)
    852          {
    853              char key_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    854              char key_len_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    855              char def_key_id_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    856          
    857              char temp_str[4];
    858              char temp_str1[WIFI_MAX_WEP_KEY_LENGTH + 2];
    859              char *key_len_ptr = key_len_buf;
    860              char *key_ptr = key_buf;
    861          
    862              if (!wifi_is_port_valid(port)) {
    863                  LOG_E(wifi, "port is invalid: %d", port);
    864                  return WIFI_ERR_PARA_INVALID;
    865              }
    866              if (NULL == wep_keys) {
    867                  LOG_E(wifi, "wep_keys is null");
    868                  return WIFI_ERR_PARA_INVALID;
    869              }
    870          
    871              for (uint8_t index = 0; index < WIFI_NUMBER_WEP_KEYS; index++) {
    872                  if (index < WIFI_NUMBER_WEP_KEYS - 1) {
    873                      sprintf(temp_str, "%d,", wep_keys->wep_key_length[index]);
    874                      os_memcpy(temp_str1, wep_keys->wep_key[index], wep_keys->wep_key_length[index]);
    875                      temp_str1[wep_keys->wep_key_length[index]] = ',';
    876                      temp_str1[wep_keys->wep_key_length[index] + 1] = '\0';
    877                  } else {
    878                      sprintf(temp_str, "%d", wep_keys->wep_key_length[index]);
    879                      os_memcpy(temp_str1, wep_keys->wep_key[index], wep_keys->wep_key_length[index]);
    880                      temp_str1[wep_keys->wep_key_length[index]] = '\0';
    881                  }
    882                  strcpy(key_len_ptr, temp_str);
    883                  key_len_ptr += strlen(temp_str);
    884                  strcpy(key_ptr, temp_str1);
    885                  key_ptr += strlen(temp_str1);
    886                  os_memset(temp_str, 0, 4);
    887                  os_memset(temp_str1, 0, WIFI_MAX_WEP_KEY_LENGTH + 2);
    888              }
    889          
    890              sprintf(def_key_id_buf, "%d", wep_keys->wep_tx_key_index);
    891              LOG_I(wifi, "wifi_profile_set_wep_key: SharedKey =%s, SharedKeyLen=%s, DefaultKeyId=%s", key_buf, key_len_buf, temp_str);
    892          
    893              if (port == WIFI_PORT_AP) {
    894                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "SharedKey",
    895                          NVDM_DATA_ITEM_TYPE_STRING,
    896                          (uint8_t *)key_buf, os_strlen(key_buf))) {
    897                      return WIFI_FAIL;
    898                  }
    899                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "SharedKeyLen",
    900                          NVDM_DATA_ITEM_TYPE_STRING,
    901                          (uint8_t *)key_len_buf, os_strlen(key_len_buf))) {
    902                      return WIFI_FAIL;
    903                  }
    904                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "DefaultKeyId",
    905                          NVDM_DATA_ITEM_TYPE_STRING,
    906                          (uint8_t *)def_key_id_buf, os_strlen(def_key_id_buf))) {
    907                      return WIFI_FAIL;
    908                  }
    909              } else {
    910                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "SharedKey",
    911                          NVDM_DATA_ITEM_TYPE_STRING,
    912                          (uint8_t *)key_buf, os_strlen(key_buf))) {
    913                      return WIFI_FAIL;
    914                  }
    915                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "SharedKeyLen",
    916                          NVDM_DATA_ITEM_TYPE_STRING,
    917                          (uint8_t *)key_len_buf, os_strlen(key_len_buf))) {
    918                      return WIFI_FAIL;
    919                  }
    920                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "DefaultKeyId",
    921                          NVDM_DATA_ITEM_TYPE_STRING,
    922                          (uint8_t *)def_key_id_buf, os_strlen(def_key_id_buf))) {
    923                      return WIFI_FAIL;
    924                  }
    925              }
    926              return WIFI_SUCC;
    927          }
    928          
    929          int32_t wifi_profile_get_wep_key(uint8_t port, wifi_wep_key_t *wep_keys)
    930          {
    931              char key_len_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    932              uint32_t key_len_buf_size = sizeof(key_len_buf);
    933          
    934              uint8_t index = 0;
    935              char *ptr = NULL;
    936          
    937              if (!wifi_is_port_valid(port)) {
    938                  LOG_E(wifi, "port is invalid: %d", port);
    939                  return WIFI_ERR_PARA_INVALID;
    940              }
    941              if (NULL == wep_keys) {
    942                  LOG_E(wifi, "wep_keys is null");
    943                  return WIFI_ERR_PARA_INVALID;
    944              }
    945          
    946              /* WEP KEY LEN */
    947              if (port == WIFI_PORT_AP) {
    948                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "SharedKeyLen", (uint8_t *)key_len_buf, &key_len_buf_size)) {
    949                      return WIFI_FAIL;
    950                  }
    951              } else {
    952                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "SharedKeyLen", (uint8_t *)key_len_buf, &key_len_buf_size)) {
    953                      return WIFI_FAIL;
    954                  }
    955              }
    956          
    957              for (index = 0, ptr = rstrtok((char *)key_len_buf, ","); (ptr); ptr = rstrtok(NULL, ",")) {
    958                  wep_keys->wep_key_length[index] = atoi(ptr);
    959                  index++;
    960                  if (index >= WIFI_NUMBER_WEP_KEYS) {
    961                      break;
    962                  }
    963              }
    964          
    965              /* WEP KEY */
    966              char key_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    967              uint32_t key_buf_len = sizeof(key_buf);
    968              if (port == WIFI_PORT_AP) {
    969                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "SharedKey", (uint8_t *)key_buf, &key_buf_len)) {
    970                      return WIFI_FAIL;
    971                  }
    972              } else {
    973                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "SharedKey", (uint8_t *)key_buf, &key_buf_len)) {
    974                      return WIFI_FAIL;
    975                  }
    976              }
    977          
    978              for (index = 0, ptr = rstrtok(key_buf, ","); (ptr); ptr = rstrtok(NULL, ",")) {
    979                  if (wep_keys->wep_key_length[index] == 5 ||
    980                          wep_keys->wep_key_length[index] == 13) {
    981                      os_memcpy(&wep_keys->wep_key[index], ptr, wep_keys->wep_key_length[index]);
    982                  } else if (wep_keys->wep_key_length[index] == 10 ||
    983                             wep_keys->wep_key_length[index] == 26) {
    984                      wep_keys->wep_key_length[index] /= 2;
    985                      AtoH(ptr, (char *)&wep_keys->wep_key[index], (int)wep_keys->wep_key_length[index]);
    986                  } else {
    987                      //printf("WEP Key Length(=%d) is incorrect.\n", wep_keys->wep_key_length[index]);
    988                  }
    989                  index++;
    990                  if (index >= WIFI_NUMBER_WEP_KEYS) {
    991                      break;
    992                  }
    993              }
    994          
    995              /* Default key ID */
    996              char def_key_id_buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
    997              uint32_t def_key_id_buf_size = sizeof(def_key_id_buf);
    998              if (port == WIFI_PORT_AP) {
    999                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "DefaultKeyId", (uint8_t *)def_key_id_buf, &def_key_id_buf_size)) {
   1000                      return WIFI_FAIL;
   1001                  }
   1002              } else {
   1003                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "DefaultKeyId", (uint8_t *)def_key_id_buf, &def_key_id_buf_size)) {
   1004                      return WIFI_FAIL;
   1005                  }
   1006              }
   1007          
   1008              wep_keys->wep_tx_key_index = (uint8_t)atoi(def_key_id_buf);
   1009              return WIFI_SUCC;
   1010          }
   1011          
   1012          
   1013          int32_t wifi_profile_get_country_region(uint8_t band, uint8_t *region)
   1014          {
   1015              if (!wifi_is_band_valid(band)) {
   1016                  LOG_E(wifi, "band is invalid: %d", band);
   1017                  return WIFI_ERR_PARA_INVALID;
   1018              }
   1019          
   1020              int32_t support_5g = 0;
   1021          
   1022              support_5g = wifi_5g_support();
   1023              if ((band == WIFI_BAND_5_G) && (support_5g < 0)) {
   1024                  LOG_E(wifi, "Chip doesn't support 5G.");
   1025                  return WIFI_ERR_NOT_SUPPORT;
   1026              }
   1027          
   1028              if (NULL == region) {
   1029                  LOG_E(wifi, "region is null");
   1030                  return WIFI_ERR_PARA_INVALID;
   1031              }
   1032          
   1033              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
   1034              uint32_t len = sizeof(buf);
   1035          
   1036              if (band == WIFI_BAND_2_4_G) {
   1037                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_COMMON, "CountryRegion", (uint8_t *)buf, &len)) {
   1038                      return WIFI_FAIL;
   1039                  }
   1040              } else {
   1041                  if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_COMMON, "CountryRegionABand", (uint8_t *)buf, &len)) {
   1042                      return WIFI_FAIL;
   1043                  }
   1044              }
   1045          
   1046              *region = atoi(buf);
   1047              return WIFI_SUCC;
   1048          }
   1049          
   1050          int32_t wifi_profile_set_country_region(uint8_t band, uint8_t region)
   1051          {
   1052              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
   1053              int32_t support_5g = 0;
   1054          
   1055              if (!wifi_is_band_valid(band)) {
   1056                  LOG_E(wifi, "band is invalid: %d", band);
   1057                  return WIFI_ERR_PARA_INVALID;
   1058              }
   1059          
   1060              sprintf(buf, "%d", region);
   1061          
   1062              support_5g = wifi_5g_support();
   1063          
   1064              if (band == WIFI_BAND_2_4_G) {
   1065                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_COMMON, "CountryRegion",
   1066                          NVDM_DATA_ITEM_TYPE_STRING,
   1067                          (uint8_t *)buf, os_strlen(buf))) {
   1068                      return WIFI_FAIL;
   1069                  }
   1070                  if (wifi_get_channel_list(WIFI_BAND_2_4_G, region, buf) >= 0) {
   1071                      if (NVDM_STATUS_OK != nvdm_write_data_item("common", "BGChannelTable",
   1072                              NVDM_DATA_ITEM_TYPE_STRING,
   1073                              (uint8_t *)buf, os_strlen(buf))) {
   1074                          return WIFI_FAIL;
   1075                      }
   1076                  }
   1077              } else {
   1078                  if (support_5g < 0) {
   1079                      LOG_E(wifi, "Chip doesn't support 5G.");
   1080                      return WIFI_ERR_NOT_SUPPORT;
   1081          		}
   1082                  if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_COMMON, "CountryRegionABand",
   1083                          NVDM_DATA_ITEM_TYPE_STRING,
   1084                          (uint8_t *)buf, os_strlen(buf))) {
   1085                      return WIFI_FAIL;
   1086                  }
   1087                  if (wifi_get_channel_list(WIFI_BAND_5_G, region, buf) >= 0) {
   1088                      if (NVDM_STATUS_OK != nvdm_write_data_item("common", "AChannelTable",
   1089                              NVDM_DATA_ITEM_TYPE_STRING,
   1090                              (uint8_t *)buf, os_strlen(buf))) {
   1091                          return WIFI_FAIL;
   1092                      }
   1093                  }
   1094              }
   1095              return WIFI_SUCC;
   1096          }
   1097          
   1098          
   1099          int32_t wifi_profile_get_dtim_interval(uint8_t *interval)
   1100          {
   1101              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
   1102              uint32_t len = sizeof(buf);
   1103          
   1104              if (NULL == interval) {
   1105                  LOG_E(wifi, "interval is null");
   1106                  return WIFI_ERR_PARA_INVALID;
   1107              }
   1108          
   1109              if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_AP, "DtimPeriod", (uint8_t *)buf, &len)) {
   1110                  return WIFI_FAIL;
   1111              }
   1112          
   1113              *interval = atoi(buf);
   1114              return WIFI_SUCC;
   1115          }
   1116          
   1117          
   1118          int32_t wifi_profile_set_dtim_interval(uint8_t interval)
   1119          {
   1120              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
   1121          
   1122              if (0 == interval) {
   1123                  LOG_E(wifi, "interval is invalid: %d", interval);
   1124                  return WIFI_ERR_PARA_INVALID;
   1125              }
   1126          
   1127              sprintf(buf, "%d", interval);
   1128              if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_AP, "DtimPeriod",
   1129                      NVDM_DATA_ITEM_TYPE_STRING,
   1130                      (const uint8_t *)buf, os_strlen(buf))) {
   1131                  return WIFI_FAIL;
   1132              }
   1133          
   1134              return WIFI_SUCC;
   1135          }
   1136          
   1137          
   1138          int32_t wifi_profile_get_listen_interval(uint8_t *interval)
   1139          {
   1140              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
   1141              uint32_t len = sizeof(buf);
   1142          
   1143              if (NULL == interval) {
   1144                  LOG_E(wifi, "interval is null");
   1145                  return WIFI_ERR_PARA_INVALID;
   1146              }
   1147          
   1148              if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "ListenInterval", (uint8_t *)buf, &len)) {
   1149                  return WIFI_FAIL;
   1150              }
   1151          
   1152              *interval = atoi(buf);
   1153              return WIFI_SUCC;
   1154          }
   1155          
   1156          
   1157          int32_t wifi_profile_set_listen_interval(uint8_t interval)
   1158          {
   1159              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
   1160          
   1161              if (0 == interval) {
   1162                  LOG_E(wifi, "interval is invalid: %d", interval);
   1163                  return WIFI_ERR_PARA_INVALID;
   1164              }
   1165          
   1166              sprintf(buf, "%d", interval);
   1167          
   1168              if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "ListenInterval",
   1169                      NVDM_DATA_ITEM_TYPE_STRING,
   1170                      (const uint8_t *)buf, os_strlen(buf))) {
   1171                  return WIFI_FAIL;
   1172              }
   1173          
   1174              return WIFI_SUCC;
   1175          }
   1176          
   1177          int32_t wifi_profile_get_power_save_mode(uint8_t *power_save_mode)
   1178          {
   1179              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
   1180              uint32_t len = sizeof(buf);
   1181          
   1182              if (NULL == power_save_mode) {
   1183                  LOG_E(wifi, "power_save_mode is null");
   1184                  return WIFI_ERR_PARA_INVALID;
   1185              }
   1186          
   1187              if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "PSMode", (uint8_t *)buf, &len)) {
   1188                  return WIFI_FAIL;
   1189              }
   1190          
   1191              *power_save_mode = atoi(buf);
   1192              return WIFI_SUCC;
   1193          }
   1194          
   1195          int32_t wifi_profile_set_power_save_mode(uint8_t power_save_mode)
   1196          {
   1197              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
   1198          
   1199              if (!wifi_is_ps_mode_valid(power_save_mode)) {
   1200                  LOG_E(wifi, "power_save_mode is invalid: %d", power_save_mode);
   1201                  return WIFI_ERR_PARA_INVALID;
   1202              }
   1203          
   1204              sprintf(buf, "%d", power_save_mode);
   1205              if (nvdm_write_data_item(WIFI_PROFILE_BUFFER_STA, "PSMode",
   1206                                       NVDM_DATA_ITEM_TYPE_STRING,
   1207                                       (const uint8_t *)buf, os_strlen(buf))) {
   1208                  return WIFI_FAIL;
   1209              }
   1210          
   1211              return WIFI_SUCC;
   1212          }
   1213          
   1214          int32_t wifi_profile_get_configfree(uint8_t *config_ready)
   1215          {
   1216              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
   1217              uint32_t len = sizeof(buf);
   1218          
   1219              if (NULL == config_ready) {
   1220                  LOG_E(wifi, "config_ready is null");
   1221                  return WIFI_ERR_PARA_INVALID;
   1222              }
   1223          
   1224              if (NVDM_STATUS_OK != nvdm_read_data_item(WIFI_PROFILE_BUFFER_COMMON, "ConfigFree_Ready", (uint8_t *)buf, &len)) {
   1225                  return WIFI_FAIL;
   1226              }
   1227          
   1228              *config_ready = atoi(buf);
   1229              return WIFI_SUCC;
   1230          }
   1231          
   1232          int32_t wifi_profile_set_configfree(uint8_t config_ready)
   1233          {
   1234              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
   1235          
   1236              if (0 != config_ready && 1 != config_ready) {
   1237                  LOG_E(wifi, "config_ready is invalid: %d", config_ready);
   1238                  return WIFI_ERR_PARA_INVALID;
   1239              }
   1240          
   1241              sprintf(buf, "%d", WIFI_MODE_REPEATER);
   1242              LOG_I(wifi, "wifi_profile_set_opmode: opmode=%s", buf);
   1243          
   1244              if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_COMMON, "OpMode",
   1245                      NVDM_DATA_ITEM_TYPE_STRING,
   1246                      (uint8_t *)buf, os_strlen(buf))) {
   1247                  return WIFI_FAIL;
   1248              }
   1249          
   1250              os_memset(buf, 0x0, WIFI_PROFILE_BUFFER_LENGTH);
   1251          
   1252              sprintf(buf, "%d", config_ready);
   1253              LOG_I(wifi, "ConfigFree ready: %s", buf);
   1254          
   1255              if (NVDM_STATUS_OK != nvdm_write_data_item(WIFI_PROFILE_BUFFER_COMMON, "ConfigFree_Ready",
   1256                      NVDM_DATA_ITEM_TYPE_STRING,
   1257                      (uint8_t *)buf, os_strlen(buf))) {
   1258                  return WIFI_FAIL;
   1259              }
   1260          
   1261              return WIFI_SUCC;
   1262          }
   1263          #endif //MTK_WIFI_PROFILE_ENABLE
   1264          
   1265          #ifdef MTK_WIFI_PROFILE_ENABLE
   1266          static uint8_t wifi_profile_set_opmode_ex(uint8_t len, char *param[])
   1267          {
   1268              uint8_t status = 0;
   1269              uint8_t mode = atoi(param[0]);
   1270          
   1271              status = wifi_profile_set_opmode(mode);
   1272              status = wifi_profile_commit_setting(WIFI_PROFILE_BUFFER_COMMON);
   1273          
   1274              printf("save opmode=%d done.\n", mode);
   1275          
   1276              return status;
   1277          }
   1278          
   1279          /**
   1280           * @brief Store channel to the profile in the Flash memory.
   1281           * wifi profile set ch <port> <ch>
   1282           * @param [IN]port
   1283           * @param 0 STA / AP Client
   1284           * @param 1 AP
   1285           * @param [IN]channel    1~14 are supported for 2.4G only product.
   1286           *
   1287           * @return  >=0 means success, <0 means fail
   1288           */
   1289          static uint8_t wifi_profile_set_channel_ex(uint8_t len, char *param[])
   1290          {
   1291              uint8_t status = 0;
   1292              int32_t port = port_sanity_check(param[0]);
   1293              uint8_t ch = atoi(param[1]);
   1294              char *section = (port == WIFI_PORT_STA ? WIFI_PROFILE_BUFFER_STA : WIFI_PROFILE_BUFFER_AP);
   1295          
   1296              if (port < 0) {
   1297                  return 1;
   1298              }
   1299          
   1300              if (ch < 1) {
   1301                  printf("Invalid channel number\n");
   1302                  return 1;
   1303              }
   1304          
   1305              status = wifi_profile_set_channel((uint8_t)port, ch);
   1306          
   1307              status = wifi_profile_commit_setting(section);
   1308          
   1309              printf("[%s] save ch =%d done.\n", section, ch);
   1310          
   1311              return status;
   1312          }
   1313          
   1314          /**
   1315           * @brief Store bandwidth to the profile in the Flash memory.
   1316           * wifi profile set bw <port> <bw>
   1317           * @param [IN]port
   1318           * @param 0 STA / AP Client
   1319           * @param 1 AP
   1320           * @param [IN]bandwidth Bandwidth IOT_CMD_CBW_20MHZ, IOT_CMD_CBW_40MHZ,
   1321           *                  IOT_CMD_CBW_2040MHZ are supported.
   1322           * @return  >=0 means success, <0 means fail
   1323           */
   1324          static uint8_t wifi_profile_set_bandwidth_ex(uint8_t len, char *param[])
   1325          {
   1326              uint8_t status = 0;
   1327              int32_t port = port_sanity_check(param[0]);
   1328              uint8_t bw = atoi(param[1]);
   1329              char *section = (port == WIFI_PORT_STA ? WIFI_PROFILE_BUFFER_STA : WIFI_PROFILE_BUFFER_AP);
   1330          
   1331              if (port < 0) {
   1332                  return 1;
   1333              }
   1334          
   1335              status = wifi_profile_set_bandwidth((uint8_t)port, bw);
   1336              status = wifi_profile_commit_setting(section);
   1337          
   1338              printf("[%s] save bw =%d done.\n", section, bw);
   1339          
   1340              return status;
   1341          }
   1342          
   1343          /**
   1344          * @brief Store SSID to the profile in the Flash memory.
   1345          * wifi profile set ssid <port> <ssid>
   1346          * @param [IN]port
   1347          * @param 0 STA / AP Client
   1348          * @param 1 AP
   1349          * @param [IN]ssid SSID
   1350          * @return  >=0 means success, <0 means fail
   1351          */
   1352          static uint8_t wifi_profile_set_ssid_ex(uint8_t len, char *param[])
   1353          {
   1354              uint8_t status = 0;
   1355              int32_t port = port_sanity_check(param[0]);
   1356              char *ssid = param[1];
   1357              char *section = (port == WIFI_PORT_STA ? WIFI_PROFILE_BUFFER_STA : WIFI_PROFILE_BUFFER_AP);
   1358          
   1359              if (port < 0) {
   1360                  return 1;
   1361              }
   1362          
   1363              status = wifi_profile_set_ssid((uint8_t)port, (uint8_t *)ssid, strlen(ssid));
   1364              status = wifi_profile_commit_setting(section);
   1365          
   1366              printf("[%s] save ssid = %s done.\n", section, ssid);
   1367          
   1368              return status;
   1369          }
   1370          #if 0
   1371          /**
   1372          * @brief Store WiFi BSSID to the profile in the Flash memory.
   1373          * wifi profile set bssid <port> <bssid>
   1374          * ex: wifi profile set bssid 0 00:0c:43:76:87:02
   1375          * @param [IN]port
   1376          * @param 0 STA / AP Client
   1377          * @param 1 AP
   1378          * @param [IN]bssid BSSID
   1379          *
   1380          * @return  >=0 means success, <0 means fail
   1381          */
   1382          
   1383          static uint8_t wifi_profile_set_bssid_ex(uint8_t len, char *param[])
   1384          {
   1385              uint8_t status = 0;
   1386              uint8_t port = atoi(param[0]);
   1387              uint8_t bssid[6];
   1388          
   1389              __wifi_conf_get_mac_from_str((char *)bssid, param[1]);
   1390          
   1391              status = wifi_profile_set_bssid(port, bssid);
   1392          
   1393              printf("save bssid = %02x:%02x:%02x:%02x:%02x:%02x done.\n",
   1394                     bssid[0],
   1395                     bssid[1],
   1396                     bssid[2],
   1397                     bssid[3],
   1398                     bssid[4],
   1399                     bssid[5]);
   1400          
   1401              return status;
   1402          }
   1403          #endif
   1404          
   1405          /**
   1406          * @brief Store WiFi Wireless Mode to the profile in the Flash memory.
   1407          * wifi profile set wirelessmode <port> <mode>
   1408          * @param [IN]port
   1409          * @param 0 STA / AP Client
   1410          * @param 1 AP
   1411          * @param [IN]mode
   1412          * @param 1 legacy 11B only
   1413          * @param 2 legacy 11A only
   1414          * @param 3 legacy 11A/B/G mixed
   1415          * @param 4 legacy 11G only
   1416          * @param 5 11ABGN mixed
   1417          * @param 6 11N only in 2.4G
   1418          * @param 7 11GN mixed
   1419          * @param 8 11AN mixed
   1420          * @param 9 11BGN mixed
   1421          * @param 10 11AGN mixed
   1422          *
   1423          * @return  >=0 means success, <0 means fail
   1424          */
   1425          
   1426          static uint8_t wifi_profile_set_wireless_mode_ex(uint8_t len, char *param[])
   1427          {
   1428              uint8_t status = 0;
   1429              int32_t port = port_sanity_check(param[0]);
   1430              wifi_phy_mode_t mode = (wifi_phy_mode_t)atoi(param[1]);
   1431              char *section = (port == WIFI_PORT_STA ? WIFI_PROFILE_BUFFER_STA : WIFI_PROFILE_BUFFER_AP);
   1432          
   1433              if (port < 0) {
   1434                  return 1;
   1435              }
   1436          
   1437              status = wifi_profile_set_wireless_mode((uint8_t)port, mode);
   1438              status = wifi_profile_commit_setting(section);
   1439          
   1440              printf("[%s] save wireless mode =%d done.\n", section, mode);
   1441          
   1442              return status;
   1443          }
   1444          static uint8_t wifi_profile_set_country_region_ex(uint8_t len, char *param[])
   1445          {
   1446              uint8_t status = 0;
   1447              uint8_t band = atoi(param[0]);
   1448              uint8_t region = atoi(param[1]);
   1449          
   1450              status = wifi_profile_set_country_region(band, region);
   1451              status = wifi_profile_commit_setting(WIFI_PROFILE_BUFFER_COMMON);
   1452          
   1453              printf("save country band(%d) region =%d done.\n", band, region);
   1454          
   1455              return status;
   1456          }
   1457          static uint8_t wifi_profile_set_dtim_interval_ex(uint8_t len, char *param[])
   1458          {
   1459              uint8_t status = 0;
   1460              uint8_t dtim = atoi(param[0]);
   1461          
   1462              status = wifi_profile_set_dtim_interval(dtim);
   1463              status = wifi_profile_commit_setting(WIFI_PROFILE_BUFFER_AP);
   1464          
   1465              printf("save dtim interval =%d done.\n", dtim);
   1466          
   1467              return status;
   1468          }
   1469          static uint8_t wifi_profile_set_listen_interval_ex(uint8_t len, char *param[])
   1470          {
   1471              uint8_t status = 0;
   1472              uint8_t interval = atoi(param[0]);
   1473          
   1474              status = wifi_profile_set_listen_interval(interval);
   1475              status = wifi_profile_commit_setting(WIFI_PROFILE_BUFFER_STA);
   1476          
   1477              printf("save listen interval =%d done.\n", interval);
   1478          
   1479              return status;
   1480          }
   1481          static uint8_t wifi_profile_set_mac_address_ex(uint8_t len, char *param[])
   1482          {
   1483              uint8_t status = 0;
   1484              int32_t port = port_sanity_check(param[0]);
   1485              uint8_t mac[6] = {0};
   1486          
   1487          #ifdef MTK_WIFI_REPEATER_ENABLE
   1488              uint8_t mode;
   1489              char *section = WIFI_PROFILE_BUFFER_STA;
   1490          
   1491              status = wifi_profile_get_opmode(&mode);
   1492              if (mode == WIFI_MODE_REPEATER) {
   1493                  strcpy(section,(port == WIFI_PORT_STA ? WIFI_PROFILE_BUFFER_STA : WIFI_PROFILE_BUFFER_AP));
   1494              } else {
   1495                  strcpy(section, WIFI_PROFILE_BUFFER_STA);
   1496              }
   1497              //char *section = (port == WIFI_PORT_STA ? WIFI_PROFILE_BUFFER_STA : WIFI_PROFILE_BUFFER_AP);
   1498          #else
   1499              /* Use STA MAC/IP as AP MAC/IP for the time being, due to N9 dual interface not ready yet */
   1500              char *section = WIFI_PROFILE_BUFFER_STA;
   1501          #endif /* MTK_WIFI_REPEATER_ENABLE */
   1502          
   1503              if (port < 0) {
   1504                  return 1;
   1505              }
   1506          
   1507              wifi_conf_get_mac_from_str((char *)mac, param[1]);
   1508          
   1509              status = wifi_profile_set_mac_address((uint8_t)port, mac);
   1510              status = wifi_profile_commit_setting(section);
   1511          
   1512              printf("[%s] save mac address = %02x:%02x:%02x:%02x:%02x:%02x done.\n",
   1513                     section,
   1514                     mac[0],
   1515                     mac[1],
   1516                     mac[2],
   1517                     mac[3],
   1518                     mac[4],
   1519                     mac[5]);
   1520              return status;
   1521          }
   1522          
   1523          static uint8_t wifi_profile_set_security_mode_ex(uint8_t len, char *param[])
   1524          {
   1525              uint8_t status = 0;
   1526              int32_t port = port_sanity_check(param[0]);
   1527              wifi_auth_mode_t auth = (wifi_auth_mode_t)atoi(param[1]);
   1528              wifi_encrypt_type_t encryp = (wifi_encrypt_type_t)atoi(param[2]);
   1529              char *section = (port == WIFI_PORT_STA ? WIFI_PROFILE_BUFFER_STA : WIFI_PROFILE_BUFFER_AP);
   1530          
   1531              if (port < 0) {
   1532                  return 1;
   1533              }
   1534          
   1535              status = wifi_profile_set_security_mode((uint8_t)port, auth, encryp);
   1536              status = wifi_profile_commit_setting(section);
   1537          
   1538              printf("[%s] save auth mode=%d, encrypt type=%d done.\n", section, auth, encryp);
   1539          
   1540              return status;
   1541          }
   1542          
   1543          static uint8_t wifi_profile_set_psk_ex(uint8_t len, char *param[])
   1544          {
   1545              int8_t status = 0;
   1546              int32_t port = port_sanity_check(param[0]);
   1547              char *password = param[1];
   1548              char *section = (port == WIFI_PORT_STA ? WIFI_PROFILE_BUFFER_STA : WIFI_PROFILE_BUFFER_AP);
   1549          
   1550              if (port < 0) {
   1551                  return 1;
   1552              }
   1553          
   1554              status = wifi_profile_set_wpa_psk_key((uint8_t)port, (uint8_t *)password, strlen(password));
   1555              if (status < 0) {
   1556                  printf("[%s] ERROR! Fail to save password =%s len = %d.\n", section, password, strlen(password));
   1557                  return 1;
   1558              }
   1559              status = wifi_profile_commit_setting(section);
   1560          
   1561              printf("[%s] save password =%s len = %d done.\n", section, password, strlen(password));
   1562          
   1563              return 0;
   1564          }
   1565          
   1566          /**
   1567          * @brief Example of Store PMK for the specified STA/AP port into the Flash memory
   1568          * wifi profile set pmk <port> <PMK>
   1569          * @param [IN]port
   1570          *       0 STA / AP Client
   1571          *       1 AP
   1572          * @param  [IN] PMK (in hex)
   1573          *       00, 05, 30, ......(size 32)
   1574          * @return >=0 means success, <0 means fail
   1575          * @note Default to OPEN
   1576          */
   1577          static uint8_t wifi_profile_set_pmk_ex(uint8_t len, char *param[])
   1578          {
   1579              int8_t status = 0;
   1580              int32_t port = port_sanity_check(param[0]);
   1581              char *section = (port == WIFI_PORT_STA ? WIFI_PROFILE_BUFFER_STA : WIFI_PROFILE_BUFFER_AP);
   1582              uint8_t hex[32] = {0};
   1583          
   1584              if (port < 0) {
   1585                  return 1;
   1586              }
   1587          
   1588              os_memset(hex, 0, sizeof(hex));
   1589              convert_string_to_hex_array(param[1], hex);
   1590              status = wifi_profile_set_pmk((uint8_t)port, hex);
   1591              if (status < 0) {
   1592                  printf("[%s] ERROR! Fail to save pmk.\n", section);
   1593                  return 1;
   1594              }
   1595              status = wifi_profile_commit_setting(section);
   1596          
   1597              printf("[%s] wifi_profile_set_pmk_ex: status:%d\n",
   1598                     section, status);
   1599          
   1600              return 0;
   1601          
   1602          }
   1603          
   1604          /**
   1605          * @brief Example of Get profile stored in NVRAM
   1606          *
   1607          * @param [IN]port
   1608          * @param 0 AP
   1609          * @param 1 AP Client
   1610          * @param 2 STA
   1611          * @param [OUT]profile WiFi Profile
   1612          *
   1613          * @return  >=0 means success, <0 means fail
   1614          */
   1615          int32_t wifi_config_init(sys_cfg_t *wifi_config);
   1616          uint8_t wifi_profile_get_profile_ex(uint8_t len, char *param[])
   1617          {
   1618              sys_cfg_t wifi_profile_struct = {0};
   1619              sys_cfg_t *wifi_profile = &wifi_profile_struct;
   1620              uint8_t status = wifi_config_init(&wifi_profile_struct);
   1621          
   1622              // COMMON
   1623              printf("[COMMON]\n");
   1624              printf("\tOpMode = %d\n", wifi_profile->opmode);
   1625              printf("\tCountryRegion = %d\n", wifi_profile->country_region);
   1626              printf("\tCountryRegionABand = %d\n", wifi_profile->country_region_a_band);
   1627              printf("\tCountryCode = %s\n", wifi_profile->country_code);
   1628              printf("\tRadioOff = %d\n", wifi_profile->radio_off);
   1629              printf("\tRTSThreshold = %d\n", wifi_profile->rts_threshold);
   1630              printf("\tFragThreshold = %d\n", wifi_profile->frag_threshold);
   1631              printf("\tDbgLevel = %d\n", wifi_profile->dbg_level);
   1632              printf("\tForwardingZeroCopy = %d\n", wifi_profile->forwarding_zero_copy);
   1633              // STA
   1634              printf("[STA]\n");
   1635              printf("\tLocalAdminMAC = %d\n", wifi_profile->sta_local_admin_mac);
   1636              printf("\tIpAddr = %d.%d.%d.%d\n",
   1637                     wifi_profile->sta_ip_addr[0],
   1638                     wifi_profile->sta_ip_addr[1],
   1639                     wifi_profile->sta_ip_addr[2],
   1640                     wifi_profile->sta_ip_addr[3]);
   1641              printf("\tMacAddr = %02x:%02x:%02x:%02x:%02x:%02x\n",
   1642                     wifi_profile->sta_mac_addr[0],
   1643                     wifi_profile->sta_mac_addr[1],
   1644                     wifi_profile->sta_mac_addr[2],
   1645                     wifi_profile->sta_mac_addr[3],
   1646                     wifi_profile->sta_mac_addr[4],
   1647                     wifi_profile->sta_mac_addr[5]);
   1648              printf("\tSsidLen = %d\n", wifi_profile->sta_ssid_len);
   1649              printf("\tSsid = %s\n", wifi_profile->sta_ssid);
   1650              printf("\tBssType = %d\n", wifi_profile->sta_bss_type);
   1651              printf("\tChannel = %d\n", wifi_profile->sta_channel);
   1652              printf("\tBW = %d\n", wifi_profile->sta_bw);
   1653              printf("\tWirelessMode = %d\n", wifi_profile->sta_wireless_mode);
   1654              printf("\tBADecline = %d\n", wifi_profile->sta_ba_decline);
   1655              printf("\tAutoBA = %d\n", wifi_profile->sta_auto_ba);
   1656              printf("\tHT_MCS = %d\n", wifi_profile->sta_ht_mcs);
   1657              printf("\tHT_BAWinSize = %d\n", wifi_profile->sta_ht_ba_win_size);
   1658              printf("\tHT_GI = %d\n", wifi_profile->sta_ht_gi);
   1659              printf("\tHT_PROTECT = %d\n", wifi_profile->sta_ht_protect);
   1660              printf("\tHT_EXTCHA = %d\n", wifi_profile->sta_ht_ext_ch);
   1661              printf("\tWmmCapable = %d\n", wifi_profile->sta_wmm_capable);
   1662              printf("\tListenInterval = %d\n", wifi_profile->sta_listen_interval);
   1663              printf("\tAuthMode = %d\n", wifi_profile->sta_auth_mode);
   1664              printf("\tEncrypType = %d\n", wifi_profile->sta_encryp_type);
   1665              printf("\tWpaPskLen = %d\n", wifi_profile->sta_wpa_psk_len);
   1666              printf("\tPairCipher = %d\n", wifi_profile->sta_pair_cipher);
   1667              printf("\tGroupCipher = %d\n", wifi_profile->sta_group_cipher);
   1668              printf("\tDefaultKeyId = %d\n", wifi_profile->sta_default_key_id);
   1669              printf("\tPSMode = %d\n", wifi_profile->sta_ps_mode);
   1670              printf("\tKeepAlivePeriod = %d\n", wifi_profile->sta_keep_alive_period);
   1671          
   1672              hex_dump("WpaPsk", wifi_profile->sta_wpa_psk, sizeof(wifi_profile->sta_wpa_psk));
   1673              hex_dump("PMK", wifi_profile->sta_pmk, sizeof(wifi_profile->sta_pmk));
   1674          
   1675              // AP
   1676              printf("[AP]\n");
   1677              printf("\tLocalAdminMAC = %d\n", wifi_profile->ap_local_admin_mac);
   1678              printf("\tIpAddr = %d.%d.%d.%d\n",
   1679                     wifi_profile->ap_ip_addr[0],
   1680                     wifi_profile->ap_ip_addr[1],
   1681                     wifi_profile->ap_ip_addr[2],
   1682                     wifi_profile->ap_ip_addr[3]);
   1683              printf("\tMacAddr = %02x:%02x:%02x:%02x:%02x:%02x\n",
   1684                     wifi_profile->ap_mac_addr[0],
   1685                     wifi_profile->ap_mac_addr[1],
   1686                     wifi_profile->ap_mac_addr[2],
   1687                     wifi_profile->ap_mac_addr[3],
   1688                     wifi_profile->ap_mac_addr[4],
   1689                     wifi_profile->ap_mac_addr[5]);
   1690              printf("\tSsidLen = %d\n", wifi_profile->ap_ssid_len);
   1691              printf("\tSsid = %s\n", wifi_profile->ap_ssid);
   1692              printf("\tChannel = %d\n", wifi_profile->ap_channel);
   1693              printf("\tBW = %d\n", wifi_profile->ap_bw);
   1694              printf("\tWirelessMode = %d\n", wifi_profile->ap_wireless_mode);
   1695              printf("\tAutoBA = %d\n", wifi_profile->ap_auto_ba);
   1696              printf("\tHT_MCS = %d\n", wifi_profile->ap_ht_mcs);
   1697              printf("\tHT_BAWinSize = %d\n", wifi_profile->ap_ht_ba_win_size);
   1698              printf("\tHT_GI = %d\n", wifi_profile->ap_ht_gi);
   1699              printf("\tHT_PROTECT = %d\n", wifi_profile->ap_ht_protect);
   1700              printf("\tHT_EXTCHA = %d\n", wifi_profile->ap_ht_ext_ch);
   1701              printf("\tWmmCapable = %d\n", wifi_profile->ap_wmm_capable);
   1702              printf("\tDtimPeriod = %d\n", wifi_profile->ap_dtim_period);
   1703              printf("\tHideSSID = %d\n", wifi_profile->ap_hide_ssid);
   1704              printf("\tAutoChannelSelect = %d\n", wifi_profile->ap_auto_channel_select);
   1705              printf("\tAuthMode = %d\n", wifi_profile->ap_auth_mode);
   1706              printf("\tEncrypType = %d\n", wifi_profile->ap_encryp_type);
   1707              printf("\tWpaPskLen = %d\n", wifi_profile->ap_wpa_psk_len);
   1708              printf("\tPairCipher = %d\n", wifi_profile->ap_pair_cipher);
   1709              printf("\tGroupCipher = %d\n", wifi_profile->ap_group_cipher);
   1710              printf("\tDefaultKeyId = %d\n", wifi_profile->ap_default_key_id);
   1711          
   1712              hex_dump("WpaPsk", wifi_profile->ap_wpa_psk, sizeof(wifi_profile->ap_wpa_psk));
   1713              hex_dump("PMK", wifi_profile->ap_pmk, sizeof(wifi_profile->ap_pmk));
   1714          
   1715          #if 0 // not ready
   1716              // scan channel table and regulatory table
   1717              printf("[COMMON-misc.]\n");
   1718          
   1719              printf("\tBGChannelTable:\n");
   1720              for (i = 0; i < 10; i++)
   1721                  printf("\t\t{%d,%d,%d}\n",
   1722                         wifi_profile->bg_band_triple[i].first_channel,
   1723                         wifi_profile->bg_band_triple[i].num_of_ch,
   1724                         wifi_profile->bg_band_triple[i].channel_prop);
   1725          
   1726              printf("\tAChannelTable:\n");
   1727              for (i = 0; i < 10; i++)
   1728                  printf("\t\t{%d,%d,%d}\n",
   1729                         wifi_profile->a_band_triple[i].first_channel,
   1730                         wifi_profile->a_band_triple[i].num_of_ch,
   1731                         wifi_profile->a_band_triple[i].channel_prop);
   1732          #endif
   1733              return status;
   1734          }
   1735          
   1736          /**
   1737          * @brief Example of Get PMK for the specified STA/AP port from NVRAM
   1738          * wifi profile get pmk <port>
   1739          * @param [IN]port
   1740          *       0 STA / AP Client
   1741          *       1 AP
   1742          * @return >=0 means success, <0 means fail
   1743          * @note Default to OPEN
   1744          */
   1745          static uint8_t wifi_profile_get_pmk_ex(uint8_t len, char *param[])
   1746          {
   1747              int i;
   1748              uint8_t status = 0;
   1749              uint8_t hex[32] = {0};
   1750              int32_t port = port_sanity_check(param[0]);
   1751              if (port < 0) {
   1752                  return 1;
   1753              }
   1754          
   1755              os_memset(hex, 0, sizeof(hex));
   1756              status = wifi_profile_get_pmk(port, hex);
   1757              printf("wifi_profile_get_pmk_ex: port:%ld, status:%d, key dump:\n",
   1758                     port, status);
   1759              for (i = 0; i < sizeof(hex); i++) {
   1760                  if (i % 16 == 0) {
   1761                      printf("\n\t");
   1762                  }
   1763                  printf("%02x ", (unsigned int)hex[i]);
   1764              }
   1765          
   1766              return status;
   1767          
   1768          }
   1769          
   1770          
   1771          
   1772          /**
   1773          * @brief Store WiFi WEP Keys to the profile in NVRAM.
   1774          * wifi profile set wep <port> <key id> <key>
   1775          * @param [IN]port
   1776          * @param 0 STA / AP Client
   1777          * @param 1 AP
   1778          * @param [IN]wifi_wep_key_t
   1779          *
   1780          * @return  >=0 means success, <0 means fail
   1781          */
   1782          static uint8_t wifi_profile_set_wep_key_ex(uint8_t len, char *param[])
   1783          {
   1784              uint8_t status = 0;
   1785              uint8_t index = 0;
   1786              wifi_wep_key_t wep_key;
   1787              char *ptr = NULL;
   1788              int32_t port = port_sanity_check(param[0]);
   1789              char *keys = param[2];
   1790              char *section = (port == WIFI_PORT_STA ? WIFI_PROFILE_BUFFER_STA : WIFI_PROFILE_BUFFER_AP);
   1791          
   1792              if (port < 0) {
   1793                  return 1;
   1794              }
   1795          
   1796              os_memset(&wep_key, 0, sizeof(wep_key));
   1797              wep_key.wep_tx_key_index = atoi(param[1]);
   1798          
   1799              index = 0;
   1800              for (ptr = rstrtok((char *)keys, ","); (ptr); ptr = rstrtok(NULL, ",")) {
   1801                  printf("[%d] key=%s\n", index, ptr);
   1802                  if (strlen(ptr) == 1 || strlen(ptr) == 5 || strlen(ptr) == 13 || strlen(ptr) == 10 || strlen(ptr) == 26) {
   1803                      os_memcpy(wep_key.wep_key[index], ptr, strlen(ptr));
   1804                      wep_key.wep_key_length[index] = strlen(ptr);
   1805                  } else {
   1806                      printf("invalid length of value.\n");
   1807                  }
   1808                  index++;
   1809                  if (index >= WIFI_NUMBER_WEP_KEYS) {
   1810                      break;
   1811                  }
   1812              }
   1813          
   1814          
   1815              status = wifi_profile_set_wep_key((uint8_t)port, &wep_key);
   1816              status = wifi_profile_commit_setting(section);
   1817          
   1818              printf("[%s] save wep key =(%s, %s, %s, %s) key id=%d, len=(%d, %d, %d, %d) done.\n",
   1819                     section,
   1820                     wep_key.wep_key[0],
   1821                     wep_key.wep_key[1],
   1822                     wep_key.wep_key[2],
   1823                     wep_key.wep_key[3],
   1824                     wep_key.wep_tx_key_index,
   1825                     wep_key.wep_key_length[0],
   1826                     wep_key.wep_key_length[1],
   1827                     wep_key.wep_key_length[2],
   1828                     wep_key.wep_key_length[3]);
   1829          
   1830              return status;
   1831          }
   1832          #if 0
   1833          /**
   1834           * @brief Configure packet format wanted to be received
   1835           * wifi profile set rxfilter <flag>
   1836           * @param flag [IN] flag defined in iot_rx_filter_t.
   1837           * @return >=0 means success, <0 means fail
   1838           * @note Default value will be WIFI_DEFAULT_IOT_RX_FILTER
   1839           */
   1840          static uint8_t wifi_profile_set_rx_filter_ex(uint8_t len, char *param[])
   1841          {
   1842              uint8_t status = 0;
   1843              uint32_t flag = atoi(param[0]);
   1844          
   1845              status = wifi_profile_set_rx_filter(flag);
   1846          
   1847              printf("save RX filter = 0x%x done.\n", (unsigned int)flag);
   1848          
   1849              return status;
   1850          }
   1851          
   1852          
   1853          static uint8_t wifi_profile_set_smart_connection_filter_ex(uint8_t len, char *param[])
   1854          {
   1855              uint8_t status = 0;
   1856              uint8_t flag = atoi(param[0]);
   1857          
   1858              status = wifi_profile_set_smart_connection_filter(flag);
   1859          
   1860              printf("save MTK RX filter =0x%x done.\n", flag);
   1861          
   1862              return status;
   1863          }
   1864          #endif
   1865          static uint8_t wifi_profile_get_opmode_ex(uint8_t len, char *param[])
   1866          {
   1867              uint8_t status = 0;
   1868              uint8_t mode;
   1869          
   1870              status = wifi_profile_get_opmode(&mode);
   1871          
   1872              printf("fetch opmode=%d done.\n", mode);
   1873          
   1874              return status;
   1875          }
   1876          
   1877          /**
   1878           * @brief Get channel from the profile in NVRAM.
   1879           * wifi profile get ch <port>
   1880           * @param [IN]port
   1881           * @param 0 STA / AP Client
   1882           * @param 1 AP
   1883           * @param [OUT]channel    1~14 are supported for 2.4G only product.
   1884           *
   1885           * @return  >=0 means success, <0 means fail
   1886           */
   1887          
   1888          static uint8_t wifi_profile_get_channel_ex(uint8_t len, char *param[])
   1889          {
   1890              uint8_t status = 0;
   1891              int32_t port = port_sanity_check(param[0]);
   1892              uint8_t ch;
   1893          
   1894              if (port < 0) {
   1895                  return 1;
   1896              }
   1897          
   1898              status = wifi_profile_get_channel((uint8_t)port, &ch);
   1899          
   1900              printf("fetch ch =%d done.\n", ch);
   1901          
   1902              return status;
   1903          }
   1904          
   1905          /**
   1906           * @brief  Get bandwidth from the profile in NVRAM.
   1907           * wifi profile get bw <port>
   1908           * @param [IN]port
   1909           * @param 0 STA / AP Client
   1910           * @param 1 AP
   1911           * @param [OUT]bandwidth The wirelss bandwidth.
   1912           *                       IOT_CMD_CBW_20MHZ,
   1913           *                       IOT_CMD_CBW_40MHZ, and
   1914           *                       IOT_CMD_CBW_2040MHZ are supported.
   1915           *
   1916           * @return  >=0 means success, <0 means fail
   1917           *
   1918           * @note    Default value is HT_20
   1919           */
   1920          
   1921          static uint8_t wifi_profile_get_bandwidth_ex(uint8_t len, char *param[])
   1922          {
   1923              uint8_t status = 0;
   1924              int32_t port = port_sanity_check(param[0]);
   1925              uint8_t bw;
   1926          
   1927              if (port < 0) {
   1928                  return 1;
   1929              }
   1930          
   1931              status = wifi_profile_get_bandwidth((uint8_t)port, &bw);
   1932          
   1933              printf("fetch bw =%d done.\n", bw);
   1934          
   1935              return status;
   1936          }
   1937          
   1938          /**
   1939          * @brief Get SSID from the profile in NVRAM.
   1940          * wifi profile get ssid <port>
   1941          * @param [IN]port
   1942          * @param 0 STA / AP Client
   1943          * @param 1 AP
   1944          * @param [OUT]ssid SSID
   1945          * @param [OUT]ssid_length Length of SSID
   1946          *
   1947          * @return  >=0 means success, <0 means fail
   1948          */
   1949          static uint8_t wifi_profile_get_ssid_ex(uint8_t length, char *param[])
   1950          {
   1951              uint8_t status = 0;
   1952              int32_t port = port_sanity_check(param[0]);
   1953              uint8_t ssid[32] = {0};
   1954              uint8_t len;
   1955          
   1956              if (port < 0) {
   1957                  return 1;
   1958              }
   1959          
   1960              os_memset(ssid, 0x0, sizeof(ssid));
   1961              status = wifi_profile_get_ssid((uint8_t)port, ssid, &len);
   1962          
   1963              printf("fetch ssid = %s, len=%d done.\n", ssid, len);
   1964          
   1965              return status;
   1966          }
   1967          #if 0
   1968          /**
   1969          * @brief Store WiFi BSSID to the profile in NVRAM.
   1970          * wifi profile get bssid <port>
   1971          * @param [IN]port
   1972          * @param 0 STA / AP Client
   1973          * @param 1 AP
   1974          * @param [IN]bssid BSSID
   1975          *
   1976          * @return  >=0 means success, <0 means fail
   1977          */
   1978          
   1979          static uint8_t wifi_profile_get_bssid_ex(uint8_t len, char *param[])
   1980          {
   1981              uint8_t status = 0;
   1982              uint8_t port = atoi(param[0]);
   1983              uint8_t bssid[6];
   1984          
   1985              status = wifi_profile_set_bssid(port, bssid);
   1986          
   1987              printf("fetch bssid = %02x:%02x:%02x:%02x:%02x:%02x done.\n",
   1988                     bssid[0],
   1989                     bssid[1],
   1990                     bssid[2],
   1991                     bssid[3],
   1992                     bssid[4],
   1993                     bssid[5]);
   1994          
   1995              return status;
   1996          }
   1997          #endif
   1998          
   1999          /**
   2000          * @brief Get WiFi Wireless Mode from the profile in NVRAM.
   2001          * wifi profile get wirelessmode <port>
   2002          * @param [IN]port
   2003          * @param 0 STA / AP Client
   2004          * @param 1 AP
   2005          * @param [OUT]mode
   2006          * @param 1 legacy 11B only
   2007          * @param 2 legacy 11A only
   2008          * @param 3 legacy 11A/B/G mixed
   2009          * @param 4 legacy 11G only
   2010          * @param 5 11ABGN mixed
   2011          * @param 6 11N only in 2.4G
   2012          * @param 7 11GN mixed
   2013          * @param 8 11AN mixed
   2014          * @param 9 11BGN mixed
   2015          * @param 10 11AGN mixed
   2016          */
   2017          
   2018          static uint8_t wifi_profile_get_wireless_mode_ex(uint8_t len, char *param[])
   2019          {
   2020              uint8_t status = 0;
   2021              int32_t port = port_sanity_check(param[0]);
   2022              uint8_t mode;
   2023          
   2024              if (port < 0) {
   2025                  return 1;
   2026              }
   2027          
   2028              status = wifi_profile_get_wireless_mode((uint8_t)port, (wifi_phy_mode_t *)&mode);
   2029          
   2030              printf("fetch wireless mode =%d done.\n", mode);
   2031          
   2032              return status;
   2033          }
   2034          
   2035          
   2036          static uint8_t wifi_profile_get_country_region_ex(uint8_t len, char *param[])
   2037          {
   2038              uint8_t status = 0;
   2039              uint8_t band = atoi(param[0]);
   2040              uint8_t region;
   2041          
   2042              status = wifi_profile_get_country_region(band, &region);
   2043          
   2044              printf("fetch band(%d) region =%d done.\n", band, region);
   2045          
   2046              return status;
   2047          }
   2048          
   2049          static uint8_t wifi_profile_get_dtim_interval_ex(uint8_t len, char *param[])
   2050          {
   2051              uint8_t status = 0;
   2052              uint8_t dtim;
   2053          
   2054              status = wifi_profile_get_dtim_interval(&dtim);
   2055          
   2056              printf("fetch dtim = %d done.\n", dtim);
   2057          
   2058              return status;
   2059          }
   2060          static uint8_t wifi_profile_get_listen_interval_ex(uint8_t len, char *param[])
   2061          {
   2062              uint8_t status = 0;
   2063              uint8_t interval;
   2064          
   2065              status = wifi_profile_get_listen_interval(&interval);
   2066          
   2067              printf("fetch listen interval = %d done.\n", interval);
   2068          
   2069              return status;
   2070          }
   2071          static uint8_t wifi_profile_get_mac_address_ex(uint8_t len, char *param[])
   2072          {
   2073              uint8_t status = 0;
   2074              int32_t port = port_sanity_check(param[0]);
   2075              uint8_t mac[6] = {0};
   2076          
   2077              if (port < 0) {
   2078                  return 1;
   2079              }
   2080          
   2081              status = wifi_profile_get_mac_address((uint8_t)port, mac);
   2082          
   2083              printf("fetch mac address = %02x:%02x:%02x:%02x:%02x:%02x done.\n",
   2084                     mac[0],
   2085                     mac[1],
   2086                     mac[2],
   2087                     mac[3],
   2088                     mac[4],
   2089                     mac[5]);
   2090              return status;
   2091          
   2092          }
   2093          static uint8_t wifi_profile_get_security_mode_ex(uint8_t length, char *param[])
   2094          {
   2095              uint8_t status = 0;
   2096              int32_t port = port_sanity_check(param[0]);
   2097              uint8_t auth;
   2098              uint8_t encryp;
   2099          
   2100              if (port < 0) {
   2101                  return 1;
   2102              }
   2103          
   2104              status = wifi_profile_get_security_mode((uint8_t)port, (wifi_auth_mode_t *)&auth, (wifi_encrypt_type_t *)&encryp);
   2105          
   2106              printf("fetch auth mode=%d, encrypt type=%d done.\n", auth, encryp);
   2107          
   2108              return status;
   2109          }
   2110          
   2111          static uint8_t wifi_profile_get_psk_ex(uint8_t length, char *param[])
   2112          {
   2113              uint8_t status = 0;
   2114              int32_t port = port_sanity_check(param[0]);
   2115              uint8_t password[65] = {0};
   2116              uint8_t len;
   2117          
   2118              if (port < 0) {
   2119                  return 1;
   2120              }
   2121          
   2122              os_memset(password, 0, sizeof(password));
   2123              status = wifi_profile_get_wpa_psk_key((uint8_t)port, password, &len);
   2124          
   2125              printf("fetch password =%s len=%d done.\n", password, len);
   2126          
   2127              return status;
   2128          }
   2129          
   2130          /**
   2131          * @brief Get WiFi WEP Keys from the profile in NVRAM.
   2132          * wifi profile get wep <port>
   2133          * @param [IN]port
   2134          * @param 0 STA / AP Client
   2135          * @param 1 AP
   2136          * @param [OUT]wifi_wep_key_t
   2137          *
   2138          * @return >=0 means success, <0 means fail
   2139          */
   2140          
   2141          static uint8_t wifi_profile_get_wep_key_ex(uint8_t len, char *param[])
   2142          {
   2143              uint8_t status = 0;
   2144              int32_t port = port_sanity_check(param[0]);
   2145              wifi_wep_key_t wep_key;
   2146              int index, i;
   2147          
   2148              if (port < 0) {
   2149                  return 1;
   2150              }
   2151          
   2152              os_memset(&wep_key, 0, sizeof(wep_key));
   2153              status = wifi_profile_get_wep_key((uint8_t)port, &wep_key);
   2154          
   2155              wep_key.wep_key[0][wep_key.wep_key_length[0]] = '\0';
   2156              wep_key.wep_key[1][wep_key.wep_key_length[1]] = '\0';
   2157              wep_key.wep_key[2][wep_key.wep_key_length[2]] = '\0';
   2158              wep_key.wep_key[3][wep_key.wep_key_length[3]] = '\0';
   2159          
   2160              printf("fetch wep key id =%d, len = (%d, %d, %d, %d) done.\n",
   2161                     wep_key.wep_tx_key_index,
   2162                     wep_key.wep_key_length[0],
   2163                     wep_key.wep_key_length[1],
   2164                     wep_key.wep_key_length[2],
   2165                     wep_key.wep_key_length[3]);
   2166              for (index = 0; index < WIFI_NUMBER_WEP_KEYS; index++) {
   2167                  printf("[%d]: ", index);
   2168                  for (i = 0; i < wep_key.wep_key_length[index]; i++) {
   2169                      printf("%02x", wep_key.wep_key[index][i]);
   2170                  }
   2171                  printf("\n");
   2172              }
   2173              return status;
   2174          }
   2175          
   2176          /**
   2177          * @brief Save N9 Debug Level into NVRAM
   2178          * wifi profile set n9dbg <dbg_level>
   2179          * @param [IN]dbg_level
   2180          *   0: None
   2181          *   1: ERROR
   2182          *   2. WARNING
   2183          *   3. TRACE
   2184          *   4. INFO
   2185          *   5. LAUD
   2186          *
   2187          * @return  >=0 means success, <0 means fail
   2188          */
   2189          static uint8_t wifi_profile_set_n9_dbg_level(uint8_t len, char *param[])
   2190          {
   2191              uint8_t status = 0;
   2192              uint8_t dbg_level = atoi(param[0]);
   2193          
   2194              char buf[WIFI_PROFILE_BUFFER_LENGTH] = {0};
   2195          
   2196              sprintf(buf, "%d", dbg_level);
   2197              if (nvdm_write_data_item(WIFI_PROFILE_BUFFER_COMMON, "DbgLevel",NVDM_DATA_ITEM_TYPE_STRING, (const uint8_t *)buf, os_strlen(buf)) != NVDM_STATUS_OK) {
   2198                  printf("write NVDM DbgLevel fail\n");
   2199                  status = 1;
   2200              }
   2201          
   2202          
   2203              printf("wifi_profile_set_n9_dbg_level, level = %d, status:%d\n", dbg_level, status);
   2204          
   2205              return status;
   2206          }
   2207          
   2208          
   2209          /**
   2210          * @brief Get N9 Debug Level from NVRAM
   2211          * wifi profile get n9dbg
   2212          * @param [OUT]dbg_level
   2213          *   0: None
   2214          *   1: ERROR
   2215          *   2. WARNING
   2216          *   3. TRACE
   2217          *   4. INFO
   2218          *   5. LAUD
   2219          *
   2220          * @return  >=0 means success, <0 means fail
   2221          */
   2222          static uint8_t wifi_profile_get_n9_dbg_level(uint8_t len, char *param[])
   2223          {
   2224              uint8_t status = 0;
   2225              uint8_t dbg_level = 0;
   2226          
   2227              // init wifi profile
   2228              char buff[WIFI_PROFILE_BUFFER_LENGTH] = {0};
   2229              int buff_sz = sizeof(buff);
   2230              // common
   2231              nvdm_read_data_item("common", "DbgLevel", (uint8_t *)buff, (uint32_t *)&buff_sz);
   2232              dbg_level = atoi(buff);
   2233          
   2234              printf("wifi_profile_get_n9_dbg_level, level = %d, status:%d\n", dbg_level, status);
   2235          
   2236              return status;
   2237          }
   2238          
   2239          void user_data_item_reset_to_default(char *group_name);
   2240          uint8_t wifi_profile_reset_ex(uint8_t len, char *param[])
   2241          {
   2242              user_data_item_reset_to_default(NULL);
   2243              return 0;
   2244          }
   2245          
   2246          cmd_t   wifi_profile_set_cli[] = {
   2247              { "opmode",         "STA/AP/Dual",      wifi_profile_set_opmode_ex},
   2248              { "ch",             "channel",          wifi_profile_set_channel_ex},
   2249              { "bw",             "bandwidth",        wifi_profile_set_bandwidth_ex},
   2250              { "ssid",           "SSID",             wifi_profile_set_ssid_ex      },
   2251          //  { "bssid",          "BSSID",            wifi_profile_set_bssid_ex     },
   2252              { "wirelessmode",   "wireless mode",    wifi_profile_set_wireless_mode_ex},
   2253              { "country",        "country region",   wifi_profile_set_country_region_ex},
   2254              { "dtim",           "DTIM interval",    wifi_profile_set_dtim_interval_ex},
   2255              { "listen",         "listen interval",  wifi_profile_set_listen_interval_ex},
   2256              { "mac",            "MAC address",      wifi_profile_set_mac_address_ex},
   2257              { "sec",        "WPA/WPA2PSK Authmode, Encrypt Type",   wifi_profile_set_security_mode_ex   },
   2258              { "psk",         "WPA/WPA2PSK Key",  wifi_profile_set_psk_ex   },
   2259              { "pmk",            "PMK for WPA/WPA2PSK",  wifi_profile_set_pmk_ex   },
   2260              { "wep",            "WEP key",          wifi_profile_set_wep_key_ex },
   2261              { "n9dbg",          "set N9 debug level",   wifi_profile_set_n9_dbg_level},
   2262              { NULL }
   2263          };
   2264          
   2265          cmd_t   wifi_profile_get_cli[] = {
   2266              { "opmode",         "STA/AP/Dual",      wifi_profile_get_opmode_ex},
   2267              { "ch",             "channel",          wifi_profile_get_channel_ex},
   2268              { "bw",             "bandwidth",        wifi_profile_get_bandwidth_ex},
   2269              { "ssid",           "SSID",             wifi_profile_get_ssid_ex      },
   2270          //  { "bssid",          "BSSID",            wifi_profile_get_bssid_ex     },
   2271              { "wirelessmode",   "wireless mode",    wifi_profile_get_wireless_mode_ex},
   2272              { "country",        "country region",   wifi_profile_get_country_region_ex},
   2273              { "dtim",           "DTIM interval",    wifi_profile_get_dtim_interval_ex},
   2274              { "listen",         "listen interval",  wifi_profile_get_listen_interval_ex},
   2275              { "mac",            "MAC address",      wifi_profile_get_mac_address_ex},
   2276              { "sec",        "WPA/WPA2PSK Authmode, Encrypt Type",   wifi_profile_get_security_mode_ex   },
   2277              { "psk",         "WPA/WPA2PSK Key",  wifi_profile_get_psk_ex  },
   2278              { "pmk",            "PMK for WPA/WPA2PSK",  wifi_profile_get_pmk_ex   },
   2279              { "wep",            "WEP key",          wifi_profile_get_wep_key_ex },
   2280              { "profile",            "get profile txt",      wifi_profile_get_profile_ex},
   2281              { "n9dbg",          "get N9 debug level",   wifi_profile_get_n9_dbg_level},
   2282              { NULL }
   2283          };
   2284          
   2285          #endif //MTK_WIFI_PROFILE_ENABLE
   2286          
   2287          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   wifi_is_auth_mode_valid
       0   wifi_is_band_valid
       0   wifi_is_bandwidth_valid
       0   wifi_is_encrypt_type_valid
       0   wifi_is_opmode_valid
       0   wifi_is_port_valid
       0   wifi_is_ps_mode_valid
       0   wifi_profile_commit_setting
     152   wifi_profile_get_bandwidth
       152   -- Indirect call
       152   -> __aeabi_memclr4
       152   -> atoi
       152   -> nvdm_read_data_item
      16   wifi_profile_get_bandwidth_ex
        16   -> port_sanity_check
        16   -> printf
        16   -> wifi_profile_get_bandwidth
     152   wifi_profile_get_channel
       152   -- Indirect call
       152   -> __aeabi_memclr4
       152   -> atoi
       152   -> nvdm_read_data_item
      16   wifi_profile_get_channel_ex
        16   -> port_sanity_check
        16   -> printf
        16   -> wifi_profile_get_channel
     144   wifi_profile_get_configfree
       144   -- Indirect call
       144   -> __aeabi_memclr4
       144   -> atoi
       144   -> nvdm_read_data_item
     152   wifi_profile_get_country_region
       152   -- Indirect call
       152   -> __aeabi_memclr4
       152   -> atoi
       152   -> nvdm_read_data_item
       152   -> wifi_5g_support
       152   -> wifi_is_band_valid
      16   wifi_profile_get_country_region_ex
        16   -> atoi
        16   -> printf
        16   -> wifi_profile_get_country_region
     144   wifi_profile_get_dtim_interval
       144   -- Indirect call
       144   -> __aeabi_memclr4
       144   -> atoi
       144   -> nvdm_read_data_item
      16   wifi_profile_get_dtim_interval_ex
        16   -> printf
        16   -> wifi_profile_get_dtim_interval
     144   wifi_profile_get_listen_interval
       144   -- Indirect call
       144   -> __aeabi_memclr4
       144   -> atoi
       144   -> nvdm_read_data_item
      16   wifi_profile_get_listen_interval_ex
        16   -> printf
        16   -> wifi_profile_get_listen_interval
     152   wifi_profile_get_mac_address
       152   -- Indirect call
       152   -> __aeabi_memclr4
       152   -> nvdm_read_data_item
       152   -> wifi_conf_get_mac_from_str
       152   -> wifi_is_port_valid
       152   -> wifi_profile_get_opmode
      32   wifi_profile_get_mac_address_ex
        32   -> port_sanity_check
        32   -> printf
        32   -> wifi_profile_get_mac_address
     136   wifi_profile_get_n9_dbg_level
       136   -> __aeabi_memclr4
       136   -> atoi
       136   -> nvdm_read_data_item
       136   -> printf
     144   wifi_profile_get_opmode
       144   -- Indirect call
       144   -> __aeabi_memclr4
       144   -> atoi
       144   -> nvdm_read_data_item
      16   wifi_profile_get_opmode_ex
        16   -> printf
        16   -> wifi_profile_get_opmode
     152   wifi_profile_get_pmk
       152   -- Indirect call
       152   -> __aeabi_memclr4
       152   -> nvdm_read_data_item
       152   -> os_memcpy
       152   -> os_memset
       152   -> os_strlen
       152   -> strtol
       152   -> wifi_is_port_valid
      48   wifi_profile_get_pmk_ex
        48   -> __aeabi_memclr4
        48   -> os_memset
        48   -> port_sanity_check
        48   -> printf
        48   -> wifi_profile_get_pmk
     144   wifi_profile_get_power_save_mode
       144   -- Indirect call
       144   -> __aeabi_memclr4
       144   -> atoi
       144   -> nvdm_read_data_item
       0   wifi_profile_get_profile
     544   wifi_profile_get_profile_ex
       544   -> __aeabi_memclr4
       544   -> hex_dump
       544   -> printf
       544   -> wifi_config_init
      80   wifi_profile_get_psk_ex
        80   -> __aeabi_memclr4
        80   -> os_memset
        80   -> port_sanity_check
        80   -> printf
        80   -> wifi_profile_get_wpa_psk_key
     288   wifi_profile_get_security_mode
       288   -- Indirect call
       288   -> __aeabi_memclr4
       288   -> atoi
       288   -> nvdm_read_data_item
       288   -> wifi_is_port_valid
      16   wifi_profile_get_security_mode_ex
        16   -> port_sanity_check
        16   -> printf
        16   -> wifi_profile_get_security_mode
     160   wifi_profile_get_ssid
       160   -- Indirect call
       160   -> atoi
       160   -> nvdm_read_data_item
       160   -> os_memset
       160   -> strcpy
       160   -> wifi_is_port_valid
      48   wifi_profile_get_ssid_ex
        48   -> __aeabi_memclr4
        48   -> os_memset
        48   -> port_sanity_check
        48   -> printf
        48   -> wifi_profile_get_ssid
     416   wifi_profile_get_wep_key
       416   -- Indirect call
       416   -> AtoH
       416   -> __aeabi_memclr4
       416   -> atoi
       416   -> nvdm_read_data_item
       416   -> os_memcpy
       416   -> rstrtok
       416   -> wifi_is_port_valid
     144   wifi_profile_get_wep_key_ex
       144   -> os_memset
       144   -> port_sanity_check
       144   -> printf
       144   -> wifi_profile_get_wep_key
     152   wifi_profile_get_wireless_mode
       152   -- Indirect call
       152   -> __aeabi_memclr4
       152   -> atoi
       152   -> nvdm_read_data_item
       152   -> wifi_is_port_valid
      16   wifi_profile_get_wireless_mode_ex
        16   -> port_sanity_check
        16   -> printf
        16   -> wifi_profile_get_wireless_mode
     288   wifi_profile_get_wpa_psk_key
       288   -- Indirect call
       288   -> __aeabi_memclr4
       288   -> atoi
       288   -> nvdm_read_data_item
       288   -> os_memcpy
       288   -> strlen
       288   -> wifi_is_port_valid
       8   wifi_profile_reset_ex
         8   -> user_data_item_reset_to_default
     152   wifi_profile_set_bandwidth
       152   -- Indirect call
       152   -> __aeabi_memclr4
       152   -> nvdm_write_data_item
       152   -> os_strlen
       152   -> sprintf
       152   -> wifi_is_bandwidth_valid
      16   wifi_profile_set_bandwidth_ex
        16   -> atoi
        16   -> port_sanity_check
        16   -> printf
        16   -> wifi_profile_commit_setting
        16   -> wifi_profile_set_bandwidth
     152   wifi_profile_set_channel
       152   -- Indirect call
       152   -> __aeabi_memclr4
       152   -> nvdm_write_data_item
       152   -> os_strlen
       152   -> sprintf
      16   wifi_profile_set_channel_ex
        16   -> atoi
        16   -> port_sanity_check
        16   -> printf
        16   -> wifi_profile_commit_setting
        16   -> wifi_profile_set_channel
     160   wifi_profile_set_configfree
       160   -- Indirect call
       160   -> __aeabi_memclr4
       160   -> nvdm_write_data_item
       160   -> os_memset
       160   -> os_strlen
       160   -> sprintf
     152   wifi_profile_set_country_region
       152   -- Indirect call
       152   -> __aeabi_memclr4
       152   -> nvdm_write_data_item
       152   -> os_strlen
       152   -> sprintf
       152   -> wifi_5g_support
       152   -> wifi_get_channel_list
       152   -> wifi_is_band_valid
      16   wifi_profile_set_country_region_ex
        16   -> atoi
        16   -> printf
        16   -> wifi_profile_commit_setting
        16   -> wifi_profile_set_country_region
     144   wifi_profile_set_dtim_interval
       144   -- Indirect call
       144   -> __aeabi_memclr4
       144   -> nvdm_write_data_item
       144   -> os_strlen
       144   -> sprintf
      16   wifi_profile_set_dtim_interval_ex
        16   -> atoi
        16   -> printf
        16   -> wifi_profile_commit_setting
        16   -> wifi_profile_set_dtim_interval
     144   wifi_profile_set_listen_interval
       144   -- Indirect call
       144   -> __aeabi_memclr4
       144   -> nvdm_write_data_item
       144   -> os_strlen
       144   -> sprintf
      16   wifi_profile_set_listen_interval_ex
        16   -> atoi
        16   -> printf
        16   -> wifi_profile_commit_setting
        16   -> wifi_profile_set_listen_interval
     160   wifi_profile_set_mac_address
       160   -- Indirect call
       160   -> __aeabi_memclr4
       160   -> nvdm_write_data_item
       160   -> os_strlen
       160   -> sprintf
       160   -> wifi_is_port_valid
      48   wifi_profile_set_mac_address_ex
        48   -> __aeabi_memcpy
        48   -> port_sanity_check
        48   -> printf
        48   -> strcpy
        48   -> wifi_conf_get_mac_from_str
        48   -> wifi_profile_commit_setting
        48   -> wifi_profile_get_opmode
        48   -> wifi_profile_set_mac_address
     144   wifi_profile_set_n9_dbg_level
       144   -> __aeabi_memclr4
       144   -> atoi
       144   -> nvdm_write_data_item
       144   -> os_strlen
       144   -> printf
       144   -> sprintf
     144   wifi_profile_set_opmode
       144   -- Indirect call
       144   -> __aeabi_memclr4
       144   -> nvdm_write_data_item
       144   -> os_strlen
       144   -> sprintf
       144   -> wifi_is_opmode_valid
      16   wifi_profile_set_opmode_ex
        16   -> atoi
        16   -> printf
        16   -> wifi_profile_commit_setting
        16   -> wifi_profile_set_opmode
     160   wifi_profile_set_pmk
       160   -- Indirect call
       160   -> __aeabi_memclr4
       160   -> nvdm_write_data_item
       160   -> os_strlen
       160   -> sprintf
       160   -> wifi_is_port_valid
      48   wifi_profile_set_pmk_ex
        48   -> __aeabi_memclr4
        48   -> convert_string_to_hex_array
        48   -> os_memset
        48   -> port_sanity_check
        48   -> printf
        48   -> wifi_profile_commit_setting
        48   -> wifi_profile_set_pmk
     144   wifi_profile_set_power_save_mode
       144   -- Indirect call
       144   -> __aeabi_memclr4
       144   -> nvdm_write_data_item
       144   -> os_strlen
       144   -> sprintf
       144   -> wifi_is_ps_mode_valid
      16   wifi_profile_set_psk_ex
        16   -> port_sanity_check
        16   -> printf
        16   -> strlen
        16   -> wifi_profile_commit_setting
        16   -> wifi_profile_set_wpa_psk_key
     288   wifi_profile_set_security_mode
       288   -- Indirect call
       288   -> __aeabi_memclr4
       288   -> nvdm_write_data_item
       288   -> os_strlen
       288   -> sprintf
       288   -> wifi_is_auth_mode_valid
       288   -> wifi_is_encrypt_type_valid
       288   -> wifi_is_port_valid
      24   wifi_profile_set_security_mode_ex
        24   -> atoi
        24   -> port_sanity_check
        24   -> printf
        24   -> wifi_profile_commit_setting
        24   -> wifi_profile_set_security_mode
     520   wifi_profile_set_ssid
       520   -- Indirect call
       520   -> __aeabi_memclr4
       520   -> nvdm_write_data_item
       520   -> os_memcpy
       520   -> os_strlen
       520   -> printf
       520   -> sprintf
       520   -> wifi_is_port_valid
       520   -> wifi_profile_get_wpa_psk_key
      16   wifi_profile_set_ssid_ex
        16   -> port_sanity_check
        16   -> printf
        16   -> strlen
        16   -> wifi_profile_commit_setting
        16   -> wifi_profile_set_ssid
     472   wifi_profile_set_wep_key
       472   -- Indirect call
       472   -> __aeabi_memclr4
       472   -> nvdm_write_data_item
       472   -> os_memcpy
       472   -> os_memset
       472   -> os_strlen
       472   -> sprintf
       472   -> strcpy
       472   -> strlen
       472   -> wifi_is_port_valid
     176   wifi_profile_set_wep_key_ex
       176   -> atoi
       176   -> os_memcpy
       176   -> os_memset
       176   -> port_sanity_check
       176   -> printf
       176   -> rstrtok
       176   -> strlen
       176   -> wifi_profile_commit_setting
       176   -> wifi_profile_set_wep_key
     152   wifi_profile_set_wireless_mode
       152   -- Indirect call
       152   -> __aeabi_memclr4
       152   -> nvdm_write_data_item
       152   -> os_strlen
       152   -> sprintf
       152   -> wifi_5g_support
       152   -> wifi_is_port_valid
      16   wifi_profile_set_wireless_mode_ex
        16   -> atoi
        16   -> port_sanity_check
        16   -> printf
        16   -> wifi_profile_commit_setting
        16   -> wifi_profile_set_wireless_mode
     576   wifi_profile_set_wpa_psk_key
       576   -- Indirect call
       576   -> __aeabi_memclr4
       576   -> nvdm_write_data_item
       576   -> os_memcpy
       576   -> os_strlen
       576   -> sprintf
       576   -> wifi_is_port_valid
       576   -> wifi_profile_get_ssid


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable263
       4  ??DataTable264
       4  ??DataTable264_1
       4  ??DataTable266
       4  ??DataTable266_1
       4  ??DataTable267
       4  ??DataTable268
       4  ??DataTable268_1
       4  ??DataTable269
       4  ??DataTable270
       4  ??DataTable270_1
       4  ??DataTable271
       4  ??DataTable271_1
       4  ??DataTable271_2
       4  ??DataTable271_3
       4  ??DataTable271_4
       4  ??DataTable272
       4  ??DataTable272_1
       4  ??DataTable273
       4  ??DataTable273_1
       4  ??DataTable274
       4  ??DataTable274_1
       4  ??DataTable274_2
       4  ??DataTable274_3
       4  ??DataTable275
       4  ??DataTable275_1
       4  ??DataTable276
       4  ??DataTable276_1
       4  ??DataTable276_2
       4  ??DataTable277
       4  ??DataTable277_1
       4  ??DataTable277_2
       4  ??DataTable277_3
       4  ??DataTable278
       4  ??DataTable278_1
       4  ??DataTable279
       4  ??DataTable279_1
       4  ??DataTable282
       4  ??DataTable283
       4  ??DataTable286
       4  ??DataTable287
       4  ??DataTable287_1
       4  ??DataTable288
       4  ??DataTable297
       4  ??DataTable297_1
       4  ??DataTable299
       4  ??DataTable300
       4  ??DataTable300_1
       4  ??DataTable300_2
       4  ??DataTable301
       4  ??DataTable303
       4  ??DataTable303_1
       4  ??DataTable303_2
       4  ??DataTable303_3
       4  ??DataTable305
       4  ??DataTable305_1
       8  ?_0
      12  ?_1
       8  ?_10
     128  ?_100
      20  ?_101
       4  ?_102
      76  ?_103
      12  ?_104
      16  ?_105
      16  ?_106
     128  ?_107
       2  ?_108
     128  ?_109
      16  ?_11
     128  ?_110
      20  ?_111
      16  ?_112
     128  ?_113
      16  ?_114
      20  ?_115
     128  ?_116
      16  ?_117
      16  ?_118
     128  ?_119
       8  ?_12
      20  ?_120
      12  ?_121
     128  ?_122
      24  ?_123
     128  ?_124
      16  ?_125
     128  ?_126
     128  ?_127
      24  ?_128
       8  ?_129
      16  ?_13
     128  ?_130
      32  ?_131
     128  ?_132
      24  ?_133
      20  ?_134
     128  ?_135
      28  ?_136
      36  ?_137
      24  ?_138
      24  ?_139
       8  ?_14
      24  ?_140
      24  ?_141
      24  ?_142
      28  ?_143
      36  ?_144
      40  ?_145
      32  ?_146
      32  ?_147
       8  ?_148
      64  ?_149
      16  ?_15
      48  ?_150
      52  ?_151
      40  ?_152
      32  ?_153
      32  ?_154
      44  ?_155
     492  ?_156
      12  ?_157
      16  ?_158
      24  ?_159
       4  ?_16
      28  ?_160
      20  ?_161
      16  ?_162
      20  ?_163
      24  ?_164
      16  ?_165
      28  ?_166
       8  ?_167
      24  ?_168
      24  ?_169
      12  ?_17
      44  ?_170
      16  ?_171
      12  ?_172
      16  ?_173
      16  ?_174
      12  ?_175
      20  ?_176
      20  ?_177
      16  ?_178
      16  ?_179
       4  ?_18
      20  ?_180
      16  ?_181
      20  ?_182
      20  ?_183
      20  ?_184
      24  ?_185
      16  ?_186
      20  ?_187
      20  ?_188
      20  ?_189
      36  ?_19
      20  ?_190
      20  ?_191
      16  ?_192
      24  ?_193
       8  ?_194
      20  ?_195
      16  ?_196
      28  ?_197
      32  ?_198
      60  ?_199
       4  ?_2
       4  ?_20
       4  ?_200
       8  ?_201
      16  ?_202
      28  ?_203
      76  ?_204
      24  ?_205
      20  ?_206
      20  ?_207
      32  ?_208
      32  ?_209
      16  ?_21
      32  ?_210
      36  ?_211
      24  ?_212
      36  ?_213
       8  ?_214
      60  ?_215
      44  ?_216
      68  ?_217
      36  ?_218
      52  ?_219
       4  ?_22
       8  ?_220
       2  ?_221
     128  ?_222
      12  ?_223
      28  ?_224
      56  ?_225
     128  ?_226
      56  ?_227
      20  ?_23
       4  ?_24
       8  ?_25
       8  ?_26
      20  ?_27
       8  ?_28
      16  ?_29
       8  ?_3
      20  ?_30
     128  ?_31
      20  ?_32
       4  ?_33
       8  ?_34
       8  ?_35
     128  ?_36
      16  ?_37
     128  ?_38
       4  ?_39
       4  ?_4
       8  ?_40
       4  ?_41
      20  ?_42
     128  ?_43
     128  ?_44
      28  ?_45
       4  ?_46
     128  ?_47
      20  ?_48
     128  ?_49
      12  ?_5
      16  ?_50
       8  ?_51
      24  ?_52
     128  ?_53
      32  ?_54
      24  ?_55
      16  ?_56
     128  ?_57
     128  ?_58
      44  ?_59
       8  ?_6
     128  ?_60
      64  ?_61
      32  ?_62
      12  ?_63
       8  ?_64
       8  ?_65
      24  ?_66
     128  ?_67
      28  ?_68
      16  ?_69
       8  ?_7
     128  ?_70
     128  ?_71
     128  ?_72
      28  ?_73
      28  ?_74
      12  ?_75
      12  ?_76
     128  ?_77
     128  ?_78
      20  ?_79
      16  ?_8
     128  ?_80
     128  ?_81
      20  ?_82
      52  ?_83
     128  ?_84
     128  ?_85
      28  ?_86
      12  ?_87
       8  ?_88
     128  ?_89
      16  ?_9
     128  ?_90
      36  ?_91
     128  ?_92
      12  ?_93
       8  ?_94
       4  ?_95
     128  ?_96
      28  ?_97
     128  ?_98
     128  ?_99
      12  wifi_is_auth_mode_valid
      12  wifi_is_band_valid
      12  wifi_is_bandwidth_valid
      12  wifi_is_encrypt_type_valid
      12  wifi_is_opmode_valid
      12  wifi_is_port_valid
      12  wifi_is_ps_mode_valid
       4  wifi_profile_commit_setting
     146  wifi_profile_get_bandwidth
      46  wifi_profile_get_bandwidth_ex
     120  wifi_profile_get_channel
      46  wifi_profile_get_channel_ex
     256  wifi_profile_get_cli
      92  wifi_profile_get_configfree
     194  wifi_profile_get_country_region
      42  wifi_profile_get_country_region_ex
      90  wifi_profile_get_dtim_interval
      30  wifi_profile_get_dtim_interval_ex
      90  wifi_profile_get_listen_interval
      30  wifi_profile_get_listen_interval_ex
     174  wifi_profile_get_mac_address
      82  wifi_profile_get_mac_address_ex
      58  wifi_profile_get_n9_dbg_level
      90  wifi_profile_get_opmode
      30  wifi_profile_get_opmode_ex
     254  wifi_profile_get_pmk
     114  wifi_profile_get_pmk_ex
      90  wifi_profile_get_power_save_mode
       4  wifi_profile_get_profile
     820  wifi_profile_get_profile_ex
      74  wifi_profile_get_psk_ex
     214  wifi_profile_get_security_mode
      54  wifi_profile_get_security_mode_ex
     314  wifi_profile_get_ssid
      74  wifi_profile_get_ssid_ex
     372  wifi_profile_get_wep_key
     166  wifi_profile_get_wep_key_ex
     142  wifi_profile_get_wireless_mode
      46  wifi_profile_get_wireless_mode_ex
     300  wifi_profile_get_wpa_psk_key
      12  wifi_profile_reset_ex
     166  wifi_profile_set_bandwidth
      76  wifi_profile_set_bandwidth_ex
     130  wifi_profile_set_channel
      94  wifi_profile_set_channel_ex
     240  wifi_profile_set_cli
     222  wifi_profile_set_configfree
     262  wifi_profile_set_country_region
      62  wifi_profile_set_country_region_ex
     100  wifi_profile_set_dtim_interval
      42  wifi_profile_set_dtim_interval_ex
     100  wifi_profile_set_listen_interval
      42  wifi_profile_set_listen_interval_ex
     186  wifi_profile_set_mac_address
     148  wifi_profile_set_mac_address_ex
      90  wifi_profile_set_n9_dbg_level
     104  wifi_profile_set_opmode
      44  wifi_profile_set_opmode_ex
     186  wifi_profile_set_pmk
     112  wifi_profile_set_pmk_ex
     104  wifi_profile_set_power_save_mode
     108  wifi_profile_set_psk_ex
     294  wifi_profile_set_security_mode
      92  wifi_profile_set_security_mode_ex
     444  wifi_profile_set_ssid
      74  wifi_profile_set_ssid_ex
     506  wifi_profile_set_wep_key
     284  wifi_profile_set_wep_key_ex
     184  wifi_profile_set_wireless_mode
      76  wifi_profile_set_wireless_mode_ex
     508  wifi_profile_set_wpa_psk_key
     896  -- Other

 
    496 bytes in section .data
  6 624 bytes in section .rodata
 13 798 bytes in section .text
 
 13 798 bytes of CODE  memory
  6 624 bytes of CONST memory
    496 bytes of DATA  memory

Errors: none
Warnings: none
