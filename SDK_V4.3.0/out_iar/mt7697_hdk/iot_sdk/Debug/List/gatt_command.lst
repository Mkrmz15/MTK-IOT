###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:22
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\src\ut_app\gatt_command.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW681C.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\src\ut_app\gatt_command.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\gatt_command.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\gatt_command.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\src\ut_app\gatt_command.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          #include "ut_app.h"
     36          #include "bt_uuid.h"
     37          #include "bt_lwip.h"
     38          #include <string.h>
     39          #include "FreeRTOS.h"
     40          #include "queue.h"
     41          #include "task.h"
     42          #include "syslog.h"
     43          
     44          bt_status_t bt_app_gattc_io_callback(void *input, void *output);
     45          bt_status_t bt_app_gatts_io_callback(void *input, void *output);
     46          const bt_gatts_service_t** bqb_get_gatt_server(void);
     47          bt_status_t bt_gatt_service_execute_write(uint16_t handle, uint8_t flag);
     48          
     49          // Weak symbol declaration
     50          #if _MSC_VER >= 1500
     51              #pragma comment(linker, "/alternatename:_bqb_get_gatt_server=_default_bqb_get_gatt_server")
     52              #pragma comment(linker, "/alternatename:_bt_app_gattc_io_callback=_default_bt_app_gattc_io_callback")
     53              #pragma comment(linker, "/alternatename:_bt_app_gatts_io_callback=_default_bt_app_gatts_io_callback")
     54              #pragma comment(linker, "/alternatename:_bt_gatt_service_execute_write=_default_bt_gatt_service_execute_write")
     55          #elif defined(__GNUC__) || defined(__ICCARM__) || defined(__CC_ARM)
     56              #pragma weak bqb_get_gatt_server = default_bqb_get_gatt_server
     57              #pragma weak bt_app_gattc_io_callback = default_bt_app_gattc_io_callback
     58              #pragma weak bt_app_gatts_io_callback = default_bt_app_gatts_io_callback
     59              #pragma weak bt_gatt_service_execute_write = default_bt_gatt_service_execute_write
     60          #else
     61              #error "Unsupported Platform"
     62          #endif
     63          
     64          const bt_gatts_service_t** default_bqb_get_gatt_server()
     65          {
     66              return NULL;
     67          }
     68          
     69          bt_status_t default_bt_app_gattc_io_callback(void *input, void *output)
     70          {
     71             return BT_STATUS_SUCCESS;
     72          }
     73          
     74          bt_status_t default_bt_app_gatts_io_callback(void *input, void *output)
     75          {
     76             return BT_STATUS_SUCCESS;
     77          }
     78          
     79          bt_status_t default_bt_gatt_service_execute_write(uint16_t handle, uint8_t flag)
     80          {
     81             return BT_STATUS_SUCCESS;
     82          }
     83          
     84          
     85          typedef struct _list_entry
     86          {
     87              struct _list_entry *prev;
     88              struct _list_entry *next;
     89          } list_entry;
     90          
     91          typedef struct _gatt_service
     92          {
     93              uint16_t start_handle;
     94              uint16_t end_handle;
     95              bt_uuid_t uuid;
     96          } gatt_service;
     97          
     98          typedef struct _gatt_include_service
     99          {
    100              uint16_t included_service_handle;
    101              uint16_t end_group_handle;
    102              bt_uuid_t uuid;
    103              uint16_t handle;
    104          } gatt_include_service;
    105          
    106          typedef struct _gatt_char
    107          {
    108              uint16_t handle;
    109              uint8_t  properties;
    110              uint16_t value_handle;
    111              bt_uuid_t charc_uuid;
    112          } gatt_char;
    113          
    114          typedef struct _gatt_desc
    115          {
    116              uint16_t handle;
    117              bt_uuid_t desc_uuid;
    118          } gatt_desc;
    119          
    120          typedef struct _gatt_service_node
    121          {
    122              list_entry node;
    123              gatt_service service;
    124              list_entry include_list;	// gatt_include_service_node is defined for each node
    125              list_entry char_list;	    // gatt_char_node is defined for each node
    126          } gatt_service_node;
    127          
    128          typedef struct _gatt_include_service_node
    129          {
    130              list_entry  node;
    131              gatt_include_service include_service;
    132          } gatt_include_service_node;
    133          
    134          typedef struct _gatt_char_node
    135          {
    136              list_entry node;
    137              gatt_char  characteristic;
    138              list_entry char_desc_list;     // gatt_desc_node is defined for each node
    139          } gatt_char_node;
    140          
    141          typedef struct _gatt_desc_node
    142          {
    143              list_entry node;
    144              gatt_desc  descriptor;
    145          } gatt_desc_node;
    146          
    147          #define TEST_DISCOVER_ALL_PRIMARY_SERVICES      0x0001
    148          #define TEST_DISCOVER_ALL_INCLUDE_SERVICES_STEP 0x0002
    149          #define TEST_DISCOVER_ALL_CHAR_STEP             0x0004
    150          #define TEST_DISCOVER_ALL_DESC_STEP             0x0008
    151          #define TEST_READ_CHAR_DESCRIPTOR               0x0010
    152          #define TEST_WRITE_CHAR_DESCRIPTOR              0x0020
    153          
    154          static uint16_t test_conn_id;
    155          #ifdef BLE_THROUGHPUT
    156          static uint32_t test_index;
    157          static uint32_t test_show_interval;
    158          static uint32_t test_next_show;
    159          #endif
    160          static uint32_t test_start_time;
    161          static uint32_t test_finish_time;
    162          static uint8_t  test_started;
    163          static uint32_t cur_tick;
    164          static uint16_t mtu = 23;
    165          uint16_t conn_interval = 1;
    166          //static uint16_t expected_mtu = 244;    // This is for BLE4.2
    167          static uint8_t test_data[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    168                                      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    169                                      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    170                                      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    171                                      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    172                                      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    173                                      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    174                                      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    175                                      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    176                                      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    177                                      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    178                                      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    179                                      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13 };
    180          
    181          static uint16_t conn_id;
    182          static list_entry g_service_list;
    183          static uint16_t gatt_test_flag = 0;
    184          static uint16_t srv_count = 0;
    185          static uint16_t cur_srv_index = 0;
    186          #define MAX_SERVICE_NO (50)
    187          static gatt_service service_table[MAX_SERVICE_NO];
    188          static gatt_service_node *cur_srv_node = NULL;
    189          static gatt_char_node *cur_char_node = NULL;
    190          
    191          static gatt_service_node *find_service_node_by_handle_range(list_entry *service_list, uint16_t handle)
    192          {
    193              gatt_service_node *service_node;
    194          
    195              service_node = (gatt_service_node *)(service_list->next);
    196              while ((list_entry *)service_node != service_list)
    197              {
    198                  if ((handle >= service_node->service.start_handle) &&
    199                      (handle <= service_node->service.end_handle))
    200                  {
    201                      return service_node;
    202                  }
    203                  /* try the next node in the list */
    204                  service_node = (gatt_service_node *)(service_node->node.next);
    205              }
    206              return NULL;
    207          }
    208          
    209          static gatt_char_node *find_char_node_by_handle_range(gatt_service_node *service_node, uint16_t handle)
    210          {
    211              gatt_char_node *char_node;
    212              gatt_char_node *char_next_node;
    213          
    214              char_node = (gatt_char_node *)(service_node->char_list.next);
    215              while ((list_entry *)char_node != &service_node->char_list)
    216              {
    217                  char_next_node = (gatt_char_node *)(char_node->node.next);
    218          
    219                  if (((list_entry *)char_next_node == &service_node->char_list) &&
    220                      (handle >= char_node->characteristic.handle) &&
    221                      (handle <= service_node->service.end_handle))
    222                  {
    223                      return char_node;
    224                  }
    225          
    226                  if ((handle >= char_node->characteristic.handle) &&
    227                      (handle < char_next_node->characteristic.handle))
    228                  {
    229                      return char_node;
    230                  }
    231                  /* try the next node in the list */
    232                  char_node = char_next_node;
    233              }
    234              return NULL;
    235          }
    236          
    237          static void *gatt_malloc(unsigned int size)
    238          {
    239              return pvPortMalloc(size);
    240          }
    241          
    242          static void gatt_free(void *pv)
    243          {
    244              vPortFree(pv);
    245          }
    246          
    247          void initialize_list_head(list_entry *list)
    248          {
    249              list->prev = list;
    250              list->next = list;
    251          }
    252          
    253          void initialize_list_entry(list_entry *list)
    254          {
    255              list->prev = 0;
    256              list->next = 0;
    257          }
    258          
    259          uint8_t is_list_empty(list_entry *list)
    260          {
    261              return ((list)->next == (list));
    262          }
    263          #define is_node_connected(n) (((n)->next->prev == (n)) && ((n)->prev->next == (n)))
    264          
    265          uint8_t is_list_circular(list_entry *list)
    266          {
    267              list_entry *tmp = list;
    268              if (!is_node_connected(list)) {
    269                  return 0;
    270              }
    271              for (tmp = tmp->next; tmp != list; tmp = tmp->next) {
    272                  if (!is_node_connected(tmp)) {
    273                      return 0;
    274                  }
    275              }
    276              return 1;
    277          }
    278          
    279          uint8_t is_node_on_list(list_entry *head, list_entry *node)
    280          {
    281              list_entry *tmp;
    282              assert(is_list_circular(head));
    283              tmp = head->next;
    284              while (tmp != head) {
    285                  if (tmp == node) {
    286                      return 1;
    287                  }
    288                  tmp = tmp->next;
    289              }
    290              return 0;
    291          }
    292          
    293          void insert_tail_list(list_entry *head, list_entry *entry)
    294          {
    295              assert(is_list_circular(head));
    296              entry->next = head;
    297              entry->prev = head->prev;
    298              head->prev->next = entry;
    299              head->prev = entry;
    300              assert(is_node_connected(entry));
    301              assert(is_list_circular(head));
    302          }
    303          /*  Remove the first entry on the list specified by head. */
    304          list_entry *remove_head(list_entry *head)
    305          {
    306              list_entry *first;
    307              assert(is_list_circular(head));
    308              first = head->next;
    309              first->next->prev = head;
    310              head->next = first->next;
    311              assert(is_list_circular(head));
    312              return (first);
    313          }
    314          
    315          /* Remove the given entry from the list. */
    316          void remove_entry(list_entry *entry)
    317          {
    318              assert(is_list_circular(entry));
    319              entry->prev->next = entry->next;
    320              entry->next->prev = entry->prev;
    321              assert(is_list_circular(entry->prev));
    322              initialize_list_entry(entry);
    323          }
    324          
    325          static void dump_uuid128(bt_uuid_t *uuid128)
    326          {
    327              uint8_t buf[34] = { 0 };
    328              int i, j;
    329              for (j = 15, i = 0; j >= 0; j--, i += 2) {
    330                  snprintf((char *)(buf + i), 3, "%02x", uuid128->uuid[j]);
    331              }
    332              LOG_I(common, "[GATT]uuid = %s", buf);
    333          }
    334          
    335          static uint8_t tmp_uuid_buf[34] = { 0 };
    336          static uint8_t*  get_uuid128(bt_uuid_t *uuid128)
    337          {
    338              int i, j;
    339              memset(tmp_uuid_buf, 0, 34);
    340              for (j = 15, i = 0; j >= 0; j--, i += 2) {
    341                  snprintf((char *)(tmp_uuid_buf + i), 3, "%02x", uuid128->uuid[j]);
    342              }
    343              return tmp_uuid_buf;
    344          }
    345          
    346          static void print_include_service(gatt_include_service *inc_srv)
    347          {
    348              if (!inc_srv) return;
    349              LOG_I(common, "  [GATT]Include Service Handle = 0x%04x", inc_srv->handle);
    350              if (bt_uuid_is_uuid16(&inc_srv->uuid)) {
    351                  LOG_I(common, "    [GATT]Start Handle = 0x%04x End Handle = 0x%04x uuid = %04x", inc_srv->included_service_handle, inc_srv->end_group_handle, inc_srv->uuid.uuid16);
    352              } else {
    353                  LOG_I(common, "    [GATT]Start Handle = 0x%04x End Handle = 0x%04x", inc_srv->included_service_handle, inc_srv->end_group_handle);
    354                  LOG_I(common, "      [GATT]uuid = %s", get_uuid128(&inc_srv->uuid));
    355              }
    356          }
    357          
    358          static void print_all_include_service(list_entry *include_list)
    359          {
    360              gatt_include_service_node *inc_srv_node;
    361              inc_srv_node = (gatt_include_service_node *)include_list->next;
    362              while ((NULL != inc_srv_node) && ((list_entry *)inc_srv_node != include_list)) {
    363                  print_include_service(&inc_srv_node->include_service);
    364                  inc_srv_node = (gatt_include_service_node *)inc_srv_node->node.next;
    365              }
    366          }
    367          
    368          static void print_descriptor(gatt_desc *desc)
    369          {
    370              if (!desc) return;
    371              if (bt_uuid_is_uuid16(&desc->desc_uuid)) {
    372                  LOG_I(common, "      [GATT]Descriptor: Handle = 0x%04x, uuid = %04x", desc->handle, desc->desc_uuid.uuid16);
    373              } else {
    374                  LOG_I(common, "      [GATT]Descriptor: Handle = 0x%04x uuid = %s", desc->handle, get_uuid128(&desc->desc_uuid));
    375              }
    376          }
    377          
    378          static void print_all_descriptor(list_entry *desc_list)
    379          {
    380              gatt_desc_node *desc_node;
    381              desc_node = (gatt_desc_node *)desc_list->next;
    382              while ((NULL != desc_node) && ((list_entry *)desc_node != desc_list)) {
    383                  print_descriptor(&desc_node->descriptor);
    384                  desc_node = (gatt_desc_node *)desc_node->node.next;
    385              }
    386          }
    387          
    388          static void dump_char_properties(uint8_t prop)
    389          {
    390              char buf[80] = { 0 };
    391              char *ptr = buf;
    392              if (prop & 0x01) {
    393                  const char *prop_str = "Broadcast|";
    394                  snprintf(ptr, strlen(prop_str) + 1, prop_str);
    395                  ptr += strlen(ptr);
    396              }
    397              if (prop & 0x02) {
    398                  const char *prop_str = "Read|";
    399                  snprintf(ptr, strlen(prop_str) + 1, prop_str);
    400                  ptr += strlen(ptr);
    401              }
    402              if (prop & 0x04) {
    403                  const char *prop_str = "Write Without Response|";
    404                  snprintf(ptr, strlen(prop_str) + 1, prop_str);
    405                  ptr += strlen(ptr);
    406              }
    407              if (prop & 0x08) {
    408                  const char *prop_str = "Write|";
    409                  snprintf(ptr, strlen(prop_str) + 1, prop_str);
    410                  ptr += strlen(ptr);
    411              }
    412              if (prop & 0x10) {
    413                  const char *prop_str = "Notify|";
    414                  snprintf(ptr, strlen(prop_str) + 1, prop_str);
    415                  ptr += strlen(ptr);
    416              }
    417              if (prop & 0x20) {
    418                  const char *prop_str = "Indicate|";
    419                  snprintf(ptr, strlen(prop_str) + 1, prop_str);
    420                  ptr += strlen(ptr);
    421              }
    422              if (prop & 0x40) {
    423                  const char *prop_str = "Authenticated Signed Writes|";
    424                  snprintf(ptr, strlen(prop_str) + 1, prop_str);
    425                  ptr += strlen(ptr);
    426              }
    427              if (prop & 0x80) {
    428                  const char *prop_str = "Extend Properties|";
    429                  snprintf(ptr, strlen(prop_str) + 1, prop_str);
    430                  ptr += strlen(ptr);
    431              }
    432              if (ptr != buf) ptr--;
    433              *ptr = 0;
    434              LOG_I(common, "      [GATT]Properties:%s", buf);
    435          }
    436          
    437          static void print_char_info(gatt_char *char_info)
    438          {
    439              if (!char_info) return;
    440              if (bt_uuid_is_uuid16(&char_info->charc_uuid)) {
    441                  LOG_I(common, "    [GATT]Characteristic: ValueHandle = 0x%04x uuid = %04x", char_info->value_handle, char_info->charc_uuid.uuid16);
    442              } else {
    443                  LOG_I(common, "    [GATT]Characteristic: ValueHandle = 0x%04x", char_info->value_handle);
    444                  LOG_I(common, "      [GATT]uuid = %s", get_uuid128(&char_info->charc_uuid));
    445              }
    446              dump_char_properties(char_info->properties);
    447          }
    448          
    449          static void print_all_character(list_entry *char_list)
    450          {
    451              gatt_char_node *char_node;
    452              char_node = (gatt_char_node *)char_list->next;
    453              while ((NULL != char_node) && ((list_entry *)char_node != char_list)) {
    454                  print_char_info(&char_node->characteristic);
    455                  print_all_descriptor(&char_node->char_desc_list);
    456                  char_node = (gatt_char_node *)char_node->node.next;
    457              }
    458          }
    459          
    460          static void print_service(gatt_service *srv)
    461          {
    462              if (!srv) return;
    463              if (bt_uuid_is_uuid16(&srv->uuid)) {
    464                  LOG_I(common, "[GATT]Primary Service: [0x%04x-0x%04x] uuid = %04x", srv->start_handle, srv->end_handle, srv->uuid.uuid16);
    465              }
    466              else {
    467                  LOG_I(common, "[GATT]Primary Service: [0x%04x-0x%04x] ", srv->start_handle, srv->end_handle);
    468                  LOG_I(common, "  [GATT]uuid = %s", get_uuid128(&srv->uuid));
    469              }
    470          }
    471          
    472          static void gatt_free_service_node(gatt_service_node *service_node)
    473          {
    474              gatt_include_service_node *include_node;
    475              gatt_char_node *char_node;
    476              gatt_desc_node *char_desc_node;
    477          
    478              while (!is_list_empty(&service_node->include_list))
    479              {
    480                  include_node = (gatt_include_service_node *)remove_head(&service_node->include_list);
    481                  gatt_free(include_node);
    482              }
    483          
    484              while (!is_list_empty(&service_node->char_list))
    485              {
    486                  char_node = (gatt_char_node *)remove_head(&service_node->char_list);
    487                  while (!is_list_empty(&char_node->char_desc_list))
    488                  {
    489                      char_desc_node = (gatt_desc_node *)remove_head(&char_node->char_desc_list);
    490                      gatt_free(char_desc_node);
    491                  }
    492                  gatt_free(char_node);
    493              }
    494          
    495              gatt_free(service_node);
    496          }
    497          
    498          static void gatt_free_all_service()
    499          {
    500              gatt_service_node *service_node;
    501          
    502              while (!is_list_empty(&g_service_list)) {
    503                  service_node = (gatt_service_node *)remove_head(&g_service_list);
    504                  gatt_free_service_node(service_node);
    505              }
    506          }
    507          
    508          static void print_all_service(list_entry *service_list)
    509          {
    510              gatt_service_node *srv_node;
    511              gatt_service *srv;
    512              if (!service_list || is_list_empty(service_list)) return;
    513              srv_node = (gatt_service_node *)service_list->next;
    514              while ((list_entry *)srv_node != service_list) {
    515                  srv = &srv_node->service;
    516                  print_service(srv);
    517                  print_all_include_service(&srv_node->include_list);
    518                  print_all_character(&srv_node->char_list);
    519                  srv_node = (gatt_service_node *)(srv_node->node.next);
    520              }
    521              /* free all service_list */
    522              gatt_free_all_service();
    523          }
    524          
    525          static gatt_service_node *gatt_new_service(uint16_t start_handle, uint16_t end_handle, bt_uuid_t *uuid)
    526          {
    527              gatt_service_node *service_node = NULL;
    528              service_node = (gatt_service_node *)gatt_malloc(sizeof(gatt_service_node));
    529              if (service_node) {
    530                  memset((uint8_t *)service_node, 0, sizeof(gatt_service_node));
    531                  initialize_list_head(&service_node->include_list);
    532                  initialize_list_head(&service_node->char_list);
    533          
    534                  service_node->service.start_handle = start_handle;
    535                  service_node->service.end_handle = end_handle;
    536                  bt_uuid_copy(&service_node->service.uuid, uuid);
    537              } else {
    538                  LOG_I(common, "[GATT]Memory alloc fail for service");
    539              }
    540          
    541              return service_node;
    542          }
    543          
    544          static gatt_include_service_node *gatt_new_included_service(uint16_t attribute_handle, uint16_t start_handle, uint16_t end_handle, bt_uuid_t *uuid)
    545          {
    546              gatt_include_service_node *inc_srv_node = NULL;
    547              inc_srv_node = (gatt_include_service_node *)gatt_malloc(sizeof(gatt_include_service_node));
    548              if (inc_srv_node) {
    549                  memset((uint8_t *)inc_srv_node, 0, sizeof(gatt_include_service_node));
    550                  inc_srv_node->include_service.handle = attribute_handle;
    551                  inc_srv_node->include_service.included_service_handle = start_handle;
    552                  inc_srv_node->include_service.end_group_handle = end_handle;
    553                  bt_uuid_copy(&inc_srv_node->include_service.uuid, uuid);
    554              } else {
    555                  LOG_I(common, "[GATT]Memory alloc fail for included service");
    556              }
    557          
    558              return inc_srv_node;
    559          }
    560          
    561          static gatt_char_node *gatt_new_char(uint16_t handle, uint16_t value_handle, uint8_t properties, bt_uuid_t *uuid)
    562          {
    563              gatt_char_node *char_node = NULL;
    564              char_node = (gatt_char_node *)gatt_malloc(sizeof(gatt_char_node));
    565              if (char_node) {
    566                  memset((uint8_t *)char_node, 0, sizeof(gatt_char_node));
    567                  initialize_list_head(&char_node->char_desc_list);
    568                  char_node->characteristic.handle = handle;
    569                  char_node->characteristic.value_handle = value_handle;
    570                  char_node->characteristic.properties = properties;
    571                  bt_uuid_copy(&char_node->characteristic.charc_uuid, uuid);
    572              }
    573              return char_node;
    574          }
    575          
    576          static gatt_desc_node *gatt_new_desc(uint16_t handle, bt_uuid_t *uuid)
    577          {
    578              gatt_desc_node *desc_node = NULL;
    579              desc_node = (gatt_desc_node *)gatt_malloc(sizeof(gatt_desc_node));
    580              if (desc_node) {
    581                  memset((uint8_t *)desc_node, 0, sizeof(gatt_desc_node));
    582                  desc_node->descriptor.handle = handle;
    583                  bt_uuid_copy(&desc_node->descriptor.desc_uuid, uuid);
    584              }
    585              return desc_node;
    586          }
    587          
    588          static void ble_gattc_find_included_service(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle)
    589          {
    590              bt_gattc_find_included_services_req_t req;
    591          
    592              req.opcode = BT_ATT_OPCODE_READ_BY_TYPE_REQUEST;
    593              req.starting_handle = start_handle;
    594              req.ending_handle = end_handle;
    595              req.type16 = BT_GATT_UUID16_INCLUDE;
    596          
    597              bt_gattc_find_included_services(conn_handle, &req);
    598          }
    599          
    600          static void ble_gattc_discover_all_charc(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle)
    601          {
    602              bt_gattc_discover_charc_req_t req;
    603              uint16_t uuid_16 = BT_GATT_UUID16_CHARC;
    604          
    605              req.opcode = BT_ATT_OPCODE_READ_BY_TYPE_REQUEST;
    606              req.starting_handle = start_handle;
    607              req.ending_handle = end_handle;
    608          
    609              bt_uuid_load(&(req.type), (void *)&uuid_16, 2);
    610              bt_gattc_discover_charc(conn_handle, &req);
    611          }
    612          
    613          static void ble_gattc_discover_descriptors(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle)
    614          {
    615              bt_gattc_discover_charc_descriptor_req_t req;
    616          
    617              req.opcode = BT_ATT_OPCODE_FIND_INFORMATION_REQUEST;
    618              req.starting_handle = start_handle;
    619              req.ending_handle = end_handle;
    620          
    621              bt_gattc_discover_charc_descriptor(conn_handle, &req);
    622          }
    623          
    624          static void real_begin_discover_next_charc()
    625          {
    626              gatt_test_flag = TEST_DISCOVER_ALL_CHAR_STEP;
    627              ble_gattc_discover_all_charc(conn_id, service_table[cur_srv_index].start_handle, service_table[cur_srv_index].end_handle);
    628          }
    629          
    630          static void real_begin_discover_next_include_service()
    631          {
    632              cur_srv_index++;
    633              if (cur_srv_index < srv_count) {
    634                  gatt_test_flag = TEST_DISCOVER_ALL_INCLUDE_SERVICES_STEP;
    635                  ble_gattc_find_included_service(conn_id, service_table[cur_srv_index].start_handle, service_table[cur_srv_index].end_handle);
    636              } else {
    637                  gatt_test_flag = 0;
    638                  cur_srv_index = 0;
    639                  print_all_service(&g_service_list);
    640              }
    641          }
    642          
    643          static void begin_discover_desc()
    644          {
    645              gatt_test_flag = TEST_DISCOVER_ALL_DESC_STEP;
    646              cur_srv_node = find_service_node_by_handle_range(&g_service_list, service_table[cur_srv_index].start_handle);
    647              if (!cur_srv_node) return;
    648              cur_char_node = (gatt_char_node *)cur_srv_node->char_list.next;
    649              if (is_list_empty((list_entry *)&cur_srv_node->char_list)) {
    650                  /* should not come here, there should be at least 1 character */
    651                  real_begin_discover_next_include_service();
    652                  return;
    653              }
    654              if (cur_char_node->characteristic.value_handle == cur_srv_node->service.end_handle) {
    655                  /* no descriptor, begin to discover next primary service's include service */
    656                  real_begin_discover_next_include_service();
    657              }
    658              else {
    659                  uint16_t start_handle;
    660                  uint16_t end_handle;
    661                  if ((list_entry *)cur_char_node->node.next != &cur_srv_node->char_list) {
    662                      /* there are more than one character in service */
    663                      while ((list_entry *)cur_char_node->node.next != &cur_srv_node->char_list) {
    664                          start_handle = cur_char_node->characteristic.value_handle + 1;
    665                          end_handle = ((gatt_char_node *)cur_char_node->node.next)->characteristic.handle - 1;
    666                          if (start_handle <= end_handle) {
    667                              ble_gattc_discover_descriptors(conn_id, start_handle, end_handle);
    668                              return;
    669                          }
    670                          cur_char_node = (gatt_char_node *)cur_char_node->node.next;
    671                      }
    672                      /* come here means all character have no descriptor, now it goes to the last character */
    673                      if (cur_char_node->characteristic.value_handle == cur_srv_node->service.end_handle) {
    674                          real_begin_discover_next_include_service();
    675                      }
    676                      else {
    677                          start_handle = cur_char_node->characteristic.value_handle + 1;
    678                          end_handle = cur_srv_node->service.end_handle;
    679                          ble_gattc_discover_descriptors(conn_id, start_handle, end_handle);
    680                      }
    681                  }
    682                  else {
    683                      /* only one character in service */
    684                      start_handle = cur_char_node->characteristic.value_handle + 1;
    685                      end_handle = cur_srv_node->service.end_handle;
    686                      ble_gattc_discover_descriptors(conn_id, start_handle, end_handle);
    687                  }
    688              }
    689          }
    690          
    691          /* find char_node by handle, then get descriptor's start and end search handle */
    692          static void discover_next_desc(uint8_t skip, uint16_t cur_handle)
    693          {
    694              gatt_char_node *char_node;
    695              uint16_t start_handle;
    696              uint16_t end_handle;
    697              static uint16_t cur_end_handle = 0;
    698              if ((gatt_test_flag & TEST_DISCOVER_ALL_DESC_STEP) == 0) {
    699                  return;
    700              }
    701              if (!cur_srv_node) return;
    702          
    703              if (cur_handle >= cur_srv_node->service.end_handle || ((cur_handle + 1) >= cur_srv_node->service.end_handle)) {
    704                  real_begin_discover_next_include_service();
    705                  return;
    706              }
    707          
    708              /* only find char node under current service node */
    709              char_node = find_char_node_by_handle_range(cur_srv_node, cur_handle);
    710              if (!char_node) {
    711                  /* begin discover next include service */
    712                  real_begin_discover_next_include_service();
    713              }
    714              else {
    715                  if ((list_entry *)char_node->node.next != &cur_srv_node->char_list) {
    716                      /* there are more than one character in service */
    717                      while ((list_entry *)char_node->node.next != &cur_srv_node->char_list) {
    718                          start_handle = char_node->characteristic.value_handle + 1;
    719                          end_handle = ((gatt_char_node *)char_node->node.next)->characteristic.handle - 1;
    720          
    721                          if (start_handle > end_handle) {
    722                              char_node = (gatt_char_node *)char_node->node.next;
    723                          }
    724                          else {
    725                              if (start_handle <= cur_handle && cur_handle <= end_handle) {
    726                                  if (0 == skip) {
    727                                      cur_end_handle = end_handle;
    728                                      ble_gattc_discover_descriptors(conn_id, cur_handle, end_handle);
    729                                  }
    730                                  else {
    731                                      discover_next_desc(0, cur_end_handle + 1);
    732                                  }
    733                                  return;
    734                              }
    735                              else {
    736                                  cur_end_handle = end_handle;
    737                                  ble_gattc_discover_descriptors(conn_id, start_handle, end_handle);
    738                                  return;
    739                              }
    740                          }
    741                      }
    742                      /* come here means all character have no descriptor, now it goes to the last character */
    743                      if (char_node->characteristic.value_handle == cur_srv_node->service.end_handle) {
    744                          real_begin_discover_next_include_service();
    745                      }
    746                      else {
    747                          start_handle = char_node->characteristic.value_handle + 1;
    748                          end_handle = cur_srv_node->service.end_handle;
    749                          cur_end_handle = end_handle;
    750                          ble_gattc_discover_descriptors(conn_id, start_handle, end_handle);
    751                      }
    752                  }
    753                  else {
    754                      /* last character in service */
    755                      start_handle = char_node->characteristic.value_handle + 1;
    756                      if (start_handle < cur_handle) start_handle = cur_handle;
    757                      end_handle = cur_srv_node->service.end_handle;
    758                      if (0 == skip) {
    759                          ble_gattc_discover_descriptors(conn_id, start_handle, end_handle);
    760                      }
    761                      else {
    762                          real_begin_discover_next_include_service();
    763                      }
    764                  }
    765              }
    766          }
    767          
    768          static bt_status_t bt_gattc_write_data_test()
    769          {
    770              uint8_t buffer[300] = { 0 };
    771              bt_gattc_write_charc_req_t req;
    772          
    773              req.attribute_value_length = mtu - 3;
    774              req.att_req = (bt_att_write_req_t *)buffer;
    775              req.att_req->opcode = BT_ATT_OPCODE_WRITE_REQUEST;
    776              req.att_req->attribute_handle = 1;
    777              memcpy(req.att_req->attribute_value, test_data, mtu - 3);
    778          
    779          #if defined(MTK_BT_LWIP_ENABLE)
    780              bt_lwip_send(test_data, 18);
    781          #endif
    782              return bt_gattc_write_charc(test_conn_id, &req);
    783          }
    784          
    785          #ifdef BLE_THROUGHPUT
    786          extern QueueHandle_t ble_tp_queue;
    787          
    788          static bt_status_t ble_gattc_write_data_test()
    789          {
    790              uint8_t buf[260] = { 0 };
    791              bt_gattc_write_without_rsp_req_t req;
    792          
    793              req.attribute_value_length = mtu - 3;
    794              req.att_req = (bt_att_write_req_t *)buf;
    795              req.att_req->opcode = BT_ATT_OPCODE_WRITE_COMMAND;
    796              req.att_req->attribute_handle = 1;
    797              //memcpy(req.att_req->attribute_value, test_data, mtu - 3);
    798              memset(req.att_req->attribute_value, test_index, mtu - 3);
    799              return bt_gattc_write_without_rsp(test_conn_id, 0, &req);
    800          }
    801          
    802          void ble_gatt_send_data()
    803          {
    804              bt_status_t status;
    805              uint32_t speed = 1;
    806              if (test_started == 0) return;
    807              do {
    808                  cur_tick = xTaskGetTickCount();
    809                  if (cur_tick > test_finish_time) {
    810                      printf("Throughput Finished: %d.\n", cur_tick);
    811                      test_started = 0;
    812                      speed = test_index * (mtu - 3) * 1000 / ((cur_tick - test_start_time) * portTICK_PERIOD_MS);
    813                      printf("Throughput: finish send data test start_time:%u end_time:%u, test_index:%d\n", test_start_time, test_finish_time, test_index);
    814                      printf("Throughput: %d bytes/sec\n", speed);
    815                      break;
    816                  }
    817                  if (cur_tick > test_next_show) {
    818                      speed = test_index * (mtu - 3) * 1000 / ((cur_tick - test_start_time) * portTICK_PERIOD_MS);
    819                      test_next_show += (test_show_interval);
    820                      printf("Throughput: test start_time:%u end_time:%u, test_index:%d\n", test_start_time, cur_tick, test_index);
    821                      printf("Throughput: %d bytes/sec\n", speed);
    822                  }
    823                  status = ble_gattc_write_data_test();
    824                  if (status != BT_STATUS_SUCCESS) {
    825                      uint8_t msg = 1;
    826                      printf("index %d fail:%x\n", test_index, status);
    827                      xQueueSend(ble_tp_queue, (void *)&msg, 0);
    828                      break;
    829                  } else {
    830                      test_index++;
    831                      /*if ((test_index % 5) == 0) {
    832                          uint8_t msg = 1;
    833                          xQueueSend(ble_tp_queue, (void *)&msg, 0);
    834                          break;
    835                      }*/
    836                  }
    837              } while (1);
    838          }
    839          #endif
    840          
    841          static void show_throughput()
    842          {
    843              if (test_started)
    844              {
    845                  cur_tick = xTaskGetTickCount();
    846                  if (cur_tick > test_finish_time)
    847                  {
    848                      test_started = 0;
    849                      test_conn_id = 0;
    850                      LOG_I(common, "send to NB-- END");
    851                  }
    852          
    853                  if (test_started)
    854                  {
    855                      bt_gattc_write_data_test();
    856                  }
    857              }
    858          }
    859          
    860          static bt_status_t bt_app_cmd_gattc_event_callback(bt_msg_type_t msg, bt_status_t status, void *buff)
    861          {
    862              switch (msg) {
    863                  case BT_GATTC_EXCHANGE_MTU:
    864                  {
    865                      LOG_I(common, "[GATT]BT_GATTC_EXCHANGE_MTU status = %d\n", status);
    866                      if (BT_STATUS_SUCCESS != status) break;
    867                      bt_gatt_exchange_mtu_rsp_t *rsp = (bt_gatt_exchange_mtu_rsp_t *)buff;
    868                      mtu = rsp->server_rx_mtu;
    869                      LOG_I(common, "[GATT] exchange mtu rsp: %d\n", mtu);
    870                  #ifdef BLE_THROUGHPUT
    871                      printf("[GATT] exchange mtu rsp: %d\n", mtu);
    872                  #endif
    873                  }
    874                  break;
    875                  case BT_GATTC_DISCOVER_PRIMARY_SERVICE:
    876                  {
    877                      LOG_I(common, "[GATT]BT_GATTC_DISCOVER_PRIMARY_SERVICE status = %d", status);
    878          
    879                      if (status != BT_STATUS_SUCCESS && status != BT_ATT_ERRCODE_CONTINUE) {
    880                          LOG_I(common, "BT_GATTC_DISCOVER_PRIMARY_SERVICE FINISHED!!");
    881                          if (gatt_test_flag & TEST_DISCOVER_ALL_PRIMARY_SERVICES) {
    882                              gatt_test_flag = TEST_DISCOVER_ALL_INCLUDE_SERVICES_STEP;
    883                              cur_srv_index = 0;
    884                              ble_gattc_find_included_service(conn_id, service_table[cur_srv_index].start_handle, service_table[cur_srv_index].end_handle);
    885                          }
    886                          break;
    887                      }
    888          
    889                      bt_gattc_read_by_group_type_rsp_t *rsp = (bt_gattc_read_by_group_type_rsp_t *)buff;
    890                      uint16_t end_group_handle = 0, starting_handle = 0, uuid = 0;
    891                      bt_uuid_t uuid128;
    892                      uint8_t *attribute_data_list = rsp->att_rsp->attribute_data_list;
    893                      uint8_t num_of_data = (rsp->length - 2) / rsp->att_rsp->length;
    894                      int i;
    895          
    896                      for (i = 0; i < num_of_data; i++){
    897                          memcpy(&starting_handle, attribute_data_list + i * rsp->att_rsp->length, 2);
    898                          memcpy(&end_group_handle, attribute_data_list + i * rsp->att_rsp->length + 2, 2);
    899                          LOG_I(common, "[GATT]data : %d", i);
    900                          LOG_I(common, "[GATT]starting_handle = 0x%04x, end_group_handle = 0x%04x", starting_handle, end_group_handle);
    901                          if (rsp->att_rsp->length == 6) {
    902                              memcpy(&uuid, attribute_data_list + i * rsp->att_rsp->length + 4, rsp->att_rsp->length - 4);
    903                              LOG_I(common, "[GATT]uuid = 0x%04x", uuid);
    904                              bt_uuid_from_uuid16(&uuid128, uuid);
    905                          }
    906                          else {
    907                              memcpy(&uuid128.uuid, attribute_data_list + i * rsp->att_rsp->length + 4, rsp->att_rsp->length - 4);
    908                              dump_uuid128(&uuid128);
    909                          }
    910                          if (gatt_test_flag & TEST_DISCOVER_ALL_PRIMARY_SERVICES) {
    911                              gatt_service_node *srv_node = NULL;
    912                              srv_node = gatt_new_service(starting_handle, end_group_handle, &uuid128);
    913          
    914                              service_table[srv_count].start_handle = starting_handle;
    915                              service_table[srv_count].end_handle = end_group_handle;
    916                              /* Only need to store start and end handle */
    917                              srv_count++;
    918                              if (srv_count >= MAX_SERVICE_NO) {
    919                                  LOG_I(common, "[GATT]There are more than %d primary services.", MAX_SERVICE_NO);
    920                                  assert(0);
    921                              }
    922                              if (srv_node) {
    923                                  insert_tail_list(&g_service_list, &srv_node->node);
    924                              }
    925                          }
    926                      }
    927                      if (status == BT_STATUS_SUCCESS) {
    928                          if (gatt_test_flag & TEST_DISCOVER_ALL_PRIMARY_SERVICES) {
    929                              gatt_test_flag = TEST_DISCOVER_ALL_INCLUDE_SERVICES_STEP;
    930                              cur_srv_index = 0;
    931                              ble_gattc_find_included_service(conn_id, service_table[cur_srv_index].start_handle, service_table[cur_srv_index].end_handle);
    932                          }
    933                      }
    934                  }
    935                  break;
    936                  case BT_GATTC_FIND_INCLUDED_SERVICES:
    937                  {
    938                      LOG_I(common, "[GATT]BT_GATTC_FIND_INCLUDED_SERVICES status = %d", status);
    939          
    940                      if (status != BT_STATUS_SUCCESS && status != BT_ATT_ERRCODE_CONTINUE) {
    941                          LOG_I(common, "[GATT]BT_GATTC_FIND_INCLUDED_SERVICES FINISHED!!");
    942                          if (gatt_test_flag & TEST_DISCOVER_ALL_INCLUDE_SERVICES_STEP) {
    943                              /* will discover characteristic actually */
    944                              real_begin_discover_next_charc();
    945                          }
    946                          break;
    947                      }
    948          
    949                      bt_gattc_read_by_type_rsp_t *rsp = (bt_gattc_read_by_type_rsp_t *)buff;
    950                      uint8_t *attribute_data_list = rsp->att_rsp->attribute_data_list;
    951                      uint16_t attribute_handle = 0, starting_handle = 0, ending_handle = 0, uuid = 0;
    952                      bt_uuid_t uuid128;
    953                      int i;
    954                      uint8_t num_of_data = (rsp->length - 2) / rsp->att_rsp->length;
    955          
    956                      for (i = 0; i < num_of_data; i++) {
    957                          LOG_I(common, "[GATT]data : %d", i);
    958                          memcpy(&attribute_handle, attribute_data_list + i * rsp->att_rsp->length, 2);
    959                          memcpy(&starting_handle, attribute_data_list + i * rsp->att_rsp->length + 2, 2);
    960                          memcpy(&ending_handle, attribute_data_list + i * rsp->att_rsp->length + 4, 2);
    961                          LOG_I(common, "[GATT]attribute_handle = 0x%04x, starting_handle = 0x%04x, end_group_handle = 0x%04x",
    962                              attribute_handle, starting_handle, ending_handle);
    963                          if (rsp->att_rsp->length <= 8) {
    964                              memcpy(&uuid, attribute_data_list + i * rsp->att_rsp->length + 6, 2);
    965                              LOG_I(common, "[GATT]uuid = 0x%04x", uuid);
    966                              bt_uuid_from_uuid16(&uuid128, uuid);
    967                          } else {
    968                              memcpy(&uuid128.uuid, attribute_data_list + i * rsp->att_rsp->length + 6, 16);
    969                              dump_uuid128(&uuid128);
    970                          }
    971                          if (gatt_test_flag & TEST_DISCOVER_ALL_INCLUDE_SERVICES_STEP) {
    972                              /* CFTBD: find position and add include service to service_list */
    973                              gatt_service_node *srv_node = NULL;
    974                              gatt_include_service_node *inc_srv_node = NULL;
    975          
    976                              srv_node = find_service_node_by_handle_range(&g_service_list, attribute_handle);
    977                              if (srv_node) {
    978                                  inc_srv_node = gatt_new_included_service(attribute_handle, starting_handle, ending_handle, &uuid128);
    979                                  if (inc_srv_node) {
    980                                      insert_tail_list(&srv_node->include_list, &inc_srv_node->node);
    981                                  }
    982                              }
    983                          }
    984                      }
    985          
    986                      if (status == BT_STATUS_SUCCESS) {
    987                          if (gatt_test_flag & TEST_DISCOVER_ALL_INCLUDE_SERVICES_STEP) {
    988                              /* will discover characteristic actually */
    989                              real_begin_discover_next_charc();
    990                          }
    991                      }
    992                  }
    993                  break;
    994                  case BT_GATTC_DISCOVER_CHARC:
    995                  {
    996                      LOG_I(common, "[GATT]BT_GATTC_DISCOVER_CHARC status = %d", status);
    997          
    998                      if (status != BT_STATUS_SUCCESS && status != BT_ATT_ERRCODE_CONTINUE) {
    999                          LOG_I(common, "[GATT]BT_GATTC_DISCOVER_CHARC FINISHED!!");
   1000                          if (gatt_test_flag & TEST_DISCOVER_ALL_CHAR_STEP) {
   1001                              begin_discover_desc();
   1002                          }
   1003                          break;
   1004                      }
   1005          
   1006                      bt_gattc_read_by_type_rsp_t *rsp = (bt_gattc_read_by_type_rsp_t *)buff;
   1007                      uint8_t *attribute_data_list = rsp->att_rsp->attribute_data_list;
   1008                      uint16_t attribute_handle = 0, value_handle = 0, uuid = 0;
   1009                      uint8_t properties = 0;
   1010                      uint8_t num_of_data = (rsp->length - 2) / rsp->att_rsp->length;
   1011                      bt_uuid_t uuid128;
   1012                      int i;
   1013          
   1014                      for (i = 0; i < num_of_data; i++) {
   1015                          memcpy(&attribute_handle, attribute_data_list + i * rsp->att_rsp->length, 2);
   1016                          memcpy(&properties, attribute_data_list + i * rsp->att_rsp->length + 2, 1);
   1017                          memcpy(&value_handle, attribute_data_list + i * rsp->att_rsp->length + 3, 2);
   1018                          LOG_I(common, "[GATT]num_of_data = %d", i);
   1019                          LOG_I(common, "[GATT]attribute handle = 0x%04x value_handle = 0x%04x, properties = 0x%02x", attribute_handle, value_handle, properties);
   1020                          if (rsp->att_rsp->length < 20) {
   1021                              memcpy(&uuid, attribute_data_list + i * rsp->att_rsp->length + 5, 2);
   1022                              LOG_I(common, "[GATT]uuid = 0x%04x", uuid);
   1023                              bt_uuid_from_uuid16(&uuid128, uuid);
   1024                          } else {
   1025                              memcpy(&uuid128.uuid, attribute_data_list + i * rsp->att_rsp->length + 5, 16);
   1026                              dump_uuid128(&uuid128);
   1027                          }
   1028          
   1029                          if (gatt_test_flag & TEST_DISCOVER_ALL_CHAR_STEP) {
   1030                              /* CFTBD: find position and add char to service_list */
   1031                              gatt_service_node *srv_node = NULL;
   1032                              gatt_char_node *char_node = NULL;
   1033          
   1034                              srv_node = find_service_node_by_handle_range(&g_service_list, attribute_handle);
   1035                              if (srv_node) {
   1036                                  char_node = gatt_new_char(attribute_handle, value_handle, properties, &uuid128);
   1037                                  if (char_node) {
   1038                                      insert_tail_list(&srv_node->char_list, &char_node->node);
   1039                                  }
   1040                              }
   1041                          }
   1042                      }
   1043          
   1044                      if (BT_STATUS_SUCCESS == status) {
   1045                          if (gatt_test_flag & TEST_DISCOVER_ALL_CHAR_STEP) {
   1046                              begin_discover_desc();
   1047                          }
   1048                      }
   1049                  }
   1050                  break;
   1051                  case BT_GATTC_DISCOVER_CHARC_DESCRIPTOR:
   1052                  {
   1053                      LOG_I(common, "[GATT]BT_GATTC_DISCOVER_CHARC_DESCRIPTOR status = %d", status);
   1054          
   1055                      if (status != BT_STATUS_SUCCESS && status != BT_ATT_ERRCODE_CONTINUE) {
   1056                          bt_att_error_rsp_t *rsp = (bt_att_error_rsp_t*)buff;
   1057                          LOG_I(common, "[GATT]BT_GATTC_DISCOVER_CHARC_DESCRIPTOR FINISHED!!");
   1058                          discover_next_desc(1, rsp->error_handle + 1);
   1059                          break;
   1060                      }
   1061          
   1062                      bt_gattc_find_info_rsp_t *rsp = (bt_gattc_find_info_rsp_t *)buff;
   1063                      uint8_t format = rsp->att_rsp->format;
   1064                      uint16_t attribute_handle = 0, attribute_value = 0;
   1065                      uint8_t attribute_length = 0;
   1066                      uint8_t num_of_attribute;
   1067                      bt_uuid_t uuid128;
   1068                      int i;
   1069          
   1070                      if (format == 0x02) {
   1071                          attribute_length = 18;
   1072                      }
   1073                      else {
   1074                          attribute_length = 4;
   1075                      }
   1076                      num_of_attribute = (rsp->length - 2) / attribute_length;
   1077                      for (i = 0; i < num_of_attribute; ++i) {
   1078                          LOG_I(common, "[GATT]num_of_data = %d", i);
   1079                          if (format == 0x02) {
   1080                              /* uuid 128 */
   1081                              memcpy(&attribute_handle, rsp->att_rsp->info_data + i * attribute_length, 2);
   1082                              memcpy(&uuid128, rsp->att_rsp->info_data + i * attribute_length + 2, 16);
   1083                              LOG_I(common, "[GATT]attribute handle = 0x%04x", attribute_handle);
   1084                              dump_uuid128(&uuid128);
   1085                          } else {
   1086                              /* uuid 16 */
   1087                              memcpy(&attribute_handle, rsp->att_rsp->info_data + i * attribute_length, 2);
   1088                              memcpy(&attribute_value, rsp->att_rsp->info_data + i * attribute_length + 2, 2);
   1089                              LOG_I(common, "[GATT]attribute handle = 0x%04x, uuid = 0x%04x", attribute_handle, attribute_value);
   1090                              bt_uuid_from_uuid16(&uuid128, attribute_value);
   1091                          }
   1092                          if (gatt_test_flag & TEST_DISCOVER_ALL_DESC_STEP) {
   1093                              /* CFTBD: find position and add desc to service_list */
   1094                              gatt_service_node *srv_node = NULL;
   1095                              gatt_char_node *char_node = NULL;
   1096                              gatt_desc_node *desc_node = NULL;
   1097          
   1098                              srv_node = find_service_node_by_handle_range(&g_service_list, attribute_handle);
   1099                              if (srv_node) {
   1100                                  char_node = find_char_node_by_handle_range(srv_node, attribute_handle);
   1101                                  if (char_node) {
   1102                                      desc_node = gatt_new_desc(attribute_handle, &uuid128);
   1103                                      if (desc_node) {
   1104                                          insert_tail_list(&char_node->char_desc_list, &desc_node->node);
   1105                                      }
   1106                                  }
   1107                              }
   1108                          }
   1109                      }
   1110                      if (BT_STATUS_SUCCESS == status) {
   1111                          if (gatt_test_flag & TEST_DISCOVER_ALL_DESC_STEP) {
   1112                              discover_next_desc(0, attribute_handle + 1);
   1113                          }
   1114                      }
   1115                  }
   1116                  break;
   1117                  case BT_GATTC_READ_CHARC:
   1118                  {
   1119                      LOG_I(common, "[GATT]BT_GATTC_READ_CHARC status = %d", status);
   1120          
   1121                      if (status != BT_STATUS_SUCCESS) {
   1122                          LOG_I(common, "[GATT]BT_GATTC_READ_CHARC FINISHED with error.");
   1123                          break;
   1124                      }
   1125          
   1126                      bt_gattc_read_rsp_t *rsp = (bt_gattc_read_rsp_t *)buff;
   1127                      uint8_t length = rsp->length - 1;
   1128                      int i;
   1129          
   1130                      for (i = 0; i < length; i++)
   1131                          printf("%02x", rsp->att_rsp->attribute_value[i]);
   1132                      printf("\n");
   1133                      if (status == BT_STATUS_SUCCESS) {
   1134                          LOG_I(common, "[GATT]bt_gattc_read_charc FINISHED!!");
   1135                      }
   1136                  }
   1137                  break;
   1138                  case BT_GATTC_WRITE_CHARC:
   1139                  {
   1140                      LOG_I(common, "[GATT]BT_GATTC_WRITE_CHARC status = %d", status);
   1141                      if (status != BT_STATUS_SUCCESS) {
   1142                          bt_gattc_error_rsp_t * err_rsp = (bt_gattc_error_rsp_t *)buff;
   1143                          if (err_rsp->connection_handle == test_conn_id) {
   1144                              show_throughput();
   1145                          } else {
   1146                              LOG_I(common, "[GATT]BT_GATTC_WRITE_CHARC FINISHED with error.");
   1147                          }
   1148                          break;
   1149                      }
   1150                      bt_gattc_write_rsp_t *rsp = (bt_gattc_write_rsp_t *)buff;
   1151                      if (rsp->connection_handle == test_conn_id) {
   1152                          show_throughput();
   1153                      }
   1154                  }
   1155                  break;
   1156                  case BT_GATTC_CHARC_VALUE_NOTIFICATION:
   1157                  {
   1158                      LOG_I(common, "BT_GATTC_CHARC_VALUE_NOTIFICATION status = %d", status);
   1159                      if (status != BT_STATUS_SUCCESS) {
   1160                          LOG_I(common, "BT_GATTC_CHARC_VALUE_NOTIFICATION FINISHED.");
   1161                          break;
   1162                      }
   1163          
   1164                      bt_gatt_handle_value_notification_t *rsp = (bt_gatt_handle_value_notification_t *)buff;
   1165                      uint16_t attribute_handle = rsp->att_rsp->handle;
   1166          
   1167                      LOG_I(common, "attribute_handle = 0x%04x", attribute_handle);
   1168          
   1169                      if (status == BT_STATUS_SUCCESS) {
   1170          #if defined(MTK_BT_LWIP_ENABLE)
   1171                          uint8_t length = rsp->length - 3;
   1172                          LOG_I(common, "length = %d", length);
   1173                          bt_lwip_send(rsp->att_rsp->attribute_value, length);
   1174                          bt_lwip_send("\r\n", 5);
   1175          #endif
   1176                          LOG_I(common, "BT_GATTC_CHARC_VALUE_NOTIFICATION FINISHED!!");
   1177                      }
   1178                  }
   1179                  break;
   1180                  case BT_GATTC_CHARC_VALUE_INDICATION:
   1181                  {
   1182                      LOG_I(common, "BT_GATTC_CHARC_VALUE_INDICATION");
   1183          
   1184                      if (status != BT_STATUS_SUCCESS) {
   1185                          LOG_I(common, "BT_GATTC_CHARC_VALUE_INDICATION FINISHED.");
   1186                          break;
   1187                      }
   1188          
   1189                      bt_gatt_handle_value_notification_t *rsp = (bt_gatt_handle_value_notification_t *)buff;
   1190                      uint16_t attribute_handle = rsp->att_rsp->handle;
   1191          
   1192                      LOG_I(common, "attribute_handle = 0x%04x", attribute_handle);
   1193          
   1194                      if (status == BT_STATUS_SUCCESS) {
   1195                          LOG_I(common, "BT_GATTC_CHARC_VALUE_INDICATION FINISHED!!");
   1196                      }
   1197                  }
   1198                  break;
   1199          #ifdef BLE_THROUGHPUT
   1200                  case BT_GAP_LE_DISCONNECT_IND:
   1201                  {
   1202                      bt_gap_le_disconnect_ind_t *ind = (bt_gap_le_disconnect_ind_t *)buff;
   1203                      printf("Connection handle:%04x disconnected.\n", ind->connection_handle);
   1204                      if (ind->connection_handle == test_conn_id) {
   1205                          test_started = 0;
   1206                      }
   1207                  }
   1208                  break;
   1209          #endif
   1210                  default:
   1211                      break;
   1212              }
   1213          
   1214              return BT_STATUS_SUCCESS;
   1215          }
   1216          
   1217          bt_status_t bt_cmd_gattc_io_callback(void *input, void *output)
   1218          {
   1219              const char *cmd = input;
   1220              if (UT_APP_CMP("gatt discover_all")) {
   1221                  const char *handle = cmd + 18;
   1222                  bt_gattc_discover_primary_service_req_t req;
   1223          
   1224                  req.opcode = BT_ATT_OPCODE_READ_BY_GROUP_TYPE_REQUEST;
   1225                  req.starting_handle = 0x0001;
   1226                  req.ending_handle = 0xFFFF;
   1227                  req.type16 = BT_GATT_UUID16_PRIMARY_SERVICE;
   1228          
   1229                  conn_id = (uint16_t)strtoul(handle, NULL, 16);
   1230          	    LOG_I(common, "[GATT]Start to discover all services.");
   1231                  ut_app_callback = bt_app_cmd_gattc_event_callback;
   1232          
   1233                  gatt_test_flag |= TEST_DISCOVER_ALL_PRIMARY_SERVICES;
   1234                  srv_count = 0;
   1235                  memset(service_table, 0, sizeof(service_table));
   1236                  initialize_list_head(&g_service_list);
   1237                  bt_gattc_discover_primary_service(conn_id, &req);
   1238              } else if (UT_APP_CMP("gatt read")) {
   1239                  const char *handle = cmd + 10;
   1240                  const char *attribute_handle = cmd + 15;
   1241          
   1242                  bt_gattc_read_charc_req_t req;
   1243          
   1244                  req.opcode = BT_ATT_OPCODE_READ_REQUEST;
   1245                  req.attribute_handle = (uint16_t)strtoul(attribute_handle, NULL, 16);
   1246                  conn_id = (uint16_t)strtoul(handle, NULL, 16);
   1247                  LOG_I(common, "[GATT]Start to read charc.");
   1248                  ut_app_callback = bt_app_cmd_gattc_event_callback;
   1249                  bt_gattc_read_charc(conn_id, &req);
   1250              } else if (UT_APP_CMP("gatt write")) {
   1251                  const char *handle = cmd + 11;
   1252                  const char *attribute_handle = cmd + 16;
   1253                  const char *attribute_value = cmd + 21;
   1254                  uint8_t buffer[158] = { 0 };
   1255                  uint8_t valuehex[158] = { 0 };
   1256                  uint8_t len;
   1257                  int i, j;
   1258                  bt_gattc_write_charc_req_t req;
   1259          
   1260                  len = strlen(attribute_value);
   1261                  for (i = len - 1, j = 0; i >= 0; --i, ++j) {
   1262                      if (attribute_value[i] >= '0' && attribute_value[i] <= '9') {
   1263                          valuehex[j] = attribute_value[i] - '0';
   1264                      }
   1265                      else if (attribute_value[i] >= 'A' && attribute_value[i] <= 'F') {
   1266                          valuehex[j] = attribute_value[i] - 'A' + 10;
   1267                      }
   1268                      else if (attribute_value[i] >= 'a' && attribute_value[i] <= 'f') {
   1269                          valuehex[j] = attribute_value[i] - 'a' + 10;
   1270                      }
   1271                  }
   1272                  req.attribute_value_length = strlen(attribute_value);
   1273                  req.att_req = (bt_att_write_req_t *)buffer;
   1274                  req.att_req->opcode = BT_ATT_OPCODE_WRITE_REQUEST;
   1275                  conn_id = (uint16_t)strtoul(handle, NULL, 16);
   1276                  req.att_req->attribute_handle = (uint16_t)strtoul(attribute_handle, NULL, 16);
   1277                  //memcpy(req.att_req->attribute_value, attribute_value, strlen(attribute_value));
   1278                  memcpy(req.att_req->attribute_value, valuehex, len);
   1279          
   1280                  LOG_I(common, "[GATT]Start to write charc.");
   1281                  ut_app_callback = bt_app_cmd_gattc_event_callback;
   1282                   bt_gattc_write_charc(conn_id, &req);
   1283              } else if (UT_APP_CMP("gatt send_data_test")) {
   1284                  uint32_t time_duration;
   1285                  const char *handle = cmd + 20;
   1286                  const char *duration = cmd + 25;
   1287          #ifdef BLE_THROUGHPUT
   1288                  const char *interval = cmd + 30;
   1289                  test_show_interval = (uint16_t)strtoul(interval, NULL, 10) * 1000 / portTICK_PERIOD_MS;
   1290          #endif
   1291                  test_conn_id = (uint16_t)strtoul(handle, NULL, 16);
   1292                  time_duration = (uint16_t)strtoul(duration, NULL, 10) * 1000 / portTICK_PERIOD_MS;
   1293                  test_start_time = xTaskGetTickCount();
   1294                  test_finish_time = time_duration + test_start_time;
   1295                  test_started = 1;
   1296                  ut_app_callback = bt_app_cmd_gattc_event_callback;
   1297          #ifdef BLE_THROUGHPUT
   1298                  test_next_show = test_start_time + (test_show_interval);
   1299                  test_index = 1;
   1300                  LOG_I(common, "start send data test");
   1301                  ble_gatt_send_data();
   1302          #else
   1303                  LOG_I(common, "send to NB-- Start");
   1304                  bt_gattc_write_data_test();
   1305          #endif
   1306              } else if (UT_APP_CMP("gatt mtu")) {
   1307                  const char *handle = cmd + 9;
   1308                  const char *cmtu = cmd + 14;
   1309                  test_conn_id = (uint16_t)strtoul(handle, NULL, 16);
   1310                  BT_GATTC_NEW_EXCHANGE_MTU_REQ(req, (uint16_t)strtoul(cmtu, NULL, 10));
   1311                  //BT_GATTC_NEW_EXCHANGE_MTU_REQ(req, expected_mtu);
   1312                  bt_gattc_exchange_mtu(test_conn_id, &req);
   1313                  ut_app_callback = bt_app_cmd_gattc_event_callback;
   1314              }
   1315          
   1316              return BT_STATUS_SUCCESS;
   1317          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   begin_discover_desc
         0   -> ble_gattc_discover_descriptors
        24   -> find_service_node_by_handle_range
        24   -> is_list_empty
         0   -> real_begin_discover_next_include_service
      40   ble_gattc_discover_all_charc
        40   -> bt_gattc_discover_charc
        40   -> bt_uuid_load
      16   ble_gattc_discover_descriptors
        16   -> bt_gattc_discover_charc_descriptor
      16   ble_gattc_find_included_service
        16   -> bt_gattc_find_included_services
      80   bt_app_cmd_gattc_event_callback
        80   -- Indirect call
        80   -> __aeabi_assert
        80   -> __aeabi_memcpy
        80   -> __iar_EmptyStepPoint
        80   -> begin_discover_desc
        80   -> ble_gattc_find_included_service
        80   -> bt_uuid_from_uuid16
        80   -> discover_next_desc
        80   -> dump_uuid128
        80   -> find_char_node_by_handle_range
        80   -> find_service_node_by_handle_range
        80   -> gatt_new_char
        80   -> gatt_new_desc
        80   -> gatt_new_included_service
        80   -> gatt_new_service
        80   -> insert_tail_list
        80   -> printf
        80   -> real_begin_discover_next_charc
        80   -> show_throughput
     352   bt_cmd_gattc_io_callback
       352   -- Indirect call
       352   -> __aeabi_memclr4
       352   -> __aeabi_memcpy
       352   -> __aeabi_memset4
       352   -> bt_gattc_discover_primary_service
       352   -> bt_gattc_exchange_mtu
       352   -> bt_gattc_read_charc
       352   -> bt_gattc_write_charc
       352   -> bt_gattc_write_data_test
       352   -> initialize_list_head
       352   -> strlen
       352   -> strncmp
       352   -> strtoul
       352   -> xTaskGetTickCount
     320   bt_gattc_write_data_test
       320   -> __aeabi_memclr4
       320   -> __aeabi_memcpy
       320   -> bt_gattc_write_charc
       0   default_bqb_get_gatt_server
       0   default_bt_app_gattc_io_callback
       0   default_bt_app_gatts_io_callback
       0   default_bt_gatt_service_execute_write
      24   discover_next_desc
         0   -> ble_gattc_discover_descriptors
        24   -> find_char_node_by_handle_range
         0   -> real_begin_discover_next_include_service
     104   dump_char_properties
       104   -- Indirect call
       104   -> __aeabi_memclr4
       104   -> snprintf
       104   -> strlen
      64   dump_uuid128
        64   -- Indirect call
        64   -> __aeabi_memclr4
        64   -> snprintf
      12   find_char_node_by_handle_range
       4   find_service_node_by_handle_range
       0   gatt_free
         0   -> vPortFree
       8   gatt_free_all_service
         8   -> gatt_free_service_node
         8   -> is_list_empty
         8   -> remove_head
      16   gatt_free_service_node
         0   -> gatt_free
        16   -> gatt_free
        16   -> is_list_empty
        16   -> remove_head
       0   gatt_malloc
         0   -> pvPortMalloc
      24   gatt_new_char
        24   -> __aeabi_memset
        24   -> bt_uuid_copy
        24   -> gatt_malloc
        24   -> initialize_list_head
      16   gatt_new_desc
        16   -> __aeabi_memset
        16   -> bt_uuid_copy
        16   -> gatt_malloc
      32   gatt_new_included_service
        32   -- Indirect call
        32   -> __aeabi_memset
        32   -> bt_uuid_copy
        32   -> gatt_malloc
      24   gatt_new_service
        24   -- Indirect call
        24   -> __aeabi_memset
        24   -> bt_uuid_copy
        24   -> gatt_malloc
        24   -> initialize_list_head
      24   get_uuid128
        24   -> __aeabi_memset4
        24   -> snprintf
       0   initialize_list_entry
       0   initialize_list_head
      16   insert_tail_list
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> is_list_circular
       0   is_list_circular
       0   is_list_empty
      16   is_node_on_list
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> is_list_circular
      16   print_all_character
        16   -> print_all_descriptor
        16   -> print_char_info
      16   print_all_descriptor
        16   -> print_descriptor
      16   print_all_include_service
        16   -> print_include_service
      16   print_all_service
         0   -> gatt_free_all_service
        16   -> is_list_empty
        16   -> print_all_character
        16   -> print_all_include_service
        16   -> print_service
      32   print_char_info
        32   -- Indirect call
        32   -> bt_uuid_is_uuid16
         0   -> dump_char_properties
        32   -> get_uuid128
      32   print_descriptor
        32   -- Indirect call
        32   -> bt_uuid_is_uuid16
        32   -> get_uuid128
      40   print_include_service
        40   -- Indirect call
        40   -> bt_uuid_is_uuid16
        40   -> get_uuid128
      40   print_service
        40   -- Indirect call
        40   -> bt_uuid_is_uuid16
        40   -> get_uuid128
       0   real_begin_discover_next_charc
         0   -> ble_gattc_discover_all_charc
       0   real_begin_discover_next_include_service
         0   -> ble_gattc_find_included_service
         0   -> print_all_service
      16   remove_entry
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
         0   -> initialize_list_entry
        16   -> is_list_circular
      16   remove_head
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> is_list_circular
      16   show_throughput
        16   -- Indirect call
         0   -> bt_gattc_write_data_test
        16   -> xTaskGetTickCount


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable104
       4  ??DataTable104_1
       4  ??DataTable104_2
       4  ??DataTable104_3
       4  ??DataTable104_4
       4  ??DataTable104_5
       4  ??DataTable105
       4  ??DataTable105_1
       4  ??DataTable105_2
       4  ??DataTable105_3
       4  ??DataTable105_4
       4  ??DataTable105_5
       4  ??DataTable105_6
       4  ??DataTable105_7
       4  ??DataTable105_8
       4  ??DataTable105_9
       4  ??DataTable106
       4  ??DataTable106_1
       4  ??DataTable106_2
       4  ??DataTable106_3
       4  ??DataTable106_4
       4  ??DataTable106_5
       4  ??DataTable106_6
       8  ?_0
      92  ?_1
      52  ?_10
      80  ?_11
      12  ?_12
       8  ?_13
      24  ?_14
       8  ?_15
       8  ?_16
      12  ?_17
      32  ?_18
      20  ?_19
      36  ?_2
      28  ?_20
      60  ?_21
      48  ?_22
      52  ?_23
      40  ?_24
      20  ?_25
      36  ?_26
      48  ?_27
     300  ?_28
      20  ?_29
       8  ?_3
      44  ?_30
      32  ?_31
      52  ?_32
      48  ?_33
      16  ?_34
      60  ?_35
      20  ?_36
      48  ?_37
      52  ?_38
      52  ?_39
      16  ?_4
      88  ?_40
      44  ?_41
      44  ?_42
      24  ?_43
      76  ?_44
      56  ?_45
      52  ?_46
      32  ?_47
      48  ?_48
      40  ?_49
      40  ?_5
      48  ?_50
       2  ?_51
      40  ?_52
      40  ?_53
      48  ?_54
      48  ?_55
      44  ?_56
      28  ?_57
      48  ?_58
      32  ?_59
      64  ?_6
      44  ?_60
      44  ?_61
      20  ?_62
      40  ?_63
      12  ?_64
      28  ?_65
      12  ?_66
     160  ?_67
     160  ?_68
      28  ?_69
      52  ?_7
      20  ?_70
      20  ?_71
      12  ?_72
      24  ?_8
      56  ?_9
     162  begin_discover_desc
      52  ble_gattc_discover_all_charc
      26  ble_gattc_discover_descriptors
      34  ble_gattc_find_included_service
       4  bqb_get_gatt_server
          default_bqb_get_gatt_server
    2332  bt_app_cmd_gattc_event_callback
     632  bt_cmd_gattc_io_callback
       4  bt_gatt_service_execute_write
          default_bt_gatt_service_execute_write
      88  bt_gattc_write_data_test
       2  conn_interval
       4  default_bt_app_gattc_io_callback
          bt_app_gattc_io_callback
       4  default_bt_app_gatts_io_callback
          bt_app_gatts_io_callback
     234  discover_next_desc
     254  dump_char_properties
      76  dump_uuid128
      68  find_char_node_by_handle_range
      38  find_service_node_by_handle_range
       4  gatt_free
      30  gatt_free_all_service
      96  gatt_free_service_node
       4  gatt_malloc
      60  gatt_new_char
      40  gatt_new_desc
      80  gatt_new_included_service
      86  gatt_new_service
      50  get_uuid128
       8  initialize_list_entry
       6  initialize_list_head
     114  insert_tail_list
      48  is_list_circular
      14  is_list_empty
      56  is_node_on_list
      36  print_all_character
      28  print_all_descriptor
      28  print_all_include_service
      56  print_all_service
     116  print_char_info
      90  print_descriptor
     144  print_include_service
     120  print_service
      30  real_begin_discover_next_charc
      58  real_begin_discover_next_include_service
      84  remove_entry
      76  remove_head
    1000  service_table
      66  show_throughput
     312  test_started
          req
          test_conn_id
          mtu
          conn_id
          gatt_test_flag
          srv_count
          cur_srv_index
          cur_end_handle
          test_start_time
          test_finish_time
          cur_tick
          cur_srv_node
          cur_char_node
          test_data
          g_service_list
      36  tmp_uuid_buf
     240  -- Other

 
 1 036 bytes in section .bss
   314 bytes in section .data
   738 bytes in section .rodata
 8 444 bytes in section .text
 
 8 444 bytes of CODE  memory
   738 bytes of CONST memory
 1 350 bytes of DATA  memory

Errors: none
Warnings: none
