###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:18
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\connsys\src\connsys_driver.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW5815.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\connsys\src\connsys_driver.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\connsys_driver.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\connsys_driver.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\connsys\src\connsys_driver.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          #include <stdio.h>
     36          #include <string.h>
     37          #include <errno.h>
     38          #include "type_def.h"
     39          #include "nvic.h"
     40          #include "cos_api.h"
     41          #include "hal_gdma.h"
     42          #include "hal_nvic.h"
     43          #include "hal_lp.h"
     44          #include "dma_sw.h"
     45          #include "misc.h"
     46          #include "connsys_driver.h"
     47          #include "connsys_bus.h"
     48          #include "connsys_util.h"
     49          #include "mt_cmd_fmt.h"
     50          #include <stdint.h>
     51          #include "memory_attribute.h"
     52          #include "hal.h"
     53          #include "hal_clock.h"
     54          #ifdef HAL_DCXO_MODULE_ENABLED
     55          #include "hal_dcxo.h"
     56          #endif
     57          
     58          #if (CFG_CONNSYS_MEASURE_INT_TIME_EN == 1)
     59          #include "gpt.h"
     60          #endif
     61          #include "syslog.h"
     62          #if (CFG_WIFI_HIF_GDMA_EN == 1)
     63          #include "dma_hw.h"
     64          #endif
     65          
     66          #if (CFG_CONNSYS_TRX_BALANCE_EN == 1)
     67          #include "net_task.h"
     68          #endif
     69          
     70          #include "connsys_adapter.h"
     71          #ifdef MTK_WIFI_ROM_ENABLE
     72          #include "patch_config_ram.h"
     73          #include "hal_spm.h"
     74          #endif
     75          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
     76          #include "hal_spm.h"
     77          #include "hal_eint.h"
     78          #include "hal_clock.h"
     79          #endif
     80          
     81          
     82          #ifdef MTK_WIFI_SLIM_ENABLE
     83          /* anthony */
     84          #define OVERRIDE_LOG
     85          #endif
     86          
     87          #include "connsys_log.h"
     88          
     89          
     90          #ifndef MTK_WIFI_SLIM_ENABLE
     91          void (*rx_interrupt_handle)(int32_t) = NULL;
     92          #else
     93          ATTR_ZIDATA_IN_TCM void (*rx_interrupt_handle)(int32_t) = NULL;
     94          #endif
     95          
     96          #ifndef MTK_WIFI_SLIM_ENABLE
     97          struct connsys_func g_connsys_func;
     98          #ifdef MTK_MINICLI_ENABLE
     99          static uint32_t g_whisr_val = 0;
    100          #endif
    101          #else
    102          ATTR_ZIDATA_IN_TCM struct connsys_func g_connsys_func;
    103          #ifdef MTK_MINICLI_ENABLE
    104          ATTR_ZIDATA_IN_TCM static uint32_t g_whisr_val = 0;
    105          #endif
    106          #endif
    107          
    108          extern bool hal_clock_fxo_is_26m(void);
    109          #ifndef MTK_WIFI_SLIM_ENABLE
    110          #if defined(__ICCARM__)
    111          ATTR_4BYTE_ALIGN enhance_mode_data_struct_t g_last_enhance_mode_data_struct;
    112          #else
    113          enhance_mode_data_struct_t g_last_enhance_mode_data_struct __attribute__((aligned(4)));
    114          #endif
    115          #else
    116          #if defined(__ICCARM__)
    117          ATTR_ZIDATA_IN_TCM ATTR_4BYTE_ALIGN enhance_mode_data_struct_t g_last_enhance_mode_data_struct;
    118          #else
    119          ATTR_ZIDATA_IN_TCM enhance_mode_data_struct_t g_last_enhance_mode_data_struct __attribute__((aligned(4)));
    120          #endif
    121          #endif
    122          
    123          
    124          #ifndef MTK_WIFI_SLIM_ENABLE
    125          wifi_hif_tx_flow_control_t g_hif_tx_flow_control_stat;
    126          uint8_t g_hif_tx_flow_ctrl_en = 0;
    127          connsys_balance_ctr_t g_balance_ctr;
    128          #else
    129          ATTR_ZIDATA_IN_TCM wifi_hif_tx_flow_control_t g_hif_tx_flow_control_stat;
    130          ATTR_ZIDATA_IN_TCM uint8_t g_hif_tx_flow_ctrl_en = 0;
    131          ATTR_ZIDATA_IN_TCM connsys_balance_ctr_t g_balance_ctr;
    132          #endif
    133          
    134          #ifndef MTK_WIFI_SLIM_ENABLE
    135          connsys_ops_t connsys_ops = NULL;
    136          #else
    137          ATTR_ZIDATA_IN_TCM connsys_ops_t connsys_ops = NULL;
    138          #endif
    139          
    140          #ifndef MTK_WIFI_SLIM_ENABLE
    141          #if (CFG_CONNSYS_MEASURE_INT_TIME_EN == 1 || defined(MTK_BSP_LOOPBACK_ENABLE))
    142          connsys_measure_time_t g_connsys_time_current;
    143          connsys_measure_time_t g_connsys_time_last;
    144          connsys_measure_time_t g_connsys_time_max;
    145          #endif
    146          #else
    147          #if (CFG_CONNSYS_MEASURE_INT_TIME_EN == 1 || defined(MTK_BSP_LOOPBACK_ENABLE))
    148          ATTR_ZIDATA_IN_TCM connsys_measure_time_t g_connsys_time_current;
    149          ATTR_ZIDATA_IN_TCM connsys_measure_time_t g_connsys_time_last;
    150          ATTR_ZIDATA_IN_TCM connsys_measure_time_t g_connsys_time_max;
    151          #endif
    152          #endif
    153          
    154          #ifndef MTK_WIFI_SLIM_ENABLE
    155          connsys_stat_t g_connsys_stat;
    156          uint32_t g_connsys_debug_feature = 0;
    157          #else
    158          ATTR_ZIDATA_IN_TCM connsys_stat_t g_connsys_stat;
    159          ATTR_ZIDATA_IN_TCM uint32_t g_connsys_debug_feature = 0;
    160          #endif
    161          
    162          #if defined(MTK_HAL_LOWPOWER_ENABLE)
    163          extern int8_t (*ptr_lp_connsys_get_own_enable_int)(void);
    164          extern int8_t (*ptr_lp_connsys_give_n9_own)(void);
    165          extern uint8_t (*ptr_connsys_get_ownership)(void);
    166          #endif
    167          
    168          #ifdef MTK_MINICLI_ENABLE
    169          void connsys_print_stat(void)
    170          {
    171              connsys_stat_t stat;
    172              uint32_t flags;
    173              uint32_t port = 0;
    174          
    175              local_irq_save(flags);
    176              memcpy(&stat, &g_connsys_stat, sizeof(connsys_stat_t));
    177              local_irq_restore(flags);
    178          
    179              printf("==>connsys_print_stat\n");
    180              printf("number of interrupt: %u\n", (unsigned int)stat.number_of_int);
    181              printf("number of tx interrupt: %u\n", (unsigned int)stat.num_of_tx_int);
    182              printf("number of rx interrupt: %u\n", (unsigned int)stat.num_of_rx_int);
    183              printf("number of tx wait: %u\n", (unsigned int)stat.num_of_tx_wait);
    184              printf("number of abnormal interrupt: %u\n", (unsigned int)stat.number_of_abnormal_int);
    185              printf("number fw_own_back: %u\n", (unsigned int)stat.number_of_fw_own_back);
    186          
    187              for (port = 0; port < NUM_OF_WIFI_HIF_RX_PORT; port++) {
    188                  printf("port index:%u\n", (unsigned int)port);
    189                  printf("\trx_packet_cnt:%u\n", (unsigned int)stat.rx_port[port].rx_packet_cnt);
    190                  printf("\trx_invalid_sz_packet_cnt:%u\n", (unsigned int)stat.rx_port[port].rx_invalid_sz_packet_cnt);
    191                  printf("\trx_max_invalid_sz:%u\n", (unsigned int)stat.rx_port[port].rx_max_invalid_sz);
    192                  printf("\trx_error_cnt:%u\n", (unsigned int)stat.rx_port[port].rx_error_cnt);
    193                  printf("\trx_allocate_fail_cnt:%u\n", (unsigned int)stat.rx_port[port].rx_allocate_fail_cnt);
    194              }
    195          }
    196          
    197          void connsys_dump_cr(void)
    198          {
    199              uint32_t value;
    200          
    201              printf("==>connsys_dump_cr\n");
    202          
    203              connsys_cr_read(WHLPCR, &value);
    204              printf("WHLPCR(0x%x): 0x%x\n", WHLPCR, (unsigned int)value);
    205              printf("\tW_INT_EN_SET:%u\n", (value & W_INT_EN_SET) ? 1 : 0);
    206              printf("\tW_INT_EN_CLR:%u\n", (value & W_INT_EN_CLR) ? 1 : 0);
    207          
    208              connsys_cr_read(WHCR, &value);
    209              printf("WHCR(0x%x): 0x%x\n", WHCR, (unsigned int)value);
    210              printf("\tRX_ENHANCE_MODE:%u\n", (value & RX_ENHANCE_MODE) ? 1 : 0);
    211              printf("\tMAX_HIF_RX_LEN_NUM:%u\n", (unsigned int)((value & MAX_HIF_RX_LEN_NUM_MASK) >> MAX_HIF_RX_LEN_NUM_OFFSET));
    212          
    213              printf("dump last intr enhance mode whisr\n");
    214              value = g_last_enhance_mode_data_struct.WHISR_reg_val;
    215              printf("WHISR(0x%x): 0x%x\n", WHISR, (unsigned int)value);
    216              printf("\tTX_DONE_INT:%u\n", (value & TX_DONE_INT) ? 1 : 0);
    217              printf("\tRX0_DONE_INT:%u\n", (value & RX0_DONE_INT) ? 1 : 0);
    218              printf("\tRX1_DONE_INT:%u\n", (value & RX1_DONE_INT) ? 1 : 0);
    219              printf("\tABNORMAL_INT:%u\n", (value & ABNORMAL_INT) ? 1 : 0);
    220              printf("\tFW_OWN_BACK_INT:%u\n", (value & FW_OWN_BACK_INT) ? 1 : 0);
    221          
    222              printf("dump last read whisr by cmd\n");
    223              value = g_whisr_val;
    224              printf("WHISR(0x%x): 0x%x\n", WHISR, (unsigned int)value);
    225              printf("\tTX_DONE_INT:%u\n", (value & TX_DONE_INT) ? 1 : 0);
    226              printf("\tRX0_DONE_INT:%u\n", (value & RX0_DONE_INT) ? 1 : 0);
    227              printf("\tRX1_DONE_INT:%u\n", (value & RX1_DONE_INT) ? 1 : 0);
    228              printf("\tABNORMAL_INT:%u\n", (value & ABNORMAL_INT) ? 1 : 0);
    229              printf("\tFW_OWN_BACK_INT:%u\n", (value & FW_OWN_BACK_INT) ? 1 : 0);
    230          
    231          
    232              connsys_cr_read(WHIER, &value);
    233              printf("WHIER(0x%x): 0x%x\n", WHIER, (unsigned int)value);
    234              printf("\tTX_DONE_INT_EN :%u\n", (value & TX_DONE_INT_EN) ? 1 : 0);
    235              printf("\tRX0_DONE_INT_EN :%u\n", (value & RX0_DONE_INT_EN) ? 1 : 0);
    236              printf("\tRX1_DONE_INT_EN :%u\n", (value & RX1_DONE_INT_EN) ? 1 : 0);
    237              printf("\tABNORMAL_INT_EN :%u\n", (value & ABNORMAL_INT_EN) ? 1 : 0);
    238              printf("\tFW_OWN_BACK_INT_EN :%u\n", (value & FW_OWN_BACK_INT_EN) ? 1 : 0);
    239          
    240              connsys_cr_read(WASR, &value);
    241              printf("WASR(0x%x): 0x%x\n", WASR, (unsigned int)value);
    242              printf("\tTX1_OVERFLOW :%u\n", (value & TX1_OVERFLOW) ? 1 : 0);
    243              printf("\tRX0_UNDERFLOW :%u\n", (value & RX0_UNDERFLOW) ? 1 : 0);
    244              printf("\tRX1_UNDERFLOW :%u\n", (value & RX1_UNDERFLOW) ? 1 : 0);
    245              printf("\tWASR2 :%u\n", (value & WASR_WASR2) ? 1 : 0);
    246          
    247              connsys_cr_read(WASR2, &value);
    248              printf("WASR2(0x%x): 0x%x (Note: all fields are read clear)\n", WASR2, (unsigned int)value);
    249              printf("\tWASR2_CMD53_ERR_CNT :%u\n",
    250                     (unsigned int)((value & WASR2_CMD53_ERR_CNT_MASK) >> WASR2_CMD53_ERR_CNT_OFFSET));
    251              printf("\tWASR2_CMD53_ERR :%u\n", (value & WASR2_CMD53_ERR) ? 1 : 0);
    252              printf("\tWASR2_CMD53_RD_TIMEOUT :%u\n", (value & WASR2_CMD53_RD_TIMEOUT) ? 1 : 0);
    253              printf("\tWASR2_CMD53_WR_TIMEOUT :%u\n", (value & WASR2_CMD53_WR_TIMEOUT) ? 1 : 0);
    254              printf("\tWASR2_FW_OWN_INVALID_ACCESS :%u\n", (value & WASR2_FW_OWN_INVALID_ACCESS) ? 1 : 0);
    255          }
    256          
    257          void connsys_dump_whisr(void)
    258          {
    259              uint32_t value;
    260          
    261              printf("==>connsys_dump_whisr\n");
    262              connsys_cr_read(WHISR, &value);
    263              g_whisr_val = value;
    264              printf("WHISR(0x%x): 0x%x\n", WHISR, (unsigned int)value);
    265              printf("\tTX_DONE_INT:%u\n", (value & TX_DONE_INT) ? 1 : 0);
    266              printf("\tRX0_DONE_INT:%u\n", (value & RX0_DONE_INT) ? 1 : 0);
    267              printf("\tRX1_DONE_INT:%u\n", (value & RX1_DONE_INT) ? 1 : 0);
    268              printf("\tABNORMAL_INT:%u\n", (value & ABNORMAL_INT) ? 1 : 0);
    269              printf("\tFW_OWN_BACK_INT:%u\n", (value & FW_OWN_BACK_INT) ? 1 : 0);
    270          }
    271          #endif
    272          
    273          
    274          #if (CFG_CONNSYS_MEASURE_INT_TIME_EN == 1 || defined(MTK_BSP_LOOPBACK_ENABLE))
    275          uint32_t connsys_measure_convert2ms(uint32_t count)
    276          {
    277              uint32_t ret;
    278              if (count) {
    279                  ret = count / (192 * 1000);
    280              } else {
    281                  ret = 0;
    282              }
    283              return ret;
    284          }
    285          
    286          void connsys_measure_time_init(void)
    287          {
    288              CM4_GPT4Init();
    289              GPT_Stop(4);
    290              GPT_Start(4);
    291          }
    292          
    293          void connsys_measure_time_finish(void)
    294          {
    295              uint32_t flags;
    296          
    297              local_irq_save(flags);
    298              memcpy(&g_connsys_time_last,
    299                     &g_connsys_time_current,
    300                     sizeof(connsys_measure_time_t));
    301          
    302          #if 0
    303              for (i = 0; i < CFG_CONNSYS_MEASURE_TIME_NUM; i++) {
    304                  if (g_connsys_time_max.time[i] < g_connsys_time_last.time[i]) {
    305                      g_connsys_time_max.time[i] = g_connsys_time_last.time[i];
    306                  }
    307              }
    308          
    309              for (i = 0; i < NUM_OF_WIFI_HIF_RX_PORT; i++) {
    310                  if (g_connsys_time_max.pkt_cnt[i] < g_connsys_time_last.pkt_cnt[i]) {
    311                      g_connsys_time_max.pkt_cnt[i] = g_connsys_time_last.pkt_cnt[i];
    312                  }
    313              }
    314          #endif
    315              if (g_connsys_time_max.time[3] < g_connsys_time_last.time[3]) {
    316                  memcpy(&g_connsys_time_max,
    317                         &g_connsys_time_last,
    318                         sizeof(connsys_measure_time_t));
    319              }
    320              local_irq_restore(flags);
    321          }
    322          
    323          
    324          void connsys_measure_time_set(uint8_t idx)
    325          {
    326              uint32_t flags;
    327              local_irq_save(flags);
    328              g_connsys_time_current.time[idx] = GPT_return_current_count(4);
    329              local_irq_restore(flags);
    330          }
    331          
    332          void connsys_measure_time_set_pkt_time(uint8_t port, uint8_t idx)
    333          {
    334              uint32_t flags;
    335              local_irq_save(flags);
    336              g_connsys_time_current.pkt_time[port][idx] = GPT_return_current_count(4);
    337              local_irq_restore(flags);
    338          }
    339          
    340          void connsys_measure_time_set_pkt_num(uint8_t port, uint8_t num)
    341          {
    342              uint32_t flags;
    343              local_irq_save(flags);
    344              g_connsys_time_current.pkt_cnt[port] = num;
    345              local_irq_restore(flags);
    346          }
    347          
    348          #ifdef MTK_MINICLI_ENABLE
    349          void connsys_measure_time_show(void)
    350          {
    351              connsys_measure_time_t tmp;
    352              uint32_t flags;
    353              uint32_t i;
    354              uint32_t port;
    355          
    356              printf("==>connsys_measure_time_show\n");
    357              local_irq_save(flags);
    358              memcpy(&tmp, &g_connsys_time_last, sizeof(connsys_measure_time_t));
    359              local_irq_restore(flags);
    360              printf("last measure time:\n");
    361              for (i = 0; i < CFG_CONNSYS_MEASURE_TIME_NUM; i++) {
    362                  printf("%u: %u count, %u ms\n",
    363                         (unsigned int)i,
    364                         (unsigned int)tmp.time[i],
    365                         (unsigned int)connsys_measure_convert2ms(tmp.time[i]));
    366              }
    367              printf("detail pkt time:\n");
    368          
    369              for (port = 0; port < NUM_OF_WIFI_HIF_RX_PORT; port ++) {
    370                  printf("p[%u]:\n", (unsigned int)port);
    371                  printf("\tmax pkt num: %u\n", (unsigned int)tmp.pkt_cnt[port]);
    372                  for (i = 0; i < tmp.pkt_cnt[port]; i++) {
    373                      printf("\tidx %u, %u count, %u ms\n",
    374                             (unsigned int)i,
    375                             (unsigned int)tmp.pkt_time[port][i],
    376                             (unsigned int)connsys_measure_convert2ms(tmp.pkt_time[port][i]));
    377                  }
    378              }
    379          
    380              local_irq_save(flags);
    381              memcpy(&tmp, &g_connsys_time_max, sizeof(connsys_measure_time_t));
    382              local_irq_restore(flags);
    383              printf("max measure time:\n");
    384              for (i = 0; i < CFG_CONNSYS_MEASURE_TIME_NUM; i++) {
    385                  printf("%u: %u count, %u ms\n",
    386                         (unsigned int)i,
    387                         (unsigned int)tmp.time[i],
    388                         (unsigned int)connsys_measure_convert2ms(tmp.time[i]));
    389              }
    390              printf("detail pkt time:\n");
    391          
    392              for (port = 0; port < NUM_OF_WIFI_HIF_RX_PORT; port ++) {
    393                  printf("p[%u]:\n", (unsigned int)port);
    394                  printf("\tmax pkt num: %u\n", (unsigned int)tmp.pkt_cnt[port]);
    395                  for (i = 0; i < tmp.pkt_cnt[port]; i++) {
    396                      printf("\t%u: %u count, %u ms\n",
    397                             (unsigned int)i,
    398                             (unsigned int)tmp.pkt_time[port][i],
    399                             (unsigned int)connsys_measure_convert2ms(tmp.pkt_time[port][i]));
    400                  }
    401              }
    402          }
    403          #endif // end of MTK_MINICLI_ENABLE
    404          
    405          #endif
    406          #ifdef MT5932_SINGLE_CONTEXT
    407          void wifi_crit_enter(u_int32 *flags)
    408          {
    409              local_irq_save(*flags);
    410              //INFO(connsys, "En\n");
    411          #if 0
    412              if (net_pkt_semaphore == NULL) {
    413                  ERR(connsys, "ERROR! inband not init yet, lock fail\n");
    414                  return;
    415              }
    416          
    417              if (xSemaphoreTake(net_pkt_semaphore, 10) == 0)  {
    418           //  if (xSemaphoreTakeFromISR(net_pkt_semaphore, 0) == 0) {
    419                  ERR(connsys, "ERROR! semaphore take fail, unlock fail\n");
    420                  return;
    421              }
    422          #endif
    423              //INFO(connsys, "Ex\n");
    424          }
    425          void wifi_crit_exit(u_int32 *flags)
    426          {
    427              local_irq_restore(*flags);
    428          //    INFO(connsys, "Ex1\n");
    429          #if 0
    430              if (net_pkt_semaphore == NULL) {
    431                  ERR(connsys, "ERROR! inband not init yet, unlock fail\n");
    432                  return;
    433              }
    434              xSemaphoreGive(net_pkt_semaphore);
    435          #endif
    436              //INFO(connsys, "Ex2\n");
    437          }
    438          #endif
    439          
    440          uint32_t connsys_get_stat_int_count(void)
    441          {
    442              uint32_t flags;
    443              uint32_t number_of_int;
    444          
    445              local_irq_save(flags);
    446              number_of_int = g_connsys_stat.number_of_int;
    447              local_irq_restore(flags);
    448          
    449              return number_of_int;
    450          }
    451          
    452          int32_t connsys_cccr_read(uint32_t addr, uint8_t *value)
    453          {
    454              int32_t ret = 0;
    455              struct connsys_func *dev_func = &g_connsys_func;
    456          
    457              connsys_bus_get_bus(dev_func);
    458              *value = connsys_bus_fn0_read_byte(dev_func, addr, &ret);
    459              connsys_bus_release_bus(dev_func);
    460              if (ret) {
    461                  ERR(connsys, "<<%s>> Read CCCR 0x%02x failed. Error = %d\n",
    462                        __FUNCTION__,
    463                        (unsigned int)addr,
    464                        (int)ret);
    465              }
    466              return ret;
    467          }
    468          
    469          int32_t connsys_cccr_write(uint32_t addr, uint8_t value)
    470          {
    471              int32_t ret = CONNSYS_STATUS_SUCCESS;
    472              struct connsys_func *dev_func = &g_connsys_func;
    473          
    474              connsys_bus_get_bus(dev_func);
    475              connsys_bus_fn0_write_byte(dev_func, value, addr, &ret);
    476              connsys_bus_release_bus(dev_func);
    477          
    478              if (ret) {
    479                  ERR(connsys, "<<%s>> Write register 0x%02x failed. Error = %d\n",
    480                        __FUNCTION__,
    481                        (unsigned int)addr,
    482                        (int)ret);
    483              }
    484          
    485              return ret;
    486          }
    487          
    488          int32_t connsys_cr_read(uint32_t addr, uint32_t *value)
    489          {
    490          
    491              int32_t ret = CONNSYS_STATUS_SUCCESS;
    492              struct connsys_func *dev_func = &g_connsys_func;
    493          
    494              connsys_bus_get_bus(dev_func);
    495              *value = connsys_bus_readl(dev_func, addr, &ret);
    496              connsys_bus_release_bus(dev_func);
    497          
    498              /* ret never be non-zero
    499                  if (ret)
    500                  {
    501                      ERR(connsys, "<<%s>> Read register 0x%08x failed. Error = %d\n",
    502                          __FUNCTION__,
    503                          (unsigned int)addr,
    504                          (int)ret);
    505                  }
    506                  */
    507          
    508              return ret;
    509          }
    510          
    511          int32_t connsys_cr_write(uint32_t addr, uint32_t value)
    512          {
    513              int32_t ret = CONNSYS_STATUS_SUCCESS;
    514              struct connsys_func *dev_func = &g_connsys_func;
    515          
    516              connsys_bus_get_bus(dev_func);
    517              connsys_bus_writel(dev_func, value, addr, &ret);
    518              connsys_bus_release_bus(dev_func);
    519          
    520              /* comment this statement because ret never be non-zero value
    521                  if (ret)
    522                  {
    523                      ERR(connsys, "<<%s>> Write register 0x%08x failed. Error = %d\n",
    524                          __FUNCTION__,
    525                          (unsigned int)addr,
    526                          (int)ret);
    527                  }
    528              */
    529              return ret;
    530          }
    531          
    532          /*
    533             use to read data
    534             @ addr:  WRDR0 / WRDR1/ WHISR
    535          */
    536          int32_t connsys_fifo_read(uint32_t addr, uint8_t *buf, size_t size)
    537          {
    538              int32_t ret = CONNSYS_STATUS_SUCCESS;
    539              struct connsys_func *dev_func = &g_connsys_func;
    540          
    541              ret = connsys_bus_read_port(dev_func, buf, addr, size);
    542              if (ret) {
    543                  ERR(connsys, "<<%s>> SDIO read data failed. Error = %d \n", __FUNCTION__, (int)ret);
    544                  ret = CONNSYS_STATUS_FAIL;
    545              }
    546              return ret;
    547          }
    548          
    549          /*use to write data*/
    550          int32_t connsys_fifo_write(uint8_t *buf, size_t size)
    551          {
    552              int32_t ret = CONNSYS_STATUS_SUCCESS;
    553              struct connsys_func *dev_func = &g_connsys_func;
    554              ret = connsys_bus_write_port(dev_func, WTDR1, buf, size);
    555              return ret;
    556          }
    557          
    558          void connsys_driver_interrupt(struct connsys_func *func)
    559          {
    560              (void) func; // avoid compiler warning
    561              if (connsys_ops && connsys_ops->enqueue_bottom_half) {
    562                  // 0. Disable HIF TX/RX Interrupt
    563                  connsys_disable_interrupt();       //connsys_cr_write(WHLPCR, W_INT_EN_CLR)
    564                  connsys_disable_whier_trx_int();   //WHIER, val &= ~(TX_DONE_INT_EN | RX0_DONE_INT_EN | RX1_DONE_INT_EN);
    565                  connsys_ops->enqueue_bottom_half(0, (PNETFUNC)connsys_util_intr_enhance_mode_receive_data);
    566              }
    567          
    568              return;
    569          }
    570          
    571          #if (CFG_CONNSYS_POLLING_IRQ_EN == 1)
    572          uint32_t connsys_polling_irq(int32_t max_tries)
    573          {
    574              int32_t count = 0;
    575          
    576              INFO(connsys, "Waiting for IRQ...\n");
    577          
    578              while (!g_connsys_func.irq_info.irq_assert) {
    579          
    580                  //g_connsys_func.irq_handler(&g_connsys_func);
    581                  if (count++ > max_tries) {
    582                      break;
    583                  }
    584                  cos_delay_time(CONNSYS_POLLING_DELAY_TIME);; //delay 50us
    585              }
    586          
    587              if (g_connsys_func.irq_info.irq_assert) {
    588                  g_connsys_func.irq_info.irq_assert = 0;
    589                  INFO(connsys, "WHISR: 0x%x\n", (unsigned int)g_connsys_func.irq_info.irq_data.WHISR_reg_val);
    590                  return 1; //g_connsys_func.irq_info.irq_data.WHISR_reg_val;
    591              }
    592              INFO(connsys, "==> No interrupt for %d loops.FUN[%d](0x%p) irq_asset=%d\n",
    593                    (int)count,
    594                    (int)g_connsys_func.num,
    595                    (void *)&g_connsys_func,
    596                    (int)g_connsys_func.irq_info.irq_assert);
    597              return 0;
    598          }
    599          #endif
    600          
    601          uint8_t connsys_giveup_ownership(void)
    602          {
    603              uint32_t value, counter = 0, addr;
    604              int32_t ret;
    605              uint8_t status = TRUE;
    606          
    607              addr = WHLPCR;
    608          
    609              // 1. check if it is already driver own
    610              ret = connsys_cr_read(addr, &value);
    611              if (ret) {
    612                  ERR(connsys, "Ownership read failed.\n");
    613                  goto err;
    614              }
    615          
    616              if (GET_W_FW_OWN_REQ_SET(value)) {
    617                  // give up owner ship
    618                  value |= W_FW_OWN_REQ_SET;
    619                  ret = connsys_cr_write(addr, value);
    620                  if (ret) {
    621                      LOG_E(connsys, "request owner ship write fail\n");
    622                      goto err;
    623                  }
    624          
    625                  // check if the ownership in FW
    626                  counter = 0;
    627                  while (GET_W_FW_OWN_REQ_SET(value)) {
    628                      if (counter > 200000) { // wait for at least 1 second
    629                          status = FALSE;
    630                          break;
    631                      }
    632                      //udelay(50); //delay 50us
    633          
    634                      ret = connsys_cr_read(addr, &value);
    635                      if (ret) {
    636                          goto err;
    637                      }
    638                      counter++;
    639                  }
    640              }
    641          
    642          err:
    643              /*io read/write fail*/
    644              if (ret) {
    645                  status = FALSE;
    646              }
    647              LOG_I(connsys, "Give up Own Bit, succ(%d), value(0x%x)\n", (int)status, (int)value);
    648              return status;
    649          }
    650          
    651          uint8_t connsys_get_ownership(void)
    652          {
    653              uint32_t value = 0, counter = 0, addr = 0;
    654              int32_t ret = 0;
    655              uint8_t status = TRUE;
    656          
    657              addr = WHLPCR;
    658              // 1. check if it is already driver own
    659              ret = connsys_cr_read(addr, &value);
    660              if (ret) {
    661                  ERR(connsys, "Read WHLPCR org value fail.\n");
    662                  goto err;
    663              }
    664          
    665              if (!GET_W_FW_OWN_REQ_SET(value)) {
    666                  // request owner ship
    667                  value |= W_FW_OWN_REQ_CLR;
    668                  ret = connsys_cr_write(addr, value);
    669                  if (ret) {
    670                      ERR(connsys, "Write WHLPCR own_req fail\n");
    671                      goto err;
    672                  }
    673          
    674                  // check if the ownership back
    675                  counter = 0;
    676                  while (!GET_W_FW_OWN_REQ_SET(value)) {
    677                      if (counter > 200000) { // wait for at least 1 second
    678                          status = FALSE;
    679                          break;
    680                      }
    681                      //udelay(50); //delay 50us
    682          
    683                      ret = connsys_cr_read(addr, &value);
    684                      if (ret) {
    685                          LOG_E(connsys, "Read WHLPCR end value fail.\n");
    686                          goto err;
    687                      }
    688                      counter++;
    689                  }
    690              }
    691          
    692          err:
    693              /*io read/write fail*/
    694              if (ret) {
    695                  status = FALSE;
    696              }
    697              LOG_I(connsys, "Get Own Bit, succ(%d), value(0x%x)\n", (int)status, (int)value);
    698              return status;
    699          }
    700          
    701          int32_t connsys_abnormal_interrupt_check(uint32_t value)
    702          {
    703              uint32_t reason;
    704              int32_t err = CONNSYS_STATUS_SUCCESS;
    705          
    706              if (value & ABNORMAL_INT) {
    707                  err = connsys_cr_read(WASR, &reason);
    708                  if (err) {
    709                      ERR(connsys, "<<%s>> Read WASR failed. Error = %d.\n", __FUNCTION__, (int)err);
    710                  } else {
    711                      INFO(connsys, "<<%s>> Read WASR = %08x.\n", __FUNCTION__, (unsigned int)reason);
    712                  }
    713              }
    714              return err;
    715          }
    716          
    717          
    718          /*
    719          void connsys_irq_handler(hal_nvic_irq_t irq_number)
    720          {
    721              uint8_t input[LEN_INT_ENHANCE_MODE] __attribute__ ((aligned (4)));
    722              uint32_t flags;
    723              enhance_mode_data_struct_t *p_int_enhance;
    724          #if (CONNSYS_DEBUG_MODE_EN == 1)
    725              g_connsys_stat.number_of_int ++;
    726          #endif
    727              connsys_disable_interrupt();
    728          
    729          #if (CFG_CONNSYS_MEASURE_INT_TIME_EN == 1)
    730              connsys_measure_time_init();
    731          #endif
    732              connsys_disable_whier_trx_int();
    733          
    734              memset(input, 0, sizeof(input));
    735              connsys_fifo_read(WHISR, (uint8_t *)input, LEN_INT_ENHANCE_MODE);
    736              p_int_enhance = (enhance_mode_data_struct_t *)input;
    737          
    738              if (p_int_enhance->WHISR_reg_val == 0)
    739              {
    740                  ERR(connsys, "WHISR=0x%x, abort...\n", (unsigned int)p_int_enhance->WHISR_reg_val);
    741                  connsys_cr_write(WHLPCR, W_INT_EN_SET);
    742                  connsys_enable_interrupt();
    743                  return;
    744              }
    745          
    746          #if (CONNSYS_DEBUG_MODE_EN == 1)
    747              if ((p_int_enhance->WHISR_reg_val) & ABNORMAL_INT)
    748              {
    749                  uint32_t reg1, reg2;
    750                  connsys_cr_read(WASR, &reg1);
    751                  connsys_cr_read(0xE0, &reg2);
    752                  local_irq_save(flags);
    753                  g_connsys_stat.number_of_abnormal_int ++;
    754                  local_irq_restore(flags);
    755                  //ERR(connsys, "Abnormal(0x%x), 0xE0(0x%x)\n", (unsigned int)reg1, (unsigned int)reg2);
    756              }
    757          
    758              if ((p_int_enhance->WHISR_reg_val) & FW_OWN_BACK_INT)
    759              {
    760                  uint32_t reg1;
    761                  connsys_cr_read(WASR, &reg1);
    762                  local_irq_save(flags);
    763                  g_connsys_stat.number_of_fw_own_back ++;
    764                  local_irq_restore(flags);
    765                  //ERR(connsys, "FW_OWN_BACK_INT: WASR(0x%x)\n", (unsigned int)reg1);
    766              }
    767          #endif
    768          
    769              if ((p_int_enhance->WHISR_reg_val) & TX_DONE_INT)
    770              {
    771          #if (CONNSYS_DEBUG_MODE_EN == 1)
    772                  g_connsys_stat.num_of_tx_int ++;
    773          #endif
    774                  connsys_tx_flow_control_update_free_page_cnt(p_int_enhance);
    775              }
    776          
    777              if ((p_int_enhance->WHISR_reg_val) & (RX0_DONE_INT | RX1_DONE_INT))
    778              {
    779                  if (((p_int_enhance->WHISR_reg_val) & TX_DONE_INT) == 0)
    780                  {
    781                      connsys_tx_flow_control_update_free_page_cnt(p_int_enhance);
    782                  }
    783          #if (CONNSYS_DEBUG_MODE_EN == 1)
    784                  g_connsys_stat.num_of_rx_int ++;
    785          #endif
    786                  local_irq_save(flags);
    787                  memcpy(&g_last_enhance_mode_data_struct, input, LEN_INT_ENHANCE_MODE);
    788          #if (CFG_CONNSYS_TRX_BALANCE_EN == 1)
    789                  g_balance_ctr.fg_rx_wait = TRUE;
    790          #endif
    791                  local_irq_restore(flags);
    792                  g_connsys_func.irq_callback(&g_connsys_func);
    793              }
    794              else
    795              {
    796                  connsys_enalbe_whier_rx_int();
    797              }
    798              connsys_enalbe_whier_tx_int();
    799              connsys_enable_interrupt();
    800          #if (CFG_CONNSYS_MEASURE_INT_TIME_EN == 1)
    801              connsys_measure_time_set(1);
    802          #endif
    803              return;
    804          }
    805          */
    806          
    807          
    808          void connsys_irq_handler(hal_nvic_irq_t irq_number)
    809          {
    810              // 1. Record Debug Information if need
    811          #if (CONNSYS_DEBUG_MODE_EN == 1)
    812              g_connsys_stat.number_of_int ++;
    813          #endif
    814          
    815          #if (CFG_CONNSYS_MEASURE_INT_TIME_EN == 1)
    816              connsys_measure_time_init();
    817          #endif
    818          
    819              // 2. Notify HIF Packet Handler
    820              g_connsys_func.irq_callback(&g_connsys_func);  //Add to netjob task
    821          
    822              // 3. Enable Interrupt - It will be implemented by netjob callback (TX/RX Packet Handler)
    823          
    824          #if (CFG_CONNSYS_MEASURE_INT_TIME_EN == 1)
    825              connsys_measure_time_set(1);
    826          #endif
    827          
    828              return;
    829          }
    830          
    831          void connsys_set_register_value(uint32_t address, short int mask, short int shift, short int value) {
    832              uint32_t mask_buffer;
    833              mask_buffer = (~(mask << shift));
    834              *((volatile uint32_t *)(address)) &=mask_buffer;
    835              *((volatile uint32_t *)(address)) |=(value << shift);
    836          }
    837          
    838          uint32_t connsys_get_register_value(uint32_t address, short int mask, short int shift) {
    839              uint32_t get_value, mask_buffer;
    840              mask_buffer = (mask << shift);
    841              get_value = *((volatile uint32_t *)(address));
    842              get_value &=mask_buffer;
    843              get_value = (get_value>> shift);
    844              return get_value;
    845          }
    846          
    847          int32_t connsys_enable_enhance_mode(void)
    848          {
    849              uint32_t reg_value = 0;
    850          
    851              /* enable RX enhance mode */
    852          
    853              INFO(connsys, "enable connsys enhance mode.\n");
    854          
    855              if (connsys_cr_read(WHCR, &reg_value)) {
    856                  ERR(connsys, "FAIL. read WHCR.\n");
    857                  return -1;
    858              }
    859          //    reg_value |= W_INT_CLR_CTRL;
    860              reg_value &= ~MAX_HIF_RX_LEN_NUM_MASK;
    861              reg_value |= MAX_HIF_RX_LEN_NUM(CFG_MAX_HIF_RX_LEN_NUM);
    862          //    reg_value |= RX_ENHANCE_MODE;
    863          
    864          #if (CFG_RPT_OWN_RX_PACKET_LEN_EN == 1)
    865              reg_value |= RPT_OWN_RX_PACKET_LEN;
    866          #endif
    867          
    868              INFO(connsys, "write 0x%x to WHCR\n", (unsigned int)reg_value);
    869          
    870              if (connsys_cr_write(WHCR, reg_value)) {
    871                  ERR(connsys, "FAIL. write WHCR.\n");
    872                  return -1;
    873              }
    874              reg_value = 0;
    875              if (connsys_cr_read(WHCR, &reg_value)) {
    876                  ERR(connsys, "FAIL. read WHCR.\n");
    877                  return -1;
    878              } else {
    879          #if 0
    880                  if (!(reg_value & RX_ENHANCE_MODE)) {
    881                      ERR(connsys, "FAIL. write RX_ENHANCE_MODE fail. WHCR = 0x%08x.\n", (unsigned int)reg_value);
    882                      return -1;
    883                  }
    884          #endif
    885              }
    886          //    INFO(connsys, "Enable enhance mode, WHCR=0x%x\n", (unsigned int)reg_value);
    887          
    888          #if (CFG_RPT_OWN_RX_PACKET_LEN_EN == 1)
    889              reg_value = (RX0_RPT_PKT_LEN(CFG_RX0_RPT_PKT_LEN) |
    890                           (RX1_RPT_PKT_LEN(CFG_RX1_RPT_PKT_LEN);
    891              if (connsys_cr_write(WPLRCR, reg_value)) {
    892                  ERR(connsys, "FAIL. write WPLRCR.\n");
    893                  return -1;
    894              }
    895          #endif
    896              return 0;
    897          }
    898          
    899          #if (CFG_WIFI_HIF_GDMA_EN == 1)
    900          void connsys_enable_dma(void)
    901          {
    902              INFO(connsys, "==>connsys_enable_dma\n");
    903              g_connsys_func.use_dma = 1;
    904          }
    905          #endif
    906          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
    907          #include "hal_gdma.h"
    908          void connsys_dma_callback(hal_gdma_event_t event, void  *user_data)
    909          {
    910              INFO(connsys, "DMA callback\n");
    911          }
    912          // mt7686
    913          #define EINT_SENS_SET0 0xA2100368
    914          #define EINT_SENS_CLR0 0xA2100370
    915          #define EINT_MASK_SET0 0xA2100328
    916          #define EINT_MASK_CLR0 0xA2100330
    917          
    918          void SET_EINT_SENS(int num, int value)
    919          {
    920              unsigned int * pReg;
    921              if (value == 0) {
    922                  pReg = (unsigned int *)((unsigned int) EINT_SENS_CLR0);
    923              } else {
    924                  pReg = (unsigned int *)((unsigned int) EINT_SENS_SET0);
    925              }
    926              *pReg = (1 << num);
    927          }
    928          
    929          void SET_EINT_MASK(int num, int value)
    930          {
    931              unsigned int * pReg;
    932              if (value == 0) {
    933                  pReg = (unsigned int *)((unsigned int) EINT_MASK_CLR0);
    934              } else {
    935                  pReg = (unsigned int *)((unsigned int) EINT_MASK_SET0);
    936              }
    937              *pReg = (1 << num);
    938          }
    939          #else
    940              // MT7687
    941          void connsys_dma_callback()
    942          {
    943              INFO(connsys, "DMA callback\n");
    944          }
    945          #endif
    946          
    947          #if (INTERRUPT_BASED_SUPPORT == 1)
    948          void send_msg_to_wifi_task();
    949          
    950          #define LP_HWIS0R            0xc0b1003c//(WIFI_INT_BASE + 0x003C)
    951          
    952          void wifi_irq_handler(hal_nvic_irq_t irq_number)
    953          {
    954              NVIC_DisableIRQ(CONNSYS1_IRQn);
    955              //INFO(connsys, "0x%x\n", HAL_REG_32(LP_HWIS0R));
    956              send_msg_to_wifi_task();
    957              return;
    958          }
    959          void wifi_enable_irq()
    960          {
    961              NVIC_EnableIRQ(CONNSYS1_IRQn);
    962          }
    963          
    964          #include "hal_eint.h"
    965          #if (MT7682_WSAP00023897 == 1)
    966          void wifi_eint_handler(void *parameter)
    967          {
    968              //INFO(connsys, "[EINT]Wifi_eint_handler\n");
    969          }
    970          #endif
    971          void register_wifi_intr_handler()
    972          {
    973              //INFO(connsys, "++++++++++++++\n\n Raghav: Register isr: %d\n+++++++++\n",CONNSYS1_IRQn);
    974              hal_nvic_register_isr_handler(CONNSYS1_IRQn, wifi_irq_handler);
    975              NVIC_SetPriority(CONNSYS1_IRQn, CM4_HIF_PRI);
    976              NVIC_EnableIRQ(CONNSYS1_IRQn);
    977          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
    978          #if (MT7682_WSAP00023897 == 0)
    979              SET_EINT_SENS(CONNSYS1_IRQn, 1);
    980              SET_EINT_MASK(CONNSYS1_IRQn, 0);
    981              //hal_eint_set_trigger_mode(CONNSYS1_IRQn,HAL_EINT_EDGE_RISING);
    982          #else
    983              hal_eint_config_t config_set;
    984              config_set.trigger_mode = HAL_EINT_LEVEL_LOW;
    985              config_set.debounce_time = 0;
    986              hal_eint_init(HAL_EINT_MAC,&config_set);
    987              hal_eint_register_callback(HAL_EINT_MAC,wifi_eint_handler,NULL);
    988              //hal_eint_mask(HAL_EINT_MAC);
    989          #endif
    990          
    991          #endif
    992          
    993          }
    994          
    995          
    996          
    997          void connsys_register_wifi_irq()
    998          {
    999              register_wifi_intr_handler();
   1000          }
   1001          #endif
   1002          
   1003          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
   1004          void connsys_eint_handler(void *parameter)
   1005          {
   1006              // Don't Remove! It's used to wakeup CM4 tickless mode.
   1007              INFO(connsys, "[EINT] connsys_eint_handler\n");
   1008          }
   1009          #endif
   1010          
   1011          int32_t connsys_open()
   1012          {
   1013              struct connsys_func *func = &g_connsys_func;
   1014              int32_t             ret   = CONNSYS_STATUS_SUCCESS;
   1015          
   1016          #if defined(MTK_HAL_LOWPOWER_ENABLE)
   1017              ptr_lp_connsys_get_own_enable_int   = lp_connsys_get_own_enable_int;
   1018              ptr_lp_connsys_give_n9_own          = lp_connsys_give_n9_own;
   1019              ptr_connsys_get_ownership           = connsys_get_ownership;
   1020          #endif
   1021          
   1022              g_connsys_func.blksize = MY_CONNSYS_BLOCK_SIZE;
   1023              g_connsys_func.num = SDIO_GEN3_FUNCTION_WIFI;
   1024              g_connsys_func.irq_callback = NULL;
   1025          #if (CFG_WIFI_HIF_GDMA_EN == 1)
   1026              g_connsys_func.use_dma = 1;
   1027          #else
   1028              g_connsys_func.use_dma = 0;
   1029          #endif
   1030          
   1031          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
   1032              // Hard code use dma to do MT7686 FW download - need discuss with Michael
   1033              g_connsys_func.use_dma = 1;
   1034          #endif
   1035              // Enable GDMA
   1036              if (g_connsys_func.use_dma) {
   1037          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
   1038          	    hal_gdma_init(CONNSYS_GDMA_CH);
   1039          	    hal_gdma_register_callback(CONNSYS_GDMA_CH, connsys_dma_callback, NULL);
   1040          	    // Enable GDMA
   1041                  hal_clock_enable(HAL_CLOCK_CG_DMA);
   1042          #else
   1043                  // MT7687
   1044                  DMA_Init();
   1045                  DMA_Register(CONNSYS_GDMA_CH, connsys_dma_callback);
   1046          
   1047          #endif
   1048              }
   1049          
   1050          
   1051          
   1052              INFO(connsys, "============> SDIO open, (0x%p) use DMA(%d)\n",
   1053                    &g_connsys_func, (int)g_connsys_func.use_dma);
   1054          
   1055              // function enable
   1056              connsys_bus_get_bus(func);
   1057              ret = connsys_bus_enable_func(func);
   1058              connsys_bus_release_bus(func);
   1059              if (ret) {
   1060                  ERR(connsys, "<<%s>> Enable function failed. Error = %d.\n", __FUNCTION__, (int)ret);
   1061                  goto err;
   1062              }
   1063          
   1064              // set block size
   1065              connsys_bus_get_bus(func);
   1066              ret = connsys_bus_set_block_size(func, func->blksize);
   1067              connsys_bus_release_bus(func);
   1068          
   1069              if (ret) {
   1070                  ERR(connsys, "<<%s>> Set block size failed. Error = %d.\n", __FUNCTION__, (int)ret);
   1071                  goto err;
   1072              }
   1073          
   1074              // register sdio irq
   1075              connsys_bus_get_bus(func);
   1076              ret = connsys_bus_get_irq(func, &connsys_driver_interrupt); /* Interrupt IRQ handler */
   1077              connsys_bus_release_bus(func);
   1078              if (ret) {
   1079                  ERR(connsys, "<<%s>> Claim irq failed. Error = %d.\n", __FUNCTION__, (int)ret);
   1080                  goto err;
   1081              }
   1082          
   1083              // register to MCU IRQ
   1084              hal_nvic_register_isr_handler(CM4_HIF_IRQ, connsys_irq_handler);
   1085              NVIC_SetPriority(CM4_HIF_IRQ, CM4_HIF_PRI);
   1086              NVIC_EnableIRQ(CM4_HIF_IRQ);
   1087          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
   1088              // Register HAL_EINT_HIF as wakeup source for CM4 tickless mode.
   1089              hal_eint_config_t config1;
   1090              config1.trigger_mode = HAL_EINT_LEVEL_LOW;
   1091              config1.debounce_time = 0;
   1092              hal_eint_init(HAL_EINT_HIF, &config1); //set EINT trigger mode and debounce time.
   1093              hal_eint_register_callback(HAL_EINT_HIF, connsys_eint_handler, NULL); // register a user callback.
   1094              // EINT unmask by SPM module if CM4 enter tickless mode
   1095              //hal_eint_unmask(HAL_EINT_HIF);
   1096          #endif
   1097          
   1098              // Bug fixed for ownbit initial value (1) error
   1099              connsys_giveup_ownership();
   1100          
   1101              if (connsys_get_ownership() == FALSE) {
   1102                  ERR(connsys, "connsys_get_ownership failed.\n");
   1103                  ret = -1;
   1104                  goto err;
   1105              }
   1106              if (connsys_enable_enhance_mode() != 0) {
   1107                  ERR(connsys, "connsys_enable_enhance_mode failed.\n");
   1108                  ret = -1;
   1109                  goto err;
   1110              }
   1111              connsys_tx_flow_control_init();
   1112          
   1113          #if (CFG_CONNSYS_TRX_BALANCE_EN == 1)
   1114              connnsys_balance_init();
   1115          #endif
   1116          
   1117              if (connsys_cr_write(WHIER, (RX0_DONE_INT_EN | RX1_DONE_INT_EN))) {
   1118                  ERR(connsys, "FAIL. write WHIER failed (1).\n");
   1119                  ret = CONNSYS_STATUS_FAIL;
   1120                  goto err;
   1121              } else {
   1122                  uint32_t reg_value = 0;
   1123                  connsys_cr_read(WHISR, &reg_value);
   1124          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
   1125                  if ((reg_value & (RX0_DONE_INT_EN))) {
   1126                      ERR(connsys, "FAIL. WHISR.RX0_DONE interrupt should be cleared first. (2). WHISR = 0x%08x.\n", (unsigned int)reg_value);
   1127                      ret = CONNSYS_STATUS_FAIL;
   1128                      goto err;
   1129                  }
   1130          #else
   1131                  if ((reg_value & (RX0_DONE_INT_EN | RX1_DONE_INT_EN))) {
   1132                      ERR(connsys, "FAIL. WHISR.RX0/1_DONE interrupt should be cleared first. (2). WHISR = 0x%08x.\n", (unsigned int)reg_value);
   1133                      ret = CONNSYS_STATUS_FAIL;
   1134                      goto err;
   1135                  }
   1136          #endif
   1137                  reg_value = 0;
   1138                  connsys_cr_read(WHIER, &reg_value);
   1139                  if (!(reg_value & (RX0_DONE_INT_EN | RX1_DONE_INT_EN))) {
   1140                      ERR(connsys, "FAIL. write WHIER failed (2). WHIER = 0x%08x.\n", (unsigned int)reg_value);
   1141                      ret = CONNSYS_STATUS_FAIL;
   1142                      goto err;
   1143                  }
   1144              }
   1145          err:
   1146              return ret;
   1147          }
   1148          
   1149          int32_t connsys_close()
   1150          {
   1151              struct connsys_func *func = &g_connsys_func;
   1152              int32_t             ret = CONNSYS_STATUS_SUCCESS;
   1153          
   1154          
   1155              if (g_connsys_func.use_dma) {
   1156                  DMA_UnRegister(CONNSYS_GDMA_CH);
   1157              }
   1158          
   1159              // release sdio irq
   1160              connsys_bus_get_bus(func);
   1161              ret = connsys_bus_release_irq(func);
   1162              connsys_bus_release_bus(func);
   1163              if (ret) {
   1164                  ERR(connsys, "<<%s>> Release irq failed. Error = %d.\n", __FUNCTION__, (int)ret);
   1165              }
   1166          
   1167              // disable function
   1168              connsys_bus_get_bus(func);
   1169              ret =  connsys_bus_disable_func(func);
   1170              connsys_bus_release_bus(func);
   1171              if (ret) {
   1172                  ERR(connsys, "<<%s>> Disable function failed. Error = %d.\n", __FUNCTION__, (int)ret);
   1173              }
   1174          
   1175              INFO(connsys, "<<%s>> Yes. Release Done.\n", __FUNCTION__);
   1176          
   1177              return ret;
   1178          }
   1179          
   1180          int32_t connsys_disable_interrupt(void)
   1181          {
   1182              int32_t ret;
   1183              ret = connsys_cr_write(WHLPCR, W_INT_EN_CLR);
   1184              return ret;
   1185          }
   1186          
   1187          int32_t connsys_enable_interrupt(void)
   1188          {
   1189              connsys_cr_write(WHLPCR, W_INT_EN_SET);
   1190              return CONNSYS_STATUS_SUCCESS;
   1191          }
   1192          
   1193          void connsys_disable_whier_trx_int(void)
   1194          {
   1195              uint32_t flags;
   1196              uint32_t val;
   1197              local_irq_save(flags);
   1198              connsys_cr_read(WHIER, &val);
   1199              val &= ~(TX_DONE_INT_EN | RX0_DONE_INT_EN | RX1_DONE_INT_EN);
   1200              connsys_cr_write(WHIER, val);
   1201              local_irq_restore(flags);
   1202          }
   1203          
   1204          void connsys_enalbe_whier_rx_int(void)
   1205          {
   1206              uint32_t flags;
   1207              uint32_t val;
   1208              local_irq_save(flags);
   1209              connsys_cr_read(WHIER, &val);
   1210              val |= (RX0_DONE_INT_EN | RX1_DONE_INT_EN);
   1211              connsys_cr_write(WHIER, val);
   1212              local_irq_restore(flags);
   1213          }
   1214          
   1215          void connsys_enalbe_whier_tx_int(void)
   1216          {
   1217              uint32_t flags;
   1218              uint32_t val;
   1219              local_irq_save(flags);
   1220              connsys_cr_read(WHIER, &val);
   1221              val |= (TX_DONE_INT_EN);
   1222              connsys_cr_write(WHIER, val);
   1223              local_irq_restore(flags);
   1224          }
   1225          
   1226          void connsys_tx_flow_control_init(void)
   1227          {
   1228              uint32_t flags;
   1229              local_irq_save(flags);
   1230              memset(&g_hif_tx_flow_control_stat, 0, sizeof(wifi_hif_tx_flow_control_t));
   1231              g_hif_tx_flow_control_stat.reserve_quota_page_cnt = DEFAULT_N9_PSE_PAGE_QUOTA;
   1232              g_hif_tx_flow_control_stat.page_sz = DEFAULT_N9_PSE_PAGE_SIZE;
   1233              g_hif_tx_flow_control_stat.available_page_cnt = DEFAULT_N9_PSE_PAGE_QUOTA;
   1234              g_hif_tx_flow_ctrl_en = 1;
   1235              local_irq_restore(flags);
   1236          }
   1237          
   1238          uint32_t connsys_tx_flow_control_get_page_size(void)
   1239          {
   1240              uint32_t flags;
   1241              uint32_t page_size;
   1242              local_irq_save(flags);
   1243              page_size = g_hif_tx_flow_control_stat.page_sz;
   1244              local_irq_restore(flags);
   1245              return page_size;
   1246          }
   1247          
   1248          #ifdef MTK_CM4_WIFI_TASK_ENABLE
   1249          extern int Send_Directly_To_lmac;
   1250          #endif
   1251          uint32_t connsys_tx_flow_control_update_free_page_cnt(void)
   1252          {
   1253              uint32_t  flags;
   1254              uint32_t  cr_wtqcr7 = 0;
   1255              wifi_hif_tx_flow_control_t *ctrl = &g_hif_tx_flow_control_stat;
   1256          
   1257              // Disable Interrupt
   1258              local_irq_save(flags);
   1259          
   1260              // Read WLAN TXQ Count Register 7 (For N9 only use this now)
   1261          
   1262          #ifdef MTK_CM4_WIFI_TASK_ENABLE
   1263          #ifdef SEND_DIRECLY_TO_LMAC
   1264              if(Send_Directly_To_lmac == 0)
   1265              {
   1266                  connsys_cr_read(WTQCR7, &cr_wtqcr7);
   1267              }
   1268              else
   1269          #endif
   1270              {
   1271          #if 0
   1272                  uint32_t  check_val,i;
   1273                  for(i=0x0130;i<=0x014C;i+=4)
   1274                  {
   1275                      connsys_cr_read(i,&check_val);
   1276          
   1277                      if(i==0x014c)
   1278                      cr_wtqcr7 = check_val;
   1279          
   1280                      if(i==0x0130)
   1281                      cr_wtqcr0 = check_val;
   1282                  }
   1283          
   1284                  if(cr_wtqcr7 == 65537)
   1285                      cr_wtqcr7 = 0;
   1286          
   1287                  if(cr_wtqcr0!=0 && cr_wtqcr7 == 0)
   1288                  {
   1289                      cr_wtqcr7 = cr_wtqcr0;
   1290                  }
   1291          
   1292          #else
   1293                      /*Need to read Status from WTQCR0 - sending to LMAC ,WTQCR1 - Beacon,WTQCR7- will have total info*/
   1294                      uint32_t read_val,i;
   1295                      for(i = WTQCR0; i <= WTQCR7; i+=0x4)
   1296                      {
   1297                          connsys_cr_read(i,&read_val);
   1298                      }
   1299                      cr_wtqcr7 = read_val;//Need to write WTQCR7 val
   1300          #endif
   1301          
   1302          
   1303              }
   1304          #else
   1305          #if (PRODUCT_VERSION == 5932 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 7686)
   1306              /*Need to read Status from WTQCR0 - sending to LMAC ,WTQCR1 - Beacon,WTQCR7- will have total info*/
   1307              uint32_t read_val,i;
   1308              for(i = WTQCR0; i <= WTQCR7; i+=0x4)
   1309              {
   1310                  connsys_cr_read(i,&read_val);
   1311              }
   1312              cr_wtqcr7 = read_val;//Need to write WTQCR7 val
   1313          #else
   1314                  // MT7687
   1315              connsys_cr_read(WTQCR7, &cr_wtqcr7);
   1316          #endif
   1317          #endif
   1318          
   1319          #if (CONNSYS_DEBUG_MODE_EN == 1)
   1320              ctrl->free_page_cnt_by_wifi_txq[WIFI_TXQ_CNT_IDX_14_TXCFFA] += (cr_wtqcr7 & 0xffff);
   1321              ctrl->free_page_cnt_by_wifi_txq[WIFI_TXQ_CNT_IDX_15_TXCCPU] += ((cr_wtqcr7 & (0xffffU << 16U)) >> 16U);
   1322              ctrl->total_free_page_cnt += (cr_wtqcr7 & 0xffff);
   1323          #endif
   1324          
   1325              // Update Current Page Count
   1326              ctrl->current_page_cnt -= (cr_wtqcr7 & 0xffff);
   1327          
   1328              // Update Available Page Count
   1329              ctrl->available_page_cnt = ctrl->reserve_quota_page_cnt - ctrl->current_page_cnt;
   1330          
   1331              // Enable Interrupt
   1332              local_irq_restore(flags);
   1333          
   1334              return (cr_wtqcr7 & 0xffff);
   1335          }
   1336          
   1337          int32_t connsys_tx_flow_control_check_and_update_tx(int32_t port, uint32_t pkt_len)
   1338          {
   1339              uint32_t flags;
   1340              uint32_t send_page = 0;
   1341              int32_t ret = CONNSYS_STATUS_SUCCESS;
   1342              wifi_hif_tx_flow_control_t *ctrl = &g_hif_tx_flow_control_stat;
   1343          
   1344              //added by guofu
   1345              if (0 == ctrl->page_sz) {
   1346                  return CONNSYS_STATUS_FAIL;
   1347              }
   1348          
   1349              local_irq_save(flags);
   1350              send_page = pkt_len / ctrl->page_sz;
   1351          
   1352              if ((pkt_len % ctrl->page_sz) > 0) {
   1353                  send_page ++;
   1354              }
   1355          
   1356          #if (CONNSYS_DEBUG_MODE_EN == 1)
   1357              if (g_hif_tx_flow_ctrl_en) {
   1358                  if (send_page <= ctrl->available_page_cnt) {
   1359                      ctrl->send_page_cnt_by_tx_port[port] += send_page;
   1360                      ctrl->total_send_page_cnt += send_page;
   1361                      ctrl->send_pkt_cnt_by_tx_port[port] ++;
   1362                      ctrl->total_send_pkt_cnt ++;
   1363          
   1364                      ctrl->current_page_cnt += send_page;
   1365          
   1366                      if (ctrl->max_page_cnt < ctrl->current_page_cnt) {
   1367                          ctrl->max_page_cnt = ctrl->current_page_cnt;
   1368                      }
   1369          
   1370                      ctrl->available_page_cnt =
   1371                          ctrl->reserve_quota_page_cnt - ctrl->current_page_cnt;
   1372          
   1373                      ret = CONNSYS_STATUS_SUCCESS;
   1374                  } else {
   1375                      ctrl->total_drop_pkt_cnt ++;
   1376                      ret = CONNSYS_STATUS_FAIL;
   1377                  }
   1378              } else {
   1379                  ctrl->send_page_cnt_by_tx_port[port] += send_page;
   1380                  ctrl->total_send_page_cnt += send_page;
   1381                  ctrl->send_pkt_cnt_by_tx_port[port] ++;
   1382                  ctrl->total_send_pkt_cnt ++;
   1383          
   1384                  ctrl->current_page_cnt += send_page;
   1385          
   1386                  if (ctrl->max_page_cnt < ctrl->current_page_cnt) {
   1387                      ctrl->max_page_cnt = ctrl->current_page_cnt;
   1388                  }
   1389          
   1390                  ctrl->available_page_cnt =
   1391                      ctrl->reserve_quota_page_cnt - ctrl->current_page_cnt;
   1392                  ret = CONNSYS_STATUS_SUCCESS;
   1393              }
   1394          #else
   1395              if (send_page <= ctrl->available_page_cnt) {
   1396                  ctrl->current_page_cnt += send_page;
   1397                  ctrl->available_page_cnt =
   1398                      ctrl->reserve_quota_page_cnt - ctrl->current_page_cnt;
   1399                  ret = CONNSYS_STATUS_SUCCESS;
   1400              } else {
   1401                  ctrl->total_drop_pkt_cnt ++;
   1402                  ret = CONNSYS_STATUS_FAIL;
   1403              }
   1404          #endif /* (CONNSYS_DEBUG_MODE_EN == 1) */
   1405          
   1406              local_irq_restore(flags);
   1407          
   1408              return ret;
   1409          }
   1410          
   1411          void connsys_tx_flow_control_config(uint8_t hif_tx_flow_ctrl_en)
   1412          {
   1413              uint32_t flags;
   1414              INFO(connsys, "==>connsys_tx_flow_control_config, hif_tx_flow_ctrl_en = %u\n",
   1415                    (unsigned int)hif_tx_flow_ctrl_en);
   1416              local_irq_save(flags);
   1417              g_hif_tx_flow_ctrl_en = hif_tx_flow_ctrl_en;
   1418              local_irq_restore(flags);
   1419          }
   1420          
   1421          void connsys_tx_flow_control_set_reserve_page(uint32_t reserve_page)
   1422          {
   1423              uint32_t flags;
   1424              wifi_hif_tx_flow_control_t *ctrl = &g_hif_tx_flow_control_stat;
   1425              INFO(connsys, "==>connsys_tx_flow_control_set_reserve_page, reserve_page = %u\n",
   1426                    (unsigned int)reserve_page);
   1427              local_irq_save(flags);
   1428              ctrl->reserve_quota_page_cnt = reserve_page;
   1429              ctrl->available_page_cnt =
   1430                  ctrl->reserve_quota_page_cnt - ctrl->current_page_cnt;
   1431              local_irq_restore(flags);
   1432          }
   1433          
   1434          
   1435          void connsys_tx_flow_control_set_reserve_page_by_cr(void)
   1436          {
   1437              uint32_t flags;
   1438              wifi_hif_tx_flow_control_t *ctrl = &g_hif_tx_flow_control_stat;
   1439              local_irq_save(flags);
   1440              ctrl->reserve_quota_page_cnt = connsys_util_pse_get_p0_min_resv();
   1441              ctrl->available_page_cnt =
   1442                  ctrl->reserve_quota_page_cnt - ctrl->current_page_cnt;
   1443              local_irq_restore(flags);
   1444          }
   1445          
   1446          
   1447          #ifdef MTK_MINICLI_ENABLE
   1448          void connsys_tx_flow_control_show_info(void)
   1449          {
   1450              uint32_t flags;
   1451              uint32_t port;
   1452              uint32_t txq_idx;
   1453              wifi_hif_tx_flow_control_t wifi_hif_tx_flow_control;
   1454              local_irq_save(flags);
   1455              memcpy(&wifi_hif_tx_flow_control,
   1456                     &g_hif_tx_flow_control_stat,
   1457                     sizeof(wifi_hif_tx_flow_control_t));
   1458              local_irq_restore(flags);
   1459          
   1460              printf("==>connsys_tx_flow_control_show_info\n");
   1461          
   1462          
   1463              printf("total_send_pkt_cnt: %u\n", (unsigned int)wifi_hif_tx_flow_control.total_send_pkt_cnt);
   1464              printf("send_pkt_cnt_by_tx_port: \n");
   1465              for (port = 0; port < NUM_OF_WIFI_HIF_TX_PORT; port++) {
   1466                  printf("\t[%u]: %u\n",
   1467                         (unsigned int)port ,
   1468                         (unsigned int)wifi_hif_tx_flow_control.send_pkt_cnt_by_tx_port[port]);
   1469              }
   1470          
   1471              printf("total_send_page_cnt: %u\n", (unsigned int)wifi_hif_tx_flow_control.total_send_page_cnt);
   1472              printf("send_page_cnt_by_tx_port: \n");
   1473              for (port = 0; port < NUM_OF_WIFI_HIF_TX_PORT; port++) {
   1474                  printf("\t[%u]: %u\n",
   1475                         (unsigned int)port,
   1476                         (unsigned int)wifi_hif_tx_flow_control.send_page_cnt_by_tx_port[port]);
   1477              }
   1478          
   1479          
   1480              printf("total_free_page_cnt: %u\n", (unsigned int)wifi_hif_tx_flow_control.total_free_page_cnt);
   1481              printf("free_page_cnt_by_wifi_txq: \n");
   1482              for (txq_idx = 0; txq_idx < NUM_OF_WIFI_TXQ; txq_idx ++) {
   1483                  printf("[%2u]:%8u\t",
   1484                         (unsigned int)txq_idx,
   1485                         (unsigned int)wifi_hif_tx_flow_control.free_page_cnt_by_wifi_txq[txq_idx]);
   1486                  if ((txq_idx % 4) == 3) {
   1487                      printf("\n");
   1488                  }
   1489              }
   1490              printf("available_page_cnt: %u\n", (int)wifi_hif_tx_flow_control.available_page_cnt);
   1491              printf("current_page_cnt: %d\n", (int)wifi_hif_tx_flow_control.current_page_cnt);
   1492              printf("max_page_cnt: %d\n", (int)wifi_hif_tx_flow_control.max_page_cnt);
   1493              printf("reserve_quota_page_cnt: %u\n", (unsigned int)wifi_hif_tx_flow_control.reserve_quota_page_cnt);
   1494              printf("page_sz: %u\n", (unsigned int)wifi_hif_tx_flow_control.page_sz);
   1495              printf("total_drop_pkt_cnt: %u\n", (unsigned int)wifi_hif_tx_flow_control.total_drop_pkt_cnt);
   1496              printf("g_hif_tx_flow_ctrl_en: %u\n", (unsigned int)g_hif_tx_flow_ctrl_en);
   1497          }
   1498          
   1499          void connsys_show_config_option(void)
   1500          {
   1501              printf("==>connsys_show_config_option\n");
   1502              printf("CONNSYS_MAX_RX_PKT_SIZE = %u\n", CONNSYS_MAX_RX_PKT_SIZE);
   1503              printf("MY_CONNSYS_BLOCK_SIZE = %u\n", MY_CONNSYS_BLOCK_SIZE);
   1504              printf("CFG_WIFI_HIF_GDMA_EN = %u\n", CFG_WIFI_HIF_GDMA_EN);
   1505              printf("CFG_CONNSYS_IOT_RX_ZERO_COPY_EN = %u\n", CFG_CONNSYS_IOT_RX_ZERO_COPY_EN);
   1506              printf("CFG_CONNSYS_IOT_TX_ZERO_COPY_EN = %u\n", CFG_CONNSYS_IOT_TX_ZERO_COPY_EN);
   1507          }
   1508          #endif
   1509          
   1510          /* Extra headroom lenght when N9 zero copy is enabled. */
   1511          static uint8_t EXTRA_HEADROOM_LEN_FOR_NON_QOS      = 38;
   1512          static uint8_t EXTRA_HEADROOM_LEN_FOR_QOS_ENABLE   = 42;
   1513          
   1514          uint32_t connsys_get_headroom_offset(uint8_t qos_enable)
   1515          {
   1516              if (qos_enable) {
   1517                  return EXTRA_HEADROOM_LEN_FOR_QOS_ENABLE;
   1518              }
   1519          
   1520              return EXTRA_HEADROOM_LEN_FOR_NON_QOS;
   1521          }
   1522          
   1523          void connsys_set_headroom_offset(uint8_t qos_enable, uint8_t offset)
   1524          {
   1525              if (qos_enable) {
   1526                  EXTRA_HEADROOM_LEN_FOR_QOS_ENABLE = offset;
   1527              } else {
   1528                  EXTRA_HEADROOM_LEN_FOR_NON_QOS = offset;
   1529              }
   1530          
   1531          }
   1532          /*
   1533          *Fot tickless
   1534          *Must open the FW_OWN_BACK_INT_EN before CM4 give own to N9
   1535          * return 0 succeed
   1536          */
   1537          int8_t lp_connsys_get_own_enable_int()
   1538          {
   1539              uint32_t flags = 0;
   1540              uint32_t reg_value = 0;
   1541              uint32_t counter = 0;
   1542          
   1543              if (connsys_get_ownership() == FALSE) {
   1544                  ERR(connsys, "FAIL get connsys ownership.\n");
   1545                  return -1;
   1546              }
   1547          
   1548              /* enable FW_OWN_BACK_INT interrupt */
   1549              local_irq_save(flags);
   1550              connsys_cr_read(WHIER, &reg_value);
   1551              reg_value |= FW_OWN_BACK_INT_EN;
   1552              connsys_cr_write(WHIER, reg_value);
   1553              local_irq_restore(flags);
   1554          
   1555              /*check int alrady open*/
   1556              reg_value = 0;
   1557              connsys_cr_read(WHIER, &reg_value);
   1558              while(!(reg_value & FW_OWN_BACK_INT_EN)) {
   1559                  if(counter > 2000) {
   1560                      ERR(connsys, "en own_back_int timeout.WHIER = 0x%08x \n", (unsigned int)reg_value);
   1561                      return -1;
   1562                  }
   1563                  connsys_cr_read(WHIER, &reg_value);
   1564                  counter ++;
   1565              }
   1566          
   1567              /* enable W_INT_EN_SET */
   1568              if(connsys_enable_interrupt()) {
   1569                  ERR(connsys, "Enable interrupt fail.\n");
   1570                  return -1;
   1571              }
   1572          
   1573              return 0;
   1574          }
   1575          
   1576          /*
   1577          *For tickless
   1578          *Must make sure own in N9 before CM4 sleep
   1579          *return 0 succeed
   1580          */
   1581          int8_t lp_connsys_give_n9_own()
   1582          {
   1583              uint32_t reg_value = 0, counter = 0;
   1584          
   1585              if (connsys_get_ownership() == FALSE) {
   1586                  ERR(connsys, "FAIL. get connsys ownership.\n");
   1587                  return -1;
   1588              }
   1589          
   1590              /* set ownership to fw */
   1591              if (connsys_cr_write(WHLPCR, W_FW_OWN_REQ_SET)) {
   1592                  ERR(connsys, "FAIL. write WHLPCR failed.\n");
   1593                  return -1;
   1594              }
   1595          
   1596              /* enable connsys interrupt */
   1597              if(connsys_enable_interrupt()) {
   1598                  ERR(connsys, "Enable interrupt fail.\n");
   1599                  return -1;
   1600              }
   1601          
   1602              /* check own in fw side */
   1603              counter = 0;
   1604              if(connsys_cr_read(WHLPCR, &reg_value)) {
   1605                  ERR(connsys, "FAIL. read WHLPCR failed.\n");
   1606                  return -1;
   1607              }
   1608              while (GET_W_FW_OWN_REQ_SET(reg_value)) {
   1609                  //loop until ownership not in driver or timeout
   1610                  if (counter > 2000) {
   1611                      LOG_E(connsys, "give own timeout.\n");
   1612                      return -1;
   1613                  }
   1614          
   1615                  if (connsys_cr_read(WHLPCR, &reg_value)) {
   1616                      LOG_E(connsys, "Read WHLPCR end value fail.\n");
   1617                      return -1;
   1618                  }
   1619                  counter++;
   1620              }
   1621          
   1622              return 0;
   1623          
   1624          }
   1625          
   1626          #if (MT7682_WSAP00020527 == 1)
   1627          #define     AON_TOP_AON_RSV 0xC00C1138
   1628          #define N9_HIF_RDY        BIT(15)
   1629          extern VOID (*setOpMode)(UINT32 OpMode);
   1630          extern int g_iot_init_done;
   1631          void radio_on_off(UCHAR Radio)
   1632          {
   1633              if (Radio == 1)
   1634              {
   1635                  HAL_REG_32(AON_TOP_AON_RSV) &= ~N9_HIF_RDY; //Need to reset this bit when doing radio off or fw reload.
   1636                  spm_control_mtcmos(SPM_MTCMOS_CONN,SPM_MTCMOS_PWR_DISABLE);
   1637              }
   1638              else
   1639              {
   1640                  g_iot_init_done = 1;
   1641                  setOpMode(0);
   1642              }
   1643          }
   1644          
   1645          uint32_t connsys_reload_fw()
   1646          {
   1647              HAL_REG_32(AON_TOP_AON_RSV) &= ~N9_HIF_RDY; //Need to reset this bit when doing radio off or fw reload.
   1648              spm_control_mtcmos(SPM_MTCMOS_CONN, SPM_MTCMOS_PWR_DISABLE);
   1649              spm_control_mtcmos(SPM_MTCMOS_CONN, SPM_MTCMOS_PWR_ENABLE);
   1650          
   1651              while(1)
   1652              {
   1653                  vTaskDelay(1 / portTICK_RATE_MS);//wifi_os_task_sleep(1);
   1654                  if (HAL_REG_32(N9ROM_INIT_DONE) == 1)
   1655                     break;
   1656              }
   1657              taskENTER_CRITICAL();
   1658          
   1659              connsys_open();
   1660              connsys_util_firmware_download();
   1661          
   1662          #if (MT7682_WSAP00020997 == 0)
   1663              g_connsys_func.use_dma = 0;
   1664          #endif
   1665          
   1666          #if 0
   1667              while(1)
   1668              {
   1669              if (HAL_REG_32(AON_TOP_AON_RSV) & N9_HIF_RDY)
   1670                  break;
   1671              }
   1672          #endif
   1673              connsys_tx_flow_control_set_reserve_page_by_cr();
   1674          
   1675              connsys_enable_interrupt();
   1676              taskEXIT_CRITICAL();
   1677              return TRUE;
   1678          }
   1679          
   1680          #endif
   1681          
   1682          
   1683          #if (PRODUCT_VERSION == 7687 || PRODUCT_VERSION == 7697)
   1684          int32_t connsys_init(sys_cfg_t *sys_config)
   1685          {
   1686          #if defined(MTK_HAL_LOWPOWER_ENABLE)
   1687              if ((hal_lp_get_wic_status()) || (1 == hal_lp_get_wic_wakeup())) {
   1688                  /* N9 MUST be active for clock switch and pinmux config*/
   1689                  /* Wakeup N9 by connsys ownership */
   1690                  connsys_open();
   1691                  connsys_close();
   1692              }
   1693          
   1694              ptr_lp_connsys_get_own_enable_int   = lp_connsys_get_own_enable_int;
   1695              ptr_lp_connsys_give_n9_own          = lp_connsys_give_n9_own;
   1696              ptr_connsys_get_ownership           = connsys_get_ownership;
   1697          #endif
   1698          
   1699              connsys_set_headroom_offset(CONNSYS_HEADROOM_OFFSET_QOS, 58);
   1700              connsys_set_headroom_offset(CONNSYS_HEADROOM_OFFSET_NON_QOS, 54);
   1701          
   1702              connsys_set_wifi_profile(sys_config);
   1703          
   1704              connsys_open();
   1705          
   1706          #if defined(MTK_HAL_LOWPOWER_ENABLE)
   1707              if ((hal_lp_get_wic_status() == 0) && (0 == hal_lp_get_wic_wakeup()))
   1708              {
   1709                  /* NO need to reload N9 patch and FW after wakeup from sleep */
   1710          #endif
   1711                  connsys_util_firmware_download();
   1712          #if defined(MTK_HAL_LOWPOWER_ENABLE)
   1713              }
   1714          #endif
   1715          
   1716          #if (CFG_WIFI_HIF_GDMA_EN == 1)
   1717              connsys_enable_dma();
   1718              /* Enable LWIP DMA copy */
   1719              if (hal_gdma_init(HAL_GDMA_CHANNEL_0) != HAL_GDMA_STATUS_OK)
   1720                  LOG_W(connsys, "WARN! LWIP DMA data copy disabled..\n");
   1721          
   1722              //hal_gdma_deinit();   // TODO?
   1723          #endif /* CFG_WIFI_HIF_GDMA_EN */
   1724          
   1725              connsys_tx_flow_control_set_reserve_page_by_cr();
   1726              //connsys_enable_interrupt();
   1727              connsys_disable_interrupt();
   1728          
   1729          #if (CFG_CONNSYS_TRX_BALANCE_EN == 1)
   1730              g_balance_ctr.rx_handle = NetJobGetTaskId();
   1731          #endif
   1732          
   1733              return 0;
   1734          }
   1735          
   1736          #endif /* (PRODUCT_VERSION == 7687 || PRODUCT_VERSION == 7697) */
   1737          
   1738          void connsys_disable_dma(void)
   1739          {
   1740              g_connsys_func.use_dma = 0;
   1741          }
   1742          
   1743          
   1744          #if (PRODUCT_VERSION == 5932 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 7686)
   1745          typedef enum _connsys_state_t
   1746          {
   1747              CONNSYS_STATE_UNINITIALIZED,
   1748              CONNSYS_STATE_READY,
   1749          } connsys_state_t;
   1750          
   1751          
   1752          /**
   1753           * MCU reset release procedure.
   1754           */
   1755          static void _connsys_init_activate_mcu(void)
   1756          {
   1757              //Enable N9 MTCMOS Power
   1758              spm_control_mtcmos(SPM_MTCMOS_CONN, SPM_MTCMOS_PWR_ENABLE);
   1759          
   1760              // Release SW reset of connsys
   1761              HAL_REG_32(CONNSYS_SW_RST) = 0x18;
   1762          
   1763              //Wait ROM Initialize done
   1764              while (HAL_REG_32(N9ROM_INIT_DONE) != 1)
   1765                  ;
   1766          }
   1767          
   1768          
   1769          static int32_t _connsys_early_open(void)
   1770          {
   1771              struct connsys_func *func = &g_connsys_func;
   1772              int32_t             ret   = CONNSYS_STATUS_SUCCESS;
   1773          
   1774              func->blksize       = MY_CONNSYS_BLOCK_SIZE;
   1775              func->num           = SDIO_GEN3_FUNCTION_WIFI;
   1776              func->irq_callback  = NULL;
   1777              func->use_dma       = 0;
   1778          
   1779          #if defined(MTK_HAL_LOWPOWER_ENABLE)
   1780              ptr_lp_connsys_get_own_enable_int   = lp_connsys_get_own_enable_int;
   1781              ptr_lp_connsys_give_n9_own          = lp_connsys_give_n9_own;
   1782              ptr_connsys_get_ownership           = connsys_get_ownership;
   1783          #endif
   1784          
   1785              // function enable
   1786              connsys_bus_get_bus(func);
   1787              ret = connsys_bus_enable_func(func);
   1788              connsys_bus_release_bus(func);
   1789              if (ret) {
   1790                  ERR(connsys, "enable function failed (%d)\n", (int)ret);
   1791                  goto err;
   1792              }
   1793          
   1794              // set block size
   1795              connsys_bus_get_bus(func);
   1796              ret = connsys_bus_set_block_size(func, func->blksize);
   1797              connsys_bus_release_bus(func);
   1798          
   1799              if (ret) {
   1800                  ERR(connsys, "set block size failed (%d)\n", (int)ret);
   1801                  goto err;
   1802              }
   1803          
   1804              // register sdio irq
   1805              connsys_bus_get_bus(func);
   1806              ret = connsys_bus_get_irq(func, &connsys_driver_interrupt); /* Interrupt IRQ handler */
   1807              connsys_bus_release_bus(func);
   1808              if (ret) {
   1809                  ERR(connsys, "claim irq failed (%d)\n", (int)ret);
   1810                  goto err;
   1811              }
   1812          
   1813              // Bug fixed for ownbit initial value (1) error
   1814              connsys_giveup_ownership();
   1815          
   1816              if (connsys_get_ownership() == FALSE) {
   1817                  ERR(connsys, "get ownership failed\n");
   1818                  ret = -1;
   1819                  goto err;
   1820              }
   1821          
   1822              connsys_tx_flow_control_init();
   1823          
   1824          err:
   1825              return ret;
   1826          }
   1827          
   1828          
   1829          static int32_t _connsys_early_close(void)
   1830          {
   1831              struct connsys_func *func = &g_connsys_func;
   1832              int32_t             ret   = CONNSYS_STATUS_SUCCESS;
   1833          
   1834              // release sdio irq
   1835              connsys_bus_get_bus(func);
   1836              ret = connsys_bus_release_irq(func);
   1837              connsys_bus_release_bus(func);
   1838              if (ret) {
   1839                  ERR(connsys, "release irq failed (%d)\n", (int)ret);
   1840              }
   1841          
   1842              // disable function
   1843              connsys_bus_get_bus(func);
   1844              ret = connsys_bus_disable_func(func);
   1845              connsys_bus_release_bus(func);
   1846              if (ret) {
   1847                  ERR(connsys, "disable function failed (%d)\n", (int)ret);
   1848              }
   1849          
   1850              return ret;
   1851          }
   1852          
   1853          
   1854          /**
   1855           * The connsys_init() performs initilization and basic settings of connsys.
   1856           * subsystem.
   1857           *
   1858           * connsys_init() can be used (invoked) in two different ways:
   1859           *
   1860           * 1. invoke two times: early init + late init
   1861           *
   1862           *    connsys_init(NULL);
   1863           *    connsys_init(&sysconfig);
   1864           *
   1865           * 2. invoke one time:  normal init (run both early init and late init)
   1866           *
   1867           *    connsys_init(&sysconfig);
   1868           *
   1869           * In both cases, PLL needs to be configured to full speed to allow baseband
   1870           * and RF to be initialized correctly.
   1871           */
   1872          int32_t connsys_init(sys_cfg_t *sys_config)
   1873          {
   1874              static ATTR_ZIDATA_IN_TCM connsys_state_t   _g_connsys_state = CONNSYS_STATE_UNINITIALIZED;
   1875          
   1876              ERR(connsys, "connsys state %u, sys_config 0x%08x\n",
   1877                              _g_connsys_state,
   1878                              sys_config);
   1879          
   1880              /* early init */
   1881          
   1882              if (_g_connsys_state == CONNSYS_STATE_UNINITIALIZED) {
   1883                  // release SW reset of connsys
   1884                  _connsys_init_activate_mcu();
   1885                  // setting xtal option to n9
   1886          #ifdef HAL_DCXO_MODULE_ENABLED
   1887                  bool connsys_xtal_type;
   1888                  connsys_xtal_type = hal_clock_fxo_is_26m(); //26M or 40M [false:40M ; true:26M]
   1889                  connsys_set_register_value((uint32_t)AON_TOP_AON_RSV2, XTAL_COMPILER_OPTION_TRAPPING_MASK, XTAL_COMPILER_OPTION_TRAPPING_SHIFT, !connsys_xtal_type);
   1890          #ifdef XO_3225
   1891                  connsys_set_register_value((uint32_t)AON_TOP_AON_RSV2, XTAL_COMPILER_OPTION_XO_MASK, XTAL_COMPILER_OPTION_XO_SHIFT,0);
   1892          #endif
   1893          #ifdef XO_2016
   1894                  connsys_set_register_value((uint32_t)AON_TOP_AON_RSV2, XTAL_COMPILER_OPTION_XO_MASK, XTAL_COMPILER_OPTION_XO_SHIFT,0x10);
   1895          #endif
   1896          #ifdef XO_2520
   1897                  connsys_set_register_value((uint32_t)AON_TOP_AON_RSV2, XTAL_COMPILER_OPTION_XO_MASK, XTAL_COMPILER_OPTION_XO_SHIFT,0x01);
   1898          #endif
   1899                  if (IS_External_32K)
   1900                  {
   1901                  	connsys_set_register_value((uint32_t)AON_TOP_AON_RSV2, XTAL_COMPILER_OPTION_CK_MASK, XTAL_COMPILER_OPTION_CK_SHIFT,0x0);
   1902                  }
   1903                  else
   1904                  {
   1905                  	connsys_set_register_value((uint32_t)AON_TOP_AON_RSV2, XTAL_COMPILER_OPTION_CK_MASK, XTAL_COMPILER_OPTION_CK_SHIFT,0x1);
   1906                  }
   1907          #endif
   1908                  connsys_set_headroom_offset(CONNSYS_HEADROOM_OFFSET_QOS,     58);
   1909                  connsys_set_headroom_offset(CONNSYS_HEADROOM_OFFSET_NON_QOS, 54);
   1910          
   1911                  _connsys_early_open();
   1912          
   1913                  connsys_util_firmware_download();
   1914          
   1915                  _connsys_early_close();
   1916          
   1917          #ifndef MTK_WIFI_SLIM_ENABLE
   1918                  _g_connsys_state = CONNSYS_STATE_READY;
   1919          #endif
   1920              }
   1921          
   1922              connsys_set_wifi_profile(sys_config);
   1923          
   1924              /* late init */
   1925          
   1926              if (_g_connsys_state == CONNSYS_STATE_READY || sys_config) {
   1927          
   1928                  connsys_open();
   1929          
   1930          #if (CFG_WIFI_HIF_GDMA_EN == 1)
   1931                  connsys_enable_dma();
   1932          
   1933                  /* Enable LWIP DMA copy */
   1934                  if (hal_gdma_init(HAL_GDMA_CHANNEL_0) != HAL_GDMA_STATUS_OK)
   1935                      LOG_W(connsys, "WARN! LWIP DMA data copy disabled..\n");
   1936          
   1937                  hal_gdma_deinit(HAL_GDMA_CHANNEL_0);   // TODO?
   1938          #endif
   1939          
   1940                  connsys_tx_flow_control_set_reserve_page_by_cr();
   1941          
   1942                  //int should be disable before connsys_ops initialized
   1943                  connsys_disable_interrupt();
   1944          
   1945          #if (CFG_CONNSYS_TRX_BALANCE_EN == 1)
   1946                  g_balance_ctr.rx_handle = NetJobGetTaskId();
   1947          #endif
   1948              }
   1949          
   1950          #ifdef MTK_WIFI_SLIM_ENABLE
   1951              /* should stop SLIM driver when normal uart driver is initialized */
   1952              connsys_util_uart_slim_enable(0);
   1953          #endif
   1954          
   1955              _g_connsys_state = CONNSYS_STATE_READY;
   1956          
   1957              return 0;
   1958          }
   1959          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_EnableIRQ
       4   NVIC_SetPriority
      32   connsys_abnormal_interrupt_check
        32   -- Indirect call
        32   -> connsys_cr_read
      40   connsys_cccr_read
        40   -- Indirect call
        40   -> connsys_bus_fn0_read_byte
        40   -> connsys_bus_get_bus
        40   -> connsys_bus_release_bus
      40   connsys_cccr_write
        40   -- Indirect call
        40   -> connsys_bus_fn0_write_byte
        40   -> connsys_bus_get_bus
        40   -> connsys_bus_release_bus
      32   connsys_close
        32   -- Indirect call
        32   -> DMA_UnRegister
        32   -> connsys_bus_disable_func
        32   -> connsys_bus_get_bus
        32   -> connsys_bus_release_bus
        32   -> connsys_bus_release_irq
      24   connsys_cr_read
        24   -> connsys_bus_get_bus
        24   -> connsys_bus_readl
        24   -> connsys_bus_release_bus
      24   connsys_cr_write
        24   -> connsys_bus_get_bus
        24   -> connsys_bus_release_bus
        24   -> connsys_bus_writel
       0   connsys_disable_dma
       0   connsys_disable_interrupt
         0   -> connsys_cr_write
      16   connsys_disable_whier_trx_int
        16   -> connsys_cr_read
        16   -> connsys_cr_write
      16   connsys_dma_callback
        16   -- Indirect call
       8   connsys_driver_interrupt
         0   -- Indirect call
         8   -> connsys_disable_interrupt
         8   -> connsys_disable_whier_trx_int
      40   connsys_dump_cr
        40   -> connsys_cr_read
        40   -> printf
       8   connsys_dump_whisr
         8   -> connsys_cr_read
         8   -> printf
      32   connsys_enable_enhance_mode
        32   -- Indirect call
        32   -> connsys_cr_read
        32   -> connsys_cr_write
       8   connsys_enable_interrupt
         8   -> connsys_cr_write
      16   connsys_enalbe_whier_rx_int
        16   -> connsys_cr_read
        16   -> connsys_cr_write
      16   connsys_enalbe_whier_tx_int
        16   -> connsys_cr_read
        16   -> connsys_cr_write
      24   connsys_fifo_read
        24   -- Indirect call
        24   -> connsys_bus_read_port
       0   connsys_fifo_write
         0   -> connsys_bus_write_port
       0   connsys_get_headroom_offset
      32   connsys_get_ownership
        32   -- Indirect call
        32   -> connsys_cr_read
        32   -> connsys_cr_write
       0   connsys_get_register_value
       0   connsys_get_stat_int_count
      32   connsys_giveup_ownership
        32   -- Indirect call
        32   -> connsys_cr_read
        32   -> connsys_cr_write
       8   connsys_init
         8   -> connsys_close
         8   -> connsys_disable_interrupt
         8   -> connsys_open
         8   -> connsys_set_headroom_offset
         8   -> connsys_set_wifi_profile
         8   -> connsys_tx_flow_control_set_reserve_page_by_cr
         8   -> connsys_util_firmware_download
         8   -> hal_lp_get_wic_status
         8   -> hal_lp_get_wic_wakeup
       0   connsys_irq_handler
         0   -- Indirect call
      32   connsys_open
        32   -- Indirect call
        32   -> NVIC_EnableIRQ
        32   -> NVIC_SetPriority
        32   -> connsys_bus_enable_func
        32   -> connsys_bus_get_bus
        32   -> connsys_bus_get_irq
        32   -> connsys_bus_release_bus
        32   -> connsys_bus_set_block_size
        32   -> connsys_cr_read
        32   -> connsys_cr_write
        32   -> connsys_enable_enhance_mode
        32   -> connsys_get_ownership
        32   -> connsys_giveup_ownership
        32   -> connsys_tx_flow_control_init
        32   -> hal_nvic_register_isr_handler
      88   connsys_print_stat
        88   -> __aeabi_memcpy4
        88   -> printf
       0   connsys_set_headroom_offset
       4   connsys_set_register_value
       8   connsys_show_config_option
         0   -> printf
         8   -> printf
      12   connsys_tx_flow_control_check_and_update_tx
      24   connsys_tx_flow_control_config
        24   -- Indirect call
       0   connsys_tx_flow_control_get_page_size
      16   connsys_tx_flow_control_init
        16   -> __aeabi_memset4
      24   connsys_tx_flow_control_set_reserve_page
        24   -- Indirect call
       8   connsys_tx_flow_control_set_reserve_page_by_cr
         8   -> connsys_util_pse_get_p0_min_resv
     128   connsys_tx_flow_control_show_info
       128   -> __aeabi_memcpy4
       128   -> printf
      16   connsys_tx_flow_control_update_free_page_cnt
        16   -> connsys_cr_read
      24   lp_connsys_get_own_enable_int
        24   -- Indirect call
        24   -> connsys_cr_read
        24   -> connsys_cr_write
        24   -> connsys_enable_interrupt
        24   -> connsys_get_ownership
      16   lp_connsys_give_n9_own
        16   -- Indirect call
        16   -> connsys_cr_read
        16   -> connsys_cr_write
        16   -> connsys_enable_interrupt
        16   -> connsys_get_ownership


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable139
       4  ??DataTable139_1
       4  ??DataTable139_2
       4  ??DataTable139_3
       4  ??DataTable143
       4  ??DataTable152
       4  ??DataTable153
       4  ??DataTable154
       4  ??DataTable155
       4  ??DataTable155_1
       4  ??DataTable155_10
       4  ??DataTable155_11
       4  ??DataTable155_12
       4  ??DataTable155_13
       4  ??DataTable155_14
       4  ??DataTable155_15
       4  ??DataTable155_2
       4  ??DataTable155_3
       4  ??DataTable155_4
       4  ??DataTable155_5
       4  ??DataTable155_6
       4  ??DataTable155_7
       4  ??DataTable155_8
       4  ??DataTable155_9
      24  ?_0
      28  ?_1
      24  ?_10
      32  ?_100
      44  ?_101
      24  ?_102
      32  ?_103
      28  ?_104
      28  ?_105
      20  ?_106
      20  ?_11
      28  ?_12
      20  ?_13
      20  ?_14
      20  ?_15
      20  ?_16
      20  ?_17
      24  ?_18
      24  ?_19
      28  ?_2
      36  ?_20
      20  ?_21
      20  ?_22
      20  ?_23
      20  ?_24
      20  ?_25
      24  ?_26
      32  ?_27
      20  ?_28
      24  ?_29
      28  ?_3
      24  ?_30
      24  ?_31
      24  ?_32
      28  ?_33
      20  ?_34
      20  ?_35
      20  ?_36
      20  ?_37
      12  ?_38
      56  ?_39
      24  ?_4
      28  ?_40
      24  ?_41
      32  ?_42
      32  ?_43
      36  ?_44
      24  ?_45
      44  ?_46
      52  ?_47
      44  ?_48
      24  ?_49
      36  ?_5
      32  ?_50
      40  ?_51
      32  ?_52
      28  ?_53
      32  ?_54
      36  ?_55
      40  ?_56
      28  ?_57
      32  ?_58
      20  ?_59
      24  ?_6
      20  ?_60
      20  ?_61
      16  ?_62
      48  ?_63
      44  ?_64
      44  ?_65
      40  ?_66
      32  ?_67
      40  ?_68
      32  ?_69
      16  ?_7
      80  ?_70
      48  ?_71
      40  ?_72
      48  ?_73
      28  ?_74
      64  ?_75
      64  ?_76
      40  ?_77
      24  ?_78
      28  ?_79
      20  ?_8
      12  ?_80
      28  ?_81
      28  ?_82
      28  ?_83
      32  ?_84
      12  ?_85
       2  ?_86
      24  ?_87
      24  ?_88
      20  ?_89
      32  ?_9
      28  ?_90
      16  ?_91
      24  ?_92
      28  ?_93
      32  ?_94
      32  ?_95
      28  ?_96
      28  ?_97
      40  ?_98
      40  ?_99
       2  EXTRA_HEADROOM_LEN_FOR_NON_QOS
          EXTRA_HEADROOM_LEN_FOR_QOS_ENABLE
      20  NVIC_EnableIRQ
      34  NVIC_SetPriority
      78  connsys_abnormal_interrupt_check
      84  connsys_cccr_read
      84  connsys_cccr_write
     150  connsys_close
      44  connsys_cr_read
      44  connsys_cr_write
      10  connsys_disable_dma
       6  connsys_disable_interrupt
      40  connsys_disable_whier_trx_int
      30  connsys_dma_callback
      44  connsys_driver_interrupt
     604  connsys_dump_cr
     118  connsys_dump_whisr
     190  connsys_enable_enhance_mode
      14  connsys_enable_interrupt
      40  connsys_enalbe_whier_rx_int
      40  connsys_enalbe_whier_tx_int
      58  connsys_fifo_read
      14  connsys_fifo_write
      14  connsys_get_headroom_offset
     206  connsys_get_ownership
      12  connsys_get_register_value
      18  connsys_get_stat_int_count
     176  connsys_giveup_ownership
     104  connsys_init
      16  connsys_irq_handler
     476  connsys_open
       4  connsys_ops
     194  connsys_print_stat
      14  connsys_set_headroom_offset
      26  connsys_set_register_value
      66  connsys_show_config_option
     182  connsys_tx_flow_control_check_and_update_tx
      50  connsys_tx_flow_control_config
      18  connsys_tx_flow_control_get_page_size
      48  connsys_tx_flow_control_init
      56  connsys_tx_flow_control_set_reserve_page
      30  connsys_tx_flow_control_set_reserve_page_by_cr
     260  connsys_tx_flow_control_show_info
      76  connsys_tx_flow_control_update_free_page_cnt
      40  g_balance_ctr
       4  g_connsys_debug_feature
     136  g_connsys_func
      72  g_connsys_stat
     116  g_hif_tx_flow_control_stat
       1  g_hif_tx_flow_ctrl_en
     116  g_whisr_val
          g_last_enhance_mode_data_struct
     188  lp_connsys_get_own_enable_int
     254  lp_connsys_give_n9_own
       4  rx_interrupt_handle
     364  -- Other

 
   493 bytes in section .bss
     2 bytes in section .data
     2 bytes in section .rodata
 7 826 bytes in section .text
 
 7 826 bytes of CODE  memory
     2 bytes of CONST memory
   495 bytes of DATA  memory

Errors: none
Warnings: none
