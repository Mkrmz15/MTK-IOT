###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:18
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\connsys\src\connsys_util.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW5893.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\connsys\src\connsys_util.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\connsys_util.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\connsys_util.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\connsys\src\connsys_util.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          #include <stdio.h>
     36          #include <stdlib.h>
     37          #include <string.h>
     38          #include "type_def.h"
     39          #include "mem_util.h"
     40          #include "mt_cmd_fmt.h"
     41          #include "connsys_driver.h"
     42          #include "connsys_bus.h"
     43          #include "connsys_util.h"
     44          #include "connsys_adapter.h"
     45          #include "sfc.h"
     46          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
     47          #include "mt7686.h"
     48          #include "hal_clock.h"
     49          #else
     50          #include "mt7687.h"
     51          #endif
     52          #include "nvic.h"
     53          #include "debug.h"
     54          #include "dma_sw.h"
     55          #include "dma_hw.h"
     56          #include "misc.h"
     57          #include "toi.h"
     58          #include "memory_attribute.h"
     59          #include "connsys_profile.h"
     60          #include "hal_log.h"
     61          #include "hal_gpt.h"
     62          #include "syslog.h"
     63          #ifdef MTK_CM4_WIFI_TASK_ENABLE
     64          #include "stats.h"
     65          #endif
     66          #include "wifi_rx_desc.h"
     67          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
     68          #include "patch_config_ram.h"
     69          #endif
     70          #define CFG_FPGA 0
     71          
     72          
     73          #ifdef MTK_WIFI_SLIM_ENABLE
     74          /* anthony */
     75          #define OVERRIDE_LOG
     76          #endif
     77          
     78          #include "connsys_log.h"
     79          
     80          
     81          #ifndef MTK_WIFI_SLIM_ENABLE
     82          sys_cfg_t *g_wifi_profile = NULL;
     83          
     84          uint32_t ilm_dl_duration_count, dlm_dl_duration_count, fw_start_duration_count;
     85          #else
     86          ATTR_ZIDATA_IN_TCM sys_cfg_t *g_wifi_profile = NULL;
     87          
     88          ATTR_ZIDATA_IN_TCM uint32_t ilm_dl_duration_count, dlm_dl_duration_count, fw_start_duration_count;
     89          #endif
     90          
     91          uint32_t connsys_fw_download_CmdAddressLenReq(uint32_t addr, uint32_t len, uint32_t data_mode, uint8_t *buffer);
     92          int32_t connsys_pda_config(uint32_t dest_addr, uint32_t data_len, uint32_t data_mode);
     93          
     94          //+++++++ Firmware Download +++++++++//
     95          #if defined(__ICCARM__)
     96          ATTR_ZIDATA_IN_TCM ATTR_4BYTE_ALIGN uint8_t g_tx_buf[MAX_BUF_SIZE + 0x10];
     97          #else
     98          ATTR_ZIDATA_IN_TCM uint8_t g_tx_buf[MAX_BUF_SIZE + 0x10] __attribute__((aligned(4)));
     99          #endif
    100          
    101          #define WIFI_PROFILE_LEN                (0x800) // 2K
    102          #define WIFI_PROFILE_ADDR               (0x020B2000)
    103          #define WIFI_PROFILE_DATA_MODE          (0x80000000) // plain (non-encrypted)
    104          #define WIFI_PROFILE_KEY_INDEX          (0x0)
    105          
    106          #ifndef MTK_WIFI_SLIM_ENABLE
    107          wifi_rx_handler_t connsys_raw_handler = NULL;
    108          #else
    109          ATTR_ZIDATA_IN_TCM wifi_rx_handler_t connsys_raw_handler = NULL;
    110          #endif
    111          
    112          #ifdef MTK_CM4_N9_SINGLE_IMG
    113          #if (PRODUCT_VERSION == 7687 || PRODUCT_VERSION == 7697)
    114          #define N9_IMG_NAME __out_ram_mt7687_ram_release_flash_bin
    115          #define N9_IMG_LEN  __out_ram_mt7687_ram_release_flash_bin_len
    116          #else
    117          #define N9_IMG_NAME __out_ram_mt7686_ram_release_flash_bin
    118          #define N9_IMG_LEN  __out_ram_mt7686_ram_release_flash_bin_len
    119          #endif
    120          extern unsigned char N9_IMG_NAME[];
    121          extern unsigned int  N9_IMG_LEN;
    122          #endif
    123          
    124          #define SDIO_TERMINATOR_LEN 4
    125          
    126          #ifndef MTK_WIFI_SLIM_ENABLE
    127          static fw_image_tailer_t *n9_fw_info;
    128          #else
    129          static ATTR_ZIDATA_IN_TCM fw_image_tailer_t *n9_fw_info;
    130          #endif
    131          
    132          void connsys_get_ilm_image_info(fw_dl_data_t *output, ssize_t length)
    133          {
    134          
    135          
    136              //fw_image_tailer_t *info;
    137              n9_fw_info = (fw_image_tailer_t *) & (output->image[length - sizeof(fw_image_tailer_t)]);
    138          
    139              INFO(connsys, "ilm_addr = %08x, ilm_len = %x, feature_set = %d.\n",
    140                    (unsigned int)n9_fw_info->ilm_info.addr,
    141                    (unsigned int)n9_fw_info->ilm_info.len,
    142                    (int)n9_fw_info->ilm_info.feature_set);
    143              INFO(connsys, "dlm_addr = %08x, dlm_len = %x, feature_set = %d.\n",
    144                    (unsigned int)n9_fw_info->dlm_info.addr,
    145                    (unsigned int)n9_fw_info->dlm_info.len,
    146                    (int)n9_fw_info->dlm_info.feature_set);
    147          
    148              output->ilm_addr = n9_fw_info->ilm_info.addr;
    149              output->ilm_len = n9_fw_info->ilm_info.len;
    150              output->ilm_encrypt = ((n9_fw_info->ilm_info.feature_set) & FEATURE_MASK_ENCRYPT_MODE) & 0xFF;
    151              output->ilm_encrypt_key_index = ((n9_fw_info->ilm_info.feature_set) & FEATURE_MASK_KEY_INDEX) & 0xFF;
    152          
    153              output->dlm_addr = n9_fw_info->dlm_info.addr;
    154              output->dlm_len = n9_fw_info->dlm_info.len;
    155              output->dlm_encrypt = ((n9_fw_info->dlm_info.feature_set) & FEATURE_MASK_ENCRYPT_MODE) & 0xFF;
    156              output->dlm_encrypt_key_index = ((n9_fw_info->dlm_info.feature_set) & FEATURE_MASK_KEY_INDEX) & 0xFF;
    157          }
    158          
    159          
    160          void connsys_util_get_n9_fw_ver(char *ver)
    161          {
    162              n9_fw_info->ilm_info.ram_built_date[0] = ' '; // workaround to remove the prefix: '_'
    163              memcpy(ver, &(n9_fw_info->ilm_info.ram_built_date[1]), 14);
    164          }
    165          
    166          void connsys_get_ilm_image_info_from_flash(fw_dl_data_t *output)
    167          {
    168          
    169              uint32_t length = 0;
    170          
    171              length = *((uint32_t *) & (output->image[0]));
    172          
    173              n9_fw_info = (fw_image_tailer_t *) & (output->image[length - sizeof(fw_image_tailer_t)]);
    174              // print_content(sizeof(fw_image_tailer_t), (uint8_t *)n9_fw_info, "tailer");
    175              CONNSYS_DUMP_I(connsys, "tailer", (const char *)n9_fw_info, sizeof(fw_image_tailer_t));
    176          
    177              INFO(connsys, "ilm_addr = %08x, ilm_len = %x, feature_set = %d.\n",
    178                    (unsigned int)n9_fw_info->ilm_info.addr,
    179                    (unsigned int)n9_fw_info->ilm_info.len,
    180                    (int)n9_fw_info->ilm_info.feature_set);
    181              INFO(connsys, "dlm_addr = %08x, dlm_len = %x, feature_set = %d.\n",
    182                    (unsigned int)n9_fw_info->dlm_info.addr,
    183                    (unsigned int)n9_fw_info->dlm_info.len,
    184                    (int)n9_fw_info->dlm_info.feature_set);
    185              INFO(connsys, "N9 RAM build date: %s\n", n9_fw_info->ilm_info.ram_built_date);
    186          
    187              output->ilm_addr = n9_fw_info->ilm_info.addr;
    188              output->ilm_len = n9_fw_info->ilm_info.len;
    189              output->ilm_encrypt = ((n9_fw_info->ilm_info.feature_set) & FEATURE_MASK_ENCRYPT_MODE) & 0xFF;
    190              output->ilm_encrypt_key_index = ((n9_fw_info->ilm_info.feature_set) & FEATURE_MASK_KEY_INDEX) & 0xFF;
    191          
    192              output->dlm_addr = n9_fw_info->dlm_info.addr;
    193              output->dlm_len = n9_fw_info->dlm_info.len;
    194              output->dlm_encrypt = ((n9_fw_info->dlm_info.feature_set) & FEATURE_MASK_ENCRYPT_MODE) & 0xFF;
    195              output->dlm_encrypt_key_index = ((n9_fw_info->dlm_info.feature_set) & FEATURE_MASK_KEY_INDEX) & 0xFF;
    196          }
    197          
    198          uint32_t connsys_img_direct_download(uint32_t target_addr, uint32_t length, uint32_t src_addr, uint32_t data_mode, uint32_t key_index)
    199          {
    200              uint32_t len = 0, reg = 0, total = 0;
    201              uint32_t volatile_reg1 = 0, volatile_reg2 = 0;
    202          
    203              connsys_pda_config(target_addr, length, data_mode);
    204          
    205              volatile_reg1 = REG32(PDA_SOURCE_CON);
    206              volatile_reg2 = REG32(PDA_DWLD_STATE);
    207              INFO(connsys, "Before Switch PDA source, con=0x%x, state=0x%x\n", volatile_reg1, volatile_reg2);
    208              // Step2: Set PDA source to PKT-GEN, instead of HIF
    209              REG32(PDA_SOURCE_CON) |= (PDA_SOURCE_SEL_BIT);
    210              volatile_reg1 = REG32(PDA_SOURCE_CON);
    211              volatile_reg2 = REG32(PDA_DWLD_STATE);
    212              INFO(connsys, "After Switch PDA source, con=0x%x, state=0x%x\n", volatile_reg1, volatile_reg2);
    213          
    214              (void)volatile_reg1;
    215              (void)volatile_reg2;
    216          
    217              while (total < length) {
    218                  len = *((uint32_t *)src_addr);
    219          
    220                  // Step3: Configure CM4 GDMA
    221          
    222                  /* clear start bit  */
    223                  REG32(GDMA_CH2_START) &= ~(0x1 << 15); /* clear start DMA bit */
    224          
    225                  // Enable GDMA Channels
    226          //        REG32(0xE000E100) = 1;
    227          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
    228                  hal_clock_enable(HAL_CLOCK_CG_DMA);
    229          #else
    230                  REG32(GDMA_CHANNEL_ENABLE) = 0xFFFFFFFF;
    231          #endif
    232                  REG32(0xE000E100) = 2;
    233          
    234                  // Configure GDMA : CH2
    235                  REG32(GDMA_CH2_SRC) = src_addr;
    236                  REG32(GDMA_CH2_DST) = PDA_TOP_WRAPPER_PORT;
    237                  REG32(GDMA_CH2_COUNT) = (len >> 2); // by unit of  >>> [DW] <<<<, "len" includes 3DW header
    238                  REG32(GDMA_CH2_CON) = 0x3F00206; // bit[1,2,9,20-25]
    239          
    240          
    241                  // wait DMA finish
    242                  INFO(connsys, "Wait GDMA finishing...\n");
    243          
    244                  /* DMA kick out */
    245                  REG32(GDMA_CH2_START) |= (0x1 << 15); /* Start DMA channel*/
    246                  do {
    247                      reg = REG32(GDMA_CH2_RLCT);
    248                  } while (reg != 0x00);
    249                  total += (len - PDA_PKT_HDR_SIZE);
    250                  INFO(connsys, "GDMA move from (0x%x) %d bytes to N9, total %d bytes.\n",
    251                        (unsigned int)src_addr,
    252                        (int)len,
    253                        (int)total);
    254          
    255                  src_addr += len; // len includes 3DW header
    256              }
    257          
    258              // Step5: Switch back PDA source to HIF
    259              REG32(PDA_SOURCE_CON) &= ~(PDA_SOURCE_SEL_BIT);
    260          
    261              if (total != length) {
    262                  LOG_E(connsys, "ERROR! the total %d bytes != assigned length(%d bytes)\n",
    263                        (int) total, (int)length);
    264                  return 0;
    265              }
    266          
    267              return src_addr;
    268          }
    269          
    270          static int connsys_download_wifi_profile(sys_cfg_t *wifi_profile)
    271          {
    272              uint8_t err;
    273              uint8_t wifi_profile_data[WIFI_PROFILE_LEN] = {0};
    274              memcpy(wifi_profile_data, wifi_profile, sizeof(sys_cfg_t));
    275          
    276              /* for debug */
    277              CONNSYS_DUMP_I(connsys, "wifi_profile_data:", wifi_profile_data, sizeof(sys_cfg_t));
    278              INFO(connsys, "wifi profile length is %d.", sizeof(sys_cfg_t));
    279          #ifdef MTK_WIFI_PRIVILEGE_ENABLE
    280              INFO(connsys,"wifi privilege enable is %d.", wifi_profile->wifi_privilege_enable);
    281          #endif /*MTK_WIFI_PRIVILEGE_ENABLE*/
    282              err = connsys_util_pda_download(WIFI_PROFILE_ADDR, WIFI_PROFILE_LEN, WIFI_PROFILE_DATA_MODE, 0, (unsigned char *)(wifi_profile_data));
    283              if (err) {
    284                  LOG_E(connsys, "\n\n\n<<%s>> Send wifi profile download fail!\n\n\n", __FUNCTION__);
    285              }
    286          
    287              return 1;
    288          }
    289          #ifndef MTK_FLASH_DIRECT_DL
    290          uint32_t connsys_fw_download_Tx_Scatter_HIF_Header(uint8_t *image, uint32_t len)
    291          {
    292              //int32_t err = 0;
    293              int ret;
    294              int32_t left_len = len;
    295              uint32_t read_len = 0;
    296              uint32_t pos = 0; //, offset = 0;
    297              uint32_t tx_len = 0;
    298          
    299              while (left_len > 0)
    300              {
    301          
    302          	  read_len = *((uint16_t *)&image[pos]);
    303          	  //INFO(connsys, "read_len: %lu bytes, pos:(%lu), left_len=%ld bytes\n", read_len, pos, left_len);
    304                  tx_len = read_len + SDIO_TERMINATOR_LEN;
    305                  // write to dut
    306                  ret = connsys_fifo_write(&image[pos], tx_len);
    307                  if (ret != 0)
    308                  {
    309                      // error cuures
    310                      //ERR(connsys, "<<%s>> Read scatter failed. Error = %d.\n", __FUNCTION__, ret);
    311                      //err = 1;
    312                  }
    313          
    314                  pos += tx_len;
    315                  left_len -= (read_len - LEN_INBAND_CMD_HDR_ROM);
    316              }
    317              return (uint32_t)&image[pos];
    318          }
    319          #endif
    320          
    321          int32_t connsys_util_fw_direct_download(void)
    322          {
    323              uint32_t data_mode = 0;
    324              fw_dl_data_t data;
    325              uint8_t *ptr = NULL;
    326          #ifdef MTK_FW_DW_BY_CM4
    327              uint8_t mcu_mode = 1;
    328          #else
    329              uint8_t mcu_mode = 0;
    330          #endif
    331          
    332              // Step 0: get ownership form firmware
    333              if (TRUE == connsys_get_ownership()) {
    334                  INFO(connsys, "<<%s>> Get ownership ok.\n", __FUNCTION__);
    335              } else {
    336                  INFO(connsys, "<<%s>> Get ownership failed.\n", __FUNCTION__);
    337              }
    338          
    339          #ifdef MTK_CM4_N9_SINGLE_IMG
    340              data.image = N9_IMG_NAME;
    341              connsys_get_ilm_image_info(&data, N9_IMG_LEN);
    342          #elif defined(WIFI_FW_ADDR_IN_FLASH)
    343              data.image = (uint8_t *)(WIFI_FW_ADDR_IN_FLASH);
    344              connsys_get_ilm_image_info_from_flash(&data);
    345          #else
    346             #error "MTK_CM4_N9_SINGLE_IMG should be defined in MT"##PRODUCT_VERSION
    347          #endif
    348          
    349              // add 4 byte CRC len
    350              data.ilm_len += LEN_4_BYTE_CRC;
    351              data.dlm_len += LEN_4_BYTE_CRC;
    352          
    353              // only support one data mode   (ILM data mode = DLM data mode)
    354              data_mode = (((data.dlm_encrypt) << DATA_MODE_BIT_SHFT_ENCRYPT_MODE) & DATA_MODE_MASK_ENCRYPT_MODE)
    355                          | (((data.dlm_encrypt_key_index) << DATA_MODE_BIT_SHFT_KEY_INDEX) & DATA_MODE_MASK_KEY_INDEX)
    356                          | ((data.dlm_encrypt == 1) ? (((uint32_t)1 << DATA_MODE_BIT_SHFT_RESET_IV) & DATA_MODE_MASK_RESET_IV) : (0))
    357                          | (((uint32_t)1 << DATA_MODE_BIT_SHFT_NEED_ACK) & DATA_MODE_MASK_NEED_ACK);
    358          
    359              INFO(connsys, "DLM encrypt(%d), dlm key index(%d)\n",
    360                    (int)data.dlm_encrypt,
    361                    (int)data.dlm_encrypt_key_index);
    362          
    363          
    364              // Step3: download ILM
    365              INFO(connsys, "Download ILM (%d bytes to N9 0x%x, mode:0x%x)...\n",
    366                    (int)data.ilm_len, (unsigned int)data.ilm_addr, (unsigned int)data_mode);
    367          
    368              if (mcu_mode) {
    369                  int32_t err = 0;
    370          
    371                  // get ownership form firmware
    372                  if (TRUE == connsys_get_ownership()) {
    373                      INFO(connsys, "<<%s>> Get ownership ok.\n", __FUNCTION__);
    374                  } else {
    375                      INFO(connsys, "<<%s>> Get ownership failed.\n", __FUNCTION__);
    376                  }
    377          
    378                  INFO(connsys, "<<%s>> ILM: Send fw download command...\n", __FUNCTION__);
    379                  err = connsys_util_pda_download(data.ilm_addr, data.ilm_len, data_mode, 4, data.image);  /* skip total image size, offset=4 */
    380                  if (err) {
    381                      return err;
    382                  }
    383          
    384                  INFO(connsys, "<<%s>> DLM: Send fw download command...\n", __FUNCTION__);
    385                  err = connsys_util_pda_download(data.dlm_addr, data.dlm_len, data_mode, 4 + data.ilm_len, data.image); /* skip total image size+ILM size, offset=4+ilm_len */
    386                  if (err) {
    387                      return err;
    388                  }
    389          
    390              } else {
    391          #ifdef MTK_FLASH_DIRECT_DL
    392                  // MT7687, flash direct download not applied in MT7686 anymore
    393                  ptr = &(data.image[4]);    /* skip total image size */
    394                  ptr = (uint8_t *)connsys_img_direct_download(data.ilm_addr, data.ilm_len, (uint32_t)ptr,
    395                          data_mode, data.ilm_encrypt_key_index);
    396                  if (ptr == NULL) {
    397                      LOG_E(connsys, "Download ILM Fail.\n");
    398                      return 0;
    399                  }
    400          
    401                  // Step4: download DLM
    402                  INFO(connsys, "Download DLM (%d bytes to N9 0x%x, mode:0x%x), ptr=0x%p...\n",
    403                        (int)data.dlm_len, (unsigned int)data.dlm_addr, (unsigned int)data_mode, (void *)ptr);
    404          
    405                  ptr = (uint8_t *)connsys_img_direct_download(data.dlm_addr, data.dlm_len, (uint32_t)ptr,
    406                          data_mode, data.dlm_encrypt_key_index);
    407                  if (ptr == NULL) {
    408                      LOG_E(connsys, "Download DLM Fail.\n");
    409                      return 0;
    410                  }
    411          #else
    412                  int32_t ret;
    413          
    414                  ptr = &(data.image[4]);    /* skip total image size */
    415                  //ptr = (uint8_t *)connsys_img_direct_download_7686(data.ilm_addr, data.ilm_len, (uint32_t)ptr, data_mode);
    416                  ret = connsys_pda_config(data.ilm_addr, data.ilm_len, data_mode);
    417                  if (ret) {
    418                      return 0;
    419                  }
    420          
    421                  ptr = (uint8_t *) connsys_fw_download_Tx_Scatter_HIF_Header(ptr, data.ilm_len);
    422          
    423                  if (ptr == NULL) {
    424                      return 0;
    425                  }
    426                  // Step4: download DLM
    427                  INFO(connsys, "Download DLM (%d bytes to N9 0x%x, mode:0x%x), ptr=0x%p...\n",
    428                        (int)data.dlm_len, (unsigned int)data.dlm_addr, (unsigned int)data_mode, (void *)ptr);
    429          
    430                  //ptr = (uint8_t *)connsys_img_direct_download_7686(data.dlm_addr, data.dlm_len, (uint32_t)ptr, data_mode);
    431                  ret = connsys_pda_config(data.dlm_addr, data.dlm_len, data_mode);
    432                  if (ret) {
    433                      return 0;
    434                  }
    435          
    436                  ptr = (uint8_t *) connsys_fw_download_Tx_Scatter_HIF_Header(ptr, data.dlm_len);
    437          
    438                  if (ptr == NULL) {
    439                      return 0;
    440                  }
    441          
    442          #endif
    443              }
    444              // Step6: Check FW download done, and start FW
    445              connsys_util_fw_download_done();
    446          
    447              INFO(connsys, "Download done.\n");
    448          
    449              return 1;
    450          }
    451          
    452          
    453          #ifndef MTK_FLASH_DIRECT_DL
    454          /*
    455           * This function determines the packing format of a firmware binary array.
    456           *
    457           * Currently, MT7686 firmware binary file can be generated in two
    458           * diffrent formats:
    459           *
    460           * 1. direct download format.
    461           * 2. plain format.
    462           *
    463           * If direct download format is used, the array contains the headers for
    464           * hardware engine were calculated. Hence, the download API does not need to
    465           * prepare headers.
    466           *
    467           * If direct download format is used, the bytes[8:9] of the firmware would be
    468           * 0xeea0.
    469           */
    470          static uint8_t _connsys_util_get_mcu_mode(uint8_t *ptr)
    471          {
    472              uint8_t     byte0 = ptr[8];
    473              uint8_t     byte1 = ptr[9];
    474          
    475              return (byte0 != MT_FW_SCATTER) || (byte1 != PKT_ID_CMD);
    476          }
    477          #endif
    478          
    479          void connsys_fw_download(fw_dl_data_t *data)
    480          {
    481              uint32_t data_mode = 0;
    482              uint8_t err = 0;
    483          #ifdef MTK_CM4_WIFI_TASK_ENABLE
    484              uint32_t gpt_start_count;
    485              uint32_t gpt_stop_count;
    486          #endif
    487          
    488              INFO(connsys, "<<%s>> The Bin File , ilm_addr = %08x, ilm_tx_len = %x\n",
    489                    __FUNCTION__, (unsigned int)data->ilm_addr, (unsigned int)data->ilm_len);
    490          
    491              INFO(connsys, "<<%s>> dlm_addr = %08x, dlm_tx_len = %x, enrypt = %d, encrypt_key_index = %d\n",
    492                    __FUNCTION__,
    493                    (unsigned int)data->dlm_addr,
    494                    (unsigned int)data->dlm_len,
    495                    (int)data->dlm_encrypt,
    496                    (int)data->dlm_encrypt_key_index);
    497          
    498              data_mode = (((data->dlm_encrypt) << DATA_MODE_BIT_SHFT_ENCRYPT_MODE) & DATA_MODE_MASK_ENCRYPT_MODE)
    499                          | (((data->dlm_encrypt_key_index) << DATA_MODE_BIT_SHFT_KEY_INDEX) & DATA_MODE_MASK_KEY_INDEX)
    500                          | ((data->dlm_encrypt == 1) ? (((uint32_t)1 << DATA_MODE_BIT_SHFT_RESET_IV) & DATA_MODE_MASK_RESET_IV) : (0))
    501                          | (((uint32_t)1 << DATA_MODE_BIT_SHFT_NEED_ACK) & DATA_MODE_MASK_NEED_ACK);
    502          
    503              INFO(connsys, "<<%s>> data_mode = %08x\n", __FUNCTION__, (unsigned int)data_mode);
    504          
    505          
    506              // get ownership form firmware
    507              if (TRUE == connsys_get_ownership()) {
    508                  INFO(connsys, "<<%s>> Get ownership ok.\n", __FUNCTION__);
    509              } else {
    510                  INFO(connsys, "<<%s>> Get ownership failed.\n", __FUNCTION__);
    511              }
    512          
    513              INFO(connsys, "<<%s>> ILM: Send fw download command...\n", __FUNCTION__);
    514          #ifdef MTK_CM4_WIFI_TASK_ENABLE
    515              hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_1M, &gpt_start_count);
    516              err = connsys_util_pda_download(data->ilm_addr, data->ilm_len, data_mode, 4, data->image);
    517              hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_1M, &gpt_stop_count);
    518              hal_gpt_get_duration_count(gpt_start_count, gpt_stop_count, &ilm_dl_duration_count);
    519          #else
    520              err = connsys_util_pda_download(data->ilm_addr, data->ilm_len, data_mode, 0, data->image);
    521          #endif
    522              if (err) {
    523                  return;
    524              }
    525          
    526              INFO(connsys, "<<%s>> DLM: Send fw download command...\n", __FUNCTION__);
    527          #ifdef MTK_CM4_WIFI_TASK_ENABLE
    528              hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_1M, &gpt_start_count);
    529              err = connsys_util_pda_download(data->dlm_addr, data->dlm_len, data_mode, 4+data->ilm_len, data->image);
    530              hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_1M, &gpt_stop_count);
    531              hal_gpt_get_duration_count(gpt_start_count, gpt_stop_count, &dlm_dl_duration_count);
    532          #else
    533              err = connsys_util_pda_download(data->dlm_addr, data->dlm_len, data_mode, data->ilm_len, data->image);
    534          #endif
    535              if (err) {
    536                  return;
    537              }
    538              connsys_util_fw_download_done();
    539          }
    540          
    541          
    542          int32_t connsys_util_firmware_download(void)
    543          {
    544          #ifndef MTK_FLASH_DIRECT_DL
    545              uint8_t     mcu_mode;
    546          #endif
    547          
    548          #ifdef MTK_PATCH_DL_ENABLE
    549              connsys_util_patch_download();
    550          #endif
    551          
    552          #ifdef MTK_FLASH_DIRECT_DL
    553                  return connsys_util_fw_direct_download();
    554          #else
    555              mcu_mode = _connsys_util_get_mcu_mode(
    556          #ifdef MTK_CM4_N9_SINGLE_IMG
    557                              (uint8_t *)&N9_IMG_NAME[0]);
    558          #elif defined(WIFI_FW_ADDR_IN_FLASH)
    559                              (uint8_t *)(WIFI_FW_ADDR_IN_FLASH));
    560          #else
    561             #error "MTK_CM4_N9_SINGLE_IMG should be defined in MT"##PRODUCT_VERSION
    562          #endif
    563          
    564              /*
    565               * mcu_mode: 0 - direct download format
    566               *           1 - user needs to calculate the CRC and prepare headers.
    567               */
    568              INFO(connsys, "MCU mode=%d\n", mcu_mode);
    569          
    570              if (mcu_mode) {
    571                  fw_dl_data_t data;
    572          #ifdef MTK_CM4_N9_SINGLE_IMG
    573                  data.image = N9_IMG_NAME;
    574                  connsys_get_ilm_image_info(&data, N9_IMG_LEN);
    575          #elif defined(WIFI_FW_ADDR_IN_FLASH)
    576                  data.image = (uint8_t *)(WIFI_FW_ADDR_IN_FLASH);
    577                  connsys_get_ilm_image_info_from_flash(&data);
    578          #else
    579             #error "MTK_CM4_N9_SINGLE_IMG should be defined in MT"##PRODUCT_VERSION
    580          #endif
    581          
    582                  // add 4 byte CRC len
    583                  data.ilm_len += LEN_4_BYTE_CRC;
    584                  data.dlm_len += LEN_4_BYTE_CRC;
    585                  connsys_fw_download((fw_dl_data_t *)&data);
    586                  return 1;
    587              } else {
    588                  return connsys_util_fw_direct_download();
    589              }
    590          #endif
    591          }
    592          
    593          //================= Patch Download test ==========================================================//
    594          
    595          uint8_t connsys_patch_finish(void)
    596          {
    597              uint32_t counter = 0;
    598              uint32_t value; //, offset;
    599              uint32_t tx_len, cmd_len;
    600              uint32_t real_rx_len;
    601              int32_t ret;
    602              uint8_t wait_tx_done, wait_rx_done, err = 1;
    603              uint32_t buffer[SDIO_MAX_RW_SIZE/4];
    604              uint8_t *pBuf = (uint8_t *)&buffer[0];
    605          
    606              // Patch finish command
    607              cmd_len = sizeof(INIT_HIF_TX_HEADER_T);
    608              tx_len = LEN_SDIO_TX_AGG_WRAPPER(cmd_len);
    609          
    610              memset(pBuf, 0, tx_len);
    611          
    612              // fill in the txd
    613              connsys_util_create_inband_cmd_txd_rom(cmd_len, pBuf, MT_PATCH_FINISH_REQ); //offset=
    614          
    615              // print_content(tx_len, pBuf, "patch finish");
    616              CONNSYS_DUMP_I(connsys, "patch finish", (const char *)pBuf, tx_len);
    617          
    618              // send to dut
    619              INFO(connsys, "<<%s>> Send Patch finish command ...\n", __FUNCTION__);
    620              // write connsys_util_fw_download cmd to dut
    621              ret = connsys_fifo_write(pBuf, tx_len);
    622              if (ret != 0) {
    623                  // error cuures
    624                  return err;
    625              }
    626          
    627              // check tx done and rx0 done interrupt status
    628              wait_tx_done = 1;
    629              wait_rx_done = 1;
    630              counter = 0;
    631              while (1) {
    632                  ret = connsys_cr_read(WHISR, &value);
    633                  if (ret) {
    634                      LOG_E(connsys, "<<%s>> Read WHISR failed. Error = %d.\n", __FUNCTION__, (int)ret);
    635                      return err;
    636                  }
    637          
    638                  INFO(connsys, "<<%s>> WHISR = %08x.\n", __FUNCTION__, (unsigned int)value);
    639          
    640                  connsys_abnormal_interrupt_check(value);
    641          
    642          
    643                  if (wait_tx_done == 1) {
    644                      if (value & TX_DONE_INT) {
    645                          wait_tx_done = 0;
    646                      }
    647                  }
    648          
    649                  if (wait_rx_done == 1) {
    650                      if (value & RX0_DONE_INT) {
    651                          wait_rx_done = 0;
    652                      }
    653                  }
    654          
    655                  if ((wait_tx_done == 0) && (wait_rx_done == 0)) {
    656                      break;
    657                  }
    658          
    659                  if (counter > 200000) { // wait for at least 1 second
    660                      LOG_E(connsys, "<<%s>> Check interrupt failed. wait_tx_done = %d, wait_tx_done = %d.\n",
    661                            __FUNCTION__,
    662                            (int)wait_tx_done,
    663                            (int)wait_rx_done);
    664                      return err;
    665                  }
    666                  //udelay(50); //delay 50us
    667          
    668                  counter++;
    669              }
    670          
    671          
    672              // Rx Patch finish response
    673              INFO(connsys, "<<%s>> Rx Patch finish event...\n", __FUNCTION__);
    674              ret = connsys_cr_read(WRPLR, &value);
    675              if (ret) {
    676                  LOG_E(connsys, "<<%s>> Read WRPLR failed. Error = %d.\n", __FUNCTION__, (int)ret);
    677                  return err;
    678              }
    679          
    680              real_rx_len = LEN_FW_DOWNLOAD_EVENT;
    681          
    682              if (GET_RX0_PACKET_LENGTH(value) != real_rx_len) {
    683                  LOG_E(connsys, "<<%s>> Patch finish response length incoreect. WRPLR = %08x.\n",
    684                        __FUNCTION__,
    685                        (unsigned int)value);
    686                  return err;
    687              }
    688          
    689              INFO(connsys, "<<%s>> Receive Patch finish event ...\n", __FUNCTION__);
    690          
    691              connsys_fifo_read(WRDR0, pBuf, real_rx_len);
    692          
    693              // print_content(real_rx_len, pBuf, "patch finish..2");
    694              CONNSYS_DUMP_I(connsys, "patch finish..2", (const char *)pBuf, real_rx_len);
    695          
    696              // check event status
    697              if (connsys_util_fw_download_CmdAddressLenReq_event_check(pBuf) != 0) {
    698                  return err;
    699              }
    700          
    701              err = 0;
    702              return err;
    703          }
    704          
    705          /* ===============================================================
    706           * Function: connsys_util_create_inband_cmd_txd_rom()
    707           * Description: to fill the inband commnad header of rom code.
    708           * Input: total size of cmd, buffer, command id
    709           * Return: the header size
    710           * ===============================================================*/
    711          void connsys_util_create_inband_cmd_txd_rom(uint32_t cmd_len, uint8_t *buffer, enum MT_CMD_TYPE cmd)
    712          {
    713              P_INIT_HIF_TX_HEADER_T p_txd;
    714              P_INIT_WIFI_CMD_T   p_cmd;
    715          
    716              p_txd = (P_INIT_HIF_TX_HEADER_T)buffer;
    717              p_txd->u2TxByteCount = cmd_len;
    718              p_txd->u2PQ_ID = P1_Q0;
    719          
    720              p_cmd = &(p_txd->rInitWifiCmd);
    721              p_cmd->ucCID = cmd;
    722              p_cmd->ucPktTypeID = PKT_ID_CMD;
    723          }
    724          
    725          //================= FW Download test ==========================================================//
    726          uint32_t connsys_fw_download_CmdAddressLenReq(uint32_t addr, uint32_t len, uint32_t data_mode, uint8_t *buffer)
    727          {
    728              uint32_t cmd_len, offset;
    729              P_INIT_CMD_DOWNLOAD_CONFIG p_data;
    730          
    731              cmd_len = sizeof(INIT_HIF_TX_HEADER_T) + sizeof(INIT_CMD_DOWNLOAD_CONFIG);
    732          
    733              // fill in the txd
    734              connsys_util_create_inband_cmd_txd_rom(cmd_len, buffer, MT_TARGET_ADDRESS_LEN_REQ);
    735              offset = sizeof(INIT_HIF_TX_HEADER_T);
    736          
    737              // fill in the parameters
    738              p_data = (P_INIT_CMD_DOWNLOAD_CONFIG)(buffer + offset);
    739              p_data->u4Address = addr;
    740              p_data->u4Length = len;
    741              p_data->u4DataMode = data_mode;
    742          
    743              // print_content(cmd_len, buffer, "FW download: addr len req");
    744              CONNSYS_DUMP_I(connsys, "FW download: addr len req", (const char *)buffer, cmd_len);
    745          
    746              return cmd_len;
    747          }
    748          
    749          /* ===============================================================
    750           * Function: connsys_create_inband_fw_scatter_txd_rom()
    751           * Description: to fill the scatter commnad header of rom code.
    752           * Input: total size of cmd, buffer, command id
    753           * Return: the header size
    754           * ===============================================================*/
    755          uint32_t connsys_create_inband_fw_scatter_txd_rom(uint32_t cmd_len, uint8_t *buffer)
    756          {
    757              P_INIT_HIF_TX_HEADER_T p_txd;
    758              P_INIT_WIFI_CMD_T   p_cmd;
    759          
    760              p_txd = (P_INIT_HIF_TX_HEADER_T)buffer;
    761              p_txd->u2TxByteCount = cmd_len;
    762              p_txd->u2PQ_ID = PQ_TO_PDA;
    763          
    764              p_cmd = &(p_txd->rInitWifiCmd);
    765              p_cmd->ucCID = MT_FW_SCATTER;
    766              p_cmd->ucPktTypeID = PKT_ID_CMD;
    767              return LEN_INBAND_CMD_HDR_ROM;
    768          }
    769          
    770          uint8_t connsys_util_fw_download_CmdAddressLenReq_event_check(uint8_t *buffer)
    771          {
    772              P_INIT_WIFI_EVENT_T p_event;
    773              P_INIT_EVENT_CMD_RESULT p_status;
    774              uint8_t err = 0;
    775          
    776              // get stauts
    777              p_event = (P_INIT_WIFI_EVENT_T)buffer;
    778              p_status = (P_INIT_EVENT_CMD_RESULT)p_event->aucBuffer;
    779          
    780              // print_content(p_event->u2RxByteCount, buffer, "FW download: addr len req evt check");
    781              CONNSYS_DUMP_I(connsys, "FW download: addr len req evt check", (const char *)buffer, p_event->u2RxByteCount);
    782          
    783              //if ((p_status->ucStatus) || (p_event->ucEID != INIT_EVENT_ID_CMD_RESULT)) {
    784              if (p_status->ucStatus) {
    785                  LOG_E(connsys, "<<%s>> Download config event incorrect. EID = %d, Status = %d\n",
    786                        __FUNCTION__,
    787                        (int)p_event->ucEID,
    788                        (int)p_status->ucStatus);
    789                  err = 1;
    790              } else {
    791                  INFO(connsys, "<<%s>> Download config set Successfully.\n", __FUNCTION__);
    792              }
    793          
    794              return err;
    795          }
    796          
    797          uint8_t connsys_util_patch_download_get_semaphore_event_check(uint8_t *buffer, uint8_t *status)
    798          {
    799              P_INIT_WIFI_EVENT_T p_event;
    800              P_INIT_EVENT_PATCH_SEMA_CTRL_T p_status;
    801              uint8_t err = 0;
    802          
    803              // get stauts
    804              p_event = (P_INIT_WIFI_EVENT_T)buffer;
    805              p_status = (P_INIT_EVENT_PATCH_SEMA_CTRL_T)p_event->aucBuffer;
    806          
    807              // print_content(p_event->u2RxByteCount, buffer, "Patch download");
    808              CONNSYS_DUMP_I(connsys, "Patch download", (const char *)buffer, p_event->u2RxByteCount);
    809          
    810              if (p_event->ucEID != INIT_EVENT_ID_PATCH_SEMA_CTRL) {
    811                  LOG_E(connsys, "<<%s>> Patch semaphore event incorrect. EID = %d\n",
    812                        __FUNCTION__,
    813                        (int)p_event->ucEID);
    814                  err = 1;
    815              } else {
    816                  INFO(connsys, "<<%s>> Patch semaphore event ok.\n", __FUNCTION__);
    817          
    818                  *status = p_status->ucStatus;
    819              }
    820          
    821          
    822              return err;
    823          }
    824          
    825          int32_t connsys_fw_download_Tx_Scatter(uint8_t *image, uint32_t len)
    826          {
    827              int32_t err = 0;
    828              int32_t ret;
    829              uint32_t left_len = len;
    830              uint32_t read_len = 0;
    831              uint32_t pos = 0, offset = 0;
    832              uint32_t tx_len;
    833              uint32_t buffer[(MAX_BUF_SIZE + 0x10)/4];
    834              uint8_t *pBuf = (uint8_t *)&buffer[0];
    835          
    836              INFO(connsys, "<<%s>>\n", __FUNCTION__);
    837              while (left_len) {
    838                  if (left_len < LEN_FW_SCATTER) {
    839                      read_len = left_len;
    840                  } else {
    841                      read_len = LEN_FW_SCATTER;
    842                  }
    843          
    844                  // prepare txd
    845          
    846                  tx_len = LEN_SDIO_TX_AGG_WRAPPER(LEN_INBAND_CMD_HDR_ROM + read_len);
    847                  memset(pBuf, 0, tx_len);
    848                  offset = connsys_create_inband_fw_scatter_txd_rom(LEN_INBAND_CMD_HDR_ROM + read_len, pBuf);
    849                  memcpy(&pBuf[offset], &image[pos], read_len);
    850          
    851                  pos += read_len;
    852                  left_len -= read_len;
    853          
    854                  INFO(connsys, "<<%s>> Read file total_len: %d.\n", __FUNCTION__, (int)pos);
    855                  // print_content(32, pBuf, "Send FW (first 32 bytes)");
    856                  CONNSYS_DUMP_I(connsys, "Send FW (first 32 bytes)", (const char *)pBuf, 32);
    857          
    858                  // write to dut
    859                  ret = connsys_fifo_write(pBuf, tx_len);
    860                  if (ret != 0) {
    861                      // error cuures
    862                      LOG_E(connsys, "<<%s>> Read scatter failed. Error = %d.\n", __FUNCTION__, (int)ret);
    863                      err = 1;;
    864                  }
    865              }
    866              return err;
    867          }
    868          
    869          int32_t connsys_pda_config(uint32_t dest_addr, uint32_t data_len, uint32_t data_mode)
    870          {
    871              uint32_t value, rx_size, counter = 0;
    872              int32_t ret;
    873              uint8_t wait_tx_done, wait_rx_done;
    874              int32_t err = 1;
    875              uint32_t buffer[SDIO_MAX_RW_SIZE/4];
    876              uint8_t *pBuf = (uint8_t *)&buffer[0];
    877          
    878              INFO(connsys, "<<%s>> Send fw download command...\n", __FUNCTION__);
    879          
    880              memset(pBuf, 0, SDIO_MAX_RW_SIZE);
    881          
    882              value = connsys_fw_download_CmdAddressLenReq(dest_addr, data_len, data_mode, pBuf);
    883          
    884              // write connsys_util_fw_download cmd to dut
    885              ret = connsys_fifo_write(pBuf, LEN_SDIO_TX_AGG_WRAPPER(value));
    886              if (ret != 0) {
    887                  LOG_E(connsys, "<<%s>> Send fw download failed. Error = %d.\n", __FUNCTION__, (int)ret);
    888                  return err;
    889              }
    890          
    891              wait_tx_done = 1;
    892              wait_rx_done = 1;
    893              counter = 0;
    894              while (1) {
    895                  ret = connsys_cr_read(WHISR, &value);
    896                  if (ret) {
    897                      LOG_E(connsys, "<<%s>> Read WHISR failed. Error = %d.\n", __FUNCTION__, (int)ret);
    898                      return err;
    899                  }
    900          
    901                  //INFO(connsys, "<<%s>> WHISR = %08x.\n", __FUNCTION__, value);
    902          
    903                  connsys_abnormal_interrupt_check(value);
    904          
    905                  if (wait_tx_done == 1) {
    906                      if (value & TX_DONE_INT) {
    907                          wait_tx_done = 0;
    908                      }
    909                  }
    910          
    911                  if (wait_rx_done == 1) {
    912                      if (value & RX0_DONE_INT) {
    913                          wait_rx_done = 0;
    914                      }
    915                  }
    916          
    917                  if ((wait_tx_done == 0) && (wait_rx_done == 0)) {
    918                      break;
    919                  }
    920          
    921                  if (counter > 2000000) { // wait for at least 1 second
    922                      LOG_E(connsys, "<<%s>> Check interrupt failed. wait_tx_done = %d, wait_tx_done = %d.\n",
    923                            __FUNCTION__,
    924                            (int)wait_tx_done,
    925                            (int)wait_rx_done);
    926                      return err;
    927                  }
    928                  //udelay(50); //delay 50us
    929          
    930                  counter++;
    931              }
    932          
    933              // rx event from dut
    934              INFO(connsys, "<<%s>> Rx fw download event...\n", __FUNCTION__);
    935              ret = connsys_cr_read(WRPLR, &value);
    936              if (ret) {
    937                  LOG_E(connsys, "<<%s>> Read WRPLR failed. Error = %d.\n", __FUNCTION__, (int)ret);
    938                  return err;
    939              }
    940          
    941              INFO(connsys, "<<%s>> WRPLR = %08x.\n", __FUNCTION__, (unsigned int)value);
    942          
    943          
    944              //rx_size = LEN_SDIO_RX_PACKET_WRAPPER(LEN_FW_DOWNLOAD_EVENT); //use this one will cause data incorrect. all 0.
    945              rx_size = LEN_FW_DOWNLOAD_EVENT;
    946          
    947              if (GET_RX0_PACKET_LENGTH(value) != rx_size) {
    948                  LOG_E(connsys, "<<%s>> download config event response length incoreect. WRPLR = %08x.\n",
    949                        __FUNCTION__,
    950                        (unsigned int)value);
    951                  return err;
    952              }
    953              connsys_fifo_read(WRDR0, pBuf, rx_size);
    954              ret = connsys_util_fw_download_CmdAddressLenReq_event_check(pBuf);
    955          
    956          #ifdef MTK_HIF_HEADER_2DW
    957          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
    958              /* Force to configure PDA header type to 2DW */
    959              HAL_REG_32(PDA_CONFG) &= ~PDA_CONFG_HEADER_3DW;
    960          #endif
    961          #endif
    962          
    963              INFO(connsys, "<<%s>> done\n", __FUNCTION__);
    964          
    965              return 0;
    966          }
    967          
    968          int32_t connsys_util_pda_download(uint32_t dest_addr, uint32_t data_len, uint32_t data_mode, uint32_t data_offset, uint8_t *image)
    969          {
    970              int32_t ret;
    971          
    972              ret = connsys_pda_config(dest_addr, data_len, data_mode);
    973          
    974          
    975              if (image != NULL) {
    976                  ret = connsys_fw_download_Tx_Scatter(&(image[data_offset]), data_len);
    977              }
    978              return ret;
    979          }
    980          
    981          void connsys_util_fw_download_done()
    982          {
    983              uint32_t counter = 0;
    984              uint32_t tx_len, cmd_len;
    985              uint32_t value, offset;
    986              P_INIT_CMD_WIFI_START p_data;
    987              uint8_t wait_tx_done, wait_rx_done;
    988              uint32_t buffer[SDIO_MAX_RW_SIZE/4];
    989              uint8_t *pBuf = (uint8_t *)&buffer[0];
    990              uint32_t real_rx_len, valid_rx_len;
    991              int32_t ret;
    992              uint32_t gpt_start_count, gpt_stop_count;
    993          
    994              memset(pBuf, 0, SDIO_MAX_RW_SIZE);
    995          
    996              // FW Start command
    997              cmd_len = sizeof(INIT_HIF_TX_HEADER_T) + sizeof(INIT_CMD_WIFI_START);
    998              tx_len = LEN_SDIO_TX_AGG_WRAPPER(cmd_len);
    999          
   1000              memset(pBuf, 0, tx_len);
   1001          
   1002              // fill in the txd
   1003              connsys_util_create_inband_cmd_txd_rom(cmd_len, pBuf, MT_FW_START_REQ);
   1004              offset = sizeof(INIT_HIF_TX_HEADER_T);
   1005          
   1006              // fill in the parameters
   1007              p_data = (P_INIT_CMD_WIFI_START)(pBuf + offset);
   1008              p_data->u4Address = 0;
   1009              p_data->u4Override = 0;
   1010              // print_content(tx_len, pBuf, "fw download test");
   1011              CONNSYS_DUMP_I(connsys, "fw download test", (const char *)pBuf, tx_len);
   1012          
   1013              hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_1M, &gpt_start_count);
   1014          
   1015              // send to dut
   1016              INFO(connsys, "<<%s>> Send FW_START command ...\n", __FUNCTION__);
   1017              // write connsys_util_fw_download cmd to dut
   1018              ret = connsys_fifo_write(pBuf, tx_len);
   1019              if (ret != 0) {
   1020                  // error cuures
   1021                  return;
   1022              }
   1023          
   1024          
   1025              // check tx done and rx0 done interrupt status
   1026              wait_tx_done = 1;
   1027              wait_rx_done = 1;
   1028              counter = 0;
   1029              while (1) {
   1030                  ret = connsys_cr_read(WHISR, &value);
   1031                  if (ret) {
   1032                      LOG_E(connsys, "<<%s>> Read WHISR failed. Error = %d.\n", __FUNCTION__, (int)ret);
   1033                      return;
   1034                  }
   1035          
   1036                  //INFO(connsys, "<<%s>> WHISR = %08x.\n", __FUNCTION__, value);
   1037          
   1038                  connsys_abnormal_interrupt_check(value);
   1039          
   1040          
   1041                  if (wait_tx_done == 1) {
   1042                      if (value & TX_DONE_INT) {
   1043                          wait_tx_done = 0;
   1044                      }
   1045                  }
   1046          
   1047                  if (wait_rx_done == 1) {
   1048                      if (value & RX0_DONE_INT) {
   1049                          wait_rx_done = 0;
   1050                      }
   1051                  }
   1052          
   1053                  if ((wait_tx_done == 0) && (wait_rx_done == 0)) {
   1054                      break;
   1055                  }
   1056          
   1057                  if (counter > 2000000) { // wait for at least 1 second
   1058                      hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_1M, &gpt_stop_count);
   1059                      hal_gpt_get_duration_count(gpt_start_count, gpt_stop_count, &fw_start_duration_count);
   1060                      LOG_E(connsys, "<<%s>> Check interrupt failed. wait_tx_done = %d, wait_rx_done = %d.\n",
   1061                            __FUNCTION__,
   1062                            (int)wait_tx_done,
   1063                            (int)wait_rx_done);
   1064                      return;
   1065                  }
   1066                  //udelay(50); //delay 50us
   1067          
   1068                  counter++;
   1069              }
   1070          
   1071              hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_1M, &gpt_stop_count);
   1072              hal_gpt_get_duration_count(gpt_start_count, gpt_stop_count, &fw_start_duration_count);
   1073          
   1074              // Rx FW start response
   1075              INFO(connsys, "<<%s>> Rx fw download event...\n", __FUNCTION__);
   1076              ret = connsys_cr_read(WRPLR, &value);
   1077              if (ret) {
   1078                  LOG_E(connsys, "<<%s>> Read WRPLR failed. Error = %d.\n", __FUNCTION__, (int)ret);
   1079                  return;
   1080              }
   1081          
   1082              valid_rx_len = LEN_FW_DOWNLOAD_EVENT;
   1083              real_rx_len = valid_rx_len;
   1084          
   1085              if (GET_RX0_PACKET_LENGTH(value) != real_rx_len) {
   1086                  LOG_E(connsys, "<<%s>> FW start response length incoreect. WRPLR = %08x.\n",
   1087                        __FUNCTION__,
   1088                        (unsigned int)value);
   1089                  return;
   1090              }
   1091          
   1092              INFO(connsys, "<<%s>> Receive FW_START event ...\n", __FUNCTION__);
   1093          
   1094              connsys_fifo_read(WRDR0, pBuf, real_rx_len);
   1095              // print_content(real_rx_len, pBuf, "fw download test..2");
   1096              CONNSYS_DUMP_I(connsys, "fw download test..2", (const char *)pBuf, real_rx_len);
   1097          
   1098              // check event status
   1099              if (connsys_util_fw_download_CmdAddressLenReq_event_check(pBuf) != 0) {
   1100                  return;
   1101              }
   1102          
   1103              // polling function ready bit.
   1104              counter = 0;
   1105              while (1) {
   1106                  ret = connsys_cr_read(WCIR, &value);
   1107                  if (ret) {
   1108                      LOG_E(connsys, "<<%s>> Read WCIR failed. Error = %d.\n", __FUNCTION__, (int)ret);
   1109                      return;
   1110                  }
   1111          
   1112                  INFO(connsys, "<<%s>> WCIR = %08x.\n", __FUNCTION__, (unsigned int)value);
   1113          
   1114                  if (value & W_FUNC_RDY) {
   1115                      break;
   1116                  }
   1117          
   1118                  if (counter > 2000000) { // wait for at least 1 second
   1119                      LOG_E(connsys, "<<%s>> Check interrupt failed. wait_tx_done = %d, wait_tx_done = %d.\n",
   1120                            __FUNCTION__,
   1121                            (int)wait_tx_done,
   1122                            (int)wait_rx_done);
   1123                      return;
   1124                  }
   1125                  //udelay(50); //delay 50us
   1126          
   1127                  counter++;
   1128              }
   1129              INFO(connsys, "<<%s>> FW Download Successfully.\n", __FUNCTION__);
   1130          }
   1131          
   1132          uint8_t connsys_get_patch_semaphore(void)
   1133          {
   1134              uint8_t err = 1, wait_tx_done, wait_rx_done, get_semaphore, status;
   1135              uint32_t cmd_len, tx_len, offset, counter, value, valid_rx_len, get_patch_delay;
   1136              P_INIT_CMD_PATCH_SEMA_CTRL p_data;
   1137              ssize_t ret;
   1138              uint32_t buffer[SDIO_MAX_RW_SIZE/4];
   1139              uint8_t *pBuf = (uint8_t *)&buffer[0];
   1140          
   1141              cmd_len = sizeof(INIT_HIF_TX_HEADER_T) + sizeof(INIT_CMD_PATCH_SEMA_CTRL);
   1142              tx_len = LEN_SDIO_TX_AGG_WRAPPER(cmd_len);
   1143          
   1144              memset(pBuf, 0, tx_len);
   1145          
   1146              get_semaphore = 1;
   1147              get_patch_delay = 0;
   1148              while (get_semaphore) {
   1149                  // fill in the txd
   1150                  connsys_util_create_inband_cmd_txd_rom(cmd_len, pBuf, MT_PATCH_SEM_CONTROL);
   1151                  offset = sizeof(INIT_HIF_TX_HEADER_T);
   1152          
   1153                  // fill in the parameters
   1154                  p_data = (P_INIT_CMD_PATCH_SEMA_CTRL)(pBuf + offset);
   1155                  p_data->ucGetSemaphore = 1; //get semaphore
   1156                  // print_content(tx_len, pBuf, "get patch semaphore");
   1157                  CONNSYS_DUMP_I(connsys, "get patch semaphore", (const char *)pBuf, tx_len);
   1158          
   1159                  // send to dut
   1160                  INFO(connsys, "<<%s>> Send Get Patch Semaphore command ...\n", __FUNCTION__);
   1161                  // write connsys_util_fw_download cmd to dut
   1162                  ret = connsys_fifo_write(pBuf, tx_len);
   1163                  if (ret != 0) {
   1164                      // error cuures
   1165                      return err;
   1166                  }
   1167          
   1168                  // check tx done and rx0 done interrupt status
   1169                  wait_tx_done = 1;
   1170                  wait_rx_done = 1;
   1171                  counter = 0;
   1172                  while (1) {
   1173                      ret = connsys_cr_read(WHISR, &value);
   1174                      if (ret) {
   1175                          LOG_E(connsys, "<<%s>> Read WHISR failed. Error = %d.\n", __FUNCTION__, (int)ret);
   1176                          return err;
   1177                      }
   1178          
   1179                      INFO(connsys, "<<%s>> WHISR = %08x.\n", __FUNCTION__, (unsigned int)value);
   1180          
   1181                      connsys_abnormal_interrupt_check(value);
   1182          
   1183          
   1184                      if (wait_tx_done == 1) {
   1185                          if (value & TX_DONE_INT) {
   1186                              wait_tx_done = 0;
   1187                          }
   1188                      }
   1189          
   1190                      if (wait_rx_done == 1) {
   1191                          if (value & RX0_DONE_INT) {
   1192                              wait_rx_done = 0;
   1193                          }
   1194          
   1195          
   1196                          if (value & RX1_DONE_INT) {
   1197                              wait_rx_done = 0;
   1198                          }
   1199                      }
   1200          
   1201                      if ((wait_tx_done == 0) && (wait_rx_done == 0)) {
   1202                          break;
   1203                      }
   1204          
   1205                      if (counter > 200000) { // wait for at least 1 seconds
   1206                          LOG_E(connsys, "<<%s>> Check interrupt failed. wait_tx_done = %d, wait_tx_done = %d.\n",
   1207                                __FUNCTION__,
   1208                                (int)wait_tx_done,
   1209                                (int)wait_rx_done);
   1210                          return err;
   1211                      }
   1212                      //udelay(50); //delay 50us
   1213          
   1214                      counter++;
   1215                  }
   1216          
   1217          
   1218                  // Rx get_patch_semaphore response
   1219                  INFO(connsys, "<<%s>> Rx fw download event...\n", __FUNCTION__);
   1220                  ret = connsys_cr_read(WRPLR, &value);
   1221                  if (ret) {
   1222                      LOG_E(connsys, "<<%s>> Read WRPLR failed. Error = %d.\n", __FUNCTION__, (int)ret);
   1223                      return err;
   1224                  }
   1225          
   1226                  valid_rx_len = LEN_GET_PATCH_SEMAPHORE_EVENT;
   1227          
   1228                  if (GET_RX0_PACKET_LENGTH(value) != valid_rx_len) {
   1229                      LOG_E(connsys, "<<%s>> Get patch semaphore response length incoreect. WRPLR = %08x.\n",
   1230                            __FUNCTION__,
   1231                            (unsigned int)value);
   1232                      return err;
   1233                  }
   1234          
   1235                  INFO(connsys, "<<%s>> Receive Get patch semaphore event ...\n", __FUNCTION__);
   1236          
   1237                  connsys_fifo_read(WRDR0, pBuf, valid_rx_len);
   1238                  // print_content(valid_rx_len, pBuf, "get patch semaphore...2");
   1239                  CONNSYS_DUMP_I(connsys, "get patch semaphore...2", (const char *)pBuf, valid_rx_len);
   1240          
   1241                  // check event status
   1242                  if (connsys_util_patch_download_get_semaphore_event_check(pBuf, &status)) {
   1243                      return err;
   1244                  } else {
   1245                      if (status == WIFI_PATCH_SEMA_NEED_PATCH_SEMA_FAIL) {
   1246                          if (get_patch_delay > 200000) {  //wait 1 second
   1247                              LOG_E(connsys, "<<%s>> FAIL. Get patch semaphore fail.\n", __FUNCTION__);
   1248                              return err;
   1249                          }
   1250          
   1251                          get_patch_delay += 1;
   1252                          //udelay(50); //delay 50us
   1253                      } else if (status == WIFI_PATCH_SEMA_PATCH_DONE_SEMA_IGNORE) {
   1254                          LOG_E(connsys, "<<%s>> FAIL. Get patch semaphore fail.\n", __FUNCTION__);
   1255                          get_semaphore = 0;
   1256          
   1257                      } else if (status == WIFI_PATCH_SEMA_NEED_PATCH_SEMA_SUCCESS) {
   1258                          get_semaphore = 0;
   1259                      } else if (status == WIFI_PATCH_SEMA_RELEASE_SUCCESS) {
   1260                      }
   1261                  }
   1262              }
   1263          
   1264              return status;
   1265          }
   1266          
   1267          void connsys_patch_direct_download()
   1268          {
   1269              uint32_t data_mode = 0, length = 0;
   1270              uint8_t status = 0;
   1271              patch_dl_data_t data;
   1272              uint8_t *ptr = NULL;
   1273          
   1274          #if 0
   1275              INFO(connsys, "<<%s>> The Bin File = %s, ilm_addr = %08x, ilm_tx_len = %x\n",
   1276                    __FUNCTION__, data->file_name, data->ilm_addr, data->ilm_len);
   1277          #endif
   1278          
   1279          #ifdef MTK_CM4_N9_SINGLE_IMG
   1280                  data.image = N9_IMG_NAME;
   1281          #elif defined(WIFI_FW_ADDR_IN_FLASH)
   1282                  data.image = (uint8_t *)(WIFI_FW_ADDR_IN_FLASH);
   1283          #else
   1284             #error "MTK_CM4_N9_SINGLE_IMG should be defined in MT"##PRODUCT_VERSION
   1285          #endif
   1286          
   1287              data.ilm_addr = MT7687_PATCH_START_ADDR;
   1288          
   1289              length = *((uint32_t *) & (data.image[0]));
   1290          
   1291              data.ilm_len = length - 4 - LEN_PATCH_FILE_HEADER; //??? LEN_4_BYTE_CRC;
   1292          
   1293              data_mode |= (((uint32_t)1 << DATA_MODE_BIT_SHFT_NEED_ACK) & DATA_MODE_MASK_NEED_ACK);
   1294          
   1295              INFO(connsys, "<<%s>> data_mode = %08x\n", __FUNCTION__, (unsigned int)data_mode);
   1296          
   1297              // get ownership form firmware
   1298              if (TRUE == connsys_get_ownership()) {
   1299                  INFO(connsys, "<<%s>> Get ownership ok.\n", __FUNCTION__);
   1300              } else {
   1301                  INFO(connsys, "<<%s>> Get ownership failed.\n", __FUNCTION__);
   1302              }
   1303          
   1304              // get semaphore
   1305              status = connsys_get_patch_semaphore();
   1306              if (status == WIFI_PATCH_SEMA_NEED_PATCH_SEMA_SUCCESS) {
   1307                  INFO(connsys, "<<%s>> Send patch download command...\n", __FUNCTION__);
   1308          
   1309                  ptr = &(data.image[4 + LEN_PATCH_FILE_HEADER]);    /* skip total image size */
   1310                  ptr = (uint8_t *)connsys_img_direct_download(data.ilm_addr, data.ilm_len, (uint32_t)ptr,
   1311                          data_mode, 0); // data.ilm_encrypt_key_index = 0 , just a dummy for PATCH has no encryption
   1312                  if (ptr == NULL) {
   1313                      LOG_E(connsys, "Download PATCH Fail.\n");
   1314                      return ;
   1315                  }
   1316                  // send patch finish command
   1317                  status = connsys_patch_finish();
   1318                  if (status) {
   1319                      LOG_E(connsys, "\n\n\n<<%s>> Patch Download Fail.\n\n\n", __FUNCTION__);
   1320                      return;
   1321                  }
   1322          
   1323                  INFO(connsys, "<<%s>> Patch Direct Download Successfully.\n", __FUNCTION__);
   1324              } else if (status == WIFI_PATCH_SEMA_PATCH_DONE_SEMA_IGNORE) {
   1325                  INFO(connsys, "<<%s>> Patch has been done, needn't get semaphore.\n", __FUNCTION__);
   1326              } else if (status == WIFI_PATCH_SEMA_RELEASE_SUCCESS) {
   1327                  INFO(connsys, "<<%s>> Fail! Get semaphore instead of release patch semaphore.\n", __FUNCTION__);
   1328              } else if (status == WIFI_PATCH_SEMA_NEED_PATCH_SEMA_FAIL) {
   1329                  INFO(connsys, "<<%s>> Fail! Get patch semaphore failed.\n", __FUNCTION__);
   1330              }
   1331          
   1332          }
   1333          
   1334          void connsys_set_wifi_profile(sys_cfg_t *config)
   1335          {
   1336              g_wifi_profile = config;
   1337          }
   1338          
   1339          void connsys_patch_download_body(const patch_dl_data_t *data)
   1340          {
   1341              uint32_t data_mode = 0;
   1342              uint8_t err = 0;
   1343              uint8_t status;
   1344          
   1345          #if 0
   1346              INFO(connsys, "<<%s>> The Bin File = %s, ilm_addr = %08x, ilm_tx_len = %x\n",
   1347                    __FUNCTION__, data->file_name, data->ilm_addr, data->ilm_len);
   1348          #endif
   1349              data_mode |= (((uint32_t)1 << DATA_MODE_BIT_SHFT_NEED_ACK) & DATA_MODE_MASK_NEED_ACK);
   1350          
   1351          
   1352              INFO(connsys, "<<%s>> data_mode = %08x\n", __FUNCTION__, (unsigned int)data_mode);
   1353          
   1354              // get ownership form firmware
   1355              if (TRUE == connsys_get_ownership()) {
   1356                  INFO(connsys, "<<%s>> Get ownership ok.\n", __FUNCTION__);
   1357              } else {
   1358                  INFO(connsys, "<<%s>> Get ownership failed.\n", __FUNCTION__);
   1359              }
   1360          
   1361              // get semaphore
   1362              status = connsys_get_patch_semaphore();
   1363              if (status == WIFI_PATCH_SEMA_NEED_PATCH_SEMA_SUCCESS) {
   1364          #if (CFG_FPGA == 0)
   1365                  INFO(connsys, "<<%s>> Send patch download command...\n", __FUNCTION__);
   1366                  err = connsys_util_pda_download(data->ilm_addr, data->ilm_len, data_mode, LEN_PATCH_FILE_HEADER, data->image);
   1367                  if (err) {
   1368                      LOG_E(connsys, "\n\n\n<<%s>> Send patch download fail!\n\n\n", __FUNCTION__);
   1369                      return;
   1370                  }
   1371          #endif // CFG_FPGA
   1372          
   1373                  // Download N9 wifi profile
   1374                  if (NULL != g_wifi_profile) {
   1375                      connsys_download_wifi_profile(g_wifi_profile);
   1376                  }
   1377          
   1378                  // send patch finish command
   1379                  err = connsys_patch_finish();
   1380                  if (err) {
   1381                      LOG_E(connsys, "\n\n\n<<%s>> Patch Download Fail.\n\n\n", __FUNCTION__);
   1382                      return;
   1383                  }
   1384          
   1385                  INFO(connsys, "<<%s>> Patch download Successfully.\n", __FUNCTION__);
   1386              } else if (status == WIFI_PATCH_SEMA_PATCH_DONE_SEMA_IGNORE) {
   1387                  INFO(connsys, "<<%s>> Patch has been done, needn't get semaphore.\n", __FUNCTION__);
   1388              } else if (status == WIFI_PATCH_SEMA_RELEASE_SUCCESS) {
   1389                  INFO(connsys, "<<%s>> Fail! Get semaphore instead of release patch semaphore.\n", __FUNCTION__);
   1390              } else if (status == WIFI_PATCH_SEMA_NEED_PATCH_SEMA_FAIL) {
   1391                  INFO(connsys, "<<%s>> Fail! Get patch semaphore failed.\n", __FUNCTION__);
   1392              }
   1393          
   1394          }
   1395          
   1396          
   1397          patch_header_t *g_patch_info;
   1398          void connsys_util_get_ncp_patch_ver(char *ver)
   1399          {
   1400              memcpy(ver, g_patch_info->built_date, 14);
   1401          }
   1402          
   1403          void connsys_util_patch_download(void)
   1404          {
   1405              uint32_t fw_size;
   1406              patch_dl_data_t data = {
   1407                  .ilm_addr = MT7687_PATCH_START_ADDR,
   1408                  .ilm_len  = 0,
   1409                  .image    = NULL,
   1410              };
   1411              INFO(connsys, "==> HW ID=0x%x\n", REG32(CM4_CONFIG_BASE));
   1412          
   1413          #ifdef MTK_CM4_N9_SINGLE_IMG
   1414              data.image = N9_IMG_NAME;
   1415          #elif defined(WIFI_FW_ADDR_IN_FLASH)
   1416              data.image = (uint8_t *)(WIFI_FW_ADDR_IN_FLASH);
   1417          #else
   1418             #error "MTK_CM4_N9_SINGLE_IMG should be defined in MT"##PRODUCT_VERSION
   1419          #endif
   1420          
   1421              fw_size = *((uint32_t *)(data.image)); // include 4-byte total_length  itself
   1422              data.image += fw_size;
   1423              g_patch_info = (patch_header_t *)(data.image + 4);
   1424              data.ilm_len = *((uint32_t *)(data.image)); // patch image size, include 4-byte patch length
   1425              data.ilm_len -= (LEN_PATCH_FILE_HEADER + 4); // 4-byte patch_length
   1426              data.image   += 4; // patch image start, including header
   1427              //INFO(connsys, "==> PATCH size: %d bytes, build time: %s\n", (int)data.ilm_len,	g_patch_info->built_date);
   1428          
   1429              INFO(connsys, "patch ilm_addr = %08x, ilm_len = %x.\n", (unsigned int)data.ilm_addr, (unsigned int)data.ilm_len);
   1430              connsys_patch_download_body(&data);
   1431          }
   1432          
   1433          
   1434          int32_t connsys_util_tx_data(uint8_t *buf, ssize_t len)
   1435          {
   1436              int32_t ret;
   1437          
   1438              if (CONNSYS_TEST_DEBUG(CONNSYS_DBG_TX_Q0) || CONNSYS_TEST_DEBUG(CONNSYS_DBG_TX_Q1)) {
   1439                  P_INIT_HIF_TX_HEADER_T p_txd = (P_INIT_HIF_TX_HEADER_T)buf;
   1440                  if (p_txd->u2PQ_ID == P1_Q0) {
   1441                      CONNSYS_DUMP_I(connsys, "P1_Q0 tx_buf", (uint8_t *)buf, (uint32_t)len);
   1442                  } else {
   1443                      CONNSYS_DUMP_I(connsys, "P1_Q1 tx_buf", (uint8_t *)buf, (uint32_t)len);
   1444                  }
   1445              }
   1446          
   1447              ret = connsys_fifo_write(buf, len);
   1448              return ret;
   1449          }
   1450          
   1451          int32_t connsys_util_rx_data(uint8_t *buf, ssize_t len, int32_t port)
   1452          {
   1453              ssize_t err = CONNSYS_STATUS_SUCCESS, ret;
   1454          
   1455              if (port == WIFI_HIF_RX_PORT0_IDX) {
   1456                  ret = connsys_fifo_read(WRDR0, buf, len);
   1457              } else {
   1458                  ret = connsys_fifo_read(WRDR1, buf, len);
   1459              }
   1460          
   1461              if (ret) {
   1462                  LOG_E(connsys, "<<%s>> Failed. Rx data, port(0x%x)\n", __FUNCTION__, WRDR1);
   1463                  err = CONNSYS_STATUS_FAIL;
   1464              }
   1465          
   1466              return err;
   1467          }
   1468          
   1469          #if (CFG_CONNSYS_DVT_RX_ENHANCE_MODE_EN == 1)
   1470          // return value: total read size
   1471          int32_t connsys_util_rx_data_enhance_mode(uint8_t *buf, ssize_t *len, int32_t port)
   1472          {
   1473          #if defined(__ICCARM__)
   1474              ATTR_4BYTE_ALIGN uint8_t input[LEN_INT_ENHANCE_MODE];
   1475          #else
   1476              uint8_t input[LEN_INT_ENHANCE_MODE] __attribute__((aligned(4)));
   1477          #endif
   1478              uint32_t rx_len = 0, addr = WRDR0;
   1479              uint32_t reg_value = 0;
   1480              enhance_mode_data_struct_t *p_int_enhance;
   1481              int32_t i;
   1482          
   1483              if (port == 0) {
   1484                  addr = WRDR0;
   1485              } else if (port == 1) {
   1486                  addr = WRDR1;
   1487              } else {
   1488                  LOG_E(connsys, "Invalid port:%d\n", port);
   1489                  return CONNSYS_STATUS_FAIL;
   1490              }
   1491          
   1492              // enable RX enhance mode
   1493              if (connsys_cr_read(WHCR, &reg_value)) {
   1494                  LOG_E(connsys, "FAIL. read WHCR.\n");
   1495                  return CONNSYS_STATUS_FAIL;
   1496              }
   1497              reg_value |= RX_ENHANCE_MODE;
   1498              if (connsys_cr_write(WHCR, reg_value)) {
   1499                  LOG_E(connsys, "FAIL. write WHCR.\n");
   1500                  return CONNSYS_STATUS_FAIL;
   1501              }
   1502              reg_value = 0;
   1503              if (connsys_cr_read(WHCR, &reg_value)) {
   1504                  LOG_E(connsys, "FAIL. read WHCR.\n");
   1505                  return CONNSYS_STATUS_FAIL;
   1506              } else {
   1507                  if (!(reg_value & RX_ENHANCE_MODE)) {
   1508                      LOG_E(connsys, "FAIL. write RX_ENHANCE_MODE fail. WHCR = 0x%08x.\n", reg_value);
   1509                      return CONNSYS_STATUS_FAIL;
   1510                  }
   1511              }
   1512              INFO(connsys, "Enable enhance mode, WHCR=0x%x\n", reg_value);
   1513          
   1514              memset(input, 0, sizeof(input));
   1515              connsys_fifo_read(WHISR, (uint8_t *)input, LEN_INT_ENHANCE_MODE);
   1516          
   1517              p_int_enhance = (enhance_mode_data_struct_t *)input;
   1518          
   1519              for (i = 0; i < p_int_enhance->rx_info.u.valid_len_num[port]; i++) {
   1520                  if (p_int_enhance->rx_info.u.each_rx_len[port][i] == 0) {
   1521                      LOG_E(connsys, "FAIL. au2Rx[%d]Len[%d] = %d. ()\n", port, i, p_int_enhance->rx_info.u.each_rx_len[port][i]);
   1522                      continue;
   1523                  }
   1524                  rx_len = p_int_enhance->rx_info.u.each_rx_len[port][i];
   1525                  INFO(connsys, "rx len = %d\n", rx_len);
   1526                  connsys_fifo_read(addr, (uint8_t *)buf, rx_len);
   1527              }
   1528              *len = rx_len;
   1529          
   1530              return CONNSYS_STATUS_SUCCESS;
   1531          }
   1532          
   1533          #endif /* CFG_CONNSYS_DVT_RX_ENHANCE_MODE_EN */
   1534          
   1535          
   1536          #if (CFG_CONNSYS_TRX_BALANCE_EN == 1)
   1537          void connnsys_balance_init(void)
   1538          {
   1539              uint32_t flags;
   1540              local_irq_save(flags);
   1541          
   1542              memset(&g_balance_ctr, 0, sizeof(connsys_balance_ctr_t));
   1543              g_balance_ctr.num_of_continuous_rx = CFG_CONNSYS_BALANCE_DEFAULT_RX_NUM;
   1544              g_balance_ctr.num_of_continuous_tx = CFG_CONNSYS_BALANCE_DEFAULT_TX_NUM;
   1545              g_balance_ctr.balance_en = FALSE;
   1546              local_irq_restore(flags);
   1547          }
   1548          
   1549          void connnsys_balance_set_max_num_of_continuous_rx(uint32_t num)
   1550          {
   1551              uint32_t flags;
   1552              local_irq_save(flags);
   1553              g_balance_ctr.num_of_continuous_rx = num;
   1554              local_irq_restore(flags);
   1555          }
   1556          
   1557          void connnsys_balance_set_max_num_of_continuous_tx(uint32_t num)
   1558          {
   1559              uint32_t flags;
   1560              local_irq_save(flags);
   1561              g_balance_ctr.num_of_continuous_tx = num;
   1562              local_irq_restore(flags);
   1563          }
   1564          
   1565          void connnsys_balance_set_enable(uint32_t enable)
   1566          {
   1567              uint32_t flags;
   1568              local_irq_save(flags);
   1569              g_balance_ctr.balance_en = (uint8_t)enable;
   1570              local_irq_restore(flags);
   1571          }
   1572          
   1573          
   1574          #ifdef MTK_MINICLI_ENABLE
   1575          void connnsys_balance_show_info(void)
   1576          {
   1577              uint32_t flags;
   1578              connsys_balance_ctr_t ctr;
   1579              local_irq_save(flags);
   1580              memcpy(&ctr, &g_balance_ctr, sizeof(connsys_balance_ctr_t));
   1581              local_irq_restore(flags);
   1582          
   1583              printf("show connsys balance info:\n");
   1584              printf("\tnum_of_continuous_tx = %u\n", (unsigned int)ctr.num_of_continuous_tx);
   1585              printf("\tnum_of_continuous_rx = %u\n", (unsigned int)ctr.num_of_continuous_rx);
   1586              printf("\tnum_of_tx = %u\n", (unsigned int)ctr.num_of_tx);
   1587              printf("\tnum_of_rx = %u\n", (unsigned int)ctr.num_of_rx);
   1588              printf("\tfg_tx_wait = %u\n", (unsigned int)ctr.fg_tx_wait);
   1589              printf("\tfg_rx_wait = %u\n", (unsigned int)ctr.fg_rx_wait);
   1590              printf("\ttx_yield_time = %u\n", (unsigned int)ctr.tx_yield_time);
   1591              printf("\trx_yield_time = %u\n", (unsigned int)ctr.rx_yield_time);
   1592              printf("\ttx_handle = %u\n", (unsigned int)ctr.tx_handle);
   1593              printf("\trx_handle = %u\n", (unsigned int)ctr.rx_handle);
   1594              printf("\tbalance_en = %u\n", (unsigned int)ctr.balance_en);
   1595          }
   1596          #endif
   1597          
   1598          uint8_t connsys_balance_check_tx_yield(void)
   1599          {
   1600              uint32_t flags;
   1601              uint8_t ret = FALSE;
   1602          
   1603              local_irq_save(flags);
   1604              if (g_balance_ctr.fg_rx_wait &&
   1605                      (g_balance_ctr.num_of_tx >= g_balance_ctr.num_of_continuous_tx)) {
   1606                  g_balance_ctr.num_of_tx = 0;
   1607                  g_balance_ctr.fg_tx_wait = TRUE;
   1608                  g_balance_ctr.tx_yield_time ++;
   1609                  ret = TRUE;
   1610              } else {
   1611                  g_balance_ctr.num_of_tx++;
   1612                  ret = FALSE;
   1613              }
   1614              local_irq_restore(flags);
   1615              return ret;
   1616          }
   1617          
   1618          void connsys_balance_clear_tx_wait(void)
   1619          {
   1620              uint32_t flags;
   1621              local_irq_save(flags);
   1622              g_balance_ctr.fg_tx_wait = FALSE;
   1623              local_irq_restore(flags);
   1624          }
   1625          
   1626          uint8_t connsys_balance_check_rx_yield(void)
   1627          {
   1628              uint32_t flags;
   1629              uint8_t ret = FALSE;
   1630          
   1631          
   1632              if (g_balance_ctr.balance_en == FALSE) {
   1633                  return FALSE;
   1634              }
   1635          
   1636              local_irq_save(flags);
   1637              if (g_balance_ctr.fg_tx_wait &&
   1638                      (g_balance_ctr.num_of_rx >= g_balance_ctr.num_of_continuous_rx)) {
   1639                  g_balance_ctr.num_of_rx = 0;
   1640                  g_balance_ctr.rx_yield_time ++;
   1641                  ret = TRUE;
   1642              } else {
   1643                  g_balance_ctr.num_of_rx++;
   1644                  ret = FALSE;
   1645              }
   1646              local_irq_restore(flags);
   1647              return ret;
   1648          }
   1649          
   1650          void connsys_balance_clear_rx_wait(void)
   1651          {
   1652              uint32_t flags;
   1653              local_irq_save(flags);
   1654              g_balance_ctr.fg_rx_wait = FALSE;
   1655              local_irq_restore(flags);
   1656          }
   1657          
   1658          
   1659          #endif /* CFG_CONNSYS_TRX_BALANCE_EN */
   1660          
   1661          
   1662          #ifdef MTK_MINICLI_ENABLE
   1663          void connsys_intr_enhance_mode_dump_struct(enhance_mode_data_struct_t *p_enhance_mode_struct)
   1664          {
   1665              uint32_t i, j;
   1666              printf("==>connsys_intr_enhance_mode_dump_struct\n");
   1667              printf("WHISR_reg_val = 0x%x\n", (unsigned int)p_enhance_mode_struct->WHISR_reg_val);
   1668              printf("TX:");
   1669              for (i = 0; i < NUM_OF_WIFI_TXQ; i++) {
   1670                  printf("\ttx_info.u.free_page_num[%u] = %u\n",
   1671                         (unsigned int)i,
   1672                         (unsigned int)p_enhance_mode_struct->tx_info.u.free_page_num[i]);
   1673              }
   1674          
   1675              printf("RX:");
   1676              for (i = 0; i < NUM_OF_WIFI_HIF_RX_PORT; i++) {
   1677                  printf("Port %u\n", (unsigned int)i);
   1678                  printf("\tvalid_len_num: %u\n",
   1679                         (unsigned short)p_enhance_mode_struct->rx_info.u.valid_len_num[i]);
   1680          
   1681                  printf("\teach_rx_len:\n");
   1682                  for (j = 0; j < WIFI_HIF_RX_FIFO_MAX_LEN; j++) {
   1683                      printf("\t[%2u]: %8u", (unsigned int)j, (unsigned short)p_enhance_mode_struct->rx_info.u.each_rx_len[i][j]);
   1684                      if ((j % 4) == 3) {
   1685                          printf("\n");
   1686                      }
   1687                  }
   1688              }
   1689              printf("receive_mail_box_0 = 0x%x\n", (unsigned int)p_enhance_mode_struct->receive_mail_box_0);
   1690              printf("receive_mail_box_1 = 0x%x\n", (unsigned int)p_enhance_mode_struct->receive_mail_box_1);
   1691          }
   1692          
   1693          void connsys_util_intr_enhance_mode_dump_last_struct(void)
   1694          {
   1695              connsys_intr_enhance_mode_dump_struct(&g_last_enhance_mode_data_struct);
   1696          }
   1697          #endif
   1698          
   1699          uint8_t rssi_threshold_enable = 0;
   1700          int8_t rssi_threshold = 0;
   1701          uint8_t channel_filter = 0;
   1702          
   1703          
   1704          uint8_t raw_packet_handler_enabled(void)
   1705          {
   1706              return (connsys_raw_handler != NULL);
   1707          }
   1708          
   1709          
   1710          void wifi_set_channel_filter(uint8_t on_off)
   1711          {
   1712              channel_filter = on_off;
   1713          }
   1714          
   1715          uint8_t wifi_get_channel_filter(void)
   1716          {
   1717              return channel_filter;
   1718          }
   1719          
   1720          void wifi_set_raw_rssi_threshold(uint8_t enable, int8_t rssi)
   1721          {
   1722              rssi_threshold_enable = enable;
   1723              rssi_threshold = rssi;
   1724          }
   1725          
   1726          void wifi_get_raw_rssi_threshold(uint8_t *enable, int8_t *rssi)
   1727          {
   1728              *enable = rssi_threshold_enable;
   1729              *rssi = rssi_threshold;
   1730          }
   1731          #ifdef MTK_WIFI_ROM_ENABLE
   1732          unsigned int (*get_rx_vector)(unsigned char ucGroupVLD);
   1733          #else
   1734          #ifdef MTK_CM4_WIFI_TASK_ENABLE
   1735          extern unsigned int get_rx_vector(unsigned char ucGroupVLD);
   1736          #else
   1737          // defined in rtmp_data.c ... Michael
   1738          uint32_t get_rx_vector(uint8_t group_vld)
   1739          {
   1740              uint32_t grp3_offset = 0;
   1741          
   1742              // RX Status Group
   1743              grp3_offset = sizeof(HW_MAC_RX_DESC_T);
   1744              if (group_vld & BIT(RX_GROUP_VLD_4)) {
   1745                  grp3_offset += sizeof(HW_MAC_RX_STS_GROUP_4_T);
   1746              }
   1747              if (group_vld & BIT(RX_GROUP_VLD_1)) {
   1748                  grp3_offset += sizeof(HW_MAC_RX_STS_GROUP_1_T);
   1749              }
   1750              if (group_vld & BIT(RX_GROUP_VLD_2)) {
   1751                  grp3_offset += sizeof(HW_MAC_RX_STS_GROUP_2_T);
   1752              }
   1753              if (group_vld & BIT(RX_GROUP_VLD_3)) {
   1754                  return (uint32_t)grp3_offset;
   1755              } else {
   1756                  return 0;
   1757              }
   1758          }
   1759          #endif
   1760          #endif
   1761          
   1762          int32_t check_raw_pkt_rssi_threshold(uint8_t *payload, uint32_t len)
   1763          {
   1764              if (rssi_threshold_enable == 0) {
   1765                  return 0;
   1766              }
   1767          
   1768              int32_t ret = 0;
   1769              P_HW_MAC_RX_STS_GROUP_3_T grp3;
   1770              uint32_t grp3_offset = 0;
   1771              int8_t rssi_info;
   1772              uint8_t grp_vld;
   1773          
   1774              /* grp3_offset = get_rx_vector(((*(first_dw)) >> 25) & 0xf);
   1775               * same to the following two line
   1776               */
   1777              grp_vld = HAL_RX_STATUS_GET_GROUP_VLD((P_HW_MAC_RX_DESC_T)payload);
   1778              grp3_offset = get_rx_vector(grp_vld);
   1779              if (grp3_offset != 0) {
   1780                  grp3 = (P_HW_MAC_RX_STS_GROUP_3_T)(payload + grp3_offset);
   1781                  /* RSSI = RCPI/2 - 110
   1782                   * rssi_info = ((((grp3[2]) >> 9) & 0x7f) - 110) & 0xff;
   1783                   * The same to the following line code
   1784                   */
   1785                  rssi_info = (((HAL_RX_STATUS_GET_RCPI(grp3) >> 1) & 0x7f) - 110) & 0xff;
   1786              } else {
   1787                  rssi_info = -110;
   1788              }
   1789          
   1790              /*
   1791                  hex_dump("pkt rssi:", payload, grp3_offset+40);
   1792                  if(grp3_offset != 0){
   1793                      hex_dump("grp3:", grp3, sizeof(HW_MAC_RX_STS_GROUP_3_T));
   1794                  }
   1795                  INFO(connsys, "rssi:%d\n", rssi_info);
   1796                  */
   1797          
   1798              if (rssi_info < rssi_threshold) {
   1799                  ret = -1;
   1800              }
   1801          
   1802              return ret;
   1803          }
   1804          
   1805          
   1806          void connsys_set_rxraw_handler(wifi_rx_handler_t handler)
   1807          {
   1808              connsys_raw_handler = handler;
   1809          }
   1810          
   1811          int32_t wifi_util_get_inf_number(uint8_t *buf)
   1812          {
   1813              P_INIT_WIFI_EVENT_T header = (P_INIT_WIFI_EVENT_T)(buf);
   1814              if ((header->aucReserved[0] & IOT_INF_MASK) == IOT_PACKET_TYPE_INF_1) {
   1815                  return 1;
   1816              }
   1817          
   1818              return 0;
   1819          }
   1820          #ifdef MTK_CM4_WIFI_TASK_ENABLE
   1821          #ifdef DATA_PATH_87
   1822          /* Fix Me: Violate Module Dependency? ... Michael */
   1823          //#include "lwip/pbuf.h"
   1824          extern unsigned char IoT_Init_Done;
   1825          extern int g_Rx_Raw_Pkt;
   1826          
   1827          void wifi_firmware_rxdata_msg_send(void *pbuffer);
   1828          //u8_t pbuf_free(struct pbuf *p);
   1829          #endif
   1830          #endif
   1831          void connsys_dispatch(void *pkt, uint8_t *payload, int port, unsigned int len)
   1832          {
   1833              if (pkt == NULL || payload == NULL) {
   1834                  return;
   1835              }
   1836          
   1837              PKT_HANDLE_RESULT_T handled = PKT_HANDLE_NON_COMPLETE;
   1838              WIFI_EVENT_DATA_PORT_T *wifi_event_hdr = (WIFI_EVENT_DATA_PORT_T *)payload;
   1839              unsigned int packet_total_offset;
   1840          
   1841              if (pkt != NULL) {
   1842          #if (CONNSYS_DEBUG_MODE_EN == 1)
   1843                  if (CONNSYS_TEST_DEBUG(CONNSYS_DBG_RX)) {
   1844                      DBG_CONNSYS(CONNSYS_DBG_RX, ("\n== Connsys_RX Start ==:\n"));
   1845                      DBG_CONNSYS(CONNSYS_DBG_RX, ("pkt = 0x%x, port = %d, len = %u\n",
   1846                                                   (unsigned int)pkt,
   1847                                                   (int)port,
   1848                                                   (unsigned int)len));
   1849                      DBG_CONNSYS(CONNSYS_DBG_RX, ("wifi_event_hdr:\n"));
   1850                      DBG_CONNSYS(CONNSYS_DBG_RX, ("\tu2Length = 0x%x, u2PktTypeID = 0x%x, ucPacketOffset = 0x%x\n",
   1851                                                   wifi_event_hdr->u2Length,
   1852                                                   wifi_event_hdr->u2PktTypeID,
   1853                                                   wifi_event_hdr->ucPacketOffset));
   1854                  }
   1855          #endif
   1856          
   1857                  if (len >= WIFI_HIF_HEADER_LEN) {
   1858          
   1859                      if (port == WIFI_HIF_RX_PORT0_IDX) {
   1860                          /* cmd packet */
   1861                          if (connsys_ops && connsys_ops->deliver_inband) {
   1862                              handled = connsys_ops->deliver_inband(pkt, payload, len);
   1863                          }
   1864                      } else {
   1865                          /* data packet */
   1866          #ifdef MTK_CM4_WIFI_TASK_ENABLE
   1867          #ifdef DATA_PATH_87
   1868                          if(g_Rx_Raw_Pkt == 0)
   1869                          {
   1870                              if(IoT_Init_Done == 1) {
   1871                                  //hex_dump("Rx Pkt",pkt,64);
   1872                                  wifi_firmware_rxdata_msg_send(pkt);
   1873                                  return;
   1874                              } else {
   1875                                  struct pbuf *p = (struct pbuf *) pkt;
   1876                                  //pbuf_free(p);
   1877                                  connsys_ops->free(p);
   1878                                  p = NULL;
   1879                                  return;
   1880                  	        }
   1881                          }
   1882          #endif/*DATA_PATH_87*/
   1883          #endif
   1884          
   1885                          //check_pkt_lock();
   1886                          if (connsys_raw_handler != NULL) {
   1887                              if (check_raw_pkt_rssi_threshold(payload, len) < 0) {
   1888                                  handled = PKT_HANDLE_COMPLETE;
   1889                                  LOG_I(connsys,"rssi_ignore\n");
   1890                                  goto complete;
   1891                              }
   1892          
   1893                              if(wifi_get_channel_filter()) {
   1894                                  handled = PKT_HANDLE_COMPLETE;
   1895                                  LOG_I(connsys, "ch_ignore\n");
   1896                                  goto complete;
   1897                              }
   1898                              handled = (PKT_HANDLE_RESULT_T)!!(*connsys_raw_handler)(payload, len);
   1899                              if (handled == PKT_HANDLE_COMPLETE) {
   1900                                  goto complete;
   1901                              }
   1902                          }
   1903          
   1904                          if (handled != PKT_HANDLE_COMPLETE) {
   1905          #if (CFG_CONNSYS_IOT_RX_ZERO_COPY_EN == 1)
   1906                              packet_total_offset = WIFI_HIF_HEADER_LEN + wifi_event_hdr->ucPacketOffset;
   1907          #else
   1908                              packet_total_offset = WIFI_HIF_HEADER_LEN;
   1909          #endif
   1910          #if defined(MTK_BSP_LOOPBACK_ENABLE)
   1911                              if (g_loopback_start) {
   1912                                  static unsigned int cnt = 0;
   1913                                  static unsigned int now = 0, start = 0;
   1914                                  cnt += (len - (WIFI_HIF_HEADER_LEN + wifi_event_hdr->aucReserved2[0]));
   1915                                  if (now == 0) {
   1916                                      now = GPT_return_current_count(2); //DRV_Reg32(0x83050068);
   1917                                      start = GPT_return_current_count(2); //DRV_Reg32(0x83050068);
   1918                                  }
   1919                                  if (cnt > 1024000) {
   1920                                      now = GPT_return_current_count(2); //DRV_Reg32(0x83050068);
   1921                                      INFO(connsys, "[LB] %d bytes, %d ms, %d Mbps\n", (int)cnt, (now - start) / 32, (int)((cnt * 8) * 32 / (now - start) / 1000));
   1922                                      start = now;
   1923                                      cnt = 0;
   1924                                  }
   1925                                  packet_total_offset = WIFI_HIF_HEADER_LEN + wifi_event_hdr->aucReserved2[0]; // Use TX offset field, due to loopback
   1926                              }
   1927          #endif // MTK_BSP_LOOPBACK_ENABLE
   1928          
   1929                              if (len >= packet_total_offset) {
   1930                                  int inf = 0;
   1931                                  inf = wifi_util_get_inf_number(payload);
   1932          
   1933                                  /* skip HIF header 3DW = 12 bytes */
   1934                                  connsys_ops->advance_pkt_hdr(pkt, packet_total_offset);
   1935                                  connsys_ops->deliver_tcpip(pkt, payload, len, inf);
   1936                              } else {
   1937                                  CONNSYS_DUMP_I(connsys, "len is less than WIFI HIF RX offset", payload, len);
   1938                                  handled = PKT_HANDLE_COMPLETE;
   1939                              }
   1940                          }
   1941                      }
   1942                  } else {
   1943                      INFO(connsys, "WARN! len is less than WIFI HIF header length.\n");
   1944                      handled = PKT_HANDLE_COMPLETE;
   1945                  }
   1946              }
   1947          
   1948          complete:
   1949              if (handled == PKT_HANDLE_COMPLETE) {
   1950                  connsys_ops->free(pkt);
   1951              }
   1952          }
   1953          #ifdef MT5932_SINGLE_CONTEXT
   1954          extern struct stats_ lwip_stats;
   1955          extern int g_iot_init_done;
   1956          void wifi_print_mgmt_queue();
   1957          extern void (*net_pkt_show)(void);
   1958          int32_t connsys_bus_read_port0_garbage(uint32_t addr, int32_t size);
   1959          extern int g_inband_block;
   1960          #endif
   1961          
   1962          #if (MT7682_WSAP00020553 == 1)
   1963          //void BAPrintQueueLen();
   1964          void ConnsysFlushReorderingBuffer();
   1965          #endif
   1966          int32_t connsys_get_rx_buffer_size(struct connsys_func *func, int32_t size);
   1967          
   1968          void connsys_intr_enhance_mode_receive_one_data(int32_t port, int16_t rx_len)
   1969          {
   1970              void *pkt_ptr = NULL;
   1971              uint8_t *payload_ptr = NULL;
   1972              uint32_t read_len = 0, addr = WRDR1;
   1973          #if (CONNSYS_DEBUG_MODE_EN == 1)
   1974              uint32_t flags;
   1975              static uint32_t continuous_allocate_fail_cnt = 0;
   1976          #endif
   1977          
   1978              if (port == WIFI_HIF_RX_PORT0_IDX) {
   1979                  addr = WRDR0;
   1980              }
   1981              read_len = ALIGN_4BYTE(rx_len) + WIFI_HIF_RX_CS_OFFLOAD_STATUS_LEN;
   1982              read_len = connsys_get_rx_buffer_size(&g_connsys_func, read_len);
   1983              if (read_len > CONNSYS_MAX_RX_PKT_SIZE) {
   1984                  ERR(connsys, "ERROR! connsys: receive too large pkt, read_len = %d\n", (int)read_len);
   1985              }
   1986          
   1987          #if (CONNSYS_DEBUG_MODE_EN == 1)
   1988              if (read_len > CONNSYS_MAX_RX_PKT_SIZE) {
   1989                  DBG_CONNSYS(CONNSYS_DBG_RX,
   1990                              ("WARN! connsys: receive too large pkt, rx_len = %u\n", rx_len));
   1991          
   1992                  /* Driver must read the RX0/1 data completely reported by
   1993                     interrupt enhance mode. No interrupt is trigger again for
   1994                     the remaining packets.
   1995                   */
   1996                  local_irq_save(flags);
   1997                  g_connsys_stat.rx_port[port].rx_invalid_sz_packet_cnt++;
   1998                  if (rx_len > g_connsys_stat.rx_port[port].rx_max_invalid_sz) {
   1999                      g_connsys_stat.rx_port[port].rx_max_invalid_sz = rx_len;
   2000                  }
   2001                  local_irq_restore(flags);
   2002                  connsys_bus_read_port_garbage(addr, read_len);
   2003                  return;
   2004              }
   2005          #endif
   2006          
   2007          #ifdef MT5932_SINGLE_CONTEXT
   2008          if ((port == WIFI_HIF_RX_PORT0_IDX)
   2009          #ifdef DATA_PATH_87
   2010          	|| (IoT_Init_Done == 1)
   2011          #endif
   2012          	)
   2013          {
   2014          #endif
   2015              connsys_ops->alloc(read_len, &pkt_ptr, &payload_ptr);
   2016          #ifdef MT5932_SINGLE_CONTEXT
   2017          }
   2018          else
   2019          {
   2020          //	INFOO(connsys, "lwip: av:%d, max: %d, used: %d\n",
   2021          	//	  lwip_stats.mem.avail, lwip_stats.mem.max, lwip_stats.mem.used);
   2022          	connsys_bus_read_port_garbage(addr, read_len);
   2023          	pkt_ptr = NULL;
   2024          	return;
   2025          }
   2026          #endif
   2027              if (pkt_ptr != NULL)
   2028              {
   2029                  connsys_fifo_read(addr, payload_ptr, read_len);
   2030          	 //hex_dump("payload", (unsigned char *)payload_ptr, read_len);
   2031          #if (CONNSYS_DEBUG_MODE_EN == 1)
   2032                  continuous_allocate_fail_cnt = 0;
   2033          #endif
   2034              } else {
   2035          #if (CONNSYS_DEBUG_MODE_EN == 1)
   2036                  ERR(connsys, "Connsys: can't allocate buffer\n");
   2037          
   2038                  DBG_CONNSYS(CONNSYS_DBG_RX, ("WARN! connsys: can't allocate buffer\n"));
   2039                  /* Driver must read the RX0/1 data completely reported by
   2040                     interrupt enhance mode. No interrupt is trigger again for
   2041                     the remaining packets.
   2042                   */
   2043                  continuous_allocate_fail_cnt ++;
   2044          #if (MT7682_WSAP00020553 == 1)
   2045          		ConnsysFlushReorderingBuffer();
   2046          #endif
   2047                  if ((continuous_allocate_fail_cnt > CFG_CONNSYS_CONTINOUS_ALLOCATE_FAIL_PRINT_CNT_VAL) &&
   2048                          (continuous_allocate_fail_cnt % CFG_CONNSYS_CONTINOUS_ALLOCATE_FAIL_PRINT_CNT_VAL == 1))
   2049          	{
   2050                      LOG_E(connsys, "WARN! connsys: can't allocate buffer for %u times, %u bytes\n",
   2051                            (unsigned int)continuous_allocate_fail_cnt, read_len);
   2052          #ifdef MT5932_SINGLE_CONTEXT
   2053          		wifi_print_mgmt_queue();
   2054          #endif
   2055          		//BAPrintQueueLen();
   2056          
   2057          	}
   2058          
   2059          #endif
   2060          #ifdef MT5932_SINGLE_CONTEXT
   2061          	if (port == WIFI_HIF_RX_PORT0_IDX)
   2062          	{
   2063          		//INFO(connsys, "P0 gb\n");
   2064          		if (g_inband_block)
   2065          		connsys_bus_read_port0_garbage(addr, read_len);
   2066          
   2067          	}
   2068          	else
   2069          #endif
   2070          
   2071                  connsys_bus_read_port_garbage(addr, read_len);
   2072          
   2073          #if (CONNSYS_DEBUG_MODE_EN == 1)
   2074                  local_irq_save(flags);
   2075                  g_connsys_stat.rx_port[port].rx_allocate_fail_cnt ++;
   2076                  local_irq_restore(flags);
   2077          #endif
   2078                  return;
   2079              }
   2080          
   2081              connsys_dispatch(pkt_ptr, payload_ptr, port, rx_len);
   2082          
   2083          #if (CONNSYS_DEBUG_MODE_EN == 1)
   2084              local_irq_save(flags);
   2085              g_connsys_stat.rx_port[port].rx_packet_cnt ++;
   2086              local_irq_restore(flags);
   2087          #endif
   2088          }
   2089          
   2090          
   2091          int32_t connsys_util_intr_enhance_mode_receive_data(void)
   2092          {
   2093              uint32_t cr_whisr;
   2094              uint32_t cr_wrplr;
   2095              uint32_t rx_len;
   2096              int32_t  port;
   2097              ssize_t  err;
   2098              uint32_t retry;
   2099          
   2100              rx_len = 0;
   2101              retry = 0;
   2102              err = 0;
   2103          
   2104          #if (CFG_CONNSYS_MEASURE_INT_TIME_EN == 1)
   2105              connsys_measure_time_set(2);
   2106          #endif
   2107          
   2108              // 0. Disable Interrupt
   2109              connsys_disable_interrupt();       //connsys_cr_write(WHLPCR, W_INT_EN_CLR)
   2110              connsys_disable_whier_trx_int();   //WHIER, val &= ~(TX_DONE_INT_EN | RX0_DONE_INT_EN | RX1_DONE_INT_EN);
   2111          
   2112              // 1. Packet Process
   2113              while (retry < 10)
   2114                  //while (retry<rtry_level)
   2115              {
   2116                  // Read WHISR to Check Interrupt/TX/RX Status
   2117                  connsys_cr_read(WHISR, &cr_whisr);
   2118                  if (cr_whisr == 0) {
   2119                      if (!retry) {
   2120                          LOG_E(connsys, "WHISR=0x%x, abort...\n", (unsigned int)cr_whisr);
   2121                      }
   2122          
   2123                      // Enable Interrupt
   2124                      connsys_enalbe_whier_tx_int();
   2125                      connsys_enalbe_whier_rx_int();
   2126                      connsys_enable_interrupt();
   2127                      return (retry) ? CONNSYS_STATUS_SUCCESS : CONNSYS_STATUS_FAIL;
   2128                  }
   2129          
   2130          #if (CONNSYS_DEBUG_MODE_EN == 1)
   2131                  if (cr_whisr & ABNORMAL_INT) {
   2132                      uint32_t reg1, reg2;
   2133          
   2134                      connsys_cr_read(WASR, &reg1);
   2135                      connsys_cr_read(WASR2, &reg2);
   2136          
   2137                      g_connsys_stat.number_of_abnormal_int ++;
   2138          
   2139                      LOG_E(connsys, "Abnormal Interrupt: WASR(0x%x), WASR2(0x%x)\n", (unsigned int)reg1, (unsigned int)reg2);
   2140                  }
   2141          
   2142                  if (cr_whisr & FW_OWN_BACK_INT) {
   2143                      uint32_t reg1;
   2144                      connsys_cr_read(WASR, &reg1);
   2145                      g_connsys_stat.number_of_fw_own_back ++;
   2146                      //INFO(connsys,"FW_OWN_BACK_INT: WASR(0x%x)\n", (unsigned int)reg1);
   2147                  }
   2148          #endif
   2149          
   2150                  // Update TX Status
   2151                  if (cr_whisr & TX_DONE_INT) {
   2152          #if (CONNSYS_DEBUG_MODE_EN == 1)
   2153                      g_connsys_stat.num_of_tx_int ++;
   2154          #endif
   2155                      connsys_tx_flow_control_update_free_page_cnt();
   2156                  }
   2157          
   2158                  // Process RX0/RX1 Packets
   2159                  if (cr_whisr & (RX0_DONE_INT | RX1_DONE_INT)) {
   2160          #if (CONNSYS_DEBUG_MODE_EN == 1)
   2161                      g_connsys_stat.num_of_rx_int ++;
   2162          #endif
   2163                      while (1) {
   2164                          // Read Port Select
   2165                          if (cr_whisr & RX0_DONE_INT) {
   2166                              port = WIFI_HIF_RX_PORT0_IDX;
   2167                              cr_whisr &= ~RX0_DONE_INT;
   2168                          } else if (cr_whisr & RX1_DONE_INT) {
   2169                              port = WIFI_HIF_RX_PORT1_IDX;
   2170                              cr_whisr &= ~RX1_DONE_INT;
   2171                          } else {
   2172                              break;
   2173                          }
   2174          
   2175                          // Read Packet Length
   2176                          err = connsys_cr_read(WRPLR, &cr_wrplr);
   2177                          if (!err) {
   2178                              rx_len = (port == WIFI_HIF_RX_PORT0_IDX) ? GET_RX0_PACKET_LENGTH(cr_wrplr) : GET_RX1_PACKET_LENGTH(cr_wrplr);
   2179                          }
   2180          
   2181                          if (err || !rx_len) {
   2182          #if (CONNSYS_DEBUG_MODE_EN == 1)
   2183                              g_connsys_stat.rx_port[port].rx_error_cnt++;
   2184          #endif
   2185                              //LOG_hal_fatal( "<<%s>> Read WRPLR failed. Error = %d.\n", __FUNCTION__, (int)err);
   2186                              ERR(connsys, "<<%s>> Read WRPLR failed. Error = %d.\n", __FUNCTION__, (int)err);
   2187                              return CONNSYS_STATUS_FAIL;
   2188                          }
   2189          
   2190                          // Read Packet Data
   2191                          connsys_intr_enhance_mode_receive_one_data(port, rx_len);
   2192          
   2193                          //#if (CFG_CONNSYS_MEASURE_INT_TIME_EN == 1)
   2194                          //    connsys_measure_time_set_pkt_time(port, i);
   2195                          //#endif
   2196                      }
   2197                  } else {
   2198                      break;
   2199                  }
   2200                  retry++;
   2201              }
   2202          
   2203          #if (CFG_CONNSYS_MEASURE_INT_TIME_EN == 1)
   2204              connsys_measure_time_set(3);
   2205              connsys_measure_time_finish();
   2206          #endif
   2207          
   2208              // Enable Interrupt
   2209              connsys_enalbe_whier_tx_int();
   2210              connsys_enalbe_whier_rx_int();
   2211              connsys_enable_interrupt();
   2212          
   2213          #if (CFG_CONNSYS_TRX_BALANCE_EN == 1)
   2214              connsys_balance_clear_rx_wait();
   2215          #endif
   2216          
   2217              return CONNSYS_STATUS_SUCCESS;
   2218          }
   2219          
   2220          
   2221          int32_t connsys_util_low_level_output(uint8_t *buf, ssize_t len, int32_t inf_num)
   2222          {
   2223          #if defined(__ICCARM__)
   2224              ATTR_4BYTE_ALIGN static uint8_t connsys_tx_buf[SDIO_TX_OUTPUT_BUF_SIZE];
   2225          #else
   2226              static uint8_t connsys_tx_buf[SDIO_TX_OUTPUT_BUF_SIZE] __attribute__((aligned(4)));
   2227          #endif
   2228          
   2229              uint8_t *tx_buf = connsys_tx_buf;
   2230              uint8_t fg_need_copy = TRUE;
   2231              uint32_t real_tx_len, tx_len;
   2232              uint32_t clear_len;
   2233              P_INIT_HIF_TX_HEADER_T p_txd;
   2234              int32_t ret = CONNSYS_STATUS_SUCCESS;
   2235          
   2236          #if (CFG_CONNSYS_TXD_PAD_SIZE != 0)
   2237              if (IS_NOT_ALIGN_4((uint32_t)buf) && (g_connsys_func.use_dma)) {
   2238                  tx_buf = connsys_tx_buf;
   2239                  fg_need_copy = TRUE;
   2240              } else {
   2241                  tx_buf = buf;
   2242                  fg_need_copy = FALSE;
   2243              }
   2244          
   2245          #endif
   2246          
   2247              DBG_CONNSYS(CONNSYS_DBG_TX_Q1, ("fg_need_copy = %u\n",
   2248                                              (unsigned int)fg_need_copy));
   2249          
   2250              tx_len = len + sizeof(INIT_HIF_TX_HEADER_T);
   2251              real_tx_len = ALIGN_4BYTE(tx_len);
   2252          
   2253              if (real_tx_len > SDIO_TX_OUTPUT_BUF_SIZE) {
   2254                  return CONNSYS_STATUS_FAIL;
   2255              }
   2256          
   2257              clear_len = real_tx_len + WIFI_HIF_TX_BYTE_CNT_LEN;
   2258              if (clear_len > SDIO_TX_OUTPUT_BUF_SIZE) {
   2259                  clear_len = SDIO_TX_OUTPUT_BUF_SIZE;
   2260              }
   2261              memset(tx_buf, 0, sizeof(INIT_HIF_TX_HEADER_T));
   2262          
   2263              /*
   2264               * tx_buf = INIT_HIF_TX_HEADER + packet_data
   2265               */
   2266              p_txd = (P_INIT_HIF_TX_HEADER_T)tx_buf;
   2267              p_txd->u2TxByteCount = tx_len;
   2268              p_txd->u2PQ_ID = P1_Q1;
   2269              p_txd->rInitWifiCmd.ucPktTypeID = PKT_ID_CMD;
   2270          
   2271              if (inf_num == IOT_PACKET_TYPE_INF_1_IDX) {
   2272                  p_txd->rInitWifiCmd.ucReserved = IOT_PACKET_TYPE_INF_1;
   2273              } else {
   2274                  p_txd->rInitWifiCmd.ucReserved = IOT_PACKET_TYPE_INF_0;
   2275              }
   2276          
   2277          
   2278              if (fg_need_copy) {
   2279                  /* Fill in packet data */
   2280                  memmove(p_txd->rInitWifiCmd.aucBuffer, buf, len);
   2281              }
   2282          
   2283              memset((void *)((unsigned int)tx_buf + tx_len), 0, clear_len - tx_len);
   2284          
   2285              {
   2286                  signed int flow_control_status;
   2287                  flow_control_status =
   2288                      connsys_tx_flow_control_check_and_update_tx(WIFI_HIF_TX_PORT_IDX, real_tx_len);
   2289          
   2290                  if (flow_control_status == CONNSYS_STATUS_SUCCESS) {
   2291                      ret = connsys_util_tx_data((uint8_t *)tx_buf, tx_len);
   2292                  } else {
   2293                      ret = CONNSYS_STATUS_FAIL;
   2294                  }
   2295              }
   2296          
   2297              return ret;
   2298          }
   2299          
   2300          
   2301          #if (WIFI_BUILD_OPTION == 1)
   2302          #include "dma_sw.h"
   2303          
   2304          static void connsys_dma_LP_irq_handler()
   2305          {
   2306              INFO(connsys, "DMA handler for LP...\n");
   2307          }
   2308          
   2309          // only for Low Power emulation
   2310          int32_t connsys_emulLP_connsys_open()
   2311          {
   2312              struct connsys_func *func = &g_connsys_func;
   2313              int32_t  ret = 0;
   2314          
   2315              g_connsys_func.blksize = MY_CONNSYS_BLOCK_SIZE;
   2316              g_connsys_func.num = SDIO_GEN3_FUNCTION_WIFI;
   2317              g_connsys_func.irq_callback = NULL;
   2318              g_connsys_func.use_dma = 0; // 1 for DMA mode
   2319          
   2320              if (g_connsys_func.use_dma) {
   2321                  DMA_Register(SDIO_GDMA_CH, connsys_dma_LP_irq_handler);
   2322              }
   2323          
   2324              // Enable GDMA
   2325              if (g_connsys_func.use_dma) {
   2326          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
   2327                  hal_clock_enable(HAL_CLOCK_CG_DMA);
   2328          #else
   2329                  REG32(GDMA_CHANNEL_ENABLE) = 0xFFFFFFFF;
   2330          #endif
   2331              }
   2332          
   2333              // function enable
   2334              connsys_bus_get_bus(func);
   2335              ret = connsys_bus_enable_func(func);
   2336              connsys_bus_release_bus(func);
   2337              if (ret) {
   2338                  LOG_E(connsys, "<<%s>> Enable function failed. Error = %d.\n", __FUNCTION__, (int)ret);
   2339                  goto err;
   2340              }
   2341          
   2342              // set block size
   2343              connsys_bus_get_bus(func);
   2344              ret = connsys_bus_set_block_size(func, func->blksize);
   2345              connsys_bus_release_bus(func);
   2346          
   2347              if (ret) {
   2348                  LOG_E(connsys, "<<%s>> Set block size failed. Error = %d.\n", __FUNCTION__, (int)ret);
   2349                  goto err;
   2350              }
   2351          
   2352              // register sdio irq
   2353              connsys_bus_get_bus(func);
   2354              ret = connsys_bus_get_irq(func, connsys_driver_interrupt); /* Interrupt IRQ handler */
   2355              connsys_bus_release_bus(func);
   2356              if (ret) {
   2357                  LOG_E(connsys, "<<%s>> Claim irq failed. Error = %d.\n", __FUNCTION__, (int)ret);
   2358                  goto err;
   2359              }
   2360          
   2361              // register to MCU IRQ
   2362          //    NVIC_Register(CM4_HIF_IRQ, connsys_irq_handler);
   2363          //    NVIC_EnableIRQ(CM4_HIF_IRQ);
   2364          
   2365              //connsys_bus_writel(func, 0x0, 0x160, &ret);
   2366              //INFO(connsys, "write 0x160 done, ret=0x%x\n", ret);
   2367          
   2368              INFO(connsys, " End of %s\n", __FUNCTION__);
   2369          err:
   2370              return ret;
   2371          }
   2372          #endif //#if (WIFI_BUILD_OPTION == 1)
   2373          
   2374          
   2375          /*
   2376              unit:
   2377                  0: in numbers of frames
   2378                  1: in numbers of pages
   2379           */
   2380          
   2381          uint32_t pse_get_queue_len(uint32_t pid, uint32_t qid, uint8_t unit)
   2382          {
   2383              uint32_t q_len;
   2384          
   2385              if (unit) {
   2386                  REG32(PSE_GQC) = PSE_GQC_QLEN_IN_PAGE_PAGES |
   2387                                   (pid << PSE_GQC_GET_QLEN_PID_OFFSET) |
   2388                                   (qid << PSE_GQC_GET_QLEN_QID_OFFSET);
   2389              } else {
   2390                  REG32(PSE_GQC) = PSE_GQC_QLEN_IN_PAGE_FRAMES |
   2391                                   (pid << PSE_GQC_GET_QLEN_PID_OFFSET) |
   2392                                   (qid << PSE_GQC_GET_QLEN_QID_OFFSET);
   2393              }
   2394          
   2395              q_len = (REG32(PSE_GQC) & PSE_GQC_QLEN_RETURN_VALUE_MASK) >>
   2396                      PSE_GQC_QLEN_RETURN_VALUE_OFFSET;
   2397          
   2398              return q_len;
   2399          }
   2400          
   2401          uint32_t pse_get_total_page_num(void)
   2402          {
   2403              uint32_t total_page_num;
   2404              total_page_num = (REG32(PSE_BC)&PSE_BC_TOTAL_PAGE_NUM_MASK) >> PSE_BC_TOTAL_PAGE_NUM_OFFSET;
   2405              return total_page_num;
   2406          }
   2407          
   2408          uint32_t connsys_util_pse_get_p0_min_resv(void)
   2409          {
   2410              uint32_t min_reserve;
   2411              min_reserve = (REG32(PSE_FC_P0)&PSE_FC_MIN_RSRV_MASK) >> PSE_FC_MIN_RSRV_OFFSET;
   2412              return min_reserve;
   2413          }
   2414          
   2415          uint32_t connsys_util_pse_get_min_resv(uint32_t addr)
   2416          {
   2417              uint32_t min_reserve;
   2418              min_reserve = (REG32(addr)&PSE_FC_MIN_RSRV_MASK) >> PSE_FC_MIN_RSRV_OFFSET;
   2419              return min_reserve;
   2420          }
   2421          
   2422          
   2423          void connsys_tx_query_whisr(void)
   2424          {
   2425              uint32_t cr_whisr;
   2426          
   2427              connsys_disable_interrupt();
   2428              connsys_disable_whier_trx_int();
   2429              connsys_cr_read(WHISR, &cr_whisr);
   2430              if (cr_whisr & TX_DONE_INT) {
   2431          #if (CONNSYS_DEBUG_MODE_EN == 1)
   2432                  g_connsys_stat.num_of_tx_int ++;
   2433          #endif
   2434                  connsys_tx_flow_control_update_free_page_cnt();
   2435              }
   2436              connsys_enalbe_whier_tx_int();
   2437              connsys_enalbe_whier_rx_int();
   2438              connsys_enable_interrupt();
   2439          }
   2440          
   2441          
   2442          void connsys_util_pse_ffc_get(uint32_t *ffa_cnt, uint32_t *free_page_cnt)
   2443          {
   2444              if (ffa_cnt) {
   2445                  *ffa_cnt = (REG32(PSE_FC_FFC)&PSE_FC_FFC_FFA_CNT_MASK) >> PSE_FC_FFC_FFA_CNT_OFFSET;
   2446              }
   2447          
   2448              if (free_page_cnt) {
   2449                  *free_page_cnt = (REG32(PSE_FC_FFC)&PSE_FC_FFC_FREE_PAGE_CNTT_MASK) >> PSE_FC_FFC_FREE_PAGE_CNTT_OFFSET;
   2450              }
   2451          }
   2452          
   2453          
   2454          #ifdef MTK_MINICLI_ENABLE
   2455          void connsys_cli_set_debug_falg(uint32_t debug)
   2456          {
   2457              printf("set debug flag %u\n", (unsigned int)debug);
   2458              if (debug <= CONNSYS_DBG_MAX_NUM) {
   2459                  CONNSYS_SET_DEBUG((1 << debug));
   2460              } else {
   2461                  printf("WARN! wrong argument. connsys has no such debug flag.\n");
   2462              }
   2463          }
   2464          
   2465          
   2466          void connsys_cli_clear_debug_flag(uint32_t debug)
   2467          {
   2468              printf("clear debug flag %u\n", (unsigned int)debug);
   2469          
   2470              if (debug <= CONNSYS_DBG_MAX_NUM) {
   2471                  CONNSYS_CLEAR_DEBUG((1 << debug));
   2472              } else {
   2473                  printf("WARN! wrong argument. connsys has no such debug flag.\n");
   2474              }
   2475          }
   2476          
   2477          
   2478          void connsys_cli_show_debug_flag(void)
   2479          {
   2480              printf("all debug falgs:\n");
   2481              printf("0:CONNSYS_DBG_RX\n");
   2482              printf("1:CONNSYS_DBG_TX_Q0 (in-band cmd)\n");
   2483              printf("2:CONNSYS_DBG_TX_Q1 (data)\n");
   2484              printf("3:CONNSYS_DBG_PORT\n");
   2485          }
   2486          
   2487          
   2488          void connsys_cli_show_current_debug_flag(void)
   2489          {
   2490              printf("current debug flags:\n");
   2491          
   2492              if (CONNSYS_TEST_DEBUG(CONNSYS_DBG_RX)) {
   2493                  printf("0:CONNSYS_DBG_RX\n");
   2494              }
   2495          
   2496              if (CONNSYS_TEST_DEBUG(CONNSYS_DBG_TX_Q0)) {
   2497                  printf("1:CONNSYS_DBG_TX_Q0\n");
   2498              }
   2499          
   2500              if (CONNSYS_TEST_DEBUG(CONNSYS_DBG_TX_Q1)) {
   2501                  printf("2:CONNSYS_DBG_TX_Q1\n");
   2502              }
   2503          
   2504              if (CONNSYS_TEST_DEBUG(CONNSYS_DBG_PORT)) {
   2505                  printf("3:CONNSYS_DBG_PORT\n");
   2506              }
   2507          }
   2508          
   2509          static void _connsys_util_show_pse_flow_control_setting(char *queue_name, uint32_t addr)
   2510          {
   2511              uint32_t max_quota;
   2512              uint32_t min_reserve;
   2513          
   2514              max_quota   = (REG32(addr)&PSE_FC_MAX_QUOTA_MASK) >> PSE_FC_MAX_QUOTA_OFFSET;
   2515              min_reserve = (REG32(addr)&PSE_FC_MIN_RSRV_MASK) >> PSE_FC_MIN_RSRV_OFFSET;
   2516          
   2517              if (max_quota == 0xFFF) {
   2518                  printf("\t%s(0x%x): max quota setting disable, min reserv setting %u\n",
   2519                         queue_name,
   2520                         (unsigned int)addr,
   2521                         (unsigned int)min_reserve);
   2522              } else {
   2523                  printf("\t%s(0x%x): max quota setting %u, min reserv setting %u\n",
   2524                         queue_name,
   2525                         (unsigned int)addr,
   2526                         (unsigned int)max_quota,
   2527                         (unsigned int)min_reserve);
   2528              }
   2529          
   2530          }
   2531          
   2532          void connsys_cli_show_pse(void)
   2533          {
   2534              uint32_t pid;
   2535              uint32_t qid;
   2536              uint32_t ffa_cnt;
   2537              uint32_t free_page_cnt;
   2538          
   2539              printf("==>connsys_cli_show_pse\n");
   2540          
   2541              printf("PSE queue length\n");
   2542              printf("Host (P0):\n");
   2543              printf("\tHTX Qs\n");
   2544              pid = 0;
   2545              for (qid = 0; qid < 2; qid++) {
   2546                  printf("\tQ%u: %8u frames, %8u pages\n",
   2547                         (unsigned int)qid,
   2548                         (unsigned int)pse_get_queue_len(pid, qid, 0),
   2549                         (unsigned int)pse_get_queue_len(pid, qid, 1));
   2550              }
   2551              printf("\tHRX Qs\n");
   2552              qid = 2;
   2553              printf("\tQ0: %8u frames, %8u pages\n",
   2554                     (unsigned int)pse_get_queue_len(pid, qid, 0),
   2555                     (unsigned int)pse_get_queue_len(pid, qid, 1));
   2556          
   2557              pid = 1;
   2558              printf("CPU (P1):\n");
   2559              for (qid = 0; qid < 4; qid++) {
   2560                  printf("\tCTX_Q%u: %8u frames, %8u pages\n",
   2561                         (unsigned int)qid,
   2562                         (unsigned int)pse_get_queue_len(pid, qid, 0),
   2563                         (unsigned int)pse_get_queue_len(pid, qid, 1));
   2564              }
   2565          
   2566              printf("WLAN (P2):\n");
   2567              pid = 2;
   2568              for (qid = 0; qid < 14; qid++) {
   2569                  if (qid == 7) {
   2570                      printf("\tAC%u(BC/MC): %8u frames, %8u pages\n",
   2571                             (unsigned int)qid,
   2572                             (unsigned int)pse_get_queue_len(pid, qid, 0),
   2573                             (unsigned int)pse_get_queue_len(pid, qid, 1));
   2574          
   2575                  } else if (qid == 8) {
   2576                      printf("\tAC%u(Beacon): %8u frames, %8u pages\n",
   2577                             (unsigned int)qid,
   2578                             (unsigned int)pse_get_queue_len(pid, qid, 0),
   2579                             (unsigned int)pse_get_queue_len(pid, qid, 1));
   2580                  } else {
   2581                      printf("\tAC%u: %8u frames, %8u pages\n",
   2582                             (unsigned int)qid,
   2583                             (unsigned int)pse_get_queue_len(pid, qid, 0),
   2584                             (unsigned int)pse_get_queue_len(pid, qid, 1));
   2585                  }
   2586              }
   2587          
   2588              pid = 3;
   2589              printf("PSE (P3):\n");
   2590              printf("\tSWitch Qs:\n");
   2591              for (qid = 0; qid < 8; qid++) {
   2592                  printf("\tSW%u: %8u frames, %8u pages\n",
   2593                         (unsigned int)qid,
   2594                         (unsigned int)pse_get_queue_len(pid, qid, 0),
   2595                         (unsigned int)pse_get_queue_len(pid, qid, 1));
   2596              }
   2597              printf("\tFree Q:\n");
   2598              qid = 8;
   2599              printf("\tFree: %8u frames, %8u pages\n",
   2600                     (unsigned int)pse_get_queue_len(pid, qid, 0),
   2601                     (unsigned int)pse_get_queue_len(pid, qid, 1));
   2602          
   2603              printf("Free control related:\n");
   2604              printf("Total page number:%u\n", (unsigned int)pse_get_total_page_num());
   2605          
   2606              _connsys_util_show_pse_flow_control_setting("P0", PSE_FC_P0);
   2607              _connsys_util_show_pse_flow_control_setting("P1", PSE_FC_P1);
   2608              _connsys_util_show_pse_flow_control_setting("P2 Q0", PSE_FC_P2_Q0);
   2609              _connsys_util_show_pse_flow_control_setting("P2 Q1", PSE_FC_P2_Q1);
   2610              _connsys_util_show_pse_flow_control_setting("P2 Q2", PSE_FC_P2_Q2);
   2611          
   2612              connsys_util_pse_ffc_get(&ffa_cnt, &free_page_cnt);
   2613          
   2614              printf("\tFC_FFC(0x%x):\n", (unsigned int)PSE_FC_FFC);
   2615              printf("\t\tFree for all counter status:%u\n", (unsigned int)ffa_cnt);
   2616              printf("\t\tFree page counter status:%u\n", (unsigned int)free_page_cnt);
   2617          
   2618          }
   2619          
   2620          void connsys_cli_dump_pse_reg(void)
   2621          {
   2622              uint32_t offset;
   2623              uint32_t addr;
   2624          
   2625              printf("==>connsys_cli_dump_pse_reg\n");
   2626              printf("WF_PSE_TOP_BASE: 0x%x\n", WF_PSE_TOP_BASE);
   2627          
   2628          
   2629              for (offset = 0x0; offset <= 0x18; offset += 4) {
   2630                  addr = offset + WF_PSE_TOP_BASE;
   2631                  printf("Addr: 0x%x, 0x%x\n",
   2632                         (unsigned int)addr,
   2633                         (unsigned int)REG32(addr));
   2634              }
   2635          
   2636          
   2637              for (offset = 0x118; offset <= 0x150; offset += 4) {
   2638                  addr = offset + WF_PSE_TOP_BASE;
   2639                  printf("Addr: 0x%x, 0x%x\n",
   2640                         (unsigned int)addr,
   2641                         (unsigned int)REG32(addr));
   2642              }
   2643          }
   2644          
   2645          void connsys_cli_show_help(void)
   2646          {
   2647              printf("connsys cli help:\n");
   2648              printf("Usage: c <param1> <param2>\n");
   2649              printf("The following are description for param1:\n");
   2650              printf("\t0: show connsys debug flag\n");
   2651              printf("\t1: set connsys debug flag\n");
   2652              printf("\t    e.g. '$c 1 2' ==>enable TX Q1 debug\n");
   2653              printf("\t2: clear connsys debug flag\n");
   2654              printf("\t    e.g. '$c 2 1' ==>disable TX Q0 debug\n");
   2655              printf("\t3: show current connsys debug flag\n");
   2656              printf("\t4: show stat\n");
   2657              printf("\t5: dump CR\n");
   2658              printf("\t6: show tx flow control info\n");
   2659              printf("\t7: show connsys compiler option\n");
   2660              printf("\t8: read whisr register\n");
   2661              printf("\t9: trigger connsys interrupt handler\n");
   2662              printf("\t10: show connsys time measure\n");
   2663              printf("\t11: set tx flow control config, 1: enable, 0: disable\n");
   2664              printf("\t12: show pse info \n");
   2665              printf("\t13: dump pse reg \n");
   2666              printf("\t14: set tx flow control reserve page \n");
   2667              printf("\t15: show last interrupt enhance mode struct\n");
   2668              printf("\t16: set tx/rx balance config, 1: enable, 0: disable\n");
   2669              printf("\t17: set max continus tx num for balance\n");
   2670              printf("\t18: set max continus rx num for balance\n");
   2671              printf("\t19: show tx/rx balance info\n");
   2672              printf("\t20: show headroom offset for QoS/non-QoS\n");
   2673              printf("\t21: set headroom offset for QoS, ex: c 21 42 => set offset to 42 bytes\n");
   2674              printf("\t22: set headroom offset for non-QoS, ex: c 22 38 => set offset to 38 bytes\n");
   2675              printf("\t23: get connsys driver domain CR, ex: c 23 0x14      => get WHIER(0x14)\n");
   2676              printf("\t24: set connsys driver domain CR, ex: c 24 0x14  0x0 => set WHIER(0x14) to 0\n");
   2677          }
   2678          
   2679          uint8_t connsys_util_cli_handler(uint8_t len, char *param[])
   2680          {
   2681              INFO(connsys, "==>connsys_util_cli_handler\n");
   2682          
   2683              if (len == 0) {
   2684                  printf("incomplete command\n");
   2685                  connsys_cli_show_help();
   2686                  return 0;
   2687              }
   2688          
   2689              switch (atoi(param[0])) {
   2690                  case 0: {
   2691                      connsys_cli_show_debug_flag();
   2692                  }
   2693                  break;
   2694          
   2695                  case 1: {
   2696                      uint32_t debug_flag;
   2697                      debug_flag = atoi(param[1]);
   2698                      if (len != 2) {
   2699                          LOG_E(connsys, "WARN! wrong argument\n");
   2700                      } else {
   2701                          connsys_cli_set_debug_falg(debug_flag);
   2702                      }
   2703                  }
   2704                  break;
   2705          
   2706                  case 2: {
   2707                      uint32_t debug_flag;
   2708                      debug_flag = atoi(param[1]);
   2709                      if (len != 2) {
   2710                          printf("WARN! wrong argument\n");
   2711                      } else {
   2712                          connsys_cli_clear_debug_flag(debug_flag);
   2713                      }
   2714                  }
   2715                  break;
   2716          
   2717                  case 3: {
   2718                      connsys_cli_show_current_debug_flag();
   2719                  }
   2720                  break;
   2721          
   2722                  case 4: {
   2723                      connsys_print_stat();
   2724                  }
   2725                  break;
   2726          
   2727                  case 5: {
   2728                      connsys_dump_cr();
   2729                  }
   2730                  break;
   2731          
   2732                  case 6: {
   2733                      connsys_tx_flow_control_show_info();
   2734                  }
   2735                  break;
   2736                  case 7: {
   2737                      connsys_show_config_option();
   2738                  }
   2739                  break;
   2740          
   2741                  case 8: {
   2742                      connsys_dump_whisr();
   2743                  }
   2744                  break;
   2745                  case 9: {
   2746                      printf("trigger connsys interrupt by cmd\n");
   2747                      connsys_driver_interrupt(&g_connsys_func);
   2748                  }
   2749                  break;
   2750          
   2751          
   2752                  case 10: {
   2753          #if (CFG_CONNSYS_MEASURE_INT_TIME_EN == 1)
   2754                      connsys_measure_time_show();
   2755          #else
   2756                      printf("WARN! not support\n");
   2757          #endif
   2758                  }
   2759                  break;
   2760                  case 11: {
   2761                      uint8_t config;
   2762                      config = (uint8_t)atoi(param[1]);
   2763                      printf("Configure tx flow control, 1: enable, 0: disable\n");
   2764                      if (len != 2) {
   2765                          printf("WARN! wrong argument\n");
   2766                      } else {
   2767                          connsys_tx_flow_control_config(config);
   2768                      }
   2769                  }
   2770                  break;
   2771                  case 12: {
   2772                      connsys_cli_show_pse();
   2773                  }
   2774                  break;
   2775          
   2776                  case 13: {
   2777                      connsys_cli_dump_pse_reg();
   2778                  }
   2779                  break;
   2780          
   2781                  case 14: {
   2782                      uint32_t reserve_page_num;
   2783                      reserve_page_num = (uint32_t)atoi(param[1]);
   2784                      printf("set tx flow control reserve page\n");
   2785                      if (len != 2) {
   2786                          printf("WARN! wrong argument\n");
   2787                      } else {
   2788                          connsys_tx_flow_control_set_reserve_page(reserve_page_num);
   2789                      }
   2790                  }
   2791                  break;
   2792          
   2793                  case 15: {
   2794                      connsys_util_intr_enhance_mode_dump_last_struct();
   2795                  }
   2796                  break;
   2797          
   2798          #if (CFG_CONNSYS_TRX_BALANCE_EN == 1)
   2799                  case 16: {
   2800                      uint8_t config;
   2801                      config = (uint32_t)atoi(param[1]);
   2802                      printf("Configure tx flow control, 1: enable, 0: disable\n");
   2803                      if (len != 2) {
   2804                          printf("WARN! wrong argument\n");
   2805                      } else {
   2806                          connnsys_balance_set_enable(config);
   2807                      }
   2808                  }
   2809                  break;
   2810          
   2811                  case 17: {
   2812                      uint32_t num;
   2813                      num = (uint32_t)atoi(param[1]);
   2814                      printf("set max continus tx num for balance\n");
   2815                      if (len != 2) {
   2816                          printf("WARN! wrong argument\n");
   2817                      } else {
   2818                          connnsys_balance_set_max_num_of_continuous_tx(num);
   2819                      }
   2820                  }
   2821                  break;
   2822                  case 18: {
   2823                      uint32_t num;
   2824                      num = (uint32_t)atoi(param[1]);
   2825                      printf("set max continus rx num for balance\n");
   2826                      if (len != 2) {
   2827                          printf("WARN! wrong argument\n");
   2828                      } else {
   2829                          connnsys_balance_set_max_num_of_continuous_rx(num);
   2830                      }
   2831                  }
   2832                  break;
   2833          
   2834                  case 19: {
   2835                      connnsys_balance_show_info();
   2836                  }
   2837                  break;
   2838          #endif /* (CFG_CONNSYS_TRX_BALANCE_EN == 1) */
   2839                  case 20: {
   2840                      printf("Headroom offset for QoS=%d bytes, for non-QoS=%d bytes\n",
   2841                             (int)connsys_get_headroom_offset(CONNSYS_HEADROOM_OFFSET_QOS),
   2842                             (int)connsys_get_headroom_offset(CONNSYS_HEADROOM_OFFSET_NON_QOS));
   2843                  }
   2844                  break;
   2845                  case 21: {
   2846                      uint32_t offset;
   2847                      offset = (uint32_t)atoi(param[1]);
   2848                      connsys_set_headroom_offset(CONNSYS_HEADROOM_OFFSET_QOS, offset);
   2849                      printf("set headroom offset for QoS=%d bytes\n", (int)offset);
   2850                  }
   2851                  break;
   2852                  case 22: {
   2853                      uint32_t offset;
   2854                      offset = (uint32_t)atoi(param[1]);
   2855                      connsys_set_headroom_offset(CONNSYS_HEADROOM_OFFSET_NON_QOS, offset);
   2856                      printf("set headroom offset for Non-QoS=%d bytes\n", (int)offset);
   2857                  }
   2858                  break;
   2859                  case 23: {
   2860                      uint8_t  type;
   2861                      uint32_t reg, value;
   2862          
   2863                      reg = toi(param[1], &type);
   2864                      connsys_cr_read(reg, &value);
   2865                      printf("CR[0x%x]=0x%x\n", (unsigned int)reg, (unsigned int)value);
   2866                      break;
   2867                  }
   2868          
   2869                  case 24: {
   2870                      uint8_t  type;
   2871                      uint32_t reg, value;
   2872          
   2873                      reg = toi(param[1], &type);
   2874                      value = toi(param[2], &type);
   2875                      connsys_cr_write(reg, value);
   2876                      printf("Write CR[0x%x]=0x%x\n", (unsigned int)reg, (unsigned int)value);
   2877                      break;
   2878                  }
   2879                  default:
   2880                      printf("WARN! invalid option %s\n", param[0]);
   2881                      connsys_cli_show_help();
   2882                      break;
   2883              }
   2884          
   2885              return 0;
   2886          }
   2887          
   2888          uint8_t connsys_cli_entry(uint8_t len, char *param[])
   2889          {
   2890              return connsys_util_cli_handler(len, param);
   2891          }
   2892          
   2893          
   2894          #endif
   2895          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   _connsys_util_show_pse_flow_control_setting
         0   -> printf
        16   -> printf
      16   check_raw_pkt_rssi_threshold
        16   -> get_rx_vector
       8   connsys_cli_clear_debug_flag
         0   -> printf
         8   -> printf
      16   connsys_cli_dump_pse_reg
        16   -> printf
       0   connsys_cli_entry
         0   -> connsys_util_cli_handler
       8   connsys_cli_set_debug_falg
         0   -> printf
         8   -> printf
       8   connsys_cli_show_current_debug_flag
         0   -> printf
         8   -> printf
       8   connsys_cli_show_debug_flag
         0   -> printf
         8   -> printf
       8   connsys_cli_show_help
         0   -> printf
         8   -> printf
      24   connsys_cli_show_pse
        24   -> _connsys_util_show_pse_flow_control_setting
        24   -> connsys_util_pse_ffc_get
        24   -> printf
        24   -> pse_get_queue_len
        24   -> pse_get_total_page_num
       0   connsys_create_inband_fw_scatter_txd_rom
      48   connsys_dispatch
         0   -- Indirect call
        48   -- Indirect call
        48   -> check_raw_pkt_rssi_threshold
        48   -> printf
        48   -> wifi_get_channel_filter
        48   -> wifi_util_get_inf_number
    2080   connsys_download_wifi_profile
      2080   -- Indirect call
      2080   -> __aeabi_memclr4
      2080   -> __aeabi_memcpy
      2080   -> connsys_util_pda_download
      48   connsys_fw_download
        48   -- Indirect call
        48   -> connsys_get_ownership
         0   -> connsys_util_fw_download_done
        48   -> connsys_util_pda_download
      32   connsys_fw_download_CmdAddressLenReq
        32   -- Indirect call
        32   -> connsys_util_create_inband_cmd_txd_rom
    1088   connsys_fw_download_Tx_Scatter
      1088   -- Indirect call
      1088   -> __aeabi_memcpy
      1088   -> __aeabi_memset4
      1088   -> connsys_create_inband_fw_scatter_txd_rom
      1088   -> connsys_fifo_write
      40   connsys_get_ilm_image_info
        40   -- Indirect call
      40   connsys_get_ilm_image_info_from_flash
        40   -- Indirect call
     184   connsys_get_patch_semaphore
       184   -- Indirect call
       184   -> __aeabi_memset4
       184   -> connsys_abnormal_interrupt_check
       184   -> connsys_cr_read
       184   -> connsys_fifo_read
       184   -> connsys_fifo_write
       184   -> connsys_util_create_inband_cmd_txd_rom
       184   -> connsys_util_patch_download_get_semaphore_event_check
      56   connsys_img_direct_download
        56   -- Indirect call
        56   -> connsys_pda_config
      16   connsys_intr_enhance_mode_dump_struct
         0   -> printf
        16   -> printf
      48   connsys_intr_enhance_mode_receive_one_data
        48   -- Indirect call
        48   -> connsys_bus_read_port_garbage
        48   -> connsys_dispatch
        48   -> connsys_fifo_read
        48   -> connsys_get_rx_buffer_size
        48   -> printf
      32   connsys_patch_direct_download
        32   -- Indirect call
        32   -> connsys_get_ownership
        32   -> connsys_get_patch_semaphore
        32   -> connsys_img_direct_download
        32   -> connsys_patch_finish
      32   connsys_patch_download_body
        32   -- Indirect call
        32   -> connsys_download_wifi_profile
        32   -> connsys_get_ownership
        32   -> connsys_get_patch_semaphore
        32   -> connsys_patch_finish
        32   -> connsys_util_pda_download
     176   connsys_patch_finish
       176   -- Indirect call
       176   -> __aeabi_memset4
       176   -> connsys_abnormal_interrupt_check
       176   -> connsys_cr_read
       176   -> connsys_fifo_read
       176   -> connsys_fifo_write
       176   -> connsys_util_create_inband_cmd_txd_rom
       176   -> connsys_util_fw_download_CmdAddressLenReq_event_check
     176   connsys_pda_config
       176   -- Indirect call
       176   -> __aeabi_memset4
       176   -> connsys_abnormal_interrupt_check
       176   -> connsys_cr_read
       176   -> connsys_fifo_read
       176   -> connsys_fifo_write
       176   -> connsys_fw_download_CmdAddressLenReq
       176   -> connsys_util_fw_download_CmdAddressLenReq_event_check
       0   connsys_set_rxraw_handler
       0   connsys_set_wifi_profile
       8   connsys_tx_query_whisr
         8   -> connsys_cr_read
         8   -> connsys_disable_interrupt
         8   -> connsys_disable_whier_trx_int
         8   -> connsys_enable_interrupt
         8   -> connsys_enalbe_whier_rx_int
         8   -> connsys_enalbe_whier_tx_int
         8   -> connsys_tx_flow_control_update_free_page_cnt
      32   connsys_util_cli_handler
        32   -- Indirect call
        32   -> atoi
        32   -> connsys_cli_clear_debug_flag
        32   -> connsys_cli_dump_pse_reg
        32   -> connsys_cli_set_debug_falg
        32   -> connsys_cli_show_current_debug_flag
        32   -> connsys_cli_show_debug_flag
        32   -> connsys_cli_show_help
        32   -> connsys_cli_show_pse
        32   -> connsys_cr_read
        32   -> connsys_cr_write
        32   -> connsys_driver_interrupt
        32   -> connsys_dump_cr
        32   -> connsys_dump_whisr
        32   -> connsys_get_headroom_offset
        32   -> connsys_print_stat
        32   -> connsys_set_headroom_offset
        32   -> connsys_show_config_option
        32   -> connsys_tx_flow_control_config
        32   -> connsys_tx_flow_control_set_reserve_page
        32   -> connsys_tx_flow_control_show_info
        32   -> connsys_util_intr_enhance_mode_dump_last_struct
        32   -> printf
        32   -> toi
       0   connsys_util_create_inband_cmd_txd_rom
       8   connsys_util_firmware_download
         0   -> connsys_util_fw_direct_download
         8   -> connsys_util_patch_download
      72   connsys_util_fw_direct_download
        72   -- Indirect call
        72   -> connsys_get_ilm_image_info_from_flash
        72   -> connsys_get_ownership
        72   -> connsys_img_direct_download
        72   -> connsys_util_fw_download_done
      40   connsys_util_fw_download_CmdAddressLenReq_event_check
        40   -- Indirect call
     184   connsys_util_fw_download_done
       184   -- Indirect call
       184   -> __aeabi_memset4
       184   -> connsys_abnormal_interrupt_check
       184   -> connsys_cr_read
       184   -> connsys_fifo_read
       184   -> connsys_fifo_write
       184   -> connsys_util_create_inband_cmd_txd_rom
       184   -> connsys_util_fw_download_CmdAddressLenReq_event_check
       184   -> hal_gpt_get_duration_count
       184   -> hal_gpt_get_free_run_count
       0   connsys_util_get_n9_fw_ver
         0   -> __aeabi_memcpy
       0   connsys_util_get_ncp_patch_ver
         0   -> __aeabi_memcpy
       0   connsys_util_intr_enhance_mode_dump_last_struct
         0   -> connsys_intr_enhance_mode_dump_struct
      48   connsys_util_intr_enhance_mode_receive_data
        48   -- Indirect call
        48   -> connsys_cr_read
        48   -> connsys_disable_interrupt
        48   -> connsys_disable_whier_trx_int
        48   -> connsys_enable_interrupt
        48   -> connsys_enalbe_whier_rx_int
        48   -> connsys_enalbe_whier_tx_int
        48   -> connsys_intr_enhance_mode_receive_one_data
        48   -> connsys_tx_flow_control_update_free_page_cnt
      32   connsys_util_low_level_output
        32   -> __aeabi_memmove
        32   -> __aeabi_memset
        32   -> __aeabi_memset4
        32   -> connsys_tx_flow_control_check_and_update_tx
         0   -> connsys_util_tx_data
        32   -> printf
      40   connsys_util_patch_download
        40   -- Indirect call
        40   -> connsys_patch_download_body
      40   connsys_util_patch_download_get_semaphore_event_check
        40   -- Indirect call
      16   connsys_util_pda_download
         0   -> connsys_fw_download_Tx_Scatter
        16   -> connsys_pda_config
       4   connsys_util_pse_ffc_get
       0   connsys_util_pse_get_min_resv
       0   connsys_util_pse_get_p0_min_resv
      24   connsys_util_rx_data
        24   -- Indirect call
        24   -> connsys_fifo_read
      32   connsys_util_tx_data
        32   -- Indirect call
         0   -> connsys_fifo_write
       0   get_rx_vector
       4   pse_get_queue_len
       0   pse_get_total_page_num
       0   raw_packet_handler_enabled
       0   wifi_get_channel_filter
       0   wifi_get_raw_rssi_threshold
       0   wifi_set_channel_filter
       0   wifi_set_raw_rssi_threshold
       0   wifi_util_get_inf_number


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable231
       4  ??DataTable231_1
       4  ??DataTable233
       4  ??DataTable233_1
       4  ??DataTable233_2
       4  ??DataTable233_3
       4  ??DataTable233_4
       4  ??DataTable233_5
       4  ??DataTable234
       4  ??DataTable234_1
       4  ??DataTable234_2
       4  ??DataTable234_3
       4  ??DataTable235
       4  ??DataTable235_1
       4  ??DataTable235_2
       4  ??DataTable235_3
       4  ??DataTable235_4
       4  ??DataTable235_5
       4  ??DataTable236
       4  ??DataTable239
       4  ??DataTable239_1
       4  ??DataTable243
       4  ??DataTable244
       4  ??DataTable252
       4  ??DataTable252_1
       4  ??DataTable252_2
       4  ??DataTable253
       4  ??DataTable254
       4  ??DataTable254_1
       4  ??DataTable254_2
       4  ??DataTable262
       4  ??DataTable263
       4  ??DataTable263_1
       4  ??DataTable264
       4  ??DataTable264_1
       4  ??DataTable264_2
       4  ??DataTable264_3
       4  ??DataTable265
       4  ??DataTable265_1
       4  ??DataTable265_10
       4  ??DataTable265_11
       4  ??DataTable265_2
       4  ??DataTable265_3
       4  ??DataTable265_4
       4  ??DataTable265_5
       4  ??DataTable265_6
       4  ??DataTable265_7
       4  ??DataTable265_8
       4  ??DataTable265_9
       4  ??DataTable266
       4  ??DataTable266_1
       4  ??DataTable266_2
       4  ??DataTable266_3
       4  ??DataTable266_4
       4  ??DataTable266_5
       4  ??DataTable266_6
      52  ?_0
      52  ?_1
      20  ?_10
      12  ?_100
      36  ?_101
      48  ?_102
      56  ?_103
      52  ?_104
      32  ?_105
      40  ?_106
      64  ?_107
      24  ?_108
      48  ?_109
      28  ?_11
      20  ?_110
      20  ?_111
      56  ?_112
      24  ?_113
      20  ?_114
      20  ?_115
      36  ?_116
      28  ?_117
      20  ?_118
      24  ?_119
      32  ?_12
      24  ?_120
      24  ?_121
      64  ?_122
      56  ?_123
      28  ?_124
      20  ?_125
      12  ?_126
      12  ?_127
      32  ?_128
      12  ?_129
      48  ?_13
      28  ?_130
      12  ?_131
      36  ?_132
      12  ?_133
      40  ?_134
      40  ?_135
      32  ?_136
      12  ?_137
      16  ?_138
      32  ?_139
      28  ?_14
      12  ?_140
      32  ?_141
      24  ?_142
      24  ?_143
       4  ?_144
       4  ?_145
       8  ?_146
       8  ?_147
       8  ?_148
      16  ?_149
      32  ?_15
      36  ?_150
      32  ?_151
      32  ?_152
      24  ?_153
      20  ?_154
      20  ?_155
      28  ?_156
      44  ?_157
      32  ?_158
      28  ?_159
      36  ?_16
      44  ?_160
      32  ?_161
      44  ?_162
      40  ?_163
      16  ?_164
      16  ?_165
      32  ?_166
      36  ?_167
      28  ?_168
      40  ?_169
      52  ?_17
      32  ?_170
      56  ?_171
      24  ?_172
      20  ?_173
      40  ?_174
      48  ?_175
      56  ?_176
      44  ?_177
      44  ?_178
      32  ?_179
      44  ?_18
      44  ?_180
      76  ?_181
      80  ?_182
      76  ?_183
      80  ?_184
      32  ?_185
      20  ?_186
      24  ?_187
      36  ?_188
      20  ?_189
      44  ?_19
      52  ?_190
      36  ?_191
      56  ?_192
      40  ?_193
      44  ?_194
      16  ?_195
      24  ?_196
      28  ?_197
      12  ?_198
       8  ?_2
      20  ?_20
      60  ?_21
      20  ?_22
      16  ?_23
      56  ?_24
      80  ?_25
      28  ?_26
      16  ?_27
      40  ?_28
      40  ?_29
      24  ?_3
      24  ?_30
      72  ?_31
      36  ?_32
      40  ?_33
      64  ?_34
      40  ?_35
      16  ?_36
      28  ?_37
      36  ?_38
      64  ?_39
      48  ?_4
      44  ?_40
      16  ?_41
      52  ?_42
      36  ?_43
       8  ?_44
      36  ?_45
      28  ?_46
      44  ?_47
      36  ?_48
      48  ?_49
      48  ?_5
      32  ?_50
      24  ?_51
      72  ?_52
      16  ?_53
      20  ?_54
      36  ?_55
      72  ?_56
      60  ?_57
      36  ?_58
      20  ?_59
      24  ?_6
      40  ?_60
      24  ?_61
      36  ?_62
      20  ?_63
      48  ?_64
      72  ?_65
      48  ?_66
      24  ?_67
      40  ?_68
      40  ?_69
      56  ?_7
      24  ?_70
      36  ?_71
      44  ?_72
      52  ?_73
      64  ?_74
      44  ?_75
      40  ?_76
      40  ?_77
      16  ?_78
      40  ?_79
      56  ?_8
      16  ?_80
      16  ?_81
      36  ?_82
      44  ?_83
      24  ?_84
       4  ?_85
      36  ?_86
       4  ?_87
      12  ?_88
      20  ?_89
    2048  ?_9
      16  ?_90
      12  ?_91
       2  ?_92
      28  ?_93
      28  ?_94
      28  ?_95
      36  ?_96
      20  ?_97
      64  ?_98
      16  ?_99
      58  _connsys_util_show_pse_flow_control_setting
       1  channel_filter
      72  check_raw_pkt_rssi_threshold
      48  connsys_cli_clear_debug_flag
      80  connsys_cli_dump_pse_reg
       2  connsys_cli_entry
      46  connsys_cli_set_debug_falg
      76  connsys_cli_show_current_debug_flag
      46  connsys_cli_show_debug_flag
     246  connsys_cli_show_help
     536  connsys_cli_show_pse
      20  connsys_create_inband_fw_scatter_txd_rom
     404  connsys_dispatch
     182  connsys_download_wifi_profile
     300  connsys_fw_download
      58  connsys_fw_download_CmdAddressLenReq
     228  connsys_fw_download_Tx_Scatter
     150  connsys_get_ilm_image_info
     206  connsys_get_ilm_image_info_from_flash
     588  connsys_get_patch_semaphore
     298  connsys_img_direct_download
     170  connsys_intr_enhance_mode_dump_struct
     378  connsys_intr_enhance_mode_receive_one_data
     310  connsys_patch_direct_download
     320  connsys_patch_download_body
     440  connsys_patch_finish
     414  connsys_pda_config
       4  connsys_raw_handler
       8  connsys_set_rxraw_handler
       8  connsys_set_wifi_profile
    1600  connsys_tx_buf
      52  connsys_tx_query_whisr
     504  connsys_util_cli_handler
      16  connsys_util_create_inband_cmd_txd_rom
      12  connsys_util_firmware_download
     334  connsys_util_fw_direct_download
     108  connsys_util_fw_download_CmdAddressLenReq_event_check
     598  connsys_util_fw_download_done
      18  connsys_util_get_n9_fw_ver
      12  connsys_util_get_ncp_patch_ver
       6  connsys_util_intr_enhance_mode_dump_last_struct
     352  connsys_util_intr_enhance_mode_receive_data
     180  connsys_util_low_level_output
     120  connsys_util_patch_download
     120  connsys_util_patch_download_get_semaphore_event_check
      28  connsys_util_pda_download
      38  connsys_util_pse_ffc_get
       8  connsys_util_pse_get_min_resv
      12  connsys_util_pse_get_p0_min_resv
      72  connsys_util_rx_data
      90  connsys_util_tx_data
       4  continuous_allocate_fail_cnt
       4  dlm_dl_duration_count
       4  fw_start_duration_count
       4  g_patch_info
    1040  g_tx_buf
       4  g_wifi_profile
      30  get_rx_vector
       4  ilm_dl_duration_count
       4  n9_fw_info
      36  pse_get_queue_len
      12  pse_get_total_page_num
      18  raw_packet_handler_enabled
       2  rssi_threshold_enable
          rssi_threshold
       8  wifi_get_channel_filter
      14  wifi_get_raw_rssi_threshold
       8  wifi_set_channel_filter
      10  wifi_set_raw_rssi_threshold
      18  wifi_util_get_inf_number
     740  -- Other

 
  1 635 bytes in section .bss
  2 066 bytes in section .rodata
  1 040 bytes in section .tcmBSS
 16 170 bytes in section .text
 
 16 170 bytes of CODE  memory
  2 066 bytes of CONST memory
  2 675 bytes of DATA  memory

Errors: none
Warnings: none
