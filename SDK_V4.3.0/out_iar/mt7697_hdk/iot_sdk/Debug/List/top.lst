###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:43
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\top.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EWBCF7.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\top.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\top.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\top.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\top.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          #include "type_def.h"
     36          #include "top.h"
     37          #include "mt7687.h"
     38          #include "system_mt7687.h"
     39          #include "mt7687_cm4_hw_memmap.h"
     40          #include "spi_flash.h"
     41          #include "memory_attribute.h"
     42          
     43          static uint32_t gXtalFreq;
     44          static uint32_t gCpuFrequency;
     45          
     46          
     47          /**
     48            * @brief  This function is to initialize XTAL based on HW strap.
     49            * @param  None
     50            * @retval None
     51            */
     52          void top_xtal_init(void)
     53          {
     54              uint32_t  u4RegVal = 0;
     55              unsigned long reg = HAL_REG_32(TOP_AON_CM4_STRAP_STA);
     56              reg = (reg >> 13) & 0x00000007;
     57          
     58              u4RegVal = HAL_REG_32(TOP_AON_CM4_PWRCTLCR);
     59              u4RegVal &= (~(CM4_PWRCTLCR_CM4_XTAL_FREQ_MASK));
     60          
     61              switch (reg) {
     62                  case 0:
     63                      gXtalFreq = 20000000;  /* 20Mhz */
     64                      u4RegVal |= BIT(CM4_PWRCTLCR_CM4_XTAL_FREQ_20M_OFFSET);
     65                      break;
     66                  case 1:
     67                      gXtalFreq = 40000000;  /* 40Mhz */
     68                      u4RegVal |= BIT(CM4_PWRCTLCR_CM4_XTAL_FREQ_40M_OFFSET);
     69                      break;
     70                  case 2:
     71                      gXtalFreq = 26000000;  /* 26Mhz */
     72                      u4RegVal |= BIT(CM4_PWRCTLCR_CM4_XTAL_FREQ_26M_OFFSET);
     73                      break;
     74                  case 3:
     75                      gXtalFreq = 52000000;  /* 52Mhz */
     76                      u4RegVal |= BIT(CM4_PWRCTLCR_CM4_XTAL_FREQ_52M_OFFSET);
     77                      break;
     78                  case 4:
     79                  case 5:
     80                  case 6:
     81                  case 7:
     82                      gXtalFreq = 40000000;  /* fall through */
     83                      u4RegVal |= BIT(CM4_PWRCTLCR_CM4_XTAL_FREQ_40M_OFFSET);
     84                      break;
     85              }
     86          
     87              HAL_REG_32(TOP_AON_CM4_PWRCTLCR) = u4RegVal;
     88              gCpuFrequency = gXtalFreq;
     89              SystemCoreClockUpdate();
     90              SysTick_Set(SystemCoreClock / 1000); /* 1ms trigger */
     91          }
     92          
     93          /**
     94            * @brief  This function is to get current XTAL frequency number.
     95            * @param  None
     96            * @retval current XTAL frequency number.
     97            */
     98          uint32_t top_xtal_freq_get(void)
     99          {
    100              return gXtalFreq;
    101          }
    102          
    103          /**
    104            * @brief  This function is to get current MCU frequency number.
    105            * @param  None
    106            * @retval current MCU frequency number.
    107            */
    108          uint32_t top_mcu_freq_get(void)
    109          {
    110              return gCpuFrequency;
    111          }
    112          
    113          /**
    114            * @brief  This function is to enable PPL1.
    115            * @param  None
    116            * @retval None
    117            */
    118          void cmnPLL1ON(void)
    119          {
    120              volatile uint32_t reg;
    121              volatile uint32_t *pTopCfgCM4PWRCtl = (volatile uint32_t *)TOP_CFG_CM4_PWR_CTL_CR;
    122          
    123              reg = cmnReadRegister32(pTopCfgCM4PWRCtl);
    124              reg = (reg >>  CM4_MPLL_EN_SHIFT) & CM4_MPLL_EN_MASK;
    125          
    126              if (reg == CM4_MPLL_EN_PLL1_OFF_PLL2_OFF) {
    127                  reg = cmnReadRegister32(pTopCfgCM4PWRCtl);
    128                  reg = reg & ~(CM4_NEED_RESTORE_MASK <<  CM4_NEED_RESTORE_SHIFT);    // avoid W1C
    129                  reg = reg | (CM4_MPLL_EN_PLL1_ON_PLL2_OFF << CM4_MPLL_EN_SHIFT);    // Or only, so PLL2 setting won't be cleared
    130                  cmnWriteRegister32(pTopCfgCM4PWRCtl, reg);
    131          
    132                  do {
    133                      reg = cmnReadRegister32(pTopCfgCM4PWRCtl);
    134                      reg = reg & (CM4_BT_PLL_RDY_MASK << CM4_BT_PLL_RDY_SHIFT);
    135                  } while (!reg);
    136              }
    137              return;
    138          }
    139          
    140          /**
    141            * @brief  This function is to enable both PPL1 and PLL2.
    142            * @param  MCU 960M enable selector
    143            * @retval None
    144            */
    145          void cmnPLL1ON_PLL2ON(uint8_t fg960M)
    146          {
    147              volatile uint32_t reg;
    148              volatile uint32_t *pTopCfgCM4PWRCtl = (volatile uint32_t *)TOP_CFG_CM4_PWR_CTL_CR;
    149          
    150              reg = cmnReadRegister32(pTopCfgCM4PWRCtl);
    151              reg = (reg >>  CM4_MPLL_EN_SHIFT) & CM4_MPLL_EN_MASK;
    152          
    153              if (reg != CM4_MPLL_EN_PLL1_ON_PLL2_ON) {
    154                  reg = cmnReadRegister32(pTopCfgCM4PWRCtl);
    155                  reg = reg & ~(CM4_MCU_960_EN_MASK << CM4_MCU_960_EN_SHIFT);
    156                  reg = reg & ~(CM4_NEED_RESTORE_MASK <<  CM4_NEED_RESTORE_SHIFT);    // avoid W1C
    157                  reg = reg | (CM4_MCU_960_EN_DISABLE << CM4_MCU_960_EN_SHIFT);
    158                  cmnWriteRegister32(pTopCfgCM4PWRCtl, reg);
    159          
    160                  reg = cmnReadRegister32(pTopCfgCM4PWRCtl);
    161                  reg = reg & ~(CM4_MPLL_EN_MASK << CM4_MPLL_EN_SHIFT);
    162                  reg = reg & ~(CM4_NEED_RESTORE_MASK <<  CM4_NEED_RESTORE_SHIFT);    // avoid W1C
    163                  reg = reg | (CM4_MPLL_EN_PLL1_ON_PLL2_ON << CM4_MPLL_EN_SHIFT);
    164                  cmnWriteRegister32(pTopCfgCM4PWRCtl, reg);
    165          
    166                  do {
    167                      reg = cmnReadRegister32(pTopCfgCM4PWRCtl);
    168                      reg = reg & (CM4_WF_PLL_RDY_MASK << CM4_WF_PLL_RDY_SHIFT);
    169                  } while (!reg);
    170          
    171                  reg = cmnReadRegister32(pTopCfgCM4PWRCtl);
    172                  reg = reg & ~(CM4_MCU_960_EN_MASK << CM4_MCU_960_EN_SHIFT);
    173                  reg = reg & ~(CM4_NEED_RESTORE_MASK <<  CM4_NEED_RESTORE_SHIFT);    // avoid W1C
    174              }
    175          
    176              if (fg960M) {
    177                  reg = reg | (CM4_MCU_960_EN_ENABLE << CM4_MCU_960_EN_SHIFT);
    178              } else {
    179                  reg = reg | (CM4_MCU_960_EN_DISABLE << CM4_MCU_960_EN_SHIFT);
    180              }
    181              cmnWriteRegister32(pTopCfgCM4PWRCtl, reg);
    182              return;
    183          }
    184          
    185          /**
    186            * @brief  This function is to disable both PPL1 and PLL2.
    187            * @param  None
    188            * @retval None
    189            */
    190          void cmnPLL1OFF_PLL2OFF(void)
    191          {
    192              volatile uint32_t reg;
    193              volatile uint32_t *pTopCfgCM4PWRCtl = (volatile uint32_t *)TOP_CFG_CM4_PWR_CTL_CR;
    194          
    195              reg = cmnReadRegister32(pTopCfgCM4PWRCtl);
    196              reg = reg & ~(CM4_MPLL_EN_MASK << CM4_MPLL_EN_SHIFT);
    197              reg = reg & ~(CM4_NEED_RESTORE_MASK <<  CM4_NEED_RESTORE_SHIFT);    // avoid W1C
    198              reg = reg | (CM4_MPLL_EN_PLL1_OFF_PLL2_OFF << CM4_MPLL_EN_SHIFT);
    199              cmnWriteRegister32(pTopCfgCM4PWRCtl, reg);
    200          
    201              reg = cmnReadRegister32(pTopCfgCM4PWRCtl);
    202              reg = reg & ~(CM4_MCU_960_EN_MASK << CM4_MCU_960_EN_SHIFT);
    203              reg = reg & ~(CM4_NEED_RESTORE_MASK <<  CM4_NEED_RESTORE_SHIFT);    // avoid W1C
    204              reg = reg | (CM4_MCU_960_EN_DISABLE << CM4_MCU_960_EN_SHIFT);
    205              cmnWriteRegister32(pTopCfgCM4PWRCtl, reg);
    206          
    207              return;
    208          }
    209          
    210          /**
    211            * @brief  This function is to config CPU frequency equaling with XTAL.
    212            * @param  None
    213            * @retval None
    214            */
    215          void cmnCpuClkConfigureToXtal(void)
    216          {
    217              volatile uint32_t reg;
    218              volatile uint32_t *pTopCfgCM4CKG = (volatile uint32_t *)TOP_CFG_CM4_CKG_EN0;
    219          
    220              // Step1. CM4_HCLK_SW set to XTAL
    221              reg = cmnReadRegister32(pTopCfgCM4CKG);
    222              reg = reg & ~(CM4_HCLK_SEL_MASK << CM4_HCLK_SEL_SHIFT);
    223              reg = reg | (CM4_HCLK_SEL_OSC << CM4_HCLK_SEL_SHIFT);
    224              cmnWriteRegister32(pTopCfgCM4CKG, reg);
    225          
    226              // Step2. CM4_RF_CLK_SW set to XTAL
    227              reg = cmnReadRegister32(pTopCfgCM4CKG);
    228              reg = reg & ~(CM4_WBTAC_MCU_CK_SEL_MASK << CM4_WBTAC_MCU_CK_SEL_SHIFT);
    229              reg = reg | (CM4_WBTAC_MCU_CK_SEL_XTAL << CM4_WBTAC_MCU_CK_SEL_SHIFT);
    230              cmnWriteRegister32(pTopCfgCM4CKG, reg);
    231          
    232              while (reg != cmnReadRegister32(pTopCfgCM4CKG));
    233          
    234              gCpuFrequency = top_xtal_freq_get();
    235              SystemCoreClockUpdate();
    236              SysTick_Set(SystemCoreClock / 1000); /* 1ms trigger */
    237              return;
    238          }
    239          
    240          /**
    241            * @brief  This function is to config CPU frequency to 192Mhz.
    242            * @param  None
    243            * @retval None
    244            */
    245          void cmnCpuClkConfigureTo192M(void)
    246          {
    247              volatile uint32_t reg;
    248              volatile uint32_t *pTopCfgCM4CKG = (volatile uint32_t *)TOP_CFG_CM4_CKG_EN0;
    249          
    250              // Step1. Power on PLL1 & 2
    251              cmnPLL1ON_PLL2ON(TRUE);
    252          
    253              // Step2. CM4_RF_CLK_SW set to PLL2(960)
    254              reg = cmnReadRegister32(pTopCfgCM4CKG);
    255              reg = reg & ~(CM4_WBTAC_MCU_CK_SEL_MASK << CM4_WBTAC_MCU_CK_SEL_SHIFT);
    256              reg = reg | (CM4_WBTAC_MCU_CK_SEL_WIFI_PLL_960 << CM4_WBTAC_MCU_CK_SEL_SHIFT);
    257              cmnWriteRegister32(pTopCfgCM4CKG, reg);
    258          
    259              while (reg != cmnReadRegister32(pTopCfgCM4CKG));
    260          
    261              // Step3. set divider to 1+8/2=5, ->  960/5=192Mhz
    262              reg = cmnReadRegister32(pTopCfgCM4CKG);
    263              reg = reg & ~(CM4_MCU_DIV_SEL_MASK << CM4_MCU_DIV_SEL_SHIFT);
    264              reg = reg | (8 << CM4_MCU_DIV_SEL_SHIFT);
    265              cmnWriteRegister32(pTopCfgCM4CKG, reg);
    266          
    267              // Step4. CM4_HCLK_SW set to PLL_CK
    268              reg = cmnReadRegister32(pTopCfgCM4CKG);
    269              reg = reg & ~(CM4_HCLK_SEL_MASK << CM4_HCLK_SEL_SHIFT);
    270              reg = reg | (CM4_HCLK_SEL_PLL << CM4_HCLK_SEL_SHIFT);
    271              cmnWriteRegister32(pTopCfgCM4CKG, reg);
    272              gCpuFrequency = MCU_FREQUENCY_192MHZ;
    273              SystemCoreClockUpdate();
    274              SysTick_Set(SystemCoreClock / 1000); /* 1ms trigger */
    275              return;
    276          }
    277          
    278          /**
    279            * @brief  This function is to config CPU frequency to 160Mhz.
    280            * @param  None
    281            * @retval None
    282            */
    283          void cmnCpuClkConfigureTo160M(void)
    284          {
    285              volatile uint32_t reg;
    286              volatile uint32_t *pTopCfgCM4CKG = (volatile uint32_t *)TOP_CFG_CM4_CKG_EN0;
    287          
    288              // Step1. Power on PLL1 & 2
    289              cmnPLL1ON_PLL2ON(FALSE);
    290          
    291              // Step2. CM4_RF_CLK_SW set to PLL2(320)
    292              reg = cmnReadRegister32(pTopCfgCM4CKG);
    293              reg = reg & ~(CM4_WBTAC_MCU_CK_SEL_MASK << CM4_WBTAC_MCU_CK_SEL_SHIFT);
    294              reg = reg | (CM4_WBTAC_MCU_CK_SEL_WIFI_PLL_320 << CM4_WBTAC_MCU_CK_SEL_SHIFT);
    295              cmnWriteRegister32(pTopCfgCM4CKG, reg);
    296          
    297              while (reg != cmnReadRegister32(pTopCfgCM4CKG));
    298          
    299              // Step3. set divider to 1+2/2=2, ->  320/2=160Mhz
    300              reg = cmnReadRegister32(pTopCfgCM4CKG);
    301              reg = reg & ~(CM4_MCU_DIV_SEL_MASK << CM4_MCU_DIV_SEL_SHIFT);
    302              reg = reg | (2 << CM4_MCU_DIV_SEL_SHIFT);
    303              cmnWriteRegister32(pTopCfgCM4CKG, reg);
    304          
    305              // Step4. CM4_HCLK_SW set to PLL_CK
    306              reg = cmnReadRegister32(pTopCfgCM4CKG);
    307              reg = reg & ~(CM4_HCLK_SEL_MASK << CM4_HCLK_SEL_SHIFT);
    308              reg = reg | (CM4_HCLK_SEL_PLL << CM4_HCLK_SEL_SHIFT);
    309              cmnWriteRegister32(pTopCfgCM4CKG, reg);
    310              gCpuFrequency = MCU_FREQUENCY_160MHZ;
    311              SystemCoreClockUpdate();
    312              SysTick_Set(SystemCoreClock / 1000); /* 1ms trigger */
    313              return;
    314          }
    315          
    316          
    317          /**
    318            * @brief  This function is to config CPU frequency to 64Mhz.
    319            * @param  None
    320            * @retval None
    321            */
    322          void cmnCpuClkConfigureTo64M(void)
    323          {
    324              volatile uint32_t reg;
    325              volatile uint32_t *pTopCfgCM4CKG = (volatile uint32_t *)TOP_CFG_CM4_CKG_EN0;
    326          
    327              // Step1. Power on PLL1
    328              cmnPLL1ON();
    329          
    330              // Step2. CM4_RF_CLK_SW set to XTAL
    331              reg = cmnReadRegister32(pTopCfgCM4CKG);
    332              reg = reg & ~(CM4_WBTAC_MCU_CK_SEL_MASK << CM4_WBTAC_MCU_CK_SEL_SHIFT);
    333              reg = reg | (CM4_WBTAC_MCU_CK_SEL_XTAL << CM4_WBTAC_MCU_CK_SEL_SHIFT);
    334              cmnWriteRegister32(pTopCfgCM4CKG, reg);
    335          
    336              while (reg != cmnReadRegister32(pTopCfgCM4CKG));
    337          
    338              // Step3. CM4_HCLK_SW set to SYS_64M
    339              reg = cmnReadRegister32(pTopCfgCM4CKG);
    340              reg = reg & ~(CM4_HCLK_SEL_MASK << CM4_HCLK_SEL_SHIFT);
    341              reg = reg | (CM4_HCLK_SEL_SYS_64M << CM4_HCLK_SEL_SHIFT);
    342              cmnWriteRegister32(pTopCfgCM4CKG, reg);
    343              gCpuFrequency = MCU_FREQUENCY_64MHZ;
    344              SystemCoreClockUpdate();
    345              SysTick_Set(SystemCoreClock / 1000); /* 1ms trigger */
    346              return;
    347          }
    348          
    349          //
    350          //  Using Xtal as SPI Flash clock
    351          //
    352          ATTR_TEXT_IN_TCM void cmnSerialFlashClkConfToXtal(void)
    353          {
    354              volatile UINT32 reg;
    355              volatile UINT32 *pTopCfgHclk = (volatile UINT32 *)TOP_CFG_HCLK_2M_CKGEN;
    356          
    357              reg = cmnReadRegister32(pTopCfgHclk);
    358              reg = reg & ~(SF_TOP_CLK_SEL_MASK << SF_TOP_CLK_SEL_SHIFT);
    359              reg = reg | (SF_TOP_CLK_SEL_XTAL << SF_TOP_CLK_SEL_SHIFT);
    360              cmnWriteRegister32(pTopCfgHclk, reg);
    361          }
    362          
    363          #ifdef HAL_FLASH_MODULE_ENABLED
    364          //
    365          //  Using PLL1/64M as SPI Flash clock
    366          //
    367          ATTR_TEXT_IN_TCM void cmnSerialFlashClkConfTo64M(void)
    368          {
    369              volatile UINT32 reg = 0;
    370              volatile UINT32 *pTopCfgHclk = (volatile UINT32 *)TOP_CFG_HCLK_2M_CKGEN;
    371          
    372              //open PLL1
    373              cmnPLL1ON();
    374          
    375              // Switch flash clock from XTAL to SYS 64Mhz.
    376              reg = cmnReadRegister32(pTopCfgHclk);
    377              reg = reg & ~(SF_TOP_CLK_SEL_MASK << SF_TOP_CLK_SEL_SHIFT);
    378              reg = reg | (SF_TOP_CLK_SEL_SYS_64M << SF_TOP_CLK_SEL_SHIFT);
    379              cmnWriteRegister32(pTopCfgHclk, reg);
    380          
    381          #if 1 /*set KGD value*/
    382              mSetHWEntry(SFC_MISC1_DEL_LATCH_LATENCY, 0);
    383              mSetHWEntry(SFC_MISC1_SMPCK_INV, 1);
    384              mSetHWEntry(SFC_DELAY_CONTROL3_SFCK_SAM_DLY, 0x18);
    385          #endif
    386              return;
    387          }
    388          
    389          #endif
    390          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   cmnCpuClkConfigureTo160M
         0   -> SysTick_Set
        16   -> SystemCoreClockUpdate
        16   -> cmnPLL1ON_PLL2ON
        16   -> cmnReadRegister32
        16   -> cmnWriteRegister32
      16   cmnCpuClkConfigureTo192M
         0   -> SysTick_Set
        16   -> SystemCoreClockUpdate
        16   -> cmnPLL1ON_PLL2ON
        16   -> cmnReadRegister32
        16   -> cmnWriteRegister32
      16   cmnCpuClkConfigureTo64M
         0   -> SysTick_Set
        16   -> SystemCoreClockUpdate
        16   -> cmnPLL1ON
        16   -> cmnReadRegister32
        16   -> cmnWriteRegister32
      16   cmnCpuClkConfigureToXtal
         0   -> SysTick_Set
        16   -> SystemCoreClockUpdate
        16   -> cmnReadRegister32
        16   -> cmnWriteRegister32
        16   -> top_xtal_freq_get
      16   cmnPLL1OFF_PLL2OFF
        16   -> cmnReadRegister32
         0   -> cmnWriteRegister32
        16   -> cmnWriteRegister32
      16   cmnPLL1ON
        16   -> cmnReadRegister32
        16   -> cmnWriteRegister32
      16   cmnPLL1ON_PLL2ON
        16   -> cmnReadRegister32
         0   -> cmnWriteRegister32
        16   -> cmnWriteRegister32
       0   cmnReadRegister32
      16   cmnSerialFlashClkConfTo64M
        16   -> cmnPLL1ON
        16   -> cmnReadRegister32
        16   -> cmnWriteRegister32
      16   cmnSerialFlashClkConfToXtal
        16   -> cmnReadRegister32
         0   -> cmnWriteRegister32
       0   cmnWriteRegister32
       0   top_mcu_freq_get
       0   top_xtal_freq_get
       8   top_xtal_init
         0   -> SysTick_Set
         8   -> SystemCoreClockUpdate


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable22
       4  ??DataTable22_1
     148  cmnCpuClkConfigureTo160M
     148  cmnCpuClkConfigureTo192M
     106  cmnCpuClkConfigureTo64M
      96  cmnCpuClkConfigureToXtal
      72  cmnPLL1OFF_PLL2OFF
      84  cmnPLL1ON
     168  cmnPLL1ON_PLL2ON
       4  cmnReadRegister32
      78  cmnSerialFlashClkConfTo64M
      34  cmnSerialFlashClkConfToXtal
       4  cmnWriteRegister32
       8  gXtalFreq
          gCpuFrequency
       6  top_mcu_freq_get
       6  top_xtal_freq_get
     124  top_xtal_init

 
     8 bytes in section .bss
   120 bytes in section .ramTEXT
 1 010 bytes in section .text
 
 1 130 bytes of CODE memory
     8 bytes of DATA memory

Errors: none
Warnings: none
