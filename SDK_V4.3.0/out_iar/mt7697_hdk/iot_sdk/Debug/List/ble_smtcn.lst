###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:14
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\src\ble_smtcn.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW4A83.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\src\ble_smtcn.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\ble_smtcn.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\ble_smtcn.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\src\ble_smtcn.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          /*
     36                  BLE SMART CONNECTION is able to receive the SSID, password and security mode from the APK by BLE connection, and then connect to the WIFI AP.
     37          It support GCC, Keil and IAR compilation. The lib is in middleware/MTK/ble_smtcn. Please switch MTK_BLE_SMTCN_ENABLE to enable/disable this feature
     38          in project/mt7697_hdk/apps/iot_sdk/GCC/feature.mk.
     39          
     40          
     41          *************How to use BLE SMART CONNECTION*************
     42          
     43          step1, Download the bin file to MT7697;
     44          
     45          step2, Get the APK in SDK packet in tools/ble_smart_connection/ble_smart_connection.apk and install it on Android Smartphone(Android 4.3 or later);
     46          
     47          step3, Make Smartphone connect to a WIFI AP;
     48          
     49          step4, Connect MT7697 to the PC, and connect to ComPortLogger or putty, set speed to be 115200.
     50          
     51          step5, Reset MT7697, input ATcommand "ble wifi smart" in ComPortLogger , ble smart connection will be started;
     52          
     53          step6, Start the APK and search BLE device, select the MT7697 device named "BLE_SMTCN" to connect;
     54          
     55          step7, Input the password of the connected WIFI AP and press "connect" button in the APK, MT7697 will start to connect to the same WIFI AP, and
     56                  the result will show in the APK.
     57          */
     58          
     59          
     60          
     61          /*BLE SMART CONNECTION compile option, switch it in feature.mk*/
     62          #ifdef MTK_BLE_SMTCN_ENABLE
     63          #include <string.h>
     64          #include <stdint.h>
     65          #include <stdbool.h>
     66          #include <stdio.h>
     67          #include "bt_gap_le.h"
     68          #include "bt_gatts.h"
     69          #include "bt_uuid.h"
     70          #include "wifi_api.h"
     71          #include "lwip/netif.h"
     72          #include "lwip/inet.h"
     73          #include "FreeRTOS.h"
     74          #include "timers.h"
     75          #include "lwip/dhcp.h"
     76          
     77          #define BLE_SMTCN_ADDRESS               {0x0C, 0x01, 0x02, 0x03, 0x04, 0x05}
     78          #define BLE_SMTCN_ADV_DATA              "DDDDDDDDDBLE_SMTCN"
     79          #define BLE_SMTCN_ADV_DATA_LEN          18
     80          #define BLE_SMTCN_DEVICE_NAME           "BLE_SMTCN"
     81          #define BLE_SMTCN_SERVICE_UUID          (0x18AA)
     82          #define BLE_SMTCN_MAX_INTERVAL          0x00C0    /*The range is from 0x0020 to 0x4000.*/
     83          #define BLE_SMTCN_MIN_INTERVAL          0x00C0    /*The range is from 0x0020 to 0x4000.*/
     84          #define BLE_SMTCN_CHANNEL_NUM           7
     85          #define BLE_SMTCN_FILTER_POLICY         0
     86          #define BLE_SMTCN_AD_FLAG_LEN           2
     87          #define BLE_SMTCN_AD_UUID_LEN           3
     88          #define BLE_SMTCN_AD_NAME_LEN           10
     89          
     90          
     91          #define BLE_SMTCN_SERVICE_UUID        (0x18AA) // Data Transfer Service
     92          #define BLE_SMTCN_CHAR_UUID           (0x2AAA)
     93          #define BLE_SMTCN_SSID_LEN            32
     94          #define BLE_SMTCN_IP_LEN              17
     95          #define BLE_SMTCN_CHAR_VALUE_HANDLE   0x0016
     96          #define BLE_SMTCN_MAX_DATA_LEN        (23 - 3 - 2) //mtu - 3bytes for gatt - 1byte(tagid) - 1byte(tag_length)
     97          #define BLE_SMTCN_TIMER_PERIOD       1000
     98          
     99          typedef enum {
    100              BLE_SMTCN_WIFI_INFO_SSID = 0x01,
    101              BLE_SMTCN_WIFI_INFO_PW,
    102              BLE_SMTCN_WIFI_INFO_SEC_MODE,
    103              BLE_SMTCN_WIFI_INFO_IP,
    104          
    105              BLE_SMTCN_WIFI_INFO_DISCONNECTED = 0x07,
    106              BLE_SMTCN_WIFI_INFO_CONNECTED = 0x08
    107          }ble_smtcn_wifi_info_id_t;
    108          
    109          typedef struct {
    110              uint16_t conn_handle;
    111              uint16_t indicate_enable;
    112              
    113              char ip_addr[BLE_SMTCN_IP_LEN];
    114              uint8_t ssidrx[BLE_SMTCN_SSID_LEN];
    115              uint8_t ssidrx_len;
    116              uint8_t pwrx[20];
    117              uint8_t pwrx_len;
    118              wifi_auth_mode_t authrx;
    119              wifi_encrypt_type_t encryptrx;
    120              uint16_t wifi_conn_enabled;
    121          
    122              TimerHandle_t dtp_timer;
    123              bool smtcn_started;
    124          }ble_smtcn_context_t;
    125          
    126          static ble_smtcn_context_t ble_smtcn_cntx;
    127          static ble_smtcn_context_t *p_smtcn = &ble_smtcn_cntx;
    128          /*configration for DTP*/
    129          const bt_uuid_t BLE_SMTCN_CHAR_UUID128 = BT_UUID_INIT_WITH_UUID16(BLE_SMTCN_CHAR_UUID);
    130          
    131          log_create_module(BLE_SMTCN, PRINT_LEVEL_INFO);
    132          
    133          
    134          /*****************************************************************************
    135          * FUNCTION
    136          *  ble_smtcn_set_adv
    137          * DESCRIPTION
    138          *  Set ble smart connection ramdom address
    139          * PARAMETERS
    140          *  void
    141          * RETURNS
    142          *  void
    143          *****************************************************************************/
    144          void ble_smtcn_set_adv(void)
    145          {
    146              bt_bd_addr_t addr = BLE_SMTCN_ADDRESS;
    147              bt_bd_addr_ptr_t random_addr = addr;    
    148              extern char gatts_device_name[256];
    149          
    150              LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_set_adv\n");
    151              memset(gatts_device_name, 0x00, sizeof(gatts_device_name));
    152              //memcpy(gatts_device_name, &adv_data.advertising_data[BLE_SMTCN_ADV_DATA_LEN - BLE_SMTCN_DEVICE_NAME_LEN], BLE_SMTCN_DEVICE_NAME_LEN);
    153              strcpy(gatts_device_name, BLE_SMTCN_DEVICE_NAME);
    154              
    155              bt_gap_le_set_random_address(random_addr);
    156          
    157              p_smtcn->smtcn_started = true;
    158          }
    159          
    160          
    161          /*****************************************************************************
    162          * FUNCTION
    163          *  ble_smtcn_event_callback
    164          * DESCRIPTION
    165          *  Deal with event from bt stack
    166          * PARAMETERS
    167          *  void
    168          * RETURNS
    169          *  void
    170          *****************************************************************************/
    171          void ble_smtcn_event_callback(bt_msg_type_t msg, bt_status_t status, void *buff)
    172          {
    173              switch(msg) {
    174                  case BT_GAP_LE_SET_RANDOM_ADDRESS_CNF:
    175                  {
    176                      LOG_I(BLE_SMTCN, "[BLE_SMTCN]start advertising\n");
    177                      if (p_smtcn->smtcn_started == true) {
    178                          bt_hci_cmd_le_set_advertising_enable_t enable;
    179                          bt_hci_cmd_le_set_advertising_parameters_t adv_param = {
    180                                  .advertising_interval_min = BLE_SMTCN_MIN_INTERVAL,
    181                                  .advertising_interval_max = BLE_SMTCN_MAX_INTERVAL,
    182                                  .advertising_type = BT_HCI_ADV_TYPE_CONNECTABLE_UNDIRECTED,
    183                                  .own_address_type = BT_ADDR_RANDOM,
    184                                  .advertising_channel_map = BLE_SMTCN_CHANNEL_NUM,
    185                                  .advertising_filter_policy = BLE_SMTCN_FILTER_POLICY
    186                              };
    187                          bt_hci_cmd_le_set_advertising_data_t adv_data = {
    188                              .advertising_data_length = BLE_SMTCN_ADV_DATA_LEN,
    189                              .advertising_data = BLE_SMTCN_ADV_DATA
    190                          };
    191          
    192                          adv_data.advertising_data[0] = BLE_SMTCN_AD_FLAG_LEN;
    193                          adv_data.advertising_data[1] = BT_GAP_LE_AD_TYPE_FLAG;
    194                          adv_data.advertising_data[2] = BT_GAP_LE_AD_FLAG_BR_EDR_NOT_SUPPORTED | BT_GAP_LE_AD_FLAG_GENERAL_DISCOVERABLE;
    195                          adv_data.advertising_data[3] = BLE_SMTCN_AD_UUID_LEN;
    196                          adv_data.advertising_data[4] = BT_GAP_LE_AD_TYPE_16_BIT_UUID_COMPLETE;
    197                          adv_data.advertising_data[5] = BLE_SMTCN_SERVICE_UUID & 0x00FF;
    198                          adv_data.advertising_data[6] = (BLE_SMTCN_SERVICE_UUID & 0xFF00)>>8;
    199                          adv_data.advertising_data[7] = BLE_SMTCN_AD_NAME_LEN;
    200                          adv_data.advertising_data[8] = BT_GAP_LE_AD_TYPE_NAME_COMPLETE;
    201          
    202                          enable.advertising_enable = BT_HCI_ENABLE;
    203                          bt_gap_le_set_advertising(&enable, &adv_param, &adv_data, NULL);
    204          
    205                          p_smtcn->smtcn_started = false;
    206                      }
    207                  }
    208                      break;
    209          
    210                  default:
    211                      break;
    212              }
    213                  
    214          }
    215          
    216          
    217          void ble_smtcn_send_indication(ble_smtcn_wifi_info_id_t tag_id, uint8_t len, uint8_t *value)
    218          {
    219              uint8_t buf[64] = {0};
    220              uint8_t pak[20] = {0}; 
    221              uint8_t pak_len;
    222              bt_gattc_charc_value_notification_indication_t *req;
    223              bt_status_t send_status;
    224          
    225              LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_send_indication, tag_id = %d\n", tag_id);
    226          
    227              pak[0] = tag_id;
    228          
    229              pak_len = 1;
    230          
    231              if (len > BLE_SMTCN_MAX_DATA_LEN) {
    232                  LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_send_indication: data length = %d, > 18!!!\n", len);
    233              }
    234              if (tag_id == BLE_SMTCN_WIFI_INFO_SSID || tag_id == BLE_SMTCN_WIFI_INFO_IP) {
    235                  pak[1] = len;
    236                  memcpy(pak + 2, value, (len > BLE_SMTCN_MAX_DATA_LEN)? BLE_SMTCN_MAX_DATA_LEN : len);
    237                  pak_len += len + 1;
    238              }
    239          
    240              req = (bt_gattc_charc_value_notification_indication_t*)buf;
    241              req->attribute_value_length = 3 + pak_len;
    242              req->att_req.opcode = BT_ATT_OPCODE_HANDLE_VALUE_INDICATION;
    243              req->att_req.handle = BLE_SMTCN_CHAR_VALUE_HANDLE;
    244              memcpy(req->att_req.attribute_value, pak, pak_len);
    245              send_status = bt_gatts_send_charc_value_notification_indication(p_smtcn->conn_handle, req);
    246          
    247              LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_send_indication: send_status = %x\n", send_status);
    248          }
    249          
    250          
    251          void ble_smtcn_parse_data(uint8_t *data, uint16_t size) 
    252          {
    253              ble_smtcn_wifi_info_id_t tag_id;
    254              uint8_t tag_len;   
    255          
    256              LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_parse_data\n");
    257              
    258              tag_id = (ble_smtcn_wifi_info_id_t)data[0];
    259              tag_len = data[1];
    260          
    261              tag_len = ((tag_len > BLE_SMTCN_MAX_DATA_LEN)? BLE_SMTCN_MAX_DATA_LEN : tag_len);
    262          
    263              LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_parse_data, tag_id = %d, tag_len = %d\n", tag_id, tag_len);
    264              switch (tag_id) {
    265                  case BLE_SMTCN_WIFI_INFO_SSID:
    266                  {
    267                      memcpy(p_smtcn->ssidrx, data + 2, tag_len);
    268                      p_smtcn->ssidrx_len = tag_len;
    269                      p_smtcn->wifi_conn_enabled |= (1 << BLE_SMTCN_WIFI_INFO_SSID);
    270                      LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_parse_data, ssid = %s, wifi_conn_enabled = 0x%x\n", p_smtcn->ssidrx, p_smtcn->wifi_conn_enabled);
    271                  }
    272                      break;
    273                      
    274                  case BLE_SMTCN_WIFI_INFO_PW: 
    275                  {
    276                      memcpy(p_smtcn->pwrx, data + 2, tag_len);
    277                      p_smtcn->pwrx_len = tag_len;
    278                      p_smtcn->wifi_conn_enabled |= (1 << BLE_SMTCN_WIFI_INFO_PW);
    279                      LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_parse_data, pw = %s, wifi_conn_enabled = 0x%x\n", p_smtcn->pwrx, p_smtcn->wifi_conn_enabled);
    280                  }
    281                      break;
    282                      
    283                  case BLE_SMTCN_WIFI_INFO_SEC_MODE:
    284                      if (tag_len == 2) {
    285                          p_smtcn->authrx = (wifi_auth_mode_t)data[2];  
    286                          p_smtcn->encryptrx = (wifi_encrypt_type_t)data[3]; //0, 1, 4, 6, 8 are always used
    287                          p_smtcn->wifi_conn_enabled |= (1 << BLE_SMTCN_WIFI_INFO_SEC_MODE);
    288                          //LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_parse_data, auth = %d, encryt = %d, wifi_conn_enabled = 0x%x\n", p_smtcn->authrx, p_smtcn->encryptrx, p_smtcn->wifi_conn_enabled);
    289                      } else {
    290                          LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_parse_data, security mode is wrong, tag_len = %d\n", tag_len);
    291                      }
    292                      break;
    293                      
    294                  default:
    295                      LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_parse_data, wrong tag id\n", tag_id);
    296                      break;
    297              }
    298          }
    299          
    300          
    301          void ble_smtcn_timeout_callback(TimerHandle_t xTimer)
    302          {    
    303              uint8_t link_status;
    304              uint8_t ssid[BLE_SMTCN_SSID_LEN] = {0};
    305              uint8_t ssid_len;
    306          
    307              LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_timeout_callback\n");
    308          
    309              if (wifi_connection_get_link_status(&link_status) >= 0) {
    310                  if (link_status  == WIFI_STATUS_LINK_CONNECTED) {
    311                      if (wifi_config_get_ssid(0, ssid, &(ssid_len)) >= 0) {
    312          
    313                          ble_smtcn_send_indication(BLE_SMTCN_WIFI_INFO_CONNECTED, 0, NULL);
    314                          ble_smtcn_send_indication(BLE_SMTCN_WIFI_INFO_SSID, ssid_len, ssid);
    315                          if (strlen(p_smtcn->ip_addr)) {
    316                              //send indication
    317                              ble_smtcn_send_indication(BLE_SMTCN_WIFI_INFO_IP, strlen(p_smtcn->ip_addr), (uint8_t *)(p_smtcn->ip_addr));
    318          
    319                              memset(p_smtcn->ip_addr, 0, BLE_SMTCN_IP_LEN);
    320                          }
    321                      } else {
    322                          //get ssid fail
    323                          LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_timeout_callback, get ssid fail\n");
    324                      }
    325                  } else {
    326                      //disconnected
    327                      ble_smtcn_send_indication(BLE_SMTCN_WIFI_INFO_DISCONNECTED, 0, NULL);     
    328                  }
    329              }
    330          }
    331          
    332          void ble_smtcn_setup_wifi_connection()
    333          {
    334              int32_t result;
    335              uint8_t port = WIFI_PORT_STA;
    336          
    337              result = wifi_config_set_ssid(port, p_smtcn->ssidrx, strlen((char *)(p_smtcn->ssidrx)));
    338              LOG_I(BLE_SMTCN, "[BLE_SMTCN]set ssid = %d\n", result);
    339              if (result < 0) {
    340                  return;
    341              }
    342              
    343              result = wifi_config_set_security_mode(port, p_smtcn->authrx, p_smtcn->encryptrx);
    344              LOG_I(BLE_SMTCN, "[BLE_SMTCN]set security mode = %d, encrypt = %d\n", result, p_smtcn->encryptrx);
    345              if (result < 0) {
    346                  return;
    347              }
    348              
    349              if (p_smtcn->encryptrx == 0) {
    350                  wifi_wep_key_t wep_key;
    351                  uint8_t key_id = 0; 
    352          
    353                  if (p_smtcn->pwrx_len == 5 || p_smtcn->pwrx_len == 10 || p_smtcn->pwrx_len == 13) {
    354                      wep_key.wep_tx_key_index = key_id;
    355                  
    356                      memcpy(wep_key.wep_key[key_id], p_smtcn->pwrx, p_smtcn->pwrx_len);
    357                      wep_key.wep_key_length[key_id] = p_smtcn->pwrx_len;
    358          
    359                      result = wifi_config_set_wep_key(port, &wep_key); // wep encryption mode, the pw length can only be 5, 10 or 13
    360                      LOG_I(BLE_SMTCN, "[BLE_SMTCN]set wep key = %d\n", result);
    361                      if (result < 0) {
    362                          return;
    363                      }
    364                  } else {
    365                      LOG_I(BLE_SMTCN, "[BLE_SMTCN]invalid password length = %d\n", p_smtcn->pwrx_len);
    366                  }
    367              } else {
    368                  result = wifi_config_set_wpa_psk_key(port, p_smtcn->pwrx, p_smtcn->pwrx_len);//the passwd length should be 8-64
    369                  LOG_I(BLE_SMTCN, "[BLE_SMTCN]set psk key = %d\n", result);
    370                  if (result < 0) {
    371                      return;
    372                  }
    373              }
    374             
    375              result = wifi_config_reload_setting();
    376              LOG_I(BLE_SMTCN, "[BLE_SMTCN]reload = %d\n", result);
    377          }
    378          
    379          static uint32_t ble_smtcn_charc_value_callback (const uint8_t rw, uint16_t handle, void *data, uint16_t size, uint16_t offset)
    380          {
    381              LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_charc_value_callback,rw = %d, handle = 0x%x, size = %d\n", rw, handle, size);
    382          
    383              if (rw == BT_GATTS_CALLBACK_WRITE) {
    384                  uint8_t link_status;
    385                  uint8_t ssid[BLE_SMTCN_SSID_LEN] = {0};
    386                  uint8_t ssid_len;
    387                  /*uint8_t test1[] = {0x01, 0x07, 0x53, 0x51, 0x41, 0x5F, 0x43, 0x48, 0x54};
    388                  uint8_t test2[] = {0x02, 0x08, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37};
    389                  uint8_t test3[] = {0x03, 0x02, 0x09, 0x04};*/
    390          
    391                  ble_smtcn_parse_data(data, size);
    392                  if (p_smtcn->wifi_conn_enabled == 0x0E && p_smtcn->indicate_enable == 0x0002) { 
    393                      //every tag is ready and indication is enabled
    394                      if (wifi_connection_get_link_status(&link_status) >= 0) {
    395                          if (link_status  == WIFI_STATUS_LINK_CONNECTED) {
    396          
    397                              LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_charc_value_callback: wifi connected\n");
    398                              
    399                              if (wifi_config_get_ssid(0, ssid, &(ssid_len)) >= 0) {
    400                                  
    401                                  LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_charc_value_callback: The connected ssid id %s\n", ssid);
    402                                  if (!memcmp(ssid, p_smtcn->ssidrx, BLE_SMTCN_SSID_LEN)) {
    403                                      
    404                                      //the wifi AP is already connected
    405                                      ble_smtcn_send_indication(BLE_SMTCN_WIFI_INFO_CONNECTED, 0, NULL);
    406                                      ble_smtcn_send_indication(BLE_SMTCN_WIFI_INFO_SSID, ssid_len, ssid);
    407                                      if (strlen(p_smtcn->ip_addr)) {
    408                                          //send indication
    409                                          ble_smtcn_send_indication(BLE_SMTCN_WIFI_INFO_IP, strlen(p_smtcn->ip_addr), (uint8_t *)(p_smtcn->ip_addr));
    410          
    411                                          memset(p_smtcn->ip_addr, 0, BLE_SMTCN_IP_LEN);
    412                                      }
    413                                  } else {
    414                                  
    415                                      //different ssid, setup new wifi connection
    416                                      ble_smtcn_setup_wifi_connection();
    417                                  }
    418                              } else {
    419                                  LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_charc_value_callback: get ssid fail\n");
    420                              }
    421                           } else {
    422                              //disconnected
    423                              
    424                              LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_charc_value_callback: wifi disconnected\n");
    425                              
    426                              ble_smtcn_setup_wifi_connection();
    427                           }
    428                      } else {
    429                          LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_charc_value_callback: get wifi link status fail\n");
    430                      }  
    431          
    432                      p_smtcn->wifi_conn_enabled = 0;
    433                  }
    434              }else {
    435                  return 0;
    436              }
    437          
    438              return (uint32_t)size;
    439          
    440          }
    441          
    442          static uint32_t ble_smtcn_client_config_callback (const uint8_t rw, uint16_t handle, void *data, uint16_t size, uint16_t offset)
    443          {
    444          
    445              LOG_I(BLE_SMTCN, "[BLE_SMTCN]CCC, rw = %d, handle = 0x%x, size = %d\n", rw, handle, size);
    446               
    447              p_smtcn->conn_handle = handle;
    448          
    449              //add a timer
    450              if (p_smtcn->dtp_timer == NULL) {
    451                  p_smtcn->dtp_timer = xTimerCreate("BLE_SMTCN_TIMER",
    452                                            BLE_SMTCN_TIMER_PERIOD / portTICK_PERIOD_MS, pdFALSE,
    453                                            ( void *)0,
    454                                            ble_smtcn_timeout_callback);
    455          
    456                  if (!p_smtcn->dtp_timer) {
    457                      LOG_I(BLE_SMTCN, "[BLE_SMTCN]CCC, create timer fail, timer = 0x%x\n", p_smtcn->dtp_timer);
    458                  }
    459              }
    460          
    461              if (rw == BT_GATTS_CALLBACK_WRITE) {
    462                  if (size != sizeof(p_smtcn->indicate_enable)){ //Size check
    463                      return 0;
    464                  }
    465                  p_smtcn->indicate_enable = *(uint16_t*)data;
    466          
    467                  if (p_smtcn->indicate_enable == 0x0002) {
    468                      //send indication
    469                      if (xTimerStart(p_smtcn->dtp_timer, 0 ) != pdPASS ) {
    470                          LOG_I(BLE_SMTCN, "[BLE_SMTCN]CCC: timer start fail\n");
    471                      } else {
    472                          LOG_I(BLE_SMTCN, "[BLE_SMTCN]CCC: timer start\n");
    473                      }
    474                  }
    475              }else {
    476                  if (size!=0){
    477                      memcpy(data, &p_smtcn->indicate_enable, sizeof(p_smtcn->indicate_enable));
    478                  }
    479              }
    480          
    481              return sizeof(p_smtcn->indicate_enable);
    482          }
    483          
    484          
    485          static void ble_smtcn_ip_change_callback(struct netif *netif)
    486          {
    487              if (!ip4_addr_isany_val(netif->ip_addr)) {
    488                  
    489                  strcpy(p_smtcn->ip_addr, inet_ntoa(netif->ip_addr)); 
    490                  LOG_I(BLE_SMTCN, "[BLE_SMTCN] got IP:%s", p_smtcn->ip_addr);
    491          
    492                  if (p_smtcn->indicate_enable == 0x0002) {
    493                      
    494                      ble_smtcn_send_indication(BLE_SMTCN_WIFI_INFO_IP, strlen(p_smtcn->ip_addr), (uint8_t *)(p_smtcn->ip_addr));
    495          
    496                      memset(p_smtcn->ip_addr, 0, BLE_SMTCN_IP_LEN);
    497                  }
    498              }
    499          }
    500          
    501          
    502          int32_t ble_smtcn_wifi_event_handler(wifi_event_t event, uint8_t *payload, uint32_t length)
    503          {
    504              LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_wifi_event_handler: event = %d\n", event);
    505          
    506              switch(event) {
    507                  case WIFI_EVENT_IOT_PORT_SECURE:
    508                  {
    509                      if (p_smtcn->indicate_enable == 0x0002) {
    510                          uint8_t ssid[BLE_SMTCN_SSID_LEN] = {0};
    511                          uint8_t ssid_len;
    512                          struct netif *sta_if = netif_find("st2");
    513          
    514                          netif_set_status_callback(sta_if, ble_smtcn_ip_change_callback);
    515                          netif_set_link_up(sta_if);
    516                          dhcp_start(sta_if);
    517          
    518                          wifi_config_get_ssid(0, ssid, &(ssid_len));
    519          
    520                          LOG_I(BLE_SMTCN, "[BLE_SMTCN]dtps_wifi_event_handler, ssid = %s, ssid_len = %d\n", ssid, ssid_len);
    521          
    522          
    523                          //send connected indication
    524                          LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_wifi_event_handler: send connected indication\n");
    525          
    526                          ble_smtcn_send_indication(BLE_SMTCN_WIFI_INFO_CONNECTED, 0, NULL);
    527                          ble_smtcn_send_indication(BLE_SMTCN_WIFI_INFO_SSID, ssid_len, ssid);
    528                      }
    529                      break;
    530                  }
    531          
    532                  case WIFI_EVENT_IOT_DISCONNECTED:
    533                  {
    534                      struct netif *sta_if = netif_find("st2");
    535                      netif_set_status_callback(sta_if, NULL);
    536                      netif_set_link_down(sta_if);
    537                      netif_set_addr(sta_if, IP4_ADDR_ANY, IP4_ADDR_ANY, IP4_ADDR_ANY);
    538                      break;
    539                  }
    540                  default:
    541                      break;
    542              }
    543          
    544              return 1;
    545          }
    546          
    547          
    548          int32_t ble_smtcn_init(void)
    549          {
    550              int32_t status;
    551          
    552              LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_init\n");
    553          
    554              memset(p_smtcn, 0, sizeof(ble_smtcn_context_t));
    555          
    556              status = wifi_connection_register_event_handler(WIFI_EVENT_IOT_PORT_SECURE, ble_smtcn_wifi_event_handler);
    557          
    558              if (status < 0) {
    559                  return status;
    560          }
    561          
    562              status = wifi_connection_register_event_handler(WIFI_EVENT_IOT_DISCONNECTED, ble_smtcn_wifi_event_handler);
    563          
    564              if (status < 0) {
    565                  return status;
    566              }
    567          
    568              return 0;
    569          }
    570          
    571          
    572          int32_t ble_smtcn_deinit(void)
    573          {
    574              int32_t status;
    575              
    576              LOG_I(BLE_SMTCN, "[BLE_SMTCN]ble_smtcn_deinit\n");
    577              
    578              memset(p_smtcn, 0, sizeof(ble_smtcn_context_t));
    579              
    580              status = wifi_connection_unregister_event_handler(WIFI_EVENT_IOT_PORT_SECURE, ble_smtcn_wifi_event_handler);
    581              if (status < 0) {
    582                  return status;
    583              }
    584          
    585              status = wifi_connection_unregister_event_handler(WIFI_EVENT_IOT_DISCONNECTED, ble_smtcn_wifi_event_handler);
    586              if (status < 0) {
    587                  return status;
    588              }
    589              
    590              return 0;
    591          }
    592          
    593          BT_GATTS_NEW_PRIMARY_SERVICE_16(bt_if_dtp_primary_service, BLE_SMTCN_SERVICE_UUID);
    594          
    595          BT_GATTS_NEW_CHARC_16(bt_if_dtp_char,
    596                                BT_GATT_CHARC_PROP_WRITE | BT_GATT_CHARC_PROP_INDICATE, BLE_SMTCN_CHAR_VALUE_HANDLE, BLE_SMTCN_CHAR_UUID);
    597          
    598          BT_GATTS_NEW_CHARC_VALUE_CALLBACK(bt_if_dtp_char_value, BLE_SMTCN_CHAR_UUID128,
    599                              BT_GATTS_REC_PERM_READABLE | BT_GATTS_REC_PERM_WRITABLE, ble_smtcn_charc_value_callback);
    600          
    601          BT_GATTS_NEW_CLIENT_CHARC_CONFIG(bt_if_dtp_client_config,
    602                                           BT_GATTS_REC_PERM_READABLE | BT_GATTS_REC_PERM_WRITABLE,
    603                                           ble_smtcn_client_config_callback);
    604          
    605          static const bt_gatts_service_rec_t *bt_if_ble_smtcn_service_rec[] = {
    606              (const bt_gatts_service_rec_t *) &bt_if_dtp_primary_service,
    607              (const bt_gatts_service_rec_t *) &bt_if_dtp_char,
    608              (const bt_gatts_service_rec_t *) &bt_if_dtp_char_value,
    609              (const bt_gatts_service_rec_t *) &bt_if_dtp_client_config
    610          };
    611          
    612          const bt_gatts_service_t bt_if_ble_smtcn_service = {
    613              .starting_handle = 0x0014,
    614              .ending_handle = 0x0017,
    615              .required_encryption_key_size = 0,
    616              .records = bt_if_ble_smtcn_service_rec
    617          };
    618          
    619          #endif
    620          
    621          
    622          
    623          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      72   ble_smtcn_charc_value_callback
        72   -- Indirect call
        72   -> __aeabi_memclr4
        72   -> __aeabi_memset4
        72   -> ble_smtcn_parse_data
        72   -> ble_smtcn_send_indication
        72   -> ble_smtcn_setup_wifi_connection
        72   -> memcmp
        72   -> strlen
        72   -> wifi_config_get_ssid
        72   -> wifi_connection_get_link_status
      48   ble_smtcn_client_config_callback
        48   -- Indirect call
        48   -> __aeabi_memcpy
        48   -> xTaskGetTickCount
        48   -> xTimerCreate
        48   -> xTimerGenericCommand
      16   ble_smtcn_deinit
        16   -- Indirect call
        16   -> __aeabi_memset4
        16   -> wifi_connection_unregister_event_handler
      64   ble_smtcn_event_callback
        64   -- Indirect call
        64   -> __aeabi_memcpy4
        64   -> bt_gap_le_set_advertising
      16   ble_smtcn_init
        16   -- Indirect call
        16   -> __aeabi_memset4
        16   -> wifi_connection_register_event_handler
      24   ble_smtcn_ip_change_callback
        24   -- Indirect call
         0   -> __aeabi_memset4
        24   -> ble_smtcn_send_indication
        24   -> ip4addr_ntoa
        24   -> strcpy
        24   -> strlen
      40   ble_smtcn_parse_data
        40   -- Indirect call
        40   -> __aeabi_memcpy
     128   ble_smtcn_send_indication
       128   -- Indirect call
       128   -> __aeabi_memclr4
       128   -> __aeabi_memcpy
       128   -> bt_gatts_send_charc_value_notification_indication
      24   ble_smtcn_set_adv
        24   -- Indirect call
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
        24   -> bt_gap_le_set_random_address
     144   ble_smtcn_setup_wifi_connection
       144   -- Indirect call
       144   -> __aeabi_memcpy
       144   -> strlen
       144   -> wifi_config_reload_setting
       144   -> wifi_config_set_security_mode
       144   -> wifi_config_set_ssid
       144   -> wifi_config_set_wep_key
       144   -> wifi_config_set_wpa_psk_key
      56   ble_smtcn_timeout_callback
        56   -- Indirect call
        56   -> __aeabi_memclr4
        56   -> __aeabi_memset4
        56   -> ble_smtcn_send_indication
        56   -> strlen
        56   -> wifi_config_get_ssid
        56   -> wifi_connection_get_link_status
      72   ble_smtcn_wifi_event_handler
        72   -- Indirect call
        72   -> __aeabi_memclr4
        72   -> ble_smtcn_send_indication
        72   -> dhcp_start
        72   -> netif_find
        72   -> netif_set_addr
        72   -> netif_set_link_down
        72   -> netif_set_link_up
        72   -> netif_set_status_callback
        72   -> wifi_config_get_ssid


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable75
       4  ??DataTable75_1
       4  ??DataTable75_2
       4  ??DataTable75_3
       4  ??DataTable75_4
       4  ??DataTable75_5
       4  ??DataTable75_6
       4  ??DataTable75_7
      12  ?_0
       8  ?_1
      60  ?_10
      72  ?_11
      68  ?_12
      72  ?_13
      48  ?_14
      32  ?_15
      40  ?_16
      56  ?_17
      28  ?_18
      52  ?_19
      32  ?_2
      32  ?_20
      44  ?_21
      32  ?_22
      24  ?_23
      80  ?_24
      32  ?_25
      60  ?_26
      72  ?_27
      60  ?_28
      64  ?_29
      32  ?_3
      72  ?_30
      52  ?_31
      16  ?_32
      52  ?_33
      36  ?_34
      32  ?_35
      24  ?_36
      56  ?_37
      32  ?_38
       4  ?_39
      64  ?_4
      64  ?_40
      68  ?_41
      28  ?_42
      32  ?_43
      16  ?_44
      32  ?_45
      20  ?_5
      52  ?_6
      68  ?_7
      56  ?_8
      36  ?_9
      16  BLE_SMTCN_CHAR_UUID128
     344  ble_smtcn_charc_value_callback
     234  ble_smtcn_client_config_callback
      88  ble_smtcn_cntx
      66  ble_smtcn_deinit
     154  ble_smtcn_event_callback
      66  ble_smtcn_init
     102  ble_smtcn_ip_change_callback
     304  ble_smtcn_parse_data
     206  ble_smtcn_send_indication
      84  ble_smtcn_set_adv
     290  ble_smtcn_setup_wifi_connection
     176  ble_smtcn_timeout_callback
     206  ble_smtcn_wifi_event_handler
      12  bt_if_ble_smtcn_service
      16  bt_if_ble_smtcn_service_rec
      16  bt_if_dtp_char
      12  bt_if_dtp_char_value
      12  bt_if_dtp_client_config
      12  bt_if_dtp_primary_service
      20  log_control_block_BLE_SMTCN
          p_smtcn
     328  -- Other

 
    88 bytes in section .bss
    36 bytes in section .data
   264 bytes in section .rodata
 4 432 bytes in section .text
 
 4 432 bytes of CODE  memory
   264 bytes of CONST memory
   124 bytes of DATA  memory

Errors: none
Warnings: 5
