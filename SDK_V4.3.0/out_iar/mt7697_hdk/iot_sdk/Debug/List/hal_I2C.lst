###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:24
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\hal_I2C.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW71E1.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\hal_I2C.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\hal_I2C.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\hal_I2C.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\hal_I2C.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          /*
     36          ** $Log: hal_I2C.c $
     37          **
     38          ** 04 13 2015 leo.hung
     39          ** [DVT][I2C]
     40          ** 1. Fix build error.
     41          **
     42          ** 04 13 2015 leo.hung
     43          ** [DVT][I2C]
     44          ** 1. Update I2C DVT cases.
     45          **
     46          ** 03 24 2015 leo.hung
     47          ** [DVT]
     48          ** 1. Fix build error of r=1.
     49          **
     50          ** 12 16 2014 leo.hung
     51          ** [DVT][I2C]
     52          ** 1. Fix halI2CClearFIFO.
     53          **
     54          ** 11 24 2014 leo.hung
     55          ** [DVT][I2C][PWM]
     56          ** 1. Add Auto regression.
     57          ** 2. Add volatile to fix -Os error.
     58          **
     59          ** 11 24 2014 leo.hung
     60          ** [DVT][IrTx]
     61          ** 1. Add IrTx DVT.
     62          **
     63          ** 11 11 2014 leo.hung
     64          ** [DVT][I2C][PWM]
     65          ** 1. Update I2C DMA mode.
     66          ** 2. Replace PWM field access with bit offset access.
     67          **
     68          ** 11 10 2014 leo.hung
     69          ** [DVT][I2C]
     70          ** 1. Use CPU_FREQUENCY instead of hard code.
     71          **
     72          ** 11 03 2014 leo.hung
     73          ** [DVT][I2C]
     74          ** 1. Seperate I2C clock rate setting for FPGA and Chip.
     75          ** 2. Fix I2C DMA mode setting.
     76          **
     77          ** 10 29 2014 leo.hung
     78          ** [DVT][I2C]
     79          ** 1. Remove parameter ucGModeEn in halI2CMasterCtrl().
     80          **    Config General/Normal mode per transfer instead of init time.
     81          ** 2. Fix halI2CChkStatus() for slave address exist check.
     82          ** 3. Add I2C GDMA mode for Normal and General R/W.
     83          **
     84          ** 10 28 2014 leo.hung
     85          ** [DVT][I2C]
     86          ** 1. Add transfer status check.
     87          ** 2. Add I2C interrupt check.
     88          **
     89          ** 10 27 2014 leo.hung
     90          ** [DVT]
     91          ** 1. Update I2C.
     92          **
     93          ** 10 27 2014 leo.hung
     94          ** [DVT]
     95          ** 1. Update I2C.
     96          **
     97          ** 10 23 2014 leo.hung
     98          ** [DVT]
     99          ** 1. Update I2C.
    100          **
    101          **
    102          */
    103          
    104          /*******************************************************************************
    105          *                         C O M P I L E R   F L A G S
    106          ********************************************************************************
    107          */
    108          
    109          
    110          /*******************************************************************************
    111          *                    E X T E R N A L   R E F E R E N C E S
    112          ********************************************************************************
    113          */
    114          #include "hal_i2c_master.h"
    115          #if defined(HAL_I2C_MASTER_MODULE_ENABLED)
    116          #include <stdio.h>
    117          #include <string.h>
    118          #include "type_def.h"
    119          #include "top.h"
    120          #include "hal_I2C.h"
    121          #include "dma_sw.h"
    122          #include "hal_log.h"
    123          #include "hal_gpt.h"
    124          #include "debug.h"
    125          #include "hal_nvic_internal.h"
    126          
    127          /*******************************************************************************
    128          *                              C O N S T A N T S
    129          ********************************************************************************
    130          */
    131          #define I2C_RW_POLLING    1
    132          
    133          /*******************************************************************************
    134          *                             D A T A   T Y P E S
    135          ********************************************************************************
    136          */
    137          
    138          
    139          /*******************************************************************************
    140          *                            P U B L I C   D A T A
    141          ********************************************************************************
    142          */
    143          
    144          
    145          /*
    146          ========================================================================
    147          Routine Description:
    148          
    149          Note:
    150          ========================================================================
    151          */
    152          #define I2C_ENABLE_POLLING_TIMEOUT
    153          
    154          #ifdef I2C_ENABLE_POLLING_TIMEOUT
    155          #define I2C_POLLING_TIMEOUT_VALUE (131072)  /* Unit:32k. (131072 * 1 / 32k) = 4s */
    156          
    157          static void i2c_master_wait_transaction_finish(IOT_I2C_TypeDef *pI2CTypeDef, uint8_t ucIdx, uint8_t ucI2CIdx, uint8_t is_tx)
    158          {
    159              uint32_t gpt_start_count, gpt_current_count, gpt_duration_count;
    160              hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_32K, &gpt_start_count);
    161              /* polling till transaction finish */
    162              while (1) {
    163                  uint32_t saved_mask;
    164                  saved_mask = save_and_set_interrupt_mask();
    165                  if (1 == is_tx) {
    166                      if (!((!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) && ucIdx < 0xF0)) {
    167                          restore_interrupt_mask(saved_mask);
    168                          break;
    169                      }
    170                  } else {
    171                      if (!((!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))))) {
    172                          restore_interrupt_mask(saved_mask);
    173                          break;
    174                      }
    175                  }
    176                  hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_32K, &gpt_current_count);
    177                  hal_gpt_get_duration_count(gpt_start_count, gpt_current_count, &gpt_duration_count);
    178                  if (I2C_POLLING_TIMEOUT_VALUE < gpt_duration_count) {
    179                      log_hal_error("[I2C%d][is_tx = %d]:polling tiemout!\r\n", ucI2CIdx, is_tx);
    180                      ASSERT(0);
    181                  }
    182                  restore_interrupt_mask(saved_mask);
    183              }
    184          }
    185          #endif
    186          P_IOT_I2C_TypeDef halI2CGetBaseAddr(UINT8 ucI2CIdx)
    187          {
    188              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    189          
    190              if (0 == ucI2CIdx) {
    191                  pI2CTypeDef = (IOT_I2C_TypeDef *)IOT_I2C0_MM_PAD_CON0;
    192              } else if (1 == ucI2CIdx) {
    193                  pI2CTypeDef = (IOT_I2C_TypeDef *)IOT_I2C1_MM_PAD_CON0;
    194              }
    195          
    196              return pI2CTypeDef;
    197          }
    198          
    199          
    200          ENUM_HAL_RET_T halI2CClearFIFO(UINT8 ucI2CIdx, UINT8 ucRxClr, UINT8 ucTxClr)
    201          {
    202              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    203              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    204              UINT32 u4Val = 0;
    205          
    206              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    207              //if (NULL == pI2CTypeDef)
    208              //{
    209              //    return HAL_RET_FAIL;
    210              //}
    211          
    212              u4Val = (pI2CTypeDef->MM_FIFO_CON0);
    213          
    214              if (ucRxClr) {
    215                  u4Val |= (0x1 << I2C_MM_RX_FIFO_CLR_OFFSET);
    216              }
    217          
    218              if (ucTxClr) {
    219                  u4Val |= (0x1 << I2C_MM_TX_FIFO_CLR_OFFSET);
    220              }
    221          
    222              (pI2CTypeDef->MM_FIFO_CON0) |= u4Val;
    223          
    224              return ret;
    225          }
    226          
    227          /*
    228           * ucSCLDRVHEn:
    229           * ucSDADRVHEn:     MM_PAD_CON0[6:5] can decide driving or pulling high of SDA and SCL.
    230           *                  Setting to driving high can reduce some latency, but it is different with spec.
    231           *                  Should NOT enable for normal case.
    232           * ucIntClkSyncEn:  Set MM_PAD_CON[7] to 1 to enable the internal clock synchronization of SDA and SCL inputs.
    233           *                  The glitch is not so many when enabling, but the latency with 2 internal clock cycle will be induced.
    234           * ucDeglitchCnt:   Enable the deglitch circuit by setting MM_PAD_CON[4:0] to non-zero value.
    235           */
    236          ENUM_HAL_RET_T halI2CInit(UINT8 ucI2CIdx, UINT8 ucSCLDRVHEn, UINT8 ucSDADRVHEn, UINT8 ucIntClkSyncEn, UINT8 ucDeglitchCnt)
    237          {
    238              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    239              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    240          
    241              // Sanity check
    242              if (ucDeglitchCnt & (~I2C_DE_CNT_MASK)) {
    243                  return HAL_RET_FAIL;
    244              }
    245          
    246              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    247              //if (NULL == pI2CTypeDef)
    248              //{
    249              //    return HAL_RET_FAIL;
    250              //}
    251          
    252              if (ucSCLDRVHEn) {
    253                  (pI2CTypeDef->MM_PAD_CON0) |= BIT(I2C_SCL_DRVH_EN_OFFSET);
    254              } else {
    255                  (pI2CTypeDef->MM_PAD_CON0) &= (~BIT(I2C_SCL_DRVH_EN_OFFSET));
    256              }
    257          
    258              if (ucSDADRVHEn) {
    259                  (pI2CTypeDef->MM_PAD_CON0) |= BIT(I2C_SDA_DRVH_EN_OFFSET);
    260              } else {
    261                  (pI2CTypeDef->MM_PAD_CON0) &= (~BIT(I2C_SDA_DRVH_EN_OFFSET));
    262              }
    263          
    264              if (ucIntClkSyncEn) {
    265                  (pI2CTypeDef->MM_PAD_CON0) |= BIT(I2C_CLK_SYNC_EN_OFFSET);
    266              } else {
    267                  (pI2CTypeDef->MM_PAD_CON0) &= (~BIT(I2C_CLK_SYNC_EN_OFFSET));
    268              }
    269          
    270              (pI2CTypeDef->MM_PAD_CON0) &= (~I2C_DE_CNT_MASK);
    271              (pI2CTypeDef->MM_PAD_CON0) |= (ucDeglitchCnt << I2C_DE_CNT_OFFSET);
    272          
    273              halI2CClearFIFO(ucI2CIdx, 1, 1);
    274          
    275          
    276              return ret;
    277          }
    278          
    279          /*
    280           * MM_CON0 should be set correctly according to the I2C protocol.
    281           * MM_CON0[15] is used to enable the master function.
    282           * MM_CON0[14] should be 0 in normal usage.
    283           * Then setting MM_CNT_VAL_PHL and MM_CNT_VAL_PHH decide the bit rate of I2C in standard mode or fast mode.
    284           *
    285           * Note: General Mode / Normal Mode is configured per transfer.
    286           */
    287          ENUM_HAL_RET_T halI2CMasterCtrl(UINT8 ucI2CIdx, ENUM_I2C_CLK_T eFrequency)
    288          {
    289              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    290              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    291              UINT32 u4Val = 0;
    292              UINT8 ucPhase1Adj = 0;
    293              UINT32 u4OperFreq = 0;
    294              UINT16 u2PhaseVal = 0;
    295          
    296              // sanity check
    297              if (eFrequency >= I2C_CLK_NUM) {
    298                  return HAL_RET_FAIL;
    299              }
    300          
    301              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    302              //if (NULL == pI2CTypeDef)
    303              //{
    304              //    return HAL_RET_FAIL;
    305              //}
    306          
    307              // Enable I2C transfer W   I2C_BASE + 0x270    [15]    MASTER_EN   1'b1    Set 1 to enable master mode
    308              //                                             [14]    MM_GMODE    1'b0    Set 0 to disable general mode (normal mode)
    309              //                                             [13]    MM_HS_EN    1'b0    Set 0 to disable HS mode
    310              //                                             [12]    MM_TB_EN    1'b0    Set 0 to disable Ten-Bit mode
    311              //                                             [11]    MCU_SEL 1'b0    Set 0 to select DSP I/F
    312              u4Val = (pI2CTypeDef->MM_CON0);
    313              u4Val |= BIT(I2C_MASTER_EN_OFFSET);
    314              u4Val &= (~BIT(I2C_MM_GMODE_OFFSET));
    315              u4Val &= (~BIT(I2C_MM_HS_EN_OFFSET));
    316              u4Val &= (~BIT(I2C_MM_TB_EN_OFFSET));
    317              u4Val &= (~BIT(I2C_MCU_SEL_OFFSET));
    318              (pI2CTypeDef->MM_CON0) = u4Val;
    319          
    320              // Clock rate(Frequency) selection
    321              // Sum of phase0,1,2,3 = 'Bus clock' / 'I2C clock rate'
    322              // Count from 0x0
    323              // Phase1 adjust value
    324              //1. Output register
    325              ucPhase1Adj = 1;
    326              u4Val = (pI2CTypeDef->MM_PAD_CON0);
    327              if (u4Val & BIT(I2C_CLK_SYNC_EN_OFFSET)) {
    328                  // 2. Sync enable
    329                  ucPhase1Adj += 1;
    330              }
    331              // 3. de-glitch (n+4)
    332              ucPhase1Adj += (((u4Val & I2C_DE_CNT_MASK) >> I2C_DE_CNT_OFFSET) + 4);
    333          
    334              // FPGA use 30MHz as I2C operation frequence
    335              // Confirmed with DE, 30M is 30*1000*1000 instead of 30*1024*1024
    336          
    337              u4OperFreq = top_xtal_freq_get(); // CPU_FREQUENCY;
    338              switch (eFrequency) {
    339                  case I2C_CLK_50K:
    340                      // 50KHz
    341                      // 800 = (40000 / 50)
    342                      u2PhaseVal = ((u4OperFreq / (50 * 1000)) / 4) - 1; // Count from 0
    343          
    344                      // Set the value of phase1/0
    345                      // pI2CTypeDef->MM_CNT_VAL_PHL = 0x0000BFC7; // sync disable, de-glitch=3
    346                      // Set the value of phase3/2
    347                      // pI2CTypeDef->MM_CNT_VAL_PHH = 0x0000C7C7;
    348                      break;
    349                  case I2C_CLK_100K:
    350                      // 100KHz
    351                      // 400 = (40000 / 100)
    352                      u2PhaseVal = ((u4OperFreq / (100 * 1000)) / 4) - 1; // Count from 0
    353          
    354                      // Set the value of phase1/0
    355                      // pI2CTypeDef->MM_CNT_VAL_PHL = 0x00005B63; // sync disable, de-glitch=3
    356                      // Set the value of phase3/2
    357                      // pI2CTypeDef->MM_CNT_VAL_PHH = 0x00006363;
    358                      break;
    359                  case I2C_CLK_200K:
    360                      // 200KHz
    361                      // 200 = (40000 / 200)
    362                      u2PhaseVal = ((u4OperFreq / (200 * 1000)) / 4) - 1; // Count from 0
    363          
    364                      // Set the value of phase1/0
    365                      // pI2CTypeDef->MM_CNT_VAL_PHL = 0x00002931; // sync disable, de-glitch=3
    366                      // Set the value of phase3/2
    367                      // pI2CTypeDef->MM_CNT_VAL_PHH = 0x00003131;
    368          
    369                      break;
    370                  case I2C_CLK_300K:
    371                      // 300KHz
    372                      // 300 = (40000 / 300)
    373                      u2PhaseVal = ((u4OperFreq / (300 * 1000)) / 4) - 1; // Count from 0
    374          
    375                      // Set the value of phase1/0
    376                      // pI2CTypeDef->MM_CNT_VAL_PHL = 0x00002931; // sync disable, de-glitch=3
    377                      // Set the value of phase3/2
    378                      // pI2CTypeDef->MM_CNT_VAL_PHH = 0x00003131;
    379          
    380                      break;
    381                  case I2C_CLK_400K:
    382                      // 400KHz
    383                      // 100 = (40000 / 400)
    384                      u2PhaseVal = ((u4OperFreq / (400 * 1000)) / 4) - 1; // Count from 0
    385          
    386                      // Set the value of phase1/0
    387                      // pI2CTypeDef->MM_CNT_VAL_PHL = 0x00001018; // sync disable, de-glitch=3
    388                      // Set the value of phase3/2
    389                      // pI2CTypeDef->MM_CNT_VAL_PHH = 0x00001818;
    390                      break;
    391                  default:
    392                      return HAL_RET_FAIL;
    393                      //break;
    394              }
    395              // Set the value of phase1/0
    396              pI2CTypeDef->MM_CNT_VAL_PHL = (((u2PhaseVal - ucPhase1Adj) << I2C_MM_CNTPHASE_VAL1_OFFSET) | (u2PhaseVal << I2C_MM_CNTPHASE_VAL0_OFFSET));
    397              // Set the value of phase3/2
    398              pI2CTypeDef->MM_CNT_VAL_PHH = ((u2PhaseVal << I2C_MM_CNTPHASE_VAL3_OFFSET) | (u2PhaseVal << I2C_MM_CNTPHASE_VAL2_OFFSET));
    399          
    400              return ret;
    401          }
    402          
    403          /*
    404           *
    405           */
    406          UINT8 halI2CGetFIFOSpace(UINT8 WPtr, UINT8 RPtr)
    407          {
    408          
    409              if (WPtr == RPtr) {
    410                  return I2C_FIFO_MAX_LEN;
    411              } else if ((WPtr & BITS(0, 2)) == (RPtr & BITS(0, 2))) {
    412                  return 0;
    413              }
    414          
    415              WPtr &= BITS(0, 2);
    416              RPtr &= BITS(0, 2);
    417          
    418              if (WPtr > RPtr) {
    419                  return (I2C_FIFO_MAX_LEN - (WPtr - RPtr));
    420              } else {
    421                  return (RPtr - WPtr);
    422              }
    423          }
    424          
    425          /*
    426           * return remaining space length of Tx FIFO
    427           */
    428          UINT8 halI2CTxFIFOSpace(IOT_I2C_TypeDef *pI2CTypeDef)
    429          {
    430          #if 0
    431              UINT8   ucLen = 0;
    432          #endif
    433              UINT8   ucTxWPtr = 0;
    434              UINT8   ucTxRPtr = 0;
    435              UINT32  u4Val = 0;
    436          
    437              u4Val = (pI2CTypeDef->MM_FIFO_PTR);
    438              ucTxWPtr = (u4Val & I2C_MM_TX_FIFO_WPTR_MASK) >> I2C_MM_TX_FIFO_WPTR_OFFSET;
    439              ucTxRPtr = (u4Val & I2C_MM_TX_FIFO_RPTR_MASK) >> I2C_MM_TX_FIFO_RPTR_OFFSET;
    440          
    441              //printf("[%s]ucTxWPtr=%u, ucTxRPtr=%u\n", __FUNCTION__, ucTxWPtr, ucTxRPtr);
    442              return halI2CGetFIFOSpace(ucTxWPtr, ucTxRPtr);
    443          #if 0
    444              if (ucTxWPtr == ucTxRPtr) {
    445                  return I2C_FIFO_MAX_LEN;
    446              } else if ((ucTxWPtr & BITS(0, 2)) == (ucTxRPtr & BITS(0, 2))) {
    447                  return 0;
    448              }
    449          
    450              ucTxWPtr &= BITS(0, 2);
    451              ucTxRPtr &= BITS(0, 2);
    452          
    453              if (ucTxWPtr > ucTxRPtr) {
    454                  ucLen = I2C_FIFO_MAX_LEN - (ucTxWPtr - ucTxRPtr);
    455              } else {
    456                  ucLen = ucTxRPtr - ucTxWPtr;
    457              }
    458              //printf("---len=%u\n", ucLen);
    459          
    460              return ucLen;
    461          #endif
    462          }
    463          
    464          /*
    465           * return remaining space length of Rx FIFO
    466           */
    467          UINT8 halI2CRxFIFOSpace(IOT_I2C_TypeDef *pI2CTypeDef)
    468          {
    469          #if 0
    470              UINT8   ucLen = 0;
    471          #endif
    472              UINT8   ucRxWPtr = 0;
    473              UINT8   ucRxRPtr = 0;
    474              UINT32  u4Val = 0;
    475          
    476              u4Val = (pI2CTypeDef->MM_FIFO_PTR);
    477              ucRxWPtr = (u4Val & I2C_MM_RX_FIFO_WPTR_MASK) >> I2C_MM_RX_FIFO_WPTR_OFFSET;
    478              ucRxRPtr = (u4Val & I2C_MM_RX_FIFO_RPTR_MASK) >> I2C_MM_RX_FIFO_RPTR_OFFSET;
    479              return halI2CGetFIFOSpace(ucRxWPtr, ucRxRPtr);
    480          #if 0
    481              if (ucRxWPtr == ucRxRPtr) {
    482                  return I2C_FIFO_MAX_LEN;
    483              } else if ((ucRxWPtr & BITS(0, 2)) == (ucRxRPtr & BITS(0, 2))) {
    484                  return 0;
    485              }
    486          
    487              ucRxWPtr &= BITS(0, 2);
    488              ucRxRPtr &= BITS(0, 2);
    489          
    490              if (ucRxWPtr > ucRxRPtr) {
    491                  ucLen = I2C_FIFO_MAX_LEN - (ucRxWPtr - ucRxRPtr);
    492              } else {
    493                  ucLen = ucRxRPtr - ucRxWPtr;
    494              }
    495          
    496              return ucLen;
    497          #endif
    498          }
    499          
    500          UINT16 halI2CGetFIFOStatus(UINT8 ucI2CIdx)
    501          {
    502              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    503          
    504              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    505              //if (NULL == pI2CTypeDef)
    506              //{
    507              //    return HAL_RET_FAIL;
    508              //}
    509          
    510              return (pI2CTypeDef->MM_FIFO_STATUS);
    511          }
    512          
    513          /*
    514           * a. Read MM_STATUS[2]. The I2C master circuit is ready for preparing the next trigger if the value is 1.
    515           * b. Write the TX data into the memory or MM_FIFO_DATA according the value of DMA_CON0.
    516           * c. Set a value of MM_ID_CON0 to decide which slave you want to write.
    517           * d. Set MM_PACK_CON0[0] to 0 for write.
    518           * e. Set MM_CON0[0] to 1 to trigger the master to write data to slave.
    519           * f. After setting MM_CON0[0] to 1, the value of MM_STATUS[2] will become 0.
    520           *    Waiting an interrupt or the value of MM_STATUS[2] to 1 to check the TX transfer is over.
    521           */
    522          /*
    523           * ucSlaveAddress[6:0] indicate 7-bit address, bit7 is un-used
    524           */
    525          ENUM_HAL_RET_T halI2CNormalWrite(UINT8 ucI2CIdx, UINT8 ucSlaveAddress, const UINT8 *pucTxData, UINT16 u2Length)
    526          {
    527              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    528              UINT8 ucIdx = 0;
    529              UINT8 ucTxLen = 0;
    530              UINT16 u2Residual = u2Length;
    531              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    532          
    533              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    534              //if (NULL == pI2CTypeDef)
    535              //{
    536              //    return HAL_RET_FAIL;
    537              //}
    538          
    539              // Sanity check
    540              if (!pucTxData) {
    541                  return HAL_RET_FAIL;
    542              }
    543          
    544              // General mode Disable
    545              (pI2CTypeDef->MM_CON0) &= (~BIT(I2C_MM_GMODE_OFFSET));
    546          
    547          
    548              // a. Read MM_STATUS[2]. The I2C master circuit is ready for preparing the next trigger if the value is 1.
    549              if (!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
    550                  printf("[%s](!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET)))\n", __FUNCTION__);
    551                  log_hal_error("[I2C][Normal_Write]  not ready.\r\n");
    552                  return HAL_RET_FAIL;
    553              }
    554          
    555              // b. Write the TX data into the memory or MM_FIFO_DATA according the value of DMA_CON0.
    556              ucTxLen = halI2CTxFIFOSpace(pI2CTypeDef);
    557              if (ucTxLen > u2Length) {
    558                  ucTxLen = u2Length;
    559              }
    560              for (ucIdx = 0; ucIdx < ucTxLen; ucIdx++) {
    561                  (pI2CTypeDef->MM_FIFO_DATA) = (*pucTxData);
    562                  pucTxData++;
    563              }
    564              u2Residual = u2Residual - ucTxLen;
    565          
    566              // c. Set a value of MM_ID_CON0 to decide which slave you want to write.
    567              (pI2CTypeDef->MM_ID_CON0) &= (~I2C_MM_SLAVE_ID_MASK);
    568              (pI2CTypeDef->MM_ID_CON0) |= ((ucSlaveAddress & (I2C_MM_SLAVE_ID_MASK)) << I2C_MM_SLAVE_ID_OFFSET);
    569          
    570              // d. Set MM_PACK_CON0[0] to 0 for write.
    571              (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(I2C_MM_PACK_RW_OFFSET));
    572          
    573              // e. Set MM_CON0[0] to 1 to trigger the master to write data to slave.
    574              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_START_EN_OFFSET);
    575          
    576          //#if (1 != I2C_FIFO_DVT)
    577              while (u2Residual) {
    578                  if (((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
    579                      // Tx transfer already terminated while Tx data not complete send out.
    580                      log_hal_error("[I2C][Normal_Write] return before complete;length=%d.\r\n", u2Length);
    581                      return HAL_RET_FAIL;
    582                  }
    583                  ucTxLen = halI2CTxFIFOSpace(pI2CTypeDef);
    584                  if (0 == ucTxLen) {
    585                      continue;
    586                  }
    587          
    588                  if (ucTxLen > u2Residual) {
    589                      ucTxLen = u2Residual;
    590                  }
    591          
    592                  for (ucIdx = 0; ucIdx < ucTxLen; ucIdx++) {
    593          #if 0
    594                      printf("WPTR=%u, RPTR=%u, ucTxLen=%u\n", (((pI2CTypeDef->MM_FIFO_PTR) & I2C_MM_TX_FIFO_WPTR_MASK) >> I2C_MM_TX_FIFO_WPTR_OFFSET),
    595                             (((pI2CTypeDef->MM_FIFO_PTR) & I2C_MM_TX_FIFO_RPTR_MASK) >> I2C_MM_TX_FIFO_RPTR_OFFSET),
    596                             ucTxLen);
    597          #endif
    598                      (pI2CTypeDef->MM_FIFO_DATA) = (*pucTxData);
    599                      pucTxData++;
    600                  }
    601                  u2Residual = u2Residual - ucTxLen;
    602              }
    603          //#endif //#if (1 != I2C_FIFO_DVT)
    604          
    605          #if I2C_RW_POLLING
    606              // f. After setting MM_CON0[0] to 1, the value of MM_STATUS[2] will become 0.
    607              //    Waiting an interrupt or the value of MM_STATUS[2] to 1 to check the TX transfer is over.
    608          #ifndef I2C_ENABLE_POLLING_TIMEOUT
    609              do {
    610                  // busy waiting
    611              } while ((!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) && ucIdx < 0xF0);
    612          #else
    613              i2c_master_wait_transaction_finish(pI2CTypeDef, ucIdx, ucI2CIdx, 1);
    614          #endif
    615          #endif
    616          
    617              if (I2C_TRANS_STATUS_OK != halI2CChkStatus(ucI2CIdx, 1, (1 + u2Length))) {
    618                  log_hal_error("[I2C][Normal_Write] error_status = %d.\r\n", halI2CChkStatus(ucI2CIdx, 1, (1 + u2Length)));
    619                  return HAL_RET_FAIL;
    620              }
    621          
    622              return ret;
    623          }
    624          
    625          
    626          /*
    627           * a. Read MM_STATUS[2] as 1.
    628           * b. Set MM_ID_CON0 and MM_ID_CON1 for slave address.
    629           * c. Set MM_PACK_CON0[0] to 1 for read.
    630           * d. Set the MM_CNT_BYTE_VAL_PK0 to decide how many data to be read.
    631           * e. Set MM_CON0[0] to 1
    632           * f. wait RX transfer over by interrupt or polling the value of MM_STATUS[2].
    633           */
    634          ENUM_HAL_RET_T halI2CNormalRead(UINT8 ucI2CIdx, UINT8 ucSlaveAddress, PUINT8 pucRxData, UINT16 u2Length)
    635          {
    636              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    637              UINT16  u2RetriveLen = 0;
    638              UINT16  u2Residual = u2Length;
    639              UINT8   ucRxBufIdx = 0;
    640              UINT16  u2Idx = 0;
    641              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    642          
    643              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    644              //if (NULL == pI2CTypeDef)
    645              //{
    646              //    printf("[%s](NULL == pI2CTypeDef)\n", __FUNCTION__);
    647              //    return HAL_RET_FAIL;
    648              //}
    649          
    650              if (NULL == pucRxData) {
    651                  return HAL_RET_FAIL;
    652              }
    653          
    654              // General mode Disable
    655              (pI2CTypeDef->MM_CON0) &= (~BIT(I2C_MM_GMODE_OFFSET));
    656          
    657              // a. Read MM_STATUS[2] as 1.
    658              if (!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
    659                  printf("[%s](!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET)))\n", __FUNCTION__);
    660                  log_hal_error("[I2C][Normal_Read]  not ready.\r\n");
    661                  return HAL_RET_FAIL;
    662              }
    663          
    664              // b. Set MM_ID_CON0 and MM_ID_CON1 for slave address.
    665              (pI2CTypeDef->MM_ID_CON0) &= (~I2C_MM_SLAVE_ID_MASK);
    666              (pI2CTypeDef->MM_ID_CON0) |= ((ucSlaveAddress & (I2C_MM_SLAVE_ID_MASK)) << I2C_MM_SLAVE_ID_OFFSET);
    667          
    668              // c. Set MM_PACK_CON0[0] to 1 for read.
    669              (pI2CTypeDef->MM_PACK_CON0) |= BIT(I2C_MM_PACK_RW_OFFSET);
    670          
    671              // d. Set the MM_CNT_BYTE_VAL_PK0 to decide how many data to be read.
    672              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK0) = u2Length;
    673          
    674              // e. Set MM_CON0[0] to 1
    675              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_START_EN_OFFSET);
    676          
    677              if (pucRxData) {
    678                  while (u2Residual) {
    679                      if ((((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) && ((pI2CTypeDef->MM_ACK_VAL) & 0x1)) {
    680                          log_hal_error("[I2C][Normal_Read] return before complete;length=%d\r\n", u2Length);
    681                          return HAL_RET_FAIL;
    682                          // Rx transfer already terminated while not get enough data.
    683                          // for example, an ack error happened. so we need also check
    684                          // if ack happened.
    685                      }
    686          
    687                      u2RetriveLen = (I2C_FIFO_MAX_LEN - halI2CRxFIFOSpace(pI2CTypeDef));
    688                      if (0 == u2RetriveLen) {
    689                          continue;
    690                      }
    691                      if (u2RetriveLen > u2Residual) {
    692                          u2RetriveLen = u2Residual;
    693                      }
    694                      for (u2Idx = 0; u2Idx < u2RetriveLen; u2Idx++) {
    695          #if 0
    696                          printf("WPTR=%u, RPTR=%u, u2RetriveLen=%u\n", (((pI2CTypeDef->MM_FIFO_PTR) & I2C_MM_RX_FIFO_WPTR_MASK) >> I2C_MM_RX_FIFO_WPTR_OFFSET),
    697                                 (((pI2CTypeDef->MM_FIFO_PTR) & I2C_MM_RX_FIFO_RPTR_MASK) >> I2C_MM_RX_FIFO_RPTR_OFFSET),
    698                                 u2RetriveLen);
    699          #endif
    700          
    701                          pucRxData[ucRxBufIdx] = (pI2CTypeDef->MM_FIFO_DATA);
    702                          ucRxBufIdx++;
    703                      }
    704                      u2Residual = u2Residual - u2RetriveLen;
    705                  }
    706              }
    707          
    708          #if I2C_RW_POLLING
    709              // f. wait RX transfer over by interrupt or polling the value of MM_STATUS[2].
    710          #ifndef I2C_ENABLE_POLLING_TIMEOUT
    711              do {
    712                  // busy waiting
    713              } while ((!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))));
    714          #else
    715              i2c_master_wait_transaction_finish(pI2CTypeDef, 0, ucI2CIdx, 0);
    716          
    717          #endif
    718          #endif // #if I2C_RW_POLLING
    719          
    720          #if 0
    721              printf("[halI2CNormalRead]\n------------\n");
    722              if (pucRxData) {
    723                  for (u2Idx = 0; u2Idx < u2Length; u2Idx++) {
    724                      printf("0x%02X ", pucRxData[u2Idx]);
    725                      if (0 == ((u2Idx + 1) & 0x7)) {
    726                          printf("\n");
    727                      }
    728                  }
    729              }
    730              printf("\n------------\n");
    731          #endif
    732          
    733              if (I2C_TRANS_STATUS_OK != halI2CChkStatus(ucI2CIdx, 1, 1)) {
    734                  log_hal_error("[I2C][Normal_Read] error_status = %d.\r\n", halI2CChkStatus(ucI2CIdx, 1, 1));
    735                  return HAL_RET_FAIL;
    736              }
    737          
    738              return ret;
    739          }
    740          
    741          #define I2C_GM_RX_LOG 0
    742          
    743          /*
    744             ucPkt0/1/2RW:    0: write
    745                              1: read
    746           */
    747          ENUM_HAL_RET_T halI2CGeneralRW(UINT8 ucI2CIdx,
    748                                         UINT8 ucSlaveAddress,
    749                                         PUINT8 pucTxData,
    750                                         PUINT8 pucRxData,
    751                                         UINT8 ucPktNum,
    752                                         UINT8 ucPkt0RW,
    753                                         UINT16 u2Pkt0Len,
    754                                         UINT8 ucPkt1RW,
    755                                         UINT16 u2Pkt1Len,
    756                                         UINT8 ucPkt2RW,
    757                                         UINT16 u2Pkt2Len)
    758          {
    759              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    760              UINT16  u2Idx = 0;
    761              UINT16  u2TxLen = 0;
    762              UINT16  u2TxResidual = 0;
    763              UINT16  u2RxLen = 0;
    764              UINT16  u2RxResidual = 0;
    765              UINT16  u2RxBufIdx = 0;
    766              UINT16  u2AckLen = 0;
    767              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    768          #if (1 == I2C_GM_RX_LOG)
    769              UINT16  u2RxLogLen = 0;
    770          #endif
    771          
    772              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    773              //if (NULL == pI2CTypeDef)
    774              //{
    775              //    return HAL_RET_FAIL;
    776              //}
    777          
    778              // Sanity check
    779              if (ucPktNum > I2C_PKT_MAX_NUM) {
    780                  return HAL_RET_FAIL;
    781              }
    782          
    783              if ((!pucTxData) || (!pucRxData)) {
    784                  return HAL_RET_FAIL;
    785              }
    786          
    787              // General mode enable
    788              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_GMODE_OFFSET);
    789          
    790              // a. Read MM_STATUS[2]. The I2C master circuit is ready for preparing the next trigger if the value is 1.
    791              if (!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
    792                  printf("[%s](!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET)))\n", __FUNCTION__);
    793                  log_hal_error("[I2C][General_RW]  not ready.\r\n");
    794                  return HAL_RET_FAIL;
    795              }
    796          
    797              // b. Set a value of MM_ID_CON0 to decide which slave you want to write.
    798              (pI2CTypeDef->MM_ID_CON0) &= (~I2C_MM_SLAVE_ID_MASK);
    799              (pI2CTypeDef->MM_ID_CON0) |= ((ucSlaveAddress & (I2C_MM_SLAVE_ID_MASK)) << I2C_MM_SLAVE_ID_OFFSET);
    800          
    801              // c. Set MM_PACK_CON0[5:4] packet number.
    802              (pI2CTypeDef->MM_PACK_CON0) &= ~(I2C_MM_PACK_VAL_MASK);
    803              (pI2CTypeDef->MM_PACK_CON0) |= ((ucPktNum - 1) << I2C_MM_PACK_VAL_OFFSET);
    804          
    805              // d. Set the MM_CNT_BYTE_VAL_PK0/1/2 to decide data length.
    806              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK0) = u2Pkt0Len;
    807              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK1) = u2Pkt1Len;
    808              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK2) = u2Pkt2Len;
    809          
    810              // e. Set each PKT's R/W mode
    811              if (ucPktNum) {
    812                  if (ucPkt0RW) {
    813                      // read
    814                      u2RxResidual += u2Pkt0Len;
    815                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(0);
    816                  } else {
    817                      // write
    818                      u2TxResidual += u2Pkt0Len;
    819                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(0));
    820                  }
    821                  ucPktNum--;
    822              }
    823              if (ucPktNum) {
    824                  if (ucPkt1RW) {
    825                      // read
    826                      u2RxResidual += u2Pkt1Len;
    827                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(1);
    828                  } else {
    829                      // write
    830                      u2TxResidual += u2Pkt1Len;
    831                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(1));
    832                  }
    833                  ucPktNum--;
    834              }
    835              if (ucPktNum) {
    836                  if (ucPkt2RW) {
    837                      // read
    838                      u2RxResidual += u2Pkt2Len;
    839                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(2);
    840                  } else {
    841                      // write
    842                      u2TxResidual += u2Pkt2Len;
    843                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(2));
    844                  }
    845                  ucPktNum--;
    846              }
    847          #if (1 == I2C_GM_RX_LOG)
    848              u2RxLogLen = u2RxResidual;
    849          #endif
    850              u2AckLen = ucPktNum + u2TxResidual;
    851          
    852          
    853              // f. Write the TX data into the memory or MM_FIFO_DATA according the value of DMA_CON0.
    854              u2TxLen = halI2CTxFIFOSpace(pI2CTypeDef);
    855              if (u2TxLen > u2TxResidual) {
    856                  u2TxLen = u2TxResidual;
    857              }
    858              for (u2Idx = 0; u2Idx < u2TxLen; u2Idx++) {
    859                  (pI2CTypeDef->MM_FIFO_DATA) = (*pucTxData);
    860                  pucTxData++;
    861              }
    862              u2TxResidual = u2TxResidual - u2TxLen;
    863          
    864              // g. Set MM_CON0[0] to 1 to trigger the master to write data to slave.
    865              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_START_EN_OFFSET);
    866          
    867              while (u2TxResidual || u2RxResidual) {
    868                  //if ((0 != u2TxResidual) && ((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET)))
    869                  if (((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
    870                      // Tx transfer already terminated while Tx data not complete send out.
    871                      // Rx transfer already terminated while not get enough data.
    872                      return HAL_RET_FAIL;
    873                  }
    874                  u2RxLen = (I2C_FIFO_MAX_LEN - halI2CRxFIFOSpace(pI2CTypeDef));
    875                  u2TxLen = halI2CTxFIFOSpace(pI2CTypeDef);
    876                  if ((0 == u2RxLen) && (0 == u2TxLen)) {
    877                      continue;
    878                  }
    879                  // Tx
    880                  if (u2TxLen > u2TxResidual) {
    881                      u2TxLen = u2TxResidual;
    882                  }
    883          
    884                  for (u2Idx = 0; u2Idx < u2TxLen; u2Idx++) {
    885                      (pI2CTypeDef->MM_FIFO_DATA) = (*pucTxData);
    886                      pucTxData++;
    887                  }
    888                  u2TxResidual = u2TxResidual - u2TxLen;
    889          
    890                  // Rx
    891                  if (u2RxLen > u2RxResidual) {
    892                      u2RxLen = u2RxResidual;
    893                  }
    894                  for (u2Idx = 0; u2Idx < u2RxLen; u2Idx++) {
    895                      pucRxData[u2RxBufIdx] = (pI2CTypeDef->MM_FIFO_DATA);
    896                      u2RxBufIdx++;
    897                  }
    898                  u2RxResidual = u2RxResidual - u2RxLen;
    899          
    900              }
    901          
    902          #if I2C_RW_POLLING // only for debug 
    903              // h. After setting MM_CON0[0] to 1, the value of MM_STATUS[2] will become 0.
    904              //    Waiting an interrupt or the value of MM_STATUS[2] to 1 to check the TX transfer is over.
    905          #ifndef I2C_ENABLE_POLLING_TIMEOUT
    906              do {
    907                  // busy waiting
    908          
    909              } while ((!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))));
    910          #else
    911              i2c_master_wait_transaction_finish(pI2CTypeDef, 0, ucI2CIdx, 0);
    912          #endif
    913          #endif // only for debug 
    914          
    915          #if (1 == I2C_GM_RX_LOG)
    916              printf("[%s] Rx FiFo\n------------\n", __FUNCTION__);
    917              if (pucRxData) {
    918                  for (u2Idx = 0; u2Idx < u2RxLogLen; u2Idx++) {
    919                      printf("0x%02X ", pucRxData[u2Idx]);
    920                      if (0 == ((u2Idx + 1) & 0x7)) {
    921                          printf("\n");
    922                      }
    923                  }
    924              }
    925              printf("\n------------\n");
    926          #endif
    927          
    928              if (I2C_TRANS_STATUS_OK != halI2CChkStatus(ucI2CIdx, ucPktNum, u2AckLen)) {
    929                  return HAL_RET_FAIL;
    930              }
    931          
    932              return ret;
    933          }
    934          
    935          /*
    936           * [Arbitration]
    937           * MM_STATUS[1] will become 1 to indicate that there is arbitration lose in the transfer before.
    938           * The data of TX may not be write out correctly or the data of RX may not be read correctly when arbitration lose.
    939           * Write MM_STATUS[1] as 1 to clear the value of this bit.
    940           *
    941           * [ACK bit map]
    942           * The MM_PACK_CON0[0] in standard/fast mode or MM_PACK_CON0[1] in high speed mode should be 0 to indicate the slave exist on the bus outside.
    943           * If the value is 1, the transfer will stop after the slave address has transmitted, because there is no slave to give an acknowledge bit.
    944           *
    945           * [FIFO status]
    946           * MM_FIFO_STATUS should also be checked after transfer when using FIFO mode.
    947           * There are overflow, underflow, full, and empty flags of each TX or RX FIFO.
    948           * Write MM_FIFO_CON0[1] or MM_FIFO_CON0[0] as 1 to clear the related FIFO status of TX FIFO or RX FIFO.
    949           *
    950           * ucPktNum:    Normal mode: alwasy 1
    951           *              General mode: according to pkt number 1 ~ 3
    952           * ucAckLen:    RECEIVED ack number including "slave address" and "Tx data".
    953           *              NOT including "Ack for Rx data" which is SENT by master.
    954           */
    955          ENUM_I2C_TRANS_STATUS_T halI2CChkStatus(UINT8 ucI2CIdx, UINT8 ucPktNum, UINT8 ucAckLen)
    956          {
    957              ENUM_I2C_TRANS_STATUS_T ret = I2C_TRANS_STATUS_OK;
    958              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
    959              UINT32 u4Val = 0;
    960              UINT8 ucAckCheckLen = 0;
    961              UINT8 ucPktAckVal = 0;
    962              UINT8 i = 0;
    963          
    964              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
    965              //if (NULL == pI2CTypeDef)
    966              //{
    967              //    return I2C_TRANS_STATUS_FAIL;
    968              //}
    969          
    970              // [Arbitration]
    971              if ((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_ARB_HAD_LOSE_OFFSET)) {
    972                  // Arbitration lose
    973                  return I2C_TRANS_STATUS_ARBITRATE;
    974              }
    975          
    976              // [ACK bit map]
    977              u4Val = (pI2CTypeDef->MM_ACK_VAL);
    978              ucPktAckVal = (u4Val >> (I2C_ACK_PKT0_OFFSET));
    979          
    980              // Check slave address exist
    981              for (i = 0; i < ucPktNum; i++) {
    982                  if (ucPktAckVal & (0x1 << i)) {
    983                      return I2C_TRANS_STATUS_SLAVE_NOT_EXIST;
    984                  }
    985              }
    986          
    987              // Check ACK for data
    988              // Only last 8 received ACK are recorded
    989              ucAckCheckLen = ucAckLen;
    990              if (ucAckLen > 8) {
    991                  ucAckCheckLen = 8;
    992              }
    993              for (i = 0; i < ucAckCheckLen; i++) {
    994                  if (u4Val & (0x1 << i)) {
    995                      return I2C_TRANS_STATUS_NACK;
    996                  }
    997              }
    998          
    999              // [FIFO status]
   1000              // Success Tx/Rx transfer should complete with Tx/Rx FIFO EMPTY
   1001              if (0x11 != halI2CGetFIFOStatus(ucI2CIdx)) {
   1002                  return I2C_TRANS_STATUS_FIFO_FLOW;
   1003              }
   1004          
   1005              return ret;
   1006          }
   1007          
   1008          ENUM_I2C_TRANS_STATUS_T halI2CGetBusyStatus(UINT8 ucI2CIdx)
   1009          {
   1010              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
   1011              ENUM_I2C_TRANS_STATUS_T busy_status;
   1012          
   1013              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
   1014              //if (NULL == pI2CTypeDef)
   1015              //{
   1016              //    return I2C_TRANS_STATUS_FAIL;
   1017              //}
   1018              busy_status = (ENUM_I2C_TRANS_STATUS_T)((pI2CTypeDef->MM_STATUS) & BIT(I2C_BUS_BUSY_OFFSET));
   1019              //If I2C is idle, clear FIFO for next transaction
   1020              if (I2C_TRANS_STATUS_SLAVE_NOT_EXIST == busy_status) {
   1021                  halI2CClearFIFO(ucI2CIdx, 1, 1);
   1022              }
   1023              return busy_status;
   1024          }
   1025          /*
   1026           * I2C module build-in DMA is NOT supported in MT7687.
   1027           * Leverage GDMA to do I2C+DMA access.
   1028           */
   1029          ENUM_HAL_RET_T halI2CGDMACtrl(UINT8 ucI2CIdx, UINT8 ucGDMAIdx, UINT8 ucTxMode, UINT16 u2Len, const UINT8 *pucMemAddr)
   1030          {
   1031              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
   1032              IOT_I2C_HALF_GDMA_TypeDef *pI2CHalfGDMATypeDef = NULL;
   1033              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
   1034              UINT32 u4Val = 0;
   1035          
   1036              // Sanity Check
   1037              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
   1038              if (NULL == pI2CTypeDef) {
   1039          //        return HAL_RET_FAIL;
   1040              }
   1041              // I2C MUST use half channel DMA
   1042              if ((ucGDMAIdx < 3) || (ucGDMAIdx > 12)) {
   1043                  return HAL_RET_FAIL;
   1044              }
   1045          
   1046          
   1047              /* set GDMA PDN */
   1048              DMA_Clock_Enable(ucGDMAIdx);
   1049          
   1050          
   1051          
   1052              pI2CHalfGDMATypeDef = (IOT_I2C_HALF_GDMA_TypeDef *)(CM4_DMA_BASE + (ucGDMAIdx * 0x100) + I2C_GDMA_DMAN_WPPT_OFFSET);
   1053          
   1054              /* Set DMA limiter to slowdown DMA. Avoid DMA and I2C handshake error */
   1055              (pI2CHalfGDMATypeDef->DMAn_LIMITER) = 0x80;
   1056          
   1057              // Set GDMA transfer count W   GDMA_BASE + 0x0N10  [15:0]  LEN USER_DEFINED    Unit is byte
   1058              (pI2CHalfGDMATypeDef->DMAn_COUNT) = (((pI2CHalfGDMATypeDef->DMAn_COUNT) & (~BITS(0, 15))) | u2Len);
   1059          
   1060              // Set GDMA source address	W	GDMA_BASE + 0x0N2C	[31:0]	PGMADDR	USER_DEFINED	The address in memory
   1061              (pI2CHalfGDMATypeDef->DMAn_PGMADDR) = (UINT32)(pucMemAddr);
   1062          
   1063              // Set GDMA configurations W   GDMA_BASE + 0x0N14
   1064              u4Val = (pI2CHalfGDMATypeDef->DMAn_CON);
   1065              if (0 == ucI2CIdx) {
   1066                  // [25:20] MAS 6'd2 or 6'd4    Set 6'd2/6'd4 for I2C-1/2 TX respectively
   1067                  // [25:20] MAS 6'd3 or 6'd5    Set 6'd3/6'd5 for I2C-1/2 RX respectively
   1068                  if (1 == ucTxMode) {
   1069                      // Tx
   1070                      u4Val = (u4Val & (~BITS(20, 25))) | (0x2 << 20);
   1071                      u4Val = (u4Val & (~BIT(18)));
   1072                  } else {
   1073                      // Rx
   1074                      u4Val = (u4Val & (~BITS(20, 25))) | (0x3 << 20);
   1075                      u4Val = (u4Val | BIT(18));
   1076                  }
   1077              } else if (1 == ucI2CIdx) {
   1078                  // [25:20] MAS 6'd2 or 6'd4    Set 6'd2/6'd4 for I2C-1/2 TX respectively
   1079                  // [25:20] MAS 6'd3 or 6'd5    Set 6'd3/6'd5 for I2C-1/2 RX respectively
   1080                  if (1 == ucTxMode) {
   1081                      // Tx
   1082                      u4Val = (u4Val & (~BITS(20, 25))) | (0x4 << 20);
   1083                  } else {
   1084                      // Rx
   1085                      u4Val = (u4Val & (~BITS(20, 25))) | (0x5 << 20);
   1086                  }
   1087              }
   1088          
   1089              if (1 == ucTxMode) {
   1090                  // Tx
   1091                  // [18]    DIR 1'b0    Set 0 for Read (RAM to I2C) I2C Tx
   1092                  u4Val = (u4Val & (~BIT(18)));
   1093          
   1094                  //[3] DINC    1'b0    Set 0 to disable incremental address
   1095                  u4Val = (u4Val & (~BIT(3)));
   1096                  //[2] SINC    1'b1    Set 1 to enable incremental address
   1097                  u4Val = (u4Val | BIT(2));
   1098              } else {
   1099                  // Rx
   1100                  // [18]    DIR 1'b1    Set 1 for Write (I2C to RAM) I2C Rx
   1101                  u4Val = (u4Val | BIT(18));
   1102          
   1103                  //[3] DINC    1'b1    Set 1 to enable incremental address
   1104                  u4Val = (u4Val | BIT(3));
   1105                  //[2] SINC    1'b0    Set 0 to disable incremental address
   1106                  u4Val = (u4Val & (~BIT(2)));
   1107              }
   1108          
   1109              // [17]    WPEN    1'b0    Set 0 to disable wrapping
   1110              u4Val = (u4Val & (~BIT(17)));
   1111              // [15]    ITEN    1'b0    Set 0 to disable interrupt
   1112              u4Val = (u4Val & (~BIT(15)));
   1113              // [10:8]  BURST   3'b000  Set 0 for single-byte burst
   1114              u4Val = (u4Val & (~BITS(8, 10)));
   1115              // [5] B2W 1'b0    Set 0 to disable
   1116              u4Val = (u4Val & (~BIT(5)));
   1117              // [4] DREQ    1'b1    Set 1 to enable HW handshake
   1118              u4Val = (u4Val | BIT(4));
   1119              // [1:0]   SIZE    2'b00   Set 0 for single-byte transfer
   1120              u4Val = (u4Val & (~BITS(0, 1)));
   1121              (pI2CHalfGDMATypeDef->DMAn_CON) = u4Val;
   1122          
   1123          
   1124              // Enable GDMA W   GDMA_BASE + 0x0N18  [15]    STR 1'b0    Set 0 to reset DMA transfer
   1125              //             W   GDMA_BASE + 0x0N18  [15]    STR 1'b1    Set 1 to start DMA transfer
   1126              u4Val = (pI2CHalfGDMATypeDef->DMAn_START);
   1127              (pI2CHalfGDMATypeDef->DMAn_START) = (u4Val & (~BIT(15)));
   1128              (pI2CHalfGDMATypeDef->DMAn_START) = (u4Val | BIT(15));
   1129          
   1130          
   1131              return ret;
   1132          }
   1133          
   1134          
   1135          ENUM_HAL_RET_T halI2CGDMANormalWrite(UINT8 ucI2CIdx, UINT8 ucGDMAIdx, UINT8 ucSlaveAddress, const UINT8 *pucTxData, UINT16 u2Length)
   1136          {
   1137              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
   1138              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
   1139          
   1140              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
   1141              //if (NULL == pI2CTypeDef)
   1142              //{
   1143              //    return HAL_RET_FAIL;
   1144              // }
   1145          
   1146              // Sanity check
   1147              if (!pucTxData) {
   1148                  return HAL_RET_FAIL;
   1149              }
   1150          
   1151              // General mode Disable
   1152              (pI2CTypeDef->MM_CON0) &= (~BIT(I2C_MM_GMODE_OFFSET));
   1153          
   1154          
   1155              // a. Read MM_STATUS[2]. The I2C master circuit is ready for preparing the next trigger if the value is 1.
   1156              if (!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
   1157                  log_hal_error("[I2C][DMA_Write] busy;length=%d.\r\n", u2Length);
   1158                  return HAL_RET_FAIL;
   1159              }
   1160              // b. Configure GDMA for Tx data.
   1161              halI2CGDMACtrl(ucI2CIdx, ucGDMAIdx, 1, u2Length, pucTxData);
   1162          
   1163              // c. Set a value of MM_ID_CON0 to decide which slave you want to write.
   1164              (pI2CTypeDef->MM_ID_CON0) &= (~I2C_MM_SLAVE_ID_MASK);
   1165              (pI2CTypeDef->MM_ID_CON0) |= ((ucSlaveAddress & (I2C_MM_SLAVE_ID_MASK)) << I2C_MM_SLAVE_ID_OFFSET);
   1166          
   1167              // d. Set MM_PACK_CON0[0] to 0 for write.
   1168              (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(I2C_MM_PACK_RW_OFFSET));
   1169          
   1170              // e. Set MM_CON0[0] to 1 to trigger the master to write data to slave.
   1171              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_START_EN_OFFSET);
   1172          
   1173              return ret;
   1174          }
   1175          
   1176          ENUM_HAL_RET_T halI2CGDMANormalRead(UINT8 ucI2CIdx, UINT8 ucGDMAIdx, UINT8 ucSlaveAddress, PUINT8 pucRxData, UINT16 u2Length)
   1177          {
   1178              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
   1179              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
   1180          
   1181              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
   1182              //if (NULL == pI2CTypeDef)
   1183              //{
   1184              //    printf("[%s](NULL == pI2CTypeDef)\n", __FUNCTION__);
   1185              //    return HAL_RET_FAIL;
   1186              //}
   1187          
   1188              if (NULL == pucRxData) {
   1189                  return HAL_RET_FAIL;
   1190              }
   1191          
   1192              // General mode Disable
   1193              (pI2CTypeDef->MM_CON0) &= (~BIT(I2C_MM_GMODE_OFFSET));
   1194          
   1195              // a. Read MM_STATUS[2] as 1.
   1196              if (!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
   1197                  printf("[%s](!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET)))\n", __FUNCTION__);
   1198                  log_hal_error("[I2C][DMA_Read] busy;length=%d.\r\n", u2Length);
   1199                  return HAL_RET_FAIL;
   1200              }
   1201          
   1202              // b. Set MM_ID_CON0 and MM_ID_CON1 for slave address.
   1203              (pI2CTypeDef->MM_ID_CON0) &= (~I2C_MM_SLAVE_ID_MASK);
   1204              (pI2CTypeDef->MM_ID_CON0) |= ((ucSlaveAddress & (I2C_MM_SLAVE_ID_MASK)) << I2C_MM_SLAVE_ID_OFFSET);
   1205          
   1206              // c. Set MM_PACK_CON0[0] to 1 for read.
   1207              (pI2CTypeDef->MM_PACK_CON0) |= BIT(I2C_MM_PACK_RW_OFFSET);
   1208          
   1209              // d. Set the MM_CNT_BYTE_VAL_PK0 to decide how many data to be read.
   1210              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK0) = u2Length;
   1211          
   1212              // Configure GDMA for Rx data.
   1213              halI2CGDMACtrl(ucI2CIdx, ucGDMAIdx, 0, u2Length, pucRxData);
   1214          
   1215              // e. Set MM_CON0[0] to 1
   1216              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_START_EN_OFFSET);
   1217          
   1218              return ret;
   1219          }
   1220          
   1221          ENUM_HAL_RET_T halI2CGDMAGeneralRW(UINT8 ucI2CIdx,
   1222                                             UINT8 ucTxGDMAIdx,
   1223                                             UINT8 ucRxGDMAIdx,
   1224                                             UINT8 ucSlaveAddress,
   1225                                             PUINT8 pucTxData,
   1226                                             PUINT8 pucRxData,
   1227                                             UINT8 ucPktNum,
   1228                                             UINT8 ucPkt0RW,
   1229                                             UINT16 u2Pkt0Len,
   1230                                             UINT8 ucPkt1RW,
   1231                                             UINT16 u2Pkt1Len,
   1232                                             UINT8 ucPkt2RW,
   1233                                             UINT16 u2Pkt2Len)
   1234          {
   1235              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
   1236          
   1237              UINT16  u2TxResidual = 0;
   1238              UINT16  u2RxResidual = 0;
   1239          
   1240              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
   1241          
   1242              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
   1243              //if (NULL == pI2CTypeDef)
   1244              //{
   1245              //    return HAL_RET_FAIL;
   1246              //}
   1247          
   1248              // Sanity check
   1249              if (ucPktNum > I2C_PKT_MAX_NUM) {
   1250                  return HAL_RET_FAIL;
   1251              }
   1252          
   1253              if ((!pucTxData) || (!pucRxData)) {
   1254                  return HAL_RET_FAIL;
   1255              }
   1256          
   1257              // General mode enable
   1258              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_GMODE_OFFSET);
   1259          
   1260              // a. Read MM_STATUS[2]. The I2C master circuit is ready for preparing the next trigger if the value is 1.
   1261              if (!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
   1262                  printf("[%s](!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET)))\n", __FUNCTION__);
   1263                  log_hal_error("[I2C][DMA_RW]  not ready.\r\n");
   1264                  return HAL_RET_FAIL;
   1265              }
   1266          
   1267              // b. Set a value of MM_ID_CON0 to decide which slave you want to write.
   1268              (pI2CTypeDef->MM_ID_CON0) &= (~I2C_MM_SLAVE_ID_MASK);
   1269              (pI2CTypeDef->MM_ID_CON0) |= ((ucSlaveAddress & (I2C_MM_SLAVE_ID_MASK)) << I2C_MM_SLAVE_ID_OFFSET);
   1270          
   1271              // c. Set MM_PACK_CON0[5:4] packet number.
   1272              (pI2CTypeDef->MM_PACK_CON0) &= ~(I2C_MM_PACK_VAL_MASK);
   1273              (pI2CTypeDef->MM_PACK_CON0) |= ((ucPktNum - 1) << I2C_MM_PACK_VAL_OFFSET);
   1274          
   1275              // d. Set the MM_CNT_BYTE_VAL_PK0/1/2 to decide data length.
   1276              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK0) = u2Pkt0Len;
   1277              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK1) = u2Pkt1Len;
   1278              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK2) = u2Pkt2Len;
   1279          
   1280              // e. Set each PKT's R/W mode
   1281              if (ucPktNum) {
   1282                  if (ucPkt0RW) {
   1283                      // read
   1284                      u2RxResidual += u2Pkt0Len;
   1285                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(0);
   1286                  } else {
   1287                      // write
   1288                      u2TxResidual += u2Pkt0Len;
   1289                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(0));
   1290                  }
   1291                  ucPktNum--;
   1292              }
   1293              if (ucPktNum) {
   1294                  if (ucPkt1RW) {
   1295                      // read
   1296                      u2RxResidual += u2Pkt1Len;
   1297                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(1);
   1298                  } else {
   1299                      // write
   1300                      u2TxResidual += u2Pkt1Len;
   1301                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(1));
   1302                  }
   1303                  ucPktNum--;
   1304              }
   1305              if (ucPktNum) {
   1306                  if (ucPkt2RW) {
   1307                      // read
   1308                      u2RxResidual += u2Pkt2Len;
   1309                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(2);
   1310                  } else {
   1311                      // write
   1312                      u2TxResidual += u2Pkt2Len;
   1313                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(2));
   1314                  }
   1315                  ucPktNum--;
   1316              }
   1317          
   1318              if (u2TxResidual > 0) {
   1319                  // Configure GDMA for Tx data.
   1320                  halI2CGDMACtrl(ucI2CIdx, ucTxGDMAIdx, 1, u2TxResidual, pucTxData);
   1321              }
   1322          
   1323              if (u2RxResidual > 0) {
   1324                  // Configure GDMA for Rx data.
   1325                  halI2CGDMACtrl(ucI2CIdx, ucRxGDMAIdx, 0, u2RxResidual, pucRxData);
   1326              }
   1327              // g. Set MM_CON0[0] to 1 to trigger the master to write data to slave.
   1328              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_START_EN_OFFSET);
   1329          
   1330              return ret;
   1331          }
   1332          
   1333          
   1334          #if (WIFI_BUILD_OPTION == 1)
   1335          // Only for DVT, NOT for release
   1336          // GDMA length < I2C Tx length
   1337          ENUM_HAL_RET_T halI2CGDMAGeneralRW_DVT_DEBUG(UINT8 ucI2CIdx,
   1338                  UINT8 ucTxGDMAIdx,
   1339                  UINT8 ucRxGDMAIdx,
   1340                  UINT8 ucSlaveAddress,
   1341                  PUINT8 pucTxData,
   1342                  PUINT8 pucRxData,
   1343                  UINT8 ucPktNum,
   1344                  UINT8 ucPkt0RW,
   1345                  UINT16 u2Pkt0Len,
   1346                  UINT8 ucPkt1RW,
   1347                  UINT16 u2Pkt1Len,
   1348                  UINT8 ucPkt2RW,
   1349                  UINT16 u2Pkt2Len)
   1350          {
   1351              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
   1352          
   1353              UINT16  u2TxResidual = 0;
   1354              UINT16  u2RxResidual = 0;
   1355          
   1356              IOT_I2C_TypeDef *pI2CTypeDef = NULL;
   1357          
   1358              pI2CTypeDef = halI2CGetBaseAddr(ucI2CIdx);
   1359              //if (NULL == pI2CTypeDef)
   1360              //{
   1361              //    return HAL_RET_FAIL;
   1362              //}
   1363          
   1364              // Sanity check
   1365              if (ucPktNum > I2C_PKT_MAX_NUM) {
   1366                  return HAL_RET_FAIL;
   1367              }
   1368          
   1369              if ((!pucTxData) || (!pucRxData)) {
   1370                  return HAL_RET_FAIL;
   1371              }
   1372          
   1373              // General mode enable
   1374              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_GMODE_OFFSET);
   1375          
   1376              // a. Read MM_STATUS[2]. The I2C master circuit is ready for preparing the next trigger if the value is 1.
   1377              if (!((pI2CTypeDef->MM_STATUS) & BIT(I2C_MM_START_READY_OFFSET))) {
   1378                  return HAL_RET_FAIL;
   1379              }
   1380          
   1381              // b. Set a value of MM_ID_CON0 to decide which slave you want to write.
   1382              (pI2CTypeDef->MM_ID_CON0) &= (~I2C_MM_SLAVE_ID_MASK);
   1383              (pI2CTypeDef->MM_ID_CON0) |= ((ucSlaveAddress & (I2C_MM_SLAVE_ID_MASK)) << I2C_MM_SLAVE_ID_OFFSET);
   1384          
   1385              // c. Set MM_PACK_CON0[5:4] packet number.
   1386              (pI2CTypeDef->MM_PACK_CON0) &= ~(I2C_MM_PACK_VAL_MASK);
   1387              (pI2CTypeDef->MM_PACK_CON0) |= ((ucPktNum - 1) << I2C_MM_PACK_VAL_OFFSET);
   1388          
   1389              // d. Set the MM_CNT_BYTE_VAL_PK0/1/2 to decide data length.
   1390              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK0) = u2Pkt0Len;
   1391              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK1) = u2Pkt1Len;
   1392              (pI2CTypeDef->MM_CNT_BYTE_VAL_PK2) = u2Pkt2Len;
   1393          
   1394              // e. Set each PKT's R/W mode
   1395              if (ucPktNum) {
   1396                  if (ucPkt0RW) {
   1397                      // read
   1398                      u2RxResidual += u2Pkt0Len;
   1399                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(0);
   1400                  } else {
   1401                      // write
   1402                      u2TxResidual += u2Pkt0Len;
   1403                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(0));
   1404                  }
   1405                  ucPktNum--;
   1406              }
   1407              if (ucPktNum) {
   1408                  if (ucPkt1RW) {
   1409                      // read
   1410                      u2RxResidual += u2Pkt1Len;
   1411                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(1);
   1412                  } else {
   1413                      // write
   1414                      u2TxResidual += u2Pkt1Len;
   1415                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(1));
   1416                  }
   1417                  ucPktNum--;
   1418              }
   1419              if (ucPktNum) {
   1420                  if (ucPkt2RW) {
   1421                      // read
   1422                      u2RxResidual += u2Pkt2Len;
   1423                      (pI2CTypeDef->MM_PACK_CON0) |= BIT(2);
   1424                  } else {
   1425                      // write
   1426                      u2TxResidual += u2Pkt2Len;
   1427                      (pI2CTypeDef->MM_PACK_CON0) &= (~BIT(2));
   1428                  }
   1429                  ucPktNum--;
   1430              }
   1431          
   1432              if (u2TxResidual > 0) {
   1433                  // Configure GDMA for Tx data.
   1434                  halI2CGDMACtrl(ucI2CIdx, ucTxGDMAIdx, 1, (u2TxResidual >> 1), pucTxData);
   1435              }
   1436              if (u2RxResidual > 0) {
   1437                  // Configure GDMA for Rx data.
   1438                  halI2CGDMACtrl(ucI2CIdx, ucRxGDMAIdx, 0, (u2RxResidual >> 1), pucRxData);
   1439              }
   1440              // g. Set MM_CON0[0] to 1 to trigger the master to write data to slave.
   1441              (pI2CTypeDef->MM_CON0) |= BIT(I2C_MM_START_EN_OFFSET);
   1442          
   1443              return ret;
   1444          }
   1445          #endif // #if (WIFI_BUILD_OPTION == 1)
   1446          
   1447          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   halI2CChkStatus
        24   -> halI2CGetBaseAddr
        24   -> halI2CGetFIFOStatus
      16   halI2CClearFIFO
        16   -> halI2CGetBaseAddr
      32   halI2CGDMACtrl
        32   -> DMA_Clock_Enable
        32   -> halI2CGetBaseAddr
      40   halI2CGDMAGeneralRW
        40   -> halI2CGDMACtrl
        40   -> halI2CGetBaseAddr
        40   -> log_hal_error_internal
        40   -> printf
      32   halI2CGDMANormalRead
        32   -> halI2CGDMACtrl
        32   -> halI2CGetBaseAddr
        32   -> log_hal_error_internal
        32   -> printf
      32   halI2CGDMANormalWrite
        32   -> halI2CGDMACtrl
        32   -> halI2CGetBaseAddr
        32   -> log_hal_error_internal
      56   halI2CGeneralRW
        56   -> halI2CChkStatus
        56   -> halI2CGetBaseAddr
        56   -> halI2CRxFIFOSpace
        56   -> halI2CTxFIFOSpace
        56   -> i2c_master_wait_transaction_finish
        56   -> log_hal_error_internal
        56   -> printf
       0   halI2CGetBaseAddr
      16   halI2CGetBusyStatus
        16   -> halI2CClearFIFO
        16   -> halI2CGetBaseAddr
       0   halI2CGetFIFOSpace
       8   halI2CGetFIFOStatus
         8   -> halI2CGetBaseAddr
      24   halI2CInit
        24   -> halI2CClearFIFO
        24   -> halI2CGetBaseAddr
      16   halI2CMasterCtrl
        16   -> halI2CGetBaseAddr
        16   -> top_xtal_freq_get
      40   halI2CNormalRead
        40   -> halI2CChkStatus
        40   -> halI2CGetBaseAddr
        40   -> halI2CRxFIFOSpace
        40   -> i2c_master_wait_transaction_finish
        40   -> log_hal_error_internal
        40   -> printf
      40   halI2CNormalWrite
        40   -> halI2CChkStatus
        40   -> halI2CGetBaseAddr
        40   -> halI2CTxFIFOSpace
        40   -> i2c_master_wait_transaction_finish
        40   -> log_hal_error_internal
        40   -> printf
       0   halI2CRxFIFOSpace
         0   -> halI2CGetFIFOSpace
       0   halI2CTxFIFOSpace
         0   -> halI2CGetFIFOSpace
      48   i2c_master_wait_transaction_finish
        48   -> hal_gpt_get_duration_count
        48   -> hal_gpt_get_free_run_count
        48   -> log_hal_error_internal
        48   -> printf
        48   -> restore_interrupt_mask
        48   -> save_and_set_interrupt_mask


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
      40  ?_0
      40  ?_1
      32  ?_10
      36  ?_11
      36  ?_12
      28  ?_13
      72  ?_2
      68  ?_3
      36  ?_4
      56  ?_5
      44  ?_6
      36  ?_7
      56  ?_8
      40  ?_9
     108  halI2CChkStatus
      38  halI2CClearFIFO
     170  halI2CGDMACtrl
     394  halI2CGDMAGeneralRW
     158  halI2CGDMANormalRead
     138  halI2CGDMANormalWrite
     568  halI2CGeneralRW
      24  halI2CGetBaseAddr
      30  halI2CGetBusyStatus
      60  halI2CGetFIFOSpace
      12  halI2CGetFIFOStatus
     120  halI2CInit
     156  halI2CMasterCtrl
     270  halI2CNormalRead
     334  halI2CNormalWrite
      12  halI2CRxFIFOSpace
      18  halI2CTxFIFOSpace
     132  i2c_master_wait_transaction_finish
     160  -- Other

 
 3 562 bytes in section .text
 
 3 562 bytes of CODE memory

Errors: none
Warnings: none
