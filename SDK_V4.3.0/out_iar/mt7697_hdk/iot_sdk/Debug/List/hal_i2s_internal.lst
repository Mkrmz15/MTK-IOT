###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:25
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\hal_i2s_internal.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW7417.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\hal_i2s_internal.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\hal_i2s_internal.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\hal_i2s_internal.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\hal_i2s_internal.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          /*
     36          ** $Log: hal_I2S.c $
     37          **
     38          ** 09 30 2015 pierre.chang
     39          ** 1) Purpose:
     40          ** 	Change the i2s API for phase 2
     41          ** 	2) Changed function name:
     42          ** 	N/A
     43          ** 	3) Code change description brief:
     44          ** 	Adjust the header and API
     45          ** 	4) Unit Test Result:
     46          ** 	N/A
     47          **
     48          ** 07 24 2015 pierre.chang
     49          ** Update UART, I2S, ADC.
     50          ** 02 04 2015 maker.wang
     51          ** 1. Add halI2sCfgInitialSetting, halI2sCfgSampleRate, halI2sCfgMonoStereo, halI2sCfgTdmChBitPerSample for simplify I2S intial flow
     52          ** 2. Rename I2S API
     53          **
     54          ** 12 11 2014 maker.wang
     55          ** 1. Modify I2S and vdma drvier
     56          **
     57          ** 11 07 2014 pierre.chang
     58          ** DMA change for peripherals and add I2S code.
     59          **
     60          **
     61          */
     62          
     63          
     64          /*
     65          I2S initial flow
     66          Step 1 : Config I2S setting
     67          I2sCfgInitialSetting
     68          I2sCfgSampleRate
     69          I2sCfgMonoStereo
     70          I2sCfgTdmChBitPerSample(If I2S is TDM mode)
     71          
     72          Step 2 : Set I2S config to register
     73          I2sSetGblCfg(&I2SGblCfg)
     74          I2sSetDlCfg(&I2SDLCfg)
     75          I2sSetUlCfg(&I2SULCfg)
     76          
     77          Step 3 : Enable I2S Clock, DL pipe, UL pipe
     78          I2sClkFifoEn(I2S_EN)
     79          I2sDlEn(I2S_EN)
     80          I2sUlEn(I2S_EN)
     81          
     82          I2S disable flow
     83          I2sClkFifoEn(I2S_DIS)
     84          I2sDlEn(I2S_DIS)
     85          I2sUlEn(I2S_DIS)
     86          I2sReset();
     87          */
     88          
     89          
     90          
     91          /*******************************************************************************
     92          *                         C O M P I L E R   F L A G S
     93          ********************************************************************************
     94          */
     95          
     96          
     97          /*******************************************************************************
     98          *                    E X T E R N A L   R E F E R E N C E S
     99          ********************************************************************************
    100          */
    101          #include "hal_i2s_internal.h"
    102          #ifdef HAL_I2S_MODULE_ENABLED
    103          
    104          //#include "mt7687_conf.h"
    105          //#include "nvic.h"
    106          #include "type_def.h"
    107          #include "mt7687_cm4_hw_memmap.h"
    108          #include "dma_hw.h"
    109          #include "dma_sw.h"
    110          #include "hal_i2s.h"
    111          #include "debug.h"
    112          #include "top.h"
    113          
    114          /*******************************************************************************
    115          *                              C O N S T A N T S
    116          ********************************************************************************
    117          */
    118          
    119          
    120          
    121          /*******************************************************************************
    122          *                             D A T A   T Y P E S
    123          ********************************************************************************
    124          */
    125          
    126          
    127          /*******************************************************************************
    128          *                            P U B L I C   D A T A
    129          ********************************************************************************
    130          */
    131          
    132          /*
    133          halI2STxVDMAInit
    134          u4TxBufAddr:I2S VDMA TX buffer
    135          u4TxBufLen:I2S VDMA TX buffer length
    136          u4TxCasPortAddr:I2S VDMA TX buffer cascade port address
    137          bTxCasEn: I2S_DMA_CVFF_EN, I2S_DMA_CVFF_DIS
    138          */
    139          BOOLEAN  I2sVdmaTxStart(UINT32 u4TxBufAddr, UINT32 u4TxBufLen, DMA_VFIFO_CHANNEL TxCasPortAddr, BOOLEAN bTxCasEn)
    140          {
    141              if (bTxCasEn > I2S_DMA_CVFF_EN) {
    142                  return KAL_FALSE;
    143              }
    144              DRV_WriteReg32(DMA_PGMADDR(VDMA_I2S_TX_CH), u4TxBufAddr);
    145              DRV_WriteReg32(DMA_FFSIZE(VDMA_I2S_TX_CH), u4TxBufLen);
    146          
    147              if (bTxCasEn == KAL_TRUE) {
    148                  DRV_Reg32(DMA_CVFF(VDMA_I2S_TX_CH)) = VFIFO_base | ((TxCasPortAddr - DMA_VFIFO_CH_S) << 8) | DMA_CVFF_CVFF_EN;
    149              } else {
    150                  DRV_Reg32(DMA_CVFF(VDMA_I2S_TX_CH)) &= ~(DMA_CVFF_CVFF_EN);
    151              }
    152          
    153              DMA_Vfifo_Flush(VDMA_I2S_TX_CH);
    154          
    155              return KAL_TRUE;
    156          }
    157          
    158          /*
    159          halI2SRxVDMAInit
    160          u4RxBufAddr:I2S VDMA RX buffer
    161          u4RxBufLen:I2S VDMA RX buffer length
    162          u4RxCasPortAddr:I2S VDMA RX buffer cascade port address
    163          bRxCasEn: I2S_DMA_CVFF_EN, I2S_DMA_CVFF_DIS
    164          */
    165          BOOLEAN  I2sVdmaRxStart(UINT32 u4RxBufAddr, UINT32 u4RxBufLen, DMA_VFIFO_CHANNEL RxCasPortAddr, BOOLEAN bRxCasEn)
    166          {
    167              if (bRxCasEn > I2S_DMA_CVFF_EN) {
    168                  return KAL_FALSE;
    169              }
    170              DRV_WriteReg32(DMA_PGMADDR(VDMA_I2S_RX_CH), u4RxBufAddr);
    171              DRV_WriteReg32(DMA_FFSIZE(VDMA_I2S_RX_CH), u4RxBufLen);
    172          
    173              if (bRxCasEn == KAL_TRUE) {
    174                  DRV_Reg32(DMA_CVFF(VDMA_I2S_RX_CH)) = VFIFO_base | ((RxCasPortAddr - DMA_VFIFO_CH_S) << 8) | DMA_CVFF_CVFF_EN;
    175              } else {
    176                  DRV_Reg32(DMA_CVFF(VDMA_I2S_RX_CH)) &= ~(DMA_CVFF_CVFF_EN);
    177              }
    178          
    179              DMA_Vfifo_Flush(VDMA_I2S_RX_CH);
    180          
    181              return KAL_TRUE;
    182          }
    183          
    184          BOOLEAN  I2sSetVdmaTxIntrEn(BOOLEAN bI2sVdmaTxIntrEn)
    185          {
    186              UINT32 u4DmaCon;
    187          
    188              u4DmaCon = DRV_Reg32(DMA_CON(VDMA_I2S_TX_CH));
    189          
    190              if (bI2sVdmaTxIntrEn == I2S_DMA_INTR_EN) {
    191                  u4DmaCon |= DMA_CON_ITEN;
    192              } else if (bI2sVdmaTxIntrEn == I2S_DMA_INTR_DIS) {
    193                  u4DmaCon &= ~(DMA_CON_ITEN);
    194              } else {
    195                  printf("Error parameter!!!\n");
    196              }
    197          
    198              DRV_WriteReg32(DMA_CON(VDMA_I2S_TX_CH), u4DmaCon);
    199          
    200              return KAL_TRUE;
    201          }
    202          
    203          BOOLEAN  I2sSetVdmaRxIntrEn(BOOLEAN bI2sVdmaRxIntrEn)
    204          {
    205              UINT32 u4DmaCon;
    206          
    207              u4DmaCon = DRV_Reg32(DMA_CON(VDMA_I2S_RX_CH));
    208          
    209              if (bI2sVdmaRxIntrEn == I2S_DMA_INTR_EN) {
    210                  u4DmaCon |= DMA_CON_ITEN;
    211              } else if (bI2sVdmaRxIntrEn == I2S_DMA_INTR_DIS) {
    212                  u4DmaCon &= ~(DMA_CON_ITEN);
    213              } else {
    214                  printf("Error parameter!!!\n");
    215              }
    216          
    217              DRV_WriteReg32(DMA_CON(VDMA_I2S_RX_CH), u4DmaCon);
    218          
    219              return KAL_TRUE;
    220          }
    221          
    222          BOOLEAN  I2sVdmaTxStop(void)
    223          {
    224              DMA_Stop((UINT8)VDMA_I2S_TX_CH);
    225          
    226              return KAL_TRUE;
    227          }
    228          
    229          BOOLEAN  I2sVdmaRxStop(void)
    230          {
    231              DMA_Stop((UINT8)VDMA_I2S_RX_CH);
    232          
    233              return KAL_TRUE;
    234          }
    235          
    236          BOOLEAN  I2sSetVdmaTxThreshold(UINT32 u4TxThreshold)
    237          {
    238              DRV_Reg32(DMA_COUNT(VDMA_I2S_TX_CH)) = u4TxThreshold;
    239          
    240              return KAL_TRUE;
    241          }
    242          
    243          BOOLEAN  I2sSetVdmaRxThreshold(UINT32 u4RxThreshold)
    244          {
    245              DRV_Reg32(DMA_COUNT(VDMA_I2S_RX_CH)) = u4RxThreshold;
    246          
    247              return KAL_TRUE;
    248          }
    249          
    250          BOOLEAN  I2sWriteVdmaTxFifo(UINT32 u4Txdata)
    251          {
    252              DRV_Reg32(I2S_DMA_TX_FIFO) = u4Txdata;
    253          
    254              return KAL_TRUE;
    255          }
    256          
    257          BOOLEAN  I2sReadVdmaRxFifo(PUINT32 pu4Rxdata)
    258          {
    259              *pu4Rxdata = DRV_Reg32(I2S_DMA_RX_FIFO);
    260          
    261              return KAL_TRUE;
    262          }
    263          
    264          UINT16 I2sGetVdmaTxFifoCnt()
    265          {
    266              return DRV_Reg16(I2S_DMA_TX_FIFO_CNT);
    267          }
    268          
    269          UINT16 I2sGetVdmaRxFifoCnt()
    270          {
    271              return DRV_Reg16(I2S_DMA_RX_FIFO_CNT);
    272          }
    273          
    274          /*
    275          Reference the comment of I2sCfgInitialSetting
    276          */
    277          BOOLEAN  I2sSetGblCfg(P_I2S_GBL_CFG pI2sGblCfg)
    278          {
    279              UINT32 u4RegCfg = 0;
    280          
    281              ASSERT(pI2sGblCfg);
    282          
    283              if (pI2sGblCfg->ucI2SExtCodecSel == I2S_EXT_EN) {
    284                  u4RegCfg |= BIT(I2S_EXT_SHFT);
    285              }
    286          
    287              if (pI2sGblCfg->ucI2SExtSwapLR == I2S_EXT_LRSW_EN) {
    288                  u4RegCfg |= BIT(I2S_EXT_LRSW_SHFT);
    289              }
    290          
    291              if (pI2sGblCfg->ucI2SDLSwapLR == I2S_DL_LRSW_EN) {
    292                  u4RegCfg |= BIT(I2S_DL_LRSW_SHFT);
    293              }
    294          
    295              if (pI2sGblCfg->ucI2SDLMonoStereoSel == I2S_DL_MONO) {
    296                  u4RegCfg |= BIT(I2S_DL_MONO_SHFT);
    297              }
    298          
    299              if (pI2sGblCfg->bI2SDLMonoDupEn == I2S_DL_MONO_DUP_EN) {
    300                  u4RegCfg |= BIT(I2S_DL_MONO_DUP_SHFT);
    301              }
    302          
    303              if (pI2sGblCfg->bI2S_CODEC_26M_EN == I2S_CODEC_26M_EN) {
    304                  u4RegCfg |= BIT(I2S_CODEC_26M_SHFT);
    305              }
    306          
    307              if (pI2sGblCfg->bI2S_26M_SEL == I2S_26M_SEL_XPLL) {
    308                  u4RegCfg |= BIT(I2S_26M_SEL_SHFT);
    309              }
    310          
    311              if (pI2sGblCfg->bI2SClkInvEn == I2S_CK_INV_EN) {
    312                  u4RegCfg |= BIT(I2S_CK_INV_SHFT);
    313              }
    314          
    315              if (pI2sGblCfg->bI2SNegCapEn == I2S_NEG_CAP_EN) {
    316                  u4RegCfg |= BIT(I2S_NEG_CAP_SHFT);
    317              }
    318          
    319              //u4RegCfg |= (pI2sGblCfg->u4I2SInClkSel << I2S_IN_CLK_SEL_SHFT) & I2S_IN_CLK_SEL_MASK;
    320              //u4RegCfg |= (pI2sGblCfg->u4I2SOutClkSel << I2S_OUT_CLK_SEL_SHFT) & I2S_OUT_CLK_SEL_MASK;
    321          
    322              if (pI2sGblCfg->bI2SLoopBackEn  == I2S_LOOPBACK_EN) {
    323          
    324                  u4RegCfg |= BIT(I2S_LOOPBACK_SHFT);
    325          
    326              }
    327          
    328              //set CLK_SEL_IN
    329          
    330              // clear bit 25:24
    331              u4RegCfg &= ~0x03000000;
    332          
    333              switch (pI2sGblCfg->u4I2SInClkSel) {
    334                  case I2S_CLK_SEL_13M://0x0
    335                      //u4RegCfg &= ~0x03000000;
    336                      break;
    337                  case I2S_CLK_SEL_26M:
    338                      u4RegCfg |= 0x01000000;
    339                      break;
    340                  case I2S_CLK_SEL_XPLL_16M:
    341                      u4RegCfg |= 0x02000000;
    342                      break;
    343                  case I2S_CLK_SEL_EXT_BCLK:
    344                      u4RegCfg |= 0x03000000;
    345                      break;
    346              }
    347          
    348              //set CLK_SEL_OUT
    349          
    350              // clear bit 27:26
    351              u4RegCfg &= ~0x0C000000;
    352          
    353              switch (pI2sGblCfg->u4I2SOutClkSel) {
    354                  case I2S_CLK_SEL_13M:
    355                      //u4RegCfg &= ~0x0C000000;
    356                      break;
    357                  case I2S_CLK_SEL_26M:
    358                      u4RegCfg |= 0x04000000;
    359                      break;
    360                  case I2S_CLK_SEL_XPLL_16M:
    361                      u4RegCfg |= 0x08000000;
    362                      break;
    363                  case I2S_CLK_SEL_EXT_BCLK:
    364                      u4RegCfg |= 0x0C000000;
    365                      break;
    366              }
    367          
    368              //printf("I2sSetGblCfg  u4RegCfg=%08x\n",u4RegCfg);
    369          
    370              DRV_Reg32(I2S_GLB_CONTROL_ADDR) = u4RegCfg;
    371          
    372              return KAL_TRUE;
    373          }
    374          
    375          /*
    376          Reference the comment of I2sCfgInitialSetting
    377          */
    378          BOOLEAN  I2sSetDlCfg(P_I2S_DL_CFG pI2sDlCfg)
    379          {
    380              UINT32 u4RegCfg = 0;
    381          
    382              ASSERT(pI2sDlCfg);
    383          
    384              if (pI2sDlCfg->ucI2SSRC == I2S_DL_SRC_SLAVE) {
    385                  u4RegCfg |= BIT(I2S_DL_SRC_SHFT);
    386              }
    387          
    388              if (pI2sDlCfg->ucI2SFormat == I2S_DL_FMT_I2S) {
    389                  u4RegCfg |= BIT(I2S_DL_FMT_SHFT);
    390              }
    391          
    392              if (pI2sDlCfg->ucI2SWordSelInv == I2S_DL_WSINV_EN) {
    393                  u4RegCfg |= BIT(I2S_DL_WSINV_SHFT);
    394              }
    395          
    396              //u4RegCfg |= (pI2sDlCfg->u4I2SSampleRate << I2S_DL_SR_SHFT) & I2S_DL_SR_MASK;
    397          
    398              //u4RegCfg |= (pI2sDlCfg->u4I2SBitPerSample << I2S_DL_BIT_PER_S_SHFT) & I2S_DL_BIT_PER_S_MASK;
    399          
    400              u4RegCfg |= (pI2sDlCfg->u4I2SMsbOffset << I2S_DL_MSB_OFFSET_SHFT) & I2S_DL_MSB_OFFSET_MASK;
    401          
    402              //u4RegCfg |= (pI2sDlCfg->u4I2SChPerSample << I2S_DL_CH_PER_S_SHFT) & I2S_DL_CH_PER_S_MASK;
    403          
    404              //set TX sample rate
    405              // clear bit 11:8
    406              u4RegCfg &= ~0x00000F00;
    407          
    408              switch (pI2sDlCfg->u4I2SSampleRate) {
    409                  case I2S_SAMPLE_RATE_8K:
    410                      break;
    411                  case I2S_SAMPLE_RATE_12K:
    412                      u4RegCfg |= 0x00000200;
    413                      break;
    414                  case I2S_SAMPLE_RATE_16K:
    415                      u4RegCfg |= 0x00000400;
    416                      break;
    417                  case I2S_SAMPLE_RATE_24K:
    418                      u4RegCfg |= 0x00000600;
    419                      break;
    420                  case I2S_SAMPLE_RATE_32K:
    421                      u4RegCfg |= 0x00000800;
    422                      break;
    423                  case I2S_SAMPLE_RATE_48K:
    424                      u4RegCfg |= 0x00000A00;
    425                      break;
    426              }
    427          
    428              //set TX bit per sample
    429              // clear bit 14:13
    430              u4RegCfg &= ~0x00006000;
    431          
    432              switch (pI2sDlCfg->u4I2SBitPerSample) {
    433                  case I2S_BIT_PER_S_32BTIS:
    434                      break;
    435                  case I2S_BIT_PER_S_64BTIS:
    436                      u4RegCfg |= 0x00002000;
    437                      break;
    438                  case I2S_BIT_PER_S_128BTIS:
    439                      u4RegCfg |= 0x00004000;
    440                      break;
    441              }
    442          
    443              //set TX channel per sample
    444              // clear bit 30:29
    445              u4RegCfg &= ~0x60000000;
    446          
    447              switch (pI2sDlCfg->u4I2SChPerSample) {
    448                  case I2S_CH_PER_S_2_CH:
    449                      break;
    450                  case I2S_CH_PER_S_4_CH:
    451                      u4RegCfg |= 0x20000000;
    452                      break;
    453              }
    454          
    455              //printf("I2sSetDlCfg  u4RegCfg=%08x\n",u4RegCfg);
    456          
    457              DRV_Reg32(I2S_DL_CONTROL_ADDR) = u4RegCfg | BIT(I2S_DL_WS_RESYNC_SHFT);
    458          
    459              return KAL_TRUE;
    460          }
    461          
    462          /*
    463          Reference the comment of I2sCfgInitialSetting
    464          */
    465          BOOLEAN  I2sSetUlCfg(P_I2S_UL_CFG pI2sUlCfg)
    466          {
    467              UINT32 u4RegCfg = 0;
    468          
    469              ASSERT(pI2sUlCfg);
    470          
    471              if (pI2sUlCfg->ucI2SSRC == I2S_UL_SRC_SLAVE) {
    472                  u4RegCfg |= BIT(I2S_UL_SRC_SHFT);
    473              }
    474          
    475              if (pI2sUlCfg->ucI2SFormat == I2S_UL_FMT_I2S) {
    476                  u4RegCfg |= BIT(I2S_UL_FMT_SHFT);
    477              }
    478          
    479              if (pI2sUlCfg->ucI2SWordSelInv == I2S_UL_WSINV_EN) {
    480                  u4RegCfg |= BIT(I2S_UL_WSINV_SHFT);
    481              }
    482          
    483              //u4RegCfg |= (pI2sUlCfg->u4I2SSampleRate << I2S_UL_SR_SHFT) & I2S_UL_SR_MASK;
    484          
    485              //u4RegCfg |= (pI2sUlCfg->u4I2SBitPerSample << I2S_UL_BIT_PER_S_SHFT) & I2S_UL_BIT_PER_S_MASK;
    486          
    487              if (pI2sUlCfg->bI2SDownRateEn == I2S_UL_DOWN_RATE_EN) {
    488                  u4RegCfg |= BIT(I2S_UL_DOWN_RATE_SHFT);
    489              }
    490          
    491              if (pI2sUlCfg->u4I2SLRSwap == I2S_UL_LR_SWAP_EN) {
    492                  u4RegCfg |= BIT(I2S_UL_LR_SWAP_SHFT);
    493              }
    494          
    495              u4RegCfg |= (pI2sUlCfg->u4I2SMsbOffset << I2S_UL_MSB_OFFSET_SHFT) & I2S_UL_MSB_OFFSET_MASK;
    496          
    497              u4RegCfg |= (pI2sUlCfg->u4I2SUpdateWord << I2S_UL_UPDATE_WORD_SHFT) & I2S_UL_UPDATE_WORD_MASK;
    498          
    499              //u4RegCfg |= (pI2sUlCfg->u4I2SChPerSample << I2S_UL_CH_PER_S_SHFT) & I2S_UL_CH_PER_S_MASK;
    500          
    501              //set RX sample rate
    502              // clear bit 11:8
    503              u4RegCfg &= ~0x00000F00;
    504          
    505              switch (pI2sUlCfg->u4I2SSampleRate) {
    506                  case I2S_SAMPLE_RATE_8K:
    507                      break;
    508                  case I2S_SAMPLE_RATE_12K:
    509                      u4RegCfg |= 0x00000200;
    510                      break;
    511                  case I2S_SAMPLE_RATE_16K:
    512                      u4RegCfg |= 0x00000400;
    513                      break;
    514                  case I2S_SAMPLE_RATE_24K:
    515                      u4RegCfg |= 0x00000600;
    516                      break;
    517                  case I2S_SAMPLE_RATE_32K:
    518                      u4RegCfg |= 0x00000800;
    519                      break;
    520                  case I2S_SAMPLE_RATE_48K:
    521                      u4RegCfg |= 0x00000A00;
    522                      break;
    523              }
    524          
    525              //set RX bit per sample
    526              // clear bit 14:13
    527              u4RegCfg &= ~0x00006000;
    528          
    529              switch (pI2sUlCfg->u4I2SBitPerSample) {
    530                  case I2S_BIT_PER_S_32BTIS:
    531                      break;
    532                  case I2S_BIT_PER_S_64BTIS:
    533                      u4RegCfg |= 0x00002000;
    534                      break;
    535                  case I2S_BIT_PER_S_128BTIS:
    536                      u4RegCfg |= 0x00004000;
    537                      break;
    538              }
    539          
    540              //set RX channel per sample
    541              // clear bit 30:29
    542              u4RegCfg &= ~0x60000000;
    543          
    544              switch (pI2sUlCfg->u4I2SChPerSample) {
    545                  case I2S_CH_PER_S_2_CH:
    546                      break;
    547                  case I2S_CH_PER_S_4_CH:
    548                      u4RegCfg |= 0x20000000;
    549                      break;
    550              }
    551          
    552              //printf("I2sSetUlCfg  u4RegCfg=%08x\n",u4RegCfg);
    553          
    554              DRV_Reg32(I2S_UL_CONTROL_ADDR) = u4RegCfg | BIT(I2S_UL_WS_RESYNC_SHFT);
    555          
    556              //dump register
    557              /*
    558              unsigned int temp;
    559              temp = DRV_Reg32(I2S_GLB_CONTROL_ADDR);
    560              printf("I2S_GLB_CONTROL_ADDR=%08x\n",temp);
    561          
    562              temp = DRV_Reg32(I2S_DL_CONTROL_ADDR);
    563              printf("I2S_DL_CONTROL_ADDR=%08x\n",temp);
    564          
    565              temp = DRV_Reg32(I2S_UL_CONTROL_ADDR);
    566              printf("I2S_UL_CONTROL_ADDR=%08x\n",temp);
    567              */
    568              return KAL_TRUE;
    569          }
    570          
    571          /*
    572          Reference the comment of I2sCfgInitialSetting
    573          Parameter
    574          bI2sEn:I2S_EN, I2S_DIS
    575          */
    576          BOOLEAN  I2sClkFifoEn(BOOLEAN bI2sEn)
    577          {
    578              if (bI2sEn == I2S_EN) {
    579                  DRV_Reg32(I2S_GLB_CONTROL_ADDR) |= BIT(I2S_EN_SHFT);
    580          
    581              } else {
    582                  DRV_Reg32(I2S_GLB_CONTROL_ADDR) &= ~(I2S_EN_MASK);
    583                  DRV_Reg32(I2S_GLB_CONTROL_ADDR) &= ~(I2S_ULFIFO_EN_MASK);
    584                  DRV_Reg32(I2S_GLB_CONTROL_ADDR) &= ~(I2S_DLFIFO_EN_MASK);
    585                  DRV_Reg32(I2S_GLB_CONTROL_ADDR) &= ~(I2S_ENGEN_EN_MASK);
    586              }
    587          
    588              return KAL_TRUE;
    589          }
    590          
    591          /*
    592          Reference the comment of I2sCfgInitialSetting
    593          Parameter
    594          bI2sEn:I2S_EN, I2S_DIS
    595          */
    596          BOOLEAN  I2sDlEn(BOOLEAN bI2sEn)
    597          {
    598              if (bI2sEn == I2S_EN) {
    599          
    600                  DRV_Reg32(I2S_DL_CONTROL_ADDR) |= BIT(I2S_DL_EN_SHFT);
    601              } else {
    602          
    603                  DRV_Reg32(I2S_DL_CONTROL_ADDR) &= ~(I2S_DL_EN_MASK);
    604              }
    605          
    606              return KAL_TRUE;
    607          }
    608          
    609          /*
    610          Reference the comment of I2sCfgInitialSetting
    611          Parameter
    612          bI2sEn:I2S_EN, I2S_DIS
    613          */
    614          BOOLEAN  I2sUlEn(BOOLEAN bI2sEn)
    615          {
    616              if (bI2sEn == I2S_EN) {
    617          
    618                  DRV_Reg32(I2S_UL_CONTROL_ADDR) |= BIT(I2S_UL_EN_SHFT);
    619              } else {
    620          
    621                  DRV_Reg32(I2S_UL_CONTROL_ADDR) &= ~(I2S_UL_EN_MASK);
    622              }
    623          
    624              return KAL_TRUE;
    625          }
    626          
    627          /*
    628          Reference the comment of I2sCfgInitialSetting
    629          */
    630          BOOLEAN  I2sReset()
    631          {
    632              DRV_Reg32(I2S_SW_RESET_ADDR) |= BIT(I2S_SW_RST_EN_SHFT);
    633              DRV_Reg32(I2S_SW_RESET_ADDR) &= ~(I2S_SW_RST_EN_MASK);
    634          
    635              return KAL_TRUE;
    636          }
    637          
    638          
    639          BOOLEAN I2sCfgInitialSetting(ENUM_I2S_INITIAL_TYPE_T I2sInitialType, P_I2S_GBL_CFG pI2sGblCfg, P_I2S_DL_CFG pI2sDlCfg, P_I2S_UL_CFG pI2sUlCfg)
    640          {
    641              ASSERT(pI2sGblCfg);
    642              ASSERT(pI2sDlCfg);
    643              ASSERT(pI2sUlCfg);
    644          
    645              switch (I2sInitialType) {
    646                  case I2S_INTERNAL_LOOPBACK_MODE://just for test case
    647                      pI2sGblCfg->bI2SLoopBackEn = I2S_LOOPBACK_EN;
    648                      pI2sGblCfg->u4I2SInClkSel = I2S_CLK_SEL_13M;
    649                      pI2sGblCfg->u4I2SOutClkSel = I2S_CLK_SEL_13M;
    650                      pI2sGblCfg->bI2SClkInvEn = I2S_CK_INV_DIS;
    651                      pI2sGblCfg->bI2SNegCapEn = I2S_NEG_CAP_DIS;
    652                      pI2sGblCfg->bI2S_CODEC_26M_EN = I2S_CODEC_26M_DIS;
    653                      pI2sGblCfg->bI2S_26M_SEL = I2S_26M_SEL_XTAL;
    654                      pI2sGblCfg->ucI2SDLSwapLR = I2S_DL_LRSW_DIS;
    655                      pI2sGblCfg->ucI2SExtSwapLR = I2S_EXT_LRSW_DIS;
    656                      pI2sGblCfg->ucI2SExtCodecSel = I2S_EXT_DIS;
    657                      pI2sDlCfg->u4I2SChPerSample = I2S_CH_PER_S_2_CH;
    658                      pI2sDlCfg->u4I2SMsbOffset = 0;
    659                      pI2sDlCfg->u4I2SBitPerSample = I2S_BIT_PER_S_32BTIS;
    660                      pI2sDlCfg->ucI2SWordSelInv = I2S_DL_WSINV_DIS;
    661                      pI2sDlCfg->ucI2SFormat = I2S_DL_FMT_I2S;
    662                      pI2sDlCfg->ucI2SSRC = I2S_DL_SRC_MASTER;
    663                      pI2sUlCfg->u4I2SLRSwap = I2S_UL_LR_SWAP_DIS;
    664                      pI2sUlCfg->u4I2SChPerSample = I2S_CH_PER_S_2_CH;
    665                      pI2sUlCfg->u4I2SUpdateWord = 8;
    666                      pI2sUlCfg->u4I2SMsbOffset = 0;
    667                      pI2sUlCfg->u4I2SBitPerSample = I2S_BIT_PER_S_32BTIS;
    668                      pI2sUlCfg->ucI2SWordSelInv = I2S_UL_WSINV_DIS;
    669                      pI2sUlCfg->ucI2SFormat = I2S_UL_FMT_I2S;
    670                      pI2sUlCfg->ucI2SSRC = I2S_UL_SRC_MASTER;
    671                      break;
    672                  case I2S_EXTERNAL_MODE://external codec, i2s slave mode
    673                      pI2sGblCfg->bI2SLoopBackEn = I2S_LOOPBACK_DIS;
    674                      pI2sGblCfg->u4I2SInClkSel = I2S_CLK_SEL_EXT_BCLK;
    675                      pI2sGblCfg->u4I2SOutClkSel = I2S_CLK_SEL_EXT_BCLK;
    676                      pI2sGblCfg->bI2SClkInvEn = I2S_CK_INV_EN;
    677                      pI2sGblCfg->bI2SNegCapEn = I2S_NEG_CAP_EN;
    678                      pI2sGblCfg->bI2S_CODEC_26M_EN = I2S_CODEC_26M_DIS;
    679                      pI2sGblCfg->bI2S_26M_SEL = I2S_26M_SEL_XTAL;
    680                      pI2sGblCfg->ucI2SDLSwapLR = I2S_DL_LRSW_DIS;
    681                      pI2sGblCfg->ucI2SExtSwapLR = I2S_EXT_LRSW_DIS;
    682                      pI2sGblCfg->ucI2SExtCodecSel = I2S_EXT_EN;
    683                      pI2sDlCfg->u4I2SChPerSample = I2S_CH_PER_S_2_CH;
    684                      pI2sDlCfg->u4I2SMsbOffset = 0;
    685                      pI2sDlCfg->u4I2SBitPerSample = I2S_BIT_PER_S_32BTIS;
    686                      pI2sDlCfg->ucI2SWordSelInv = I2S_DL_WSINV_DIS;
    687                      pI2sDlCfg->ucI2SFormat = I2S_DL_FMT_I2S;
    688                      pI2sDlCfg->ucI2SSRC = I2S_DL_SRC_SLAVE;
    689                      pI2sUlCfg->u4I2SLRSwap = I2S_UL_LR_SWAP_DIS;
    690                      pI2sUlCfg->u4I2SChPerSample = I2S_CH_PER_S_2_CH;
    691                      pI2sUlCfg->u4I2SUpdateWord = 8;
    692                      pI2sUlCfg->u4I2SMsbOffset = 0;
    693                      pI2sUlCfg->u4I2SBitPerSample = I2S_BIT_PER_S_32BTIS;
    694                      pI2sUlCfg->ucI2SWordSelInv = I2S_UL_WSINV_DIS;
    695                      pI2sUlCfg->ucI2SFormat = I2S_UL_FMT_I2S;
    696                      pI2sUlCfg->ucI2SSRC = I2S_DL_SRC_SLAVE;
    697                      break;
    698                  default:
    699                      return KAL_FALSE;
    700              }
    701          
    702              return KAL_TRUE;
    703          }
    704          
    705          
    706          // =======================================================================================
    707          // xpll setting
    708          
    709          #define TOP_AON_BASE  0x81021000
    710          #define RG_PMU_14                   (TOP_AON_BASE + 0x0438)
    711          
    712          //RG_PMU_14
    713          #define RG_ALDO_EN    0x80000000
    714          #define RG_ALDO_VSEL_MASK    0x70000000
    715          #define RG_ALDO_VSEL_2_POINT_65    7
    716          #define RG_ALDO_VSEL_2_POINT_6    6
    717          #define RG_ALDO_VSEL_2_POINT_55    5
    718          #define RG_ALDO_VSEL_2_POINT_5    4
    719          #define RG_ALDO_VSEL_2_POINT_45    3
    720          #define RG_ALDO_VSEL_2_POINT_4    2
    721          #define RG_ALDO_VSEL_2_POINT_35    1
    722          #define RG_ALDO_VSEL_2_POINT_3    0
    723          #define RG_ALDO_VSEL(value)    ((((UINT32) value) << 28) & RG_ALDO_VSEL_MASK)
    724          #define RG_ALDO_VCALL_MASK    0x07000000
    725          #define RG_ALDO_VSEL_POSITIVE_30_MINI_V    7
    726          #define RG_ALDO_VSEL_POSITIVE_20_MINI_V    6
    727          #define RG_ALDO_VSEL_POSITIVE_10_MINI_V    5
    728          #define RG_ALDO_VSEL_POSITIVE_0_MINI_V    4
    729          #define RG_ALDO_VSEL_NAGATIVE_10_MINI_V    3
    730          #define RG_ALDO_VSEL_NAGATIVE_20_MINI_V    2
    731          #define RG_ALDO_VSEL_NAGATIVE_30_MINI_V    1
    732          #define RG_ALDO_VSEL_NAGATIVE_40_MINI_V    0
    733          #define RG_ALDO_VCAL(value)    ((((UINT32) value) << 24) & RG_ALDO_VCALL_MASK)
    734          #define RG_ALDO_REMOTE_SEL    0x00800000
    735          
    736          #define AUD_ANA_BASE  0x830B2000
    737          
    738          //Analog reg
    739          #define AUDDEC_CON0                 (AUD_ANA_BASE + 0x0500)
    740          #define AUDDEC_CON1                 (AUD_ANA_BASE + 0x0504)
    741          #define AUDDEC_CON2                 (AUD_ANA_BASE + 0x0508)
    742          #define AUDDEC_CON3                 (AUD_ANA_BASE + 0x050C)
    743          #define AUDDEC_CON4                 (AUD_ANA_BASE + 0x0510)
    744          #define AUDDEC_CON5                 (AUD_ANA_BASE + 0x0514)
    745          #define AUDDEC_CON6                 (AUD_ANA_BASE + 0x0518)
    746          #define AUDDEC_CON7                 (AUD_ANA_BASE + 0x051C)
    747          #define AUDDEC_CON8                 (AUD_ANA_BASE + 0x0520)
    748          #define AUDDEC_CON9                 (AUD_ANA_BASE + 0x0524)
    749          #define AUDDEC_CON10                (AUD_ANA_BASE + 0x0528)
    750          #define AUDDEC_CON11                (AUD_ANA_BASE + 0x052C)
    751          
    752          //AUD_DEC_CON11
    753          #define RG_BGR_RSV_VA25_MASK   (0xFFUL << 0)
    754          #define RG_BGR_RSV_VA25(value)    ((((UINT32) value) << 0) & RG_BGR_RSV_VA25_MASK)
    755          
    756          
    757          #define XPLL_CM4_FREQ_MHZ    26
    758          #define XPLL_INSTRACTION_PRE_WHILE    5
    759          #define XPLL_ONE_MICRO_SEC_WHILE_COUNT    (XPLL_CM4_FREQ_MHZ/XPLL_INSTRACTION_PRE_WHILE)
    760          
    761          
    762          XPLL_INFO XpllInfo;
    763          
    764          void xpllMicroDelay(UINT32 u4DelayUS)
    765          {
    766              volatile UINT32 u4DealyCount;
    767          
    768              u4DealyCount = u4DelayUS * XPLL_ONE_MICRO_SEC_WHILE_COUNT;
    769          
    770              while (u4DealyCount--);
    771          }
    772          
    773          void xpllOpen()
    774          {
    775              UINT32 u4Reg;
    776              uint32_t xtal_freq;
    777          
    778              XpllInfo.u4NcpoValue = XPLL_NCPO_VALUE;//416Mhz
    779          
    780              //HAL_REG_32(0x830b2000) = 00000200;//SH setting
    781          
    782              //Open band gap for XPLL use
    783              //HAL_REG_32(0x83008040) |= 0x10;
    784              //HAL_REG_32(0x50305808) &= ~(0x20000);
    785              //HAL_REG_32(0x50305800) |= (0x8001);
    786              //HAL_REG_32(0x81021028) &= ~(0x600000);
    787              HAL_REG_32(0x81021028) |= 0x600000;
    788          
    789              xtal_freq = top_xtal_freq_get();
    790              if (xtal_freq == 26000000) {
    791                  //Set XPLL to default value start
    792                  HAL_REG_32(XPLL_CTL0) = RG_XPLL_FBSEL_DIV_2 | RG_XPLL_CKCTRL_MODE_3 | RG_XPLL_POSDIV_2 |
    793                                          RG_XPLL_PREDIV_1 | RG_XPLL_FBDIV(0xF) | RG_XPLL_PWD;//0x0000741F
    794                  HAL_REG_32(XPLL_CTL1) = RG_XPLL_BIR(0xD) | RG_XPLL_BR_20_ohm | RG_XPLL_BP(0x6) |
    795                                          RG_XPLL_FPEN_4_PH;//0x0000D861
    796                  HAL_REG_32(XPLL_CTL2) = RG_XPLL_LOAD_RSTB | RG_XPLL_AUTOK_LOAD | RG_XPLL_AUTOK_VCO |
    797                                          RG_XPLL_BIC(0x1)  | RG_XPLL_VODEN | RG_XPLL_BC_1_POINT_5_PF;//0x00007302
    798                  HAL_REG_32(XPLL_CTL3) = RG_XPLL_PCW_NCPO(XPLL_NCPO_VALUE); //0x1E000000
    799                  HAL_REG_32(XPLL_CTL8) = RG_XPLL_BIAS_RST | RG_XPLL_BIAS_PWD | RG_XPLL_RESERVE(0xF0); //0x0003F000
    800                  //Set XPLL to default value end
    801          
    802                  xpllMicroDelay(10);//Delay 10us
    803          
    804                  HAL_REG_32(XPLL_CTL8) &= ~(RG_XPLL_BIAS_PWD);
    805                  HAL_REG_32(XPLL_CTL0) &= ~(RG_XPLL_PWD);
    806                  HAL_REG_32(XPLL_CTL8) |= RG_XPLL_DDS_PWDB;
    807          
    808                  while ((HAL_REG_32(XPLL_CTL4) & AD_RGS_PLL_VCOCAL_CPLT_MASK) != AD_RGS_PLL_VCOCAL_CPLT);
    809          
    810                  xpllMicroDelay(20);//Delay 20us
    811                  HAL_REG_32(XPLL_CTL8) |= RG_XPLL_DDS_RSTB;
    812                  HAL_REG_32(XPLL_CTL3) |=  RG_XPLL_PCW_NCPO_CHG_HIGH;
    813                  HAL_REG_32(XPLL_CTL8) |= RG_XPLL_FIFO_START_MAN;//Change RG_XPLL_NCPO_EN to RG_XPLL_FIFO_START_MAN
    814                  HAL_REG_32(XPLL_CTL2) |= RG_XPLL_DDSEN;
    815                  HAL_REG_32(XPLL_CTL8) &= ~(RG_XPLL_BIAS_RST);
    816              } else if (xtal_freq == 40000000) {
    817                  HAL_REG_32(XPLL_CTL0) = 0x7413;
    818                  HAL_REG_32(XPLL_CTL1) = 0x38C5;
    819                  HAL_REG_32(XPLL_CTL2) = 0x7303;
    820                  HAL_REG_32(XPLL_CTL3) = 0x12CC0000;
    821                  HAL_REG_32(XPLL_CTL8) = 0x3FC00;
    822          
    823                  xpllMicroDelay(10);//at least delay 1us
    824          
    825                  HAL_REG_32(XPLL_CTL8) = 0x2FC00;
    826          
    827                  xpllMicroDelay(10);//at least delay 1us
    828          
    829                  HAL_REG_32(XPLL_CTL0) = 0x7412;
    830                  HAL_REG_32(XPLL_CTL8) = 0x2FC08;
    831          
    832                  xpllMicroDelay(300);//at least delay 200us
    833          
    834                  HAL_REG_32(XPLL_CTL8) = 0x2FC18;
    835          
    836                  xpllMicroDelay(10);//at least delay 1us
    837          
    838                  HAL_REG_32(XPLL_CTL3) = 0x12CC0001;
    839          
    840                  xpllMicroDelay(10);//at least delay 1us
    841          
    842                  HAL_REG_32(XPLL_CTL8) = 0x2FC38;
    843          
    844                  xpllMicroDelay(10);//at least delay 1us
    845          
    846                  HAL_REG_32(XPLL_CTL2) = 0xF303;
    847                  HAL_REG_32(XPLL_CTL8) = 0x0FC38;
    848                  HAL_REG_32(XPLL_CTL8) = 0x0FCB8;
    849          
    850                  xpllMicroDelay(200);//at least delay 20us
    851          
    852                  //halI2sClkFifoEn(1);
    853              }
    854          
    855              xpllMicroDelay(20);//Delay 20us
    856              u4Reg = HAL_REG_32(RG_PMU_14);
    857              u4Reg &= ~(RG_ALDO_EN | RG_ALDO_VSEL_MASK | RG_ALDO_VCALL_MASK);
    858              u4Reg |= RG_ALDO_EN | RG_ALDO_VSEL(RG_ALDO_VSEL_2_POINT_5) | RG_ALDO_VCAL(RG_ALDO_VSEL_POSITIVE_0_MINI_V);
    859              HAL_REG_32(RG_PMU_14) = u4Reg;
    860          
    861              xpllMicroDelay(300);//Delay 300us
    862              HAL_REG_32(AUDDEC_CON9) = 0;
    863              HAL_REG_32(AUDDEC_CON10) = 0;
    864              HAL_REG_32(AUDDEC_CON11) = 0;
    865          
    866              xpllMicroDelay(30000);//Delay 30ms
    867              /*
    868              printf("XPLL_CTL0=%x\r\n",HAL_REG_32(XPLL_CTL0));
    869              printf("XPLL_CTL0=%x\r\n",HAL_REG_32(XPLL_CTL1));
    870              printf("XPLL_CTL0=%x\r\n",HAL_REG_32(XPLL_CTL2));
    871              printf("XPLL_CTL0=%x\r\n",HAL_REG_32(XPLL_CTL3));
    872              printf("XPLL_CTL0=%x\r\n",HAL_REG_32(XPLL_CTL4));
    873              printf("XPLL_CTL0=%x\r\n",HAL_REG_32(XPLL_CTL5));
    874              printf("XPLL_CTL0=%x\r\n",HAL_REG_32(XPLL_CTL6));
    875              printf("XPLL_CTL0=%x\r\n",HAL_REG_32(XPLL_CTL7));
    876              printf("XPLL_CTL0=%x\r\n",HAL_REG_32(XPLL_CTL8));
    877              printf("XPLL_CTL0=%x\r\n",HAL_REG_32(XPLL_CTL0));
    878              printf("RG_PMU_14=%x\r\n",HAL_REG_32(RG_PMU_14));
    879              */
    880          }
    881          
    882          void xpllClose()
    883          {
    884              //XPLL power down
    885              HAL_REG_32(AUDDEC_CON11) = RG_BGR_RSV_VA25(1);//0x00000001;
    886              HAL_REG_32(RG_PMU_14) = RG_ALDO_EN | RG_ALDO_VSEL(RG_ALDO_VSEL_2_POINT_5) |
    887                                      RG_ALDO_VCAL(RG_ALDO_VSEL_POSITIVE_0_MINI_V);//0xC4000000;
    888              HAL_REG_32(XPLL_CTL8) = RG_XPLL_RESERVE(0xF0) | RG_XPLL_FIFO_START_MAN | RG_XPLL_DDS_RSTB_MASK;//0x0000F030;
    889              HAL_REG_32(XPLL_CTL0) = RG_XPLL_FBSEL_DIV_2 | RG_XPLL_CKCTRL_MODE_3 | RG_XPLL_POSDIV_2 |
    890                                      RG_XPLL_PREDIV_1 | RG_XPLL_FBDIV(0xF) | RG_XPLL_PWD;//0x0000741F
    891              HAL_REG_32(XPLL_CTL8) = RG_XPLL_BIAS_PWD | RG_XPLL_RESERVE(0xF0) | RG_XPLL_FIFO_START_MAN | RG_XPLL_DDS_RSTB_MASK;//0x0001F030;
    892          
    893              //Close band gap for XPLL use
    894              HAL_REG_32(0x81021028) &= ~(0x600000);
    895              HAL_REG_32(0x81021028) |= 0x400000;
    896          }
    897          
    898          #endif//#ifdef HAL_I2S_MODULE_ENABLED
    899          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   I2sCfgInitialSetting
         8   -> printf
       0   I2sClkFifoEn
       0   I2sDlEn
       0   I2sGetVdmaRxFifoCnt
       0   I2sGetVdmaTxFifoCnt
       0   I2sReadVdmaRxFifo
       0   I2sReset
       8   I2sSetDlCfg
         8   -> printf
       8   I2sSetGblCfg
         8   -> printf
       8   I2sSetUlCfg
         8   -> printf
      16   I2sSetVdmaRxIntrEn
        16   -> printf
       0   I2sSetVdmaRxThreshold
      16   I2sSetVdmaTxIntrEn
        16   -> printf
       0   I2sSetVdmaTxThreshold
       0   I2sUlEn
       8   I2sVdmaRxStart
         8   -> DMA_Vfifo_Flush
       8   I2sVdmaRxStop
         8   -> DMA_Stop
       8   I2sVdmaTxStart
         8   -> DMA_Vfifo_Flush
       8   I2sVdmaTxStop
         8   -> DMA_Stop
       0   I2sWriteVdmaTxFifo
       0   xpllClose
       4   xpllMicroDelay
       8   xpllOpen
         8   -> top_xtal_freq_get
         0   -> xpllMicroDelay
         8   -> xpllMicroDelay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_13
       4  ??DataTable20_14
       4  ??DataTable20_15
       4  ??DataTable20_16
       4  ??DataTable20_17
       4  ??DataTable20_18
       4  ??DataTable20_19
       4  ??DataTable20_2
       4  ??DataTable20_20
       4  ??DataTable20_21
       4  ??DataTable20_22
       4  ??DataTable20_23
       4  ??DataTable20_24
       4  ??DataTable20_25
       4  ??DataTable20_26
       4  ??DataTable20_27
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
      20  ?_0
      40  ?_1
      84  ?_2
     222  I2sCfgInitialSetting
      50  I2sClkFifoEn
      26  I2sDlEn
       8  I2sGetVdmaRxFifoCnt
       8  I2sGetVdmaTxFifoCnt
      12  I2sReadVdmaRxFifo
      22  I2sReset
     174  I2sSetDlCfg
     206  I2sSetGblCfg
     202  I2sSetUlCfg
      42  I2sSetVdmaRxIntrEn
      10  I2sSetVdmaRxThreshold
      42  I2sSetVdmaTxIntrEn
      10  I2sSetVdmaTxThreshold
      26  I2sUlEn
      52  I2sVdmaRxStart
      12  I2sVdmaRxStop
      52  I2sVdmaTxStart
      12  I2sVdmaTxStop
      10  I2sWriteVdmaTxFifo
       4  XpllInfo
      52  xpllClose
      22  xpllMicroDelay
     320  xpllOpen

 
     4 bytes in section .bss
 1 848 bytes in section .text
 
 1 848 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none
