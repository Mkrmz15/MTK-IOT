###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:18
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\connsys\src\connsys_bus.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW57D5.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\connsys\src\connsys_bus.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\connsys_bus.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\connsys_bus.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\connsys\src\connsys_bus.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          /*
     36              Module Name:
     37              connsys_bus_driver.c
     38          
     39              Abstract:
     40              Provide SDIO-GEN3  based bus driver routines
     41          
     42              Revision History:
     43              Who         When            What
     44              --------    ----------      ----------------------------------------------
     45          */
     46          #include <stdio.h>
     47          #include <string.h>
     48          #include "type_def.h"
     49          #include "connsys_driver.h"
     50          #include "connsys_bus.h"
     51          #include "cmsis_nvic.h"
     52          #include "nvic.h"
     53          #include "dma_sw.h"
     54          #include "dma_hw.h"
     55          #include "debug.h"
     56          #include "misc.h"
     57          #include "syslog.h"
     58          #include "type_def.h"
     59          #include "cos_api.h"
     60          #include "hal_cache.h"
     61          #include "ctype.h"
     62          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
     63          #include "hal_clock.h"
     64          #endif
     65          
     66          
     67          #ifdef MTK_WIFI_SLIM_ENABLE
     68          /* anthony */
     69          #define OVERRIDE_LOG
     70          #endif
     71          
     72          #include "connsys_log.h"
     73          
     74          #ifdef _CTYPE_H
     75          /* Use driver/chip/mt5932/rom/fw/inc/ctype.h, the _ctype need defined here */
     76          unsigned char _ctype[] = {
     77          _C,_C,_C,_C,_C,_C,_C,_C,                        /* 0-7 */
     78          _C,_C|_S,_C|_S,_C|_S,_C|_S,_C|_S,_C,_C,         /* 8-15 */
     79          _C,_C,_C,_C,_C,_C,_C,_C,                        /* 16-23 */
     80          _C,_C,_C,_C,_C,_C,_C,_C,                        /* 24-31 */
     81          _S|_SP,_P,_P,_P,_P,_P,_P,_P,                    /* 32-39 */
     82          _P,_P,_P,_P,_P,_P,_P,_P,                        /* 40-47 */
     83          _D,_D,_D,_D,_D,_D,_D,_D,                        /* 48-55 */
     84          _D,_D,_P,_P,_P,_P,_P,_P,                        /* 56-63 */
     85          _P,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U,      /* 64-71 */
     86          _U,_U,_U,_U,_U,_U,_U,_U,                        /* 72-79 */
     87          _U,_U,_U,_U,_U,_U,_U,_U,                        /* 80-87 */
     88          _U,_U,_U,_P,_P,_P,_P,_P,                        /* 88-95 */
     89          _P,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L,      /* 96-103 */
     90          _L,_L,_L,_L,_L,_L,_L,_L,                        /* 104-111 */
     91          _L,_L,_L,_L,_L,_L,_L,_L,                        /* 112-119 */
     92          _L,_L,_L,_P,_P,_P,_P,_C,                        /* 120-127 */
     93          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,                /* 128-143 */
     94          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,                /* 144-159 */
     95          _S|_SP,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,   /* 160-175 */
     96          _P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,       /* 176-191 */
     97          _U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,       /* 192-207 */
     98          _U,_U,_U,_U,_U,_U,_U,_P,_U,_U,_U,_U,_U,_U,_U,_L,       /* 208-223 */
     99          _L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,       /* 224-239 */
    100          _L,_L,_L,_L,_L,_L,_L,_P,_L,_L,_L,_L,_L,_L,_L,_L};      /* 240-255 */
    101          #endif
    102          
    103          
    104          log_create_module(connsys, PRINT_LEVEL_WARNING);
    105          
    106          //#include <errno.h>
    107          #define EIO 5     // errno.h not available for Keil compiler
    108          #define ETIME 62  // errno.h not available for Keil compiler
    109          
    110          // ========================== SDIO Private Routines =============================
    111          
    112          void connsys_bus_get_bus(struct connsys_func *func)
    113          {
    114          }
    115          
    116          void connsys_bus_release_bus(struct connsys_func *func)
    117          {
    118          }
    119          
    120          void connsys_bus_read_port_pio(connsys_gen3_cmd53_info *info, void *dst, int32_t count)
    121          {
    122              int32_t i;
    123              int32_t drop_count = 0;
    124              uint32_t flags;
    125          
    126              local_irq_save(flags);
    127              REG32(SDIO_GEN3_CMD_SETUP) = info->word;
    128              /* 2. CMD53 read out */
    129              for (i = 0; i < count; i += 4) {
    130                  uint32_t value = REG32(SDIO_GEN3_CMD53_DATA);
    131                  if (i < CONNSYS_MAX_RX_PKT_SIZE && dst != NULL) {
    132                      *(((uint8_t *)dst) + i) = (value & 0xFF);
    133                      *(((uint8_t *)dst) + i + 1) = ((value & 0xFF00) >> 8);
    134                      *(((uint8_t *)dst) + i + 2) = ((value & 0xFF0000) >> 16);
    135                      *(((uint8_t *)dst) + i + 3) = ((value & 0xFF000000) >> 24);
    136                  } else {
    137                      drop_count += 4;
    138                  }
    139              }
    140              local_irq_restore(flags);
    141          }
    142          
    143          
    144          void connsys_bus_read_port_pio_garbage(connsys_gen3_cmd53_info *info, int32_t count)
    145          {
    146              int32_t i;
    147              uint32_t flags;
    148          
    149              local_irq_save(flags);
    150              REG32(SDIO_GEN3_CMD_SETUP) = info->word;
    151              /* 2. CMD53 read out */
    152              for (i = 0; i < count; i += 4) {
    153                  REG32(SDIO_GEN3_CMD53_DATA);
    154              }
    155              local_irq_restore(flags);
    156          }
    157          
    158          
    159          
    160          
    161          void connsys_bus_read_port_dma(connsys_gen3_cmd53_info *info, void *dst, int32_t count)
    162          {
    163          
    164              uint32_t flags;
    165              uint32_t reg;
    166          #if 0
    167              INFO(connsys, "==>connsys_bus_read_port_dma 2, dst = 0x%x, count = %d\n",
    168                     (unsigned int)dst, (int)count);
    169          
    170              INFO(connsys, "block_mode = %u\n", (unsigned int)info->field.block_mode);
    171              INFO(connsys, "field.count = %u\n", (unsigned int)info->field.count);
    172          #endif
    173          
    174              local_irq_save(flags);
    175              REG32(SDIO_GEN3_CMD_SETUP) = info->word;
    176              /* DMA setting */
    177          #if (PRODUCT_VERSION == 7687 || PRODUCT_VERSION == 7697)
    178              // MT7687
    179              REG32(GDMA_CH4_START) &= ~(0x1 << 15);	   /* Clear DMA channel */
    180              REG32(GDMA_CH4_PGMADDR) = (uint32_t)dst;			/* Setting CM4 SRAM Start Address */
    181              REG32(GDMA_CH4_COUNT) = (count >> 2);	   /* Setting DMA transfer length in DW */
    182              REG32(GDMA_CH4_CON) = 0;
    183              REG32(GDMA_CH4_CON) |= (0x15 << 20);	   /* select HIF(SDIO) Tx/Rx */
    184              REG32(GDMA_CH4_CON) |= (0x1 << 18); 	   /* DIR=1, HIF to CM4 Sysram	=> WRITE */
    185          //	REG32(GDMA_CH4_CON) |= (0x1 << 15); 	   /* Enable DMA finish interrupt */
    186              REG32(GDMA_CH4_CON) |= (0x6 << 8);		   /* Burst transfer 4 beats in DW */
    187              REG32(GDMA_CH4_CON) |= (0x1 << 3);		   /* Increase destination address, HIF address */
    188              REG32(GDMA_CH4_CON) |= (0x0 << 2);		   /* Don't increase source address, CM4 Sysram address */
    189              REG32(GDMA_CH4_CON) |= (0x2 << 0);		   /* Double word transfer, 4 bytes */
    190          
    191              /* DMA kick out */
    192              REG32(GDMA_CH4_START) |= (0x1 << 15); /* Start DMA channel*/
    193              do {
    194                  reg = REG32(GDMA_CH4_RLCT);
    195              } while (reg != 0x00);
    196          #elif (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
    197              REG32(PDN_CLR0) = 0x1;    // turn off DMA cg
    198              REG32(GDMA_CH6_START) = 0x0; //&= ~(0x1 << 15);     /* Clear DMA channel */
    199              REG32(GDMA_CH6_PGMADDR) = (unsigned int)dst;            /* Setting CM4 SRAM Start Address */
    200              REG32(GDMA_CH6_COUNT) = (count >> 2);      /* Setting DMA transfer length in DW */
    201              //REG32(GDMA_CH6_CON) = 0x01090212;
    202              REG32(GDMA_CH6_CON) = 0x90212; // no interrupt
    203              //REG32(GDMA_CH6_CON) = 0;
    204              //REG32(GDMA_CH6_CON) |= (0x1 << 24);        /* ITEN, 1 = enable DMA transfer completion interrupt */
    205              //REG32(GDMA_CH6_CON) |= (0x2 << 18);        /* Transfer type, 10 = 4-beat Incrementing burst */
    206              //REG32(GDMA_CH6_CON) |= (0x1 << 16);        /* DREQ, 0 = no throttle control; 1 = Hardware handshake management */
    207              //REG32(GDMA_CH6_CON) |= (0x2 << 8);         /* SIZE, Word transfer - 4 bytes */
    208              //REG32(GDMA_CH6_CON) |= (0x1 << 4);         /* DIRECTION, [4] Directions of PDMA transfer */
    209              //REG32(GDMA_CH6_CON) |= (0x1 << 1);         /* DIRECTION, [1] Incremental destination address */
    210              //REG32(GDMA_CH6_CON) |= (0x0 << 0);         /* DIRECTION, [0] Incremental sourue address */
    211          
    212              /* DMA kick out */
    213              REG32(GDMA_CH6_START) |= (0x1 << 15); /* Start DMA channel*/
    214              do {
    215                  reg = REG32(GDMA_CH6_RLCT);
    216              } while (reg != 0x00);
    217          #else
    218          #endif
    219              local_irq_restore(flags);
    220          
    221          
    222          }
    223          int32_t connsys_get_rx_buffer_size(struct connsys_func *func, int32_t size)
    224          {
    225          
    226              int32_t count;
    227          
    228              /* CMD53 port mode to write n-byte, if count >= block size => block mode, otherwise =>  byte mode  */
    229              count = ALIGN_4BYTE(size);
    230          
    231          
    232              /* 1. Setup command information */
    233              if (count >= func->blksize) {
    234                  /* block  mode */
    235                  int32_t cnt  = count / func->blksize;
    236                  if (count % func->blksize > 0) {
    237                      cnt++;
    238                  }
    239                  count = cnt * func->blksize;
    240                  //INFO(connsys, "rx alloc: %d bytes\n", (int)count);
    241              } else {
    242                  ;/* byte  mode */
    243              }
    244              return count;
    245          }
    246          
    247          /**
    248           *	connsys_readsb - read from a FIFO on a SDIO function
    249           *	@func: SDIO function to access
    250           *	@dst: buffer to store the data
    251           *	@addr: address of (single byte) FIFO
    252           *	@count: number of bytes to read
    253           *
    254           *	Reads from the specified FIFO of a given SDIO function. Return
    255           *	value indicates if the transfer succeeded or not.
    256           */
    257          int32_t connsys_bus_read_port(struct connsys_func *func, void *dst, uint32_t addr,
    258                                        int32_t size)
    259          {
    260              connsys_gen3_cmd53_info info;
    261              int32_t count;
    262          
    263              if ((unsigned int)dst & 0x3) {
    264                  ERR(connsys, "==>connsys_bus_read_port, align error, dst = 0x%x", (unsigned int)dst);
    265                  connsys_bus_read_port_garbage(addr, size);
    266                  return CONNSYS_STATUS_FAIL;
    267              }
    268          
    269              /* CMD53 port mode to write n-byte, if count >= block size => block mode, otherwise =>  byte mode  */
    270              count = ALIGN_4BYTE(size);
    271          
    272              /* 1. Setup command information */
    273              info.word = 0;
    274              info.field.rw_flag = SDIO_GEN3_READ;
    275              info.field.func_num = func->num; //SDIO_GEN3_FUNCTION_WIFI;
    276              if (count >= func->blksize) {
    277                  info.field.block_mode = SDIO_GEN3_BLOCK_MODE; /* block  mode */
    278                  info.field.count = count / func->blksize;
    279                  if (count % func->blksize > 0) {
    280                      info.field.count++;
    281                  }
    282                  count = info.field.count * func->blksize;
    283              } else {
    284                  info.field.block_mode = SDIO_GEN3_BYTE_MODE; /* byte  mode */
    285                  info.field.count = count;
    286              }
    287              info.field.op_mode = SDIO_GEN3_FIXED_PORT_MODE; /* fix mode */
    288              info.field.addr = addr;
    289              if (func->use_dma) {
    290                  /*
    291                  	uint32_t drop_count = 0;
    292                  	if (count >  CONNSYS_MAX_RX_PKT_SIZE)
    293                  	{
    294                  		count = CONNSYS_MAX_RX_PKT_SIZE;
    295                  		drop_count = CONNSYS_MAX_RX_PKT_SIZE - count;
    296                  	}
    297                  */
    298                  //if (count > func->blksize)
    299                  //	INFO(connsys, "rx: %d -> %d bytes, CMD53=0x%x\n", (int)size, (int)count, (int)info.word);
    300          
    301                  connsys_bus_read_port_dma(&info, dst, count);
    302                  /*
    303                  	if (drop_count >  0)
    304                  	{
    305                  		// TODO: take care of info of drop count
    306                  		ERR(connsys, "DMA mode drop count(%d) not support yet!", (int)drop_count);
    307                  	}
    308                  */
    309              } else {
    310                  connsys_bus_read_port_pio(&info, dst, count);
    311              }
    312          
    313              return CONNSYS_STATUS_SUCCESS;
    314          }
    315          
    316          
    317          int32_t connsys_bus_read_port_garbage(uint32_t addr, int32_t size)
    318          {
    319              connsys_gen3_cmd53_info info;
    320              int32_t count;
    321              struct connsys_func *func = &g_connsys_func;
    322          
    323          
    324              /* CMD53 port mode to write n-byte, if count >= block size => block mode, otherwise =>  byte mode  */
    325              count = ALIGN_4BYTE(size);
    326          
    327              /* 1. Setup command information */
    328              info.word = 0;
    329              info.field.rw_flag = SDIO_GEN3_READ;
    330              info.field.func_num = func->num; //SDIO_GEN3_FUNCTION_WIFI;
    331              if (count >= func->blksize) {
    332                  info.field.block_mode = SDIO_GEN3_BLOCK_MODE; /* block  mode */
    333                  info.field.count = count / func->blksize;
    334                  if (count % func->blksize > 0) {
    335                      info.field.count++;
    336                  }
    337                  count = info.field.count * func->blksize;
    338              } else {
    339                  info.field.block_mode = SDIO_GEN3_BYTE_MODE; /* byte  mode */
    340                  info.field.count = count;
    341              }
    342              info.field.op_mode = SDIO_GEN3_FIXED_PORT_MODE; /* fix mode */
    343              info.field.addr = addr;
    344          
    345              connsys_bus_read_port_pio_garbage(&info, count);
    346          
    347              return 0;
    348          }
    349          
    350          #ifdef MT5932_SINGLE_CONTEXT
    351          #ifndef MTK_WIFI_SLIM_ENABLE
    352          uint8_t inband_rsp1[300];
    353          #else
    354          ATTR_ZIDATA_IN_TCM uint8_t inband_rsp1[300];
    355          #endif
    356          int inband_queue_inband_handler(void *pkt_ptr, unsigned char *payload, unsigned int len);
    357          
    358          void connsys_bus_read_port0_pio_garbage(connsys_gen3_cmd53_info *info, int32_t count, int len)
    359          {
    360              int32_t i;
    361              uint32_t flags;
    362                 uint32_t *data = (uint32_t *)inband_rsp1;
    363              local_irq_save(flags);
    364              REG32(SDIO_GEN3_CMD_SETUP) = info->word;
    365                 /* 2. CMD53 read out */
    366                 for (i = 0; i < count; i+=4)
    367              {
    368                         *data++ = REG32(SDIO_GEN3_CMD53_DATA);
    369              }
    370              local_irq_restore(flags);
    371          
    372                 inband_queue_inband_handler(NULL, inband_rsp1, len);
    373          
    374          }
    375          
    376          int32_t connsys_bus_read_port0_garbage(uint32_t addr, int32_t size)
    377          {
    378              connsys_gen3_cmd53_info info;
    379              int32_t count;
    380              struct connsys_func *func = &g_connsys_func;
    381                 //INFO(connsys, "HIT\n");
    382          
    383              /* CMD53 port mode to write n-byte, if count >= block size => block mode, otherwise =>  byte mode  */
    384              count = ALIGN_4BYTE(size);
    385          
    386              /* 1. Setup command information */
    387              info.word = 0;
    388              info.field.rw_flag = SDIO_GEN3_READ;
    389              info.field.func_num = func->num; //SDIO_GEN3_FUNCTION_WIFI;
    390              if (count >= func->blksize)
    391              {
    392                  info.field.block_mode = SDIO_GEN3_BLOCK_MODE; /* block  mode */
    393                  info.field.count = count/func->blksize;
    394                  if (count % func->blksize > 0)
    395                      info.field.count++;
    396                  count = info.field.count * func->blksize;
    397              }
    398              else
    399              {
    400                  info.field.block_mode = SDIO_GEN3_BYTE_MODE; /* byte  mode */
    401                  info.field.count = count;
    402              }
    403              info.field.op_mode = SDIO_GEN3_FIXED_PORT_MODE; /* fix mode */
    404              info.field.addr = addr;
    405          
    406                 connsys_bus_read_port0_pio_garbage(&info, count, size);
    407          
    408              return 0;
    409          }
    410          #endif
    411          void connsys_dump_cmd53_info(connsys_gen3_cmd53_info *info)
    412          {
    413              INFO(connsys, "info: 0x%x", (unsigned int)info->word);
    414              INFO(connsys, "\tByte/Block Count: %u", info->field.count);
    415              INFO(connsys, "\tRegister Address: 0x%x", info->field.addr);
    416              INFO(connsys, "\tOP Code: 0x%x", info->field.op_mode);
    417              INFO(connsys, "\tBlock Mode: 0x%x", info->field.block_mode);
    418              INFO(connsys, "\tFunction Number: 0x%x", info->field.func_num);
    419              INFO(connsys, "\tR/W flag: 0x%x", info->field.rw_flag);
    420          }
    421          
    422          
    423          
    424          static void connsys_bus_write_port_pio(connsys_gen3_cmd53_info *info, void *src, int32_t count)
    425          {
    426              int32_t i;
    427              uint32_t flags;
    428              uint32_t value;
    429          
    430          
    431              if (g_connsys_debug_feature & CONNSYS_DBG_PORT) {
    432                  CONNSYS_D(CONNSYS_DBG_PORT,
    433                              ("==>connsys_bus_write_port_pio, src = 0x%x, count = %u",
    434                               (unsigned int)src, (unsigned int)count));
    435          
    436                  connsys_dump_cmd53_info(info);
    437              }
    438          
    439              local_irq_save(flags);
    440              REG32(SDIO_GEN3_CMD_SETUP) = info->word;
    441              for (i = 0; i < count; i += 4) {
    442                  if (i >= count) {
    443                      /* Padding with all "0" */
    444                      value = 0;
    445                  } else {
    446                      value = *(((uint8_t *)src) + i);
    447                      value |= ((*(((uint8_t *)src) + i + 1)) << 8);
    448                      value |= ((*(((uint8_t *)src) + i + 2)) << 16);
    449                      value |= ((*(((uint8_t *)src) + i + 3)) << 24);
    450                  }
    451                  REG32(SDIO_GEN3_CMD53_DATA) = value;
    452              }
    453              local_irq_restore(flags);
    454          }
    455          
    456          // TODO: Support scattered packets
    457          static void connsys_bus_write_port_dma(connsys_gen3_cmd53_info *info, void *src, int32_t count)
    458          {
    459              uint32_t reg;
    460              uint32_t flags;
    461          
    462              local_irq_save(flags);
    463              REG32(SDIO_GEN3_CMD_SETUP) = info->word;
    464          #if (PRODUCT_VERSION == 7687 || PRODUCT_VERSION == 7697)
    465              // MT7687
    466              /* DMA setting */
    467              REG32(GDMA_CH4_START) = 0;	   /* Clear DMA channel */
    468              REG32(GDMA_CH4_PGMADDR) = (uint32_t)src;			/* Setting CM4 SRAM Start Address */
    469              REG32(GDMA_CH4_COUNT) = (count >> 2);	   /* Setting DMA transfer length in DW */
    470              REG32(GDMA_CH4_CON) = 0;
    471              REG32(GDMA_CH4_CON) |= (0x15 << 20);	   /* select HIF(SDIO) Tx/Rx */
    472              REG32(GDMA_CH4_CON) |= (0x0 << 18); 	   /* DIR=0, CM4 Sysram to HIF => READ */
    473          //	REG32(GDMA_CH4_CON) |= (0x0 << 15); 	   /* Enable DMA finish interrupt */
    474              REG32(GDMA_CH4_CON) |= (0x6 << 8);		   /* Burst transfer 4 beats in DW */
    475              REG32(GDMA_CH4_CON) |= (0x0 << 3);		   /* Don't increase destination address, HIF address */
    476              REG32(GDMA_CH4_CON) |= (0x1 << 2);		   /* Increase source address, CM4 Sysram address */
    477              REG32(GDMA_CH4_CON) |= (0x2 << 0);		   /* Double word transfer, 4 bytes */
    478              /* DMA kick out */
    479              REG32(GDMA_CH4_START) |= (0x1 << 15); /* Start DMA channel*/
    480              /* wait DMA finish */
    481              do {
    482                  reg = REG32(GDMA_CH4_RLCT);
    483              } while (reg != 0x00);
    484          #elif (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
    485              /* DMA setting */
    486              REG32(PDN_CLR0) = 0x1;    // turn off DMA cg
    487              REG32(GDMA_CH6_START) = 0x0;     /* Clear DMA channel */
    488              REG32(GDMA_CH6_PGMADDR) = (unsigned int)src;            /* Setting CM4 SRAM Start Address */
    489              REG32(GDMA_CH6_COUNT) = (count >> 2);      /* Setting DMA transfer length in DW */
    490              //REG32(GDMA_CH6_CON) = 0x01090201;
    491              REG32(GDMA_CH6_CON) = 0x90201; // no interrupt
    492              //REG32(GDMA_CH6_CON) = 0;
    493              //REG32(GDMA_CH6_CON) |= (0x1 << 24);        /* ITEN, 1 = enable DMA transfer completion interrupt */
    494              //REG32(GDMA_CH6_CON) |= (0x2 << 18);        /* Transfer type, 10 = 4-beat Incrementing burst */
    495              //REG32(GDMA_CH6_CON) |= (0x1 << 16);        /* DREQ, 0 = no throttle control; 1 = Hardware handshake management */
    496              //REG32(GDMA_CH6_CON) |= (0x2 << 8);         /* SIZE, Word transfer - 4 bytes */
    497              //REG32(GDMA_CH6_CON) |= (0x0 << 1);         /* DIRECTION, [1] Incremental destination address */
    498              //REG32(GDMA_CH6_CON) |= (0x1 << 0);         /* DIRECTION, [0] Incremental sourue address */
    499              /* DMA kick out */
    500              REG32(GDMA_CH6_START) |= (0x1 << 15); /* Start DMA channel*/
    501              /* wait DMA finish */
    502              do {
    503                  reg = REG32(GDMA_CH6_RLCT);
    504              } while (reg != 0x00);
    505          #endif
    506              local_irq_restore(flags);
    507          }
    508          
    509          void connsys_bus_write_port_transfer(struct connsys_func *func, connsys_gen3_cmd53_info *info, void *src, int32_t size)
    510          {
    511          
    512              if (func->use_dma) {
    513                  connsys_bus_write_port_dma(info, src, size);
    514              } else {
    515                  connsys_bus_write_port_pio(info, src, size);
    516          
    517              }
    518          }
    519          
    520          int32_t connsys_bus_write_port(struct connsys_func *func, uint32_t addr, void *src,
    521                                         int32_t size)
    522          {
    523              connsys_gen3_cmd53_info info;
    524              int32_t count;
    525          
    526              CONNSYS_D(CONNSYS_DBG_PORT, ("==>connsys_bus_write_port, addr = 0x%x, src = 0x%x, size = %u\n",
    527                                             (unsigned int)addr, (unsigned int)src, (unsigned int)size));
    528          
    529              if (!(IS_ALIGN_4((uint32_t)src)) && (func->use_dma)) {
    530                  CONNSYS_DUMP_E(connsys, "connsys_bus_write_port, align error, packet: ", (uint8_t *)src, (uint32_t)size);
    531                  return CONNSYS_STATUS_FAIL;
    532              }
    533          
    534              /* CMD53 port mode to write n-byte, if count >= block size => block mode, otherwise =>  byte mode  */
    535              count = ALIGN_4BYTE(size);
    536          
    537              /* 1. Setup command information */
    538              info.word = 0;
    539              info.field.rw_flag = SDIO_GEN3_WRITE;
    540              info.field.func_num = func->num; //SDIO_GEN3_FUNCTION_WIFI;
    541          
    542              if (count >= func->blksize) {
    543                  info.field.block_mode = SDIO_GEN3_BLOCK_MODE; /* block  mode */
    544                  info.field.count = count / func->blksize;
    545                  if (count % func->blksize > 0) {
    546                      info.field.count++;
    547                  }
    548                  count = info.field.count * func->blksize;
    549              } else {
    550                  info.field.block_mode = SDIO_GEN3_BYTE_MODE; /* byte  mode */
    551                  info.field.count = count;
    552              }
    553          
    554              info.field.op_mode = SDIO_GEN3_FIXED_PORT_MODE; /* fix mode */
    555              info.field.addr = addr;
    556          
    557              if ((func->use_dma) &&
    558                      (info.field.block_mode == SDIO_GEN3_BLOCK_MODE) &&
    559                      (count < CONNSYS_MAX_RX_PKT_SIZE))
    560          
    561              {
    562                  connsys_bus_write_port_dma(&info, src, count);
    563              } else {
    564                  connsys_bus_write_port_pio(&info, src, count);
    565          
    566              }
    567              return CONNSYS_STATUS_SUCCESS;
    568          }
    569          
    570          void connsys_dump_tx_scatter_info(connsys_tx_scatter_info_t *tx_info)
    571          {
    572              uint32_t i;
    573              INFO(connsys, "dump tx scatter info:");
    574              CONNSYS_DUMP_I(connsys, "txd", tx_info->txd, 12);
    575              INFO(connsys, "reserved_headroom_len = %u, tx_len = %u, real_tx_len = %u, buf_num = %u, fg_wmm = %d",
    576                    (unsigned int)tx_info->reserved_headroom_len,
    577                    (unsigned int)tx_info->tx_len,
    578                    (unsigned int)tx_info->real_tx_len,
    579                    (unsigned int)tx_info->buf_num,
    580                    (int)tx_info->fg_wmm);
    581          
    582              for (i = 0; i < tx_info->buf_num; i++) {
    583                  INFO(connsys, "[%u]: ", (unsigned int)i);
    584                  CONNSYS_DUMP_I(connsys, "content", tx_info->buff[i].buf_ptr, tx_info->buff[i].buf_len);
    585              }
    586          }
    587          
    588          int32_t connsys_write_data(connsys_tx_scatter_info_t *tx_info)
    589          {
    590              connsys_gen3_cmd53_info info;
    591              struct connsys_func *func = &g_connsys_func;
    592              uint32_t addr = WTDR1;
    593              int32_t count;
    594              uint32_t i;
    595              uint32_t src;
    596              uint32_t send_len;
    597              int32_t remain_send_len = 0;
    598              int32_t remain_reserved_headroom_len = 0;
    599              uint32_t  n9_pad_buf;
    600              uint32_t send_cnt = 0;
    601              uint32_t  byte_idx;
    602              uint32_t  buf_idx;
    603              uint32_t flags;
    604              uint32_t send_buf = 0;
    605          
    606              /* CMD53 port mode to write n-byte, if count >= block size => block mode, otherwise =>  byte mode  */
    607              count = tx_info->real_tx_len;
    608          
    609              /* 1. Setup command information */
    610              info.word = 0;
    611              info.field.rw_flag = SDIO_GEN3_WRITE;
    612              info.field.func_num = func->num; //SDIO_GEN3_FUNCTION_WIFI;
    613          
    614              if (count >= func->blksize) {
    615                  info.field.block_mode = SDIO_GEN3_BLOCK_MODE; /* block  mode */
    616                  info.field.count = count / func->blksize;
    617                  if (count % func->blksize > 0) {
    618                      info.field.count++;
    619                  }
    620                  count = info.field.count * func->blksize;
    621              } else {
    622                  info.field.block_mode = SDIO_GEN3_BYTE_MODE; /* byte  mode */
    623                  info.field.count = count;
    624              }
    625          
    626              info.field.op_mode = SDIO_GEN3_FIXED_PORT_MODE; /* fix mode */
    627              info.field.addr = addr;
    628          
    629          
    630          #if (CONNSYS_DEBUG_MODE_EN == 1)
    631              if (CONNSYS_TEST_DEBUG(CONNSYS_DBG_PORT)) {
    632                  CONNSYS_D(CONNSYS_DBG_PORT, ("==>connsys_write_data\n"));
    633                  connsys_dump_cmd53_info(&info);
    634              }
    635          #endif
    636          
    637              local_irq_save(flags);
    638              REG32(SDIO_GEN3_CMD_SETUP) = info.word;
    639          #if (defined MTK_CM4_WIFI_TASK_ENABLE) && (defined DATA_PATH_87)
    640          //#ifdef DATA_PATH_87
    641           uint8_t Cid = *((uint8_t*)&tx_info->txd + 4);
    642           if(Cid != 0xff)
    643           {
    644              /* Send HIF TXD */
    645              src = (uint32_t) &tx_info->txd;
    646              for (i = 0; i < 12; i+=4) {
    647                  REG32(SDIO_GEN3_CMD53_DATA) = *(uint32_t *)(src + i);
    648              }
    649              send_cnt += 12;
    650            }
    651            else
    652            {
    653              //INFO(connsys, "Skip HIF p_txd->ucCID != 0xff\n");
    654          
    655            }
    656           #else
    657          
    658              /* Send HIF TXD */
    659              src = (uint32_t) &tx_info->txd;
    660              for (i = 0; i < 12; i += 4) {
    661                  REG32(SDIO_GEN3_CMD53_DATA) = *(uint32_t *)(src + i);
    662              }
    663          
    664              send_cnt += 12;
    665          
    666          #endif /* MT7686 && DATA_PATH_87 */
    667          
    668              /* Send N9 padding */
    669              send_len = (tx_info->reserved_headroom_len / 4) * 4;
    670              for (i = 0; i < send_len; i += 4) {
    671                  REG32(SDIO_GEN3_CMD53_DATA) = 0;
    672              }
    673              send_cnt += send_len;
    674          
    675              remain_reserved_headroom_len = tx_info->reserved_headroom_len - send_len;
    676          
    677              if (remain_reserved_headroom_len && (!func->use_dma)) {
    678                  /* PIO sent out 1st DW of payload */
    679                  n9_pad_buf = 0;
    680                  memcpy((void *)((uint32_t)((uint8_t *)&n9_pad_buf) + remain_reserved_headroom_len),
    681                         tx_info->buff[0].buf_ptr,
    682                         (4 - remain_reserved_headroom_len));
    683          
    684                  REG32(SDIO_GEN3_CMD53_DATA) = n9_pad_buf;
    685                  send_cnt += 4;
    686              }
    687          
    688              /* Send packet payload */
    689              byte_idx = 0;
    690              for (buf_idx = 0; buf_idx < tx_info->buf_num; buf_idx++) {
    691                  if ((buf_idx == 0) && (remain_reserved_headroom_len)) {
    692                      if (func->use_dma) {
    693                          //ASSERT(remain_reserved_headroom_len == RESERVED_HLEN);
    694                          /* DMA not sent out 1st DW of payload  */
    695                          src = (uint32_t)tx_info->buff[0].buf_ptr - remain_reserved_headroom_len;
    696                          remain_send_len = tx_info->buff[0].buf_len + remain_reserved_headroom_len;
    697                      } else {
    698                          /* PIO has sent out 1st DW of payload  */
    699                          src = (uint32_t)tx_info->buff[0].buf_ptr + remain_reserved_headroom_len;
    700                          remain_send_len = tx_info->buff[0].buf_len - (4 - remain_reserved_headroom_len);
    701                      }
    702                  } else {
    703                      src = (uint32_t)tx_info->buff[buf_idx].buf_ptr;
    704                      remain_send_len = tx_info->buff[buf_idx].buf_len;
    705          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
    706          #ifdef HAL_CACHE_MODULE_ENABLED
    707          	     if (true == hal_cache_is_cacheable(src))
    708          	     {
    709          	     	   //hex_dump("cacheable", (unsigned char *)src, remain_send_len);
    710          	         goto pure_pio;
    711          	     }
    712          #endif
    713          #endif
    714                  }
    715                  /* 2. CMD53 write out */
    716                  if (func->use_dma) {
    717          
    718                      unsigned int reg;
    719                      unsigned int len_moved_by_dma;
    720                      if (!IS_ALIGN_4((uint32_t)src)) {
    721                          /* Sometimes, LWIP use RX buffer for TX directly, w/o pbuf_free and allocation again, in this case, PBUF_RAW type will lead to unaligned 4-byte */
    722                          INFO(connsys, "[DMA] 4-align addr(%d), len(%d), src:0x%x, tx_info->reserved_headroom_len(%d), remain_reserved_headroom_len(%d), src offset 2 bytes...\n",
    723                                IS_ALIGN_4((uint32_t)src), IS_ALIGN_4(remain_send_len), src,
    724                                tx_info->reserved_headroom_len, remain_reserved_headroom_len);
    725                          goto pure_pio;
    726                      }
    727          #if (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
    728                      hal_clock_enable(HAL_CLOCK_CG_DMA);
    729          #else
    730                      REG32(GDMA_CHANNEL_ENABLE) = 0xFFFFFFFF; // enable all DMA channel
    731          #endif
    732                      //REG32(SDIO_GEN3_CMD_SETUP) = info.word; // DMA mode same as PIO
    733          #if (PRODUCT_VERSION == 7687 || PRODUCT_VERSION == 7697)
    734                      // MT7687
    735                      /* DMA setting */
    736                      REG32(GDMA_CH4_START) = 0;     /* Clear DMA channel */
    737                      REG32(GDMA_CH4_PGMADDR) = (unsigned int)src;            /* Setting CM4 SRAM Start Address */
    738                      REG32(GDMA_CH4_COUNT) = (remain_send_len >> 2);    /* Setting DMA transfer length in DW */
    739                      REG32(GDMA_CH4_CON) = 0;
    740                      REG32(GDMA_CH4_CON) |= (0x15 << 20);       /* select HIF(SDIO) Tx/Rx */
    741                      REG32(GDMA_CH4_CON) |= (0x0 << 18);        /* DIR=0, CM4 Sysram to HIF => READ */
    742                      //REG32(GDMA_CH4_CON) |= (0x0 << 15);      /* Enable DMA finish interrupt */
    743                      REG32(GDMA_CH4_CON) |= (0x6 << 8);         /* Burst transfer 4 beats in DW */
    744                      REG32(GDMA_CH4_CON) |= (0x0 << 3);         /* Don't increase destination address, HIF address */
    745                      REG32(GDMA_CH4_CON) |= (0x1 << 2);         /* Increase source address, CM4 Sysram address */
    746                      REG32(GDMA_CH4_CON) |= (0x2 << 0);         /* Double word transfer, 4 bytes */
    747          #elif (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
    748          		REG32(PDN_CLR0) = 0x1;    // turn off DMA cg
    749          		REG32(GDMA_CH6_START) = 0x0;     /* Clear DMA channel */
    750          		REG32(GDMA_CH6_PGMADDR) = (unsigned int)src;            /* Setting CM4 SRAM Start Address */
    751          		REG32(GDMA_CH6_COUNT) = (remain_send_len >> 2);      /* Setting DMA transfer length in DW */
    752          		//REG32(GDMA_CH6_CON) = 0x01090201;
    753          		REG32(GDMA_CH6_CON) = 0x90201; // no interrupt
    754          		//REG32(GDMA_CH6_CON) = 0;
    755          		//REG32(GDMA_CH6_CON) |= (0x0 << 24);        /* ITEN, 1 = enable DMA transfer completion interrupt */
    756          		//REG32(GDMA_CH6_CON) |= (0x2 << 18);        /* Transfer type, 10 = 4-beat Incrementing burst */
    757          		//REG32(GDMA_CH6_CON) |= (0x1 << 16);        /* DREQ, 0 = no throttle control; 1 = Hardware handshake management */
    758          		//REG32(GDMA_CH6_CON) |= (0x2 << 8);         /* SIZE, Word transfer - 4 bytes */
    759          		//REG32(GDMA_CH6_CON) |= (0x0 << 1);         /* DIRECTION, [1] Incremental destination address */
    760          		//REG32(GDMA_CH6_CON) |= (0x1 << 0);         /* DIRECTION, [0] Incremental sourue address */
    761          
    762          #endif
    763                      byte_idx = 0;   //byte_idx indicate remaing bytes for residual (div by 4)
    764                      len_moved_by_dma = (remain_send_len >> 2) << 2;
    765                      src +=  len_moved_by_dma;
    766                      send_cnt += len_moved_by_dma;
    767                      remain_send_len -= len_moved_by_dma;
    768                      //INFO(connsys, "byte_idx=%d\n", byte_idx);
    769          
    770          #if 0 //(CONSYS_BUG_DBG==1)
    771                      INFO(connsys, "GDMA_CON(0x%x)=0x%x\n", GDMA_CH4_CON, REG32(GDMA_CH4_CON));
    772          
    773                      // wait DMA finish
    774                      INFO(connsys, "Wait GDMA finishing...\n");
    775          #endif
    776          
    777                      /* DMA kick out */
    778          #if (PRODUCT_VERSION == 7687 || PRODUCT_VERSION == 7697)
    779                      REG32(GDMA_CH4_START) |= (0x1 << 15); /* Start DMA channel*/
    780          #elif (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
    781                      REG32(GDMA_CH6_START) |= (0x1 << 15); /* Start DMA channel*/
    782          #endif
    783                      //INFO(connsys, "DMA kick done\n");
    784                      do {
    785          #if (PRODUCT_VERSION == 7687 || PRODUCT_VERSION == 7697)
    786                          reg = REG32(GDMA_CH4_RLCT);
    787          #elif (PRODUCT_VERSION == 7686 || PRODUCT_VERSION == 7682 || PRODUCT_VERSION == 5932)
    788                          reg = REG32(GDMA_CH6_RLCT);
    789          #endif
    790                      } while (reg != 0x00);
    791                      //INFO(connsys, "GDMA done! byte_idx(%d), len_moved_by_dma(%d), remain_send_len(%d), count(%d)\n", (int)byte_idx, (int)len_moved_by_dma, (int)remain_send_len, (int)info.field.count);
    792          
    793                  }
    794          
    795          pure_pio:
    796                  /* Pure PIO mode */
    797          	 //if (remain_send_len > 1024) 	INFO(connsys, "send by PIO %d bytes\n", (int)remain_send_len);
    798          #if 0
    799                  for (i = 0; i < remain_send_len; i++) {
    800                      *(((uint8_t *)&send_buf) + byte_idx) = *(uint8_t *)src;
    801                      byte_idx ++;
    802                      src ++;
    803                      if (byte_idx == 4) {
    804                          REG32(SDIO_GEN3_CMD53_DATA) = send_buf;
    805                          byte_idx = 0;
    806                          send_cnt += 4;
    807                      }
    808                  }
    809          #else
    810                byte_idx = 0;
    811          
    812          	  while (remain_send_len >= 4)
    813          	  {
    814          #if defined(__CC_ARM)
    815                  //REG(..) = addr;  KEIL build it to "LDM R5!,{R0}". this "addr" must be 4 byte aline. otherwise CM4 will assert.
    816          	    *(((uint8_t *)&send_buf) + byte_idx) = *(uint8_t *)src;
    817                  byte_idx++;
    818                  src ++;
    819                  if(byte_idx == 4) {
    820                      REG32(SDIO_GEN3_CMD53_DATA) = send_buf;
    821                      byte_idx = 0;
    822                      send_cnt += 4;
    823                      remain_send_len -= 4;
    824                  }
    825          #else
    826                      REG32(SDIO_GEN3_CMD53_DATA) = 	*((uint32_t *)src);
    827                      send_cnt += 4;
    828           	     src += 4;
    829          	     remain_send_len -= 4;
    830          #endif
    831           	  }
    832          
    833          	  if (remain_send_len > 0)
    834          	  {
    835          		  byte_idx = 0;
    836          	        for (i = 0; i < remain_send_len; i++) {
    837          	            *(((uint8_t *)&send_buf) + byte_idx) = *(uint8_t *)src;
    838          	            byte_idx ++;
    839          	            src ++;
    840          	        }
    841            	        send_cnt+=4;
    842                        REG32(SDIO_GEN3_CMD53_DATA) = send_buf;
    843                        //INFO(connsys, "rest PIO %d bytes, send_cnt(%d), count(%d)\n", (int)remain_send_len, (int)send_cnt, (int)count);
    844          	  }
    845          #endif
    846              }
    847          #if 0
    848              if (byte_idx) {
    849                  REG32(SDIO_GEN3_CMD53_DATA) = send_buf;
    850                  byte_idx = 0;
    851                  send_cnt += 4;
    852              }
    853          #endif
    854              /* Send all zero */
    855              for (i = send_cnt; i < count; i += 4) {
    856                  REG32(SDIO_GEN3_CMD53_DATA) = 0;
    857              }
    858          
    859              local_irq_restore(flags);
    860              return CONNSYS_STATUS_SUCCESS;
    861          }
    862          
    863          /**
    864           *	connsys_bus_readl - read a 32 bit integer from a SDIO function
    865           *	@func: SDIO function to access
    866           *	@addr: address to read
    867           *	@err_ret: optional status value from transfer
    868           *
    869           *	Reads a 32 bit integer from the address space of a given SDIO
    870           *	function. If there is a problem reading the address,
    871           *	0xffffffff is returned and @err_ret will contain the error
    872           *	code.
    873           */
    874          uint32_t connsys_bus_readl(struct connsys_func *func, uint32_t addr, int32_t *err_ret)
    875          {
    876              uint32_t value;
    877              connsys_gen3_cmd53_info info;
    878              uint32_t flags;
    879          
    880              if (err_ret) {
    881                  *err_ret = 0;
    882              }
    883          
    884              /* CMD53 incremental mode to read 4-byte */
    885              /* 1. Setup command information */
    886              info.word = 0;
    887              info.field.rw_flag = SDIO_GEN3_READ;
    888              info.field.func_num = func->num; //SDIO_GEN3_FUNCTION_WIFI;
    889              info.field.block_mode = SDIO_GEN3_BYTE_MODE; /* byte  mode */
    890              info.field.op_mode = SDIO_GEN3_FIXED_PORT_MODE; // SDIO-GEN3 only apply to fix port, forget  SDIO_GEN3_INCREMENT_MODE; /* increment mode */
    891              info.field.addr = addr;
    892              info.field.count = 4;
    893          
    894              local_irq_save(flags);
    895              REG32(SDIO_GEN3_CMD_SETUP) = info.word;
    896              /* 2. CMD53 read out */
    897              value = REG32(SDIO_GEN3_CMD53_DATA);
    898              local_irq_restore(flags);
    899          
    900              return value;
    901          }
    902          
    903          /**
    904           *	connsys_bus_writel - write a 32 bit integer to a SDIO function
    905           *	@func: SDIO function to access
    906           *	@b: integer to write
    907           *	@addr: address to write to
    908           *	@err_ret: optional status value from transfer
    909           *
    910           *	Writes a 32 bit integer to the address space of a given SDIO
    911           *	function. @err_ret will contain the status of the actual
    912           *	transfer.
    913           */
    914          void connsys_bus_writel(struct connsys_func *func, uint32_t b, uint32_t addr, int32_t *err_ret)
    915          {
    916              connsys_gen3_cmd53_info info;
    917              uint32_t flags;
    918          
    919              if (err_ret) {
    920                  *err_ret = 0;
    921              }
    922          
    923              /* CMD53 incremental mode to read 4-byte */
    924              /* 1. Setup command information */
    925              info.word = 0;
    926              info.field.rw_flag = SDIO_GEN3_WRITE;
    927              info.field.func_num = func->num; //SDIO_GEN3_FUNCTION_WIFI;
    928              info.field.block_mode = SDIO_GEN3_BYTE_MODE; /* byte  mode */
    929              info.field.op_mode = SDIO_GEN3_FIXED_PORT_MODE; // SDIO-GEN3 only apply to fix port, forget  SDIO_GEN3_INCREMENT_MODE; /* increment mode */
    930              info.field.addr = addr;
    931              info.field.count = 4;
    932              local_irq_save(flags);
    933              REG32(SDIO_GEN3_CMD_SETUP) = info.word;
    934              /* 2. CMD53 write data  */
    935              REG32(SDIO_GEN3_CMD53_DATA) = b;
    936              local_irq_restore(flags);
    937          
    938          
    939          }
    940          
    941          /**
    942           *	connsys_bus_fn0_read_byte - read a single byte from SDIO function 0
    943           *	@func: an SDIO function of the card
    944           *	@addr: address to read
    945           *	@err_ret: optional status value from transfer
    946           *
    947           *	Reads a single byte from the address space of SDIO function 0.
    948           *	If there is a problem reading the address, 0xff is returned
    949           *	and @err_ret will contain the error code.
    950           */
    951          uint8_t connsys_bus_fn0_read_byte(struct connsys_func *func, uint32_t addr,
    952                                            int32_t *err_ret)
    953          {
    954              //int32_t ret;
    955              uint8_t val;
    956              connsys_gen3_cmd52_info info;
    957              info.word = 0;
    958              uint32_t flags;
    959              /* CMD52 read 1-byte of func0 */
    960          
    961              if (err_ret) {
    962                  *err_ret = 0;
    963              }
    964          
    965              /* 1. Setup command information */
    966              info.field.rw_flag = SDIO_GEN3_READ;
    967              info.field.func_num = 0; //func->num;
    968              info.field.addr = addr;
    969          
    970              local_irq_save(flags);
    971              REG32(SDIO_GEN3_CMD_SETUP) = info.word;
    972              /* 2. CMD52 read  data  */
    973              val = REG32(SDIO_GEN3_CMD52_DATA);
    974              local_irq_restore(flags);
    975              //ret = mmc_io_rw_direct(func->card, 0, 0, addr, 0, &val);
    976          
    977              return val;
    978          }
    979          
    980          /**
    981           *	connsys_bus_fn0_write_byte - write a single byte to SDIO function 0
    982           *	@func: an SDIO function of the card
    983           *	@b: byte to write
    984           *	@addr: address to write to
    985           *	@err_ret: optional status value from transfer
    986           *
    987           *	Writes a single byte to the address space of SDIO function 0.
    988           *	@err_ret will contain the status of the actual transfer.
    989           *
    990           *	Only writes to the vendor specific CCCR registers (0xF0 -
    991           *	0xFF) are permiited; @err_ret will be set to -EINVAL for *
    992           *	writes outside this range.
    993           */
    994          void connsys_bus_fn0_write_byte(struct connsys_func *func, uint8_t b, uint32_t addr,
    995                                          int32_t *err_ret)
    996          {
    997              //int32_t ret;
    998              connsys_gen3_cmd52_info info;
    999              info.word = 0;
   1000              uint32_t flags;
   1001              /* CMD52 write 1-byte of func0 */
   1002          
   1003              if (err_ret) {
   1004                  *err_ret = 0;
   1005              }
   1006          
   1007              /* 1. Setup command information */
   1008              info.field.rw_flag = SDIO_GEN3_WRITE;
   1009              info.field.func_num = 0; //func->num;
   1010              info.field.addr = addr;
   1011              info.field.data = b;
   1012              INFO(connsys, "=== write f0, setup=0x%x\n", (unsigned int)info.word);
   1013          
   1014              local_irq_save(flags);
   1015              REG32(SDIO_GEN3_CMD_SETUP) = info.word;
   1016              /* 2. CMD52 write dummy 0 to trigger write  data  */
   1017          #if 1  //def MTK_MT7686_ENABLE
   1018              REG32(SDIO_GEN3_CMD52_DATA) = 0;
   1019          #else
   1020              REG32(SDIO_GEN3_CMD52_DATA) = b;
   1021          #endif
   1022          
   1023              local_irq_restore(flags);
   1024          }
   1025          
   1026          
   1027          /**
   1028           *	connsys_bus_enable_func - enables a SDIO function for usage
   1029           *	@func: SDIO function to enable
   1030           *
   1031           *	Powers up and activates a SDIO function so that register
   1032           *	access is possible.
   1033           */
   1034          int32_t connsys_bus_enable_func(struct connsys_func *func)
   1035          {
   1036              int32_t ret;
   1037              uint8_t reg;
   1038          
   1039              INFO(connsys, "SDIO: Enabling Function %d...\n", (int)func->num);
   1040          
   1041              reg = connsys_bus_fn0_read_byte(func, SDIO_CCCR_IOEx, &ret);
   1042              if (ret) {
   1043                  goto err;
   1044              }
   1045              INFO(connsys, "Origin Func enable=0x%x\n", reg);
   1046              reg |= 1 << func->num;
   1047          
   1048              connsys_bus_fn0_write_byte(func, reg, SDIO_CCCR_IOEx, &ret);
   1049              if (ret) {
   1050                  goto err;
   1051              }
   1052          
   1053              reg = connsys_bus_fn0_read_byte(func, SDIO_CCCR_IORx, &ret);
   1054              if (ret) {
   1055                  goto err;
   1056              }
   1057              INFO(connsys, "Read CCCR_IORx=0x%x\n", reg);
   1058              if (!(reg & (1 << func->num))) {
   1059                  ret = -ETIME;
   1060                  goto err;
   1061              }
   1062              INFO(connsys, "SDIO: Enabled Function %d\n", (int)func->num);
   1063          
   1064              return 0;
   1065          
   1066          err:
   1067              INFO(connsys, "SDIO: Failed to enable Function %d\n", (int)func->num);
   1068              return ret;
   1069          }
   1070          /**
   1071           *	connsys_bus_disable_func - disable a SDIO function
   1072           *	@func: SDIO function to disable
   1073           *
   1074           *	Powers down and deactivates a SDIO function. Register access
   1075           *	to this function will fail until the function is reenabled.
   1076           */
   1077          int32_t connsys_bus_disable_func(struct connsys_func *func)
   1078          {
   1079              int32_t ret;
   1080              uint8_t reg;
   1081          
   1082              INFO(connsys, "SDIO: Disabling Function %d...\n", (int)func->num);
   1083          
   1084              reg = connsys_bus_fn0_read_byte(func, SDIO_CCCR_IOEx, &ret);
   1085              if (ret) {
   1086                  goto err;
   1087              }
   1088          
   1089              reg &= ~(1 << func->num);
   1090          
   1091              connsys_bus_fn0_write_byte(func, reg, SDIO_CCCR_IOEx, &ret);
   1092              if (ret) {
   1093                  goto err;
   1094              }
   1095          
   1096              INFO(connsys, "SDIO: Disabled Function %d\n", (int)func->num);
   1097          
   1098              return 0;
   1099          
   1100          err:
   1101              ret = -EIO;
   1102              INFO(connsys, "SDIO: Failed to Disable Function %d\n", (int)func->num);
   1103              return ret;
   1104          
   1105          }
   1106          
   1107          /**
   1108           *	connsys_bus_set_block_size - set the block size of an SDIO function
   1109           *	@func: SDIO function to change
   1110           *	@blksz: new block size or 0 to use the default.
   1111           *
   1112           *	The default block size is the largest supported by both the function
   1113           *	and the host, with a maximum of 512 to ensure that arbitrarily sized
   1114           *	data transfer use the optimal (least) number of commands.
   1115           *
   1116           *	A driver may call this to override the default block size set by the
   1117           *	core. This can be used to set a block size greater than the maximum
   1118           *	that reported by the card; it is the driver's responsibility to ensure
   1119           *	it uses a value that the card supports.
   1120           *
   1121           *	Returns 0 on success, -EINVAL if the host does not support the
   1122           *	requested block size, or -EIO (etc.) if one of the resultant FBR block
   1123           *	size register writes failed.
   1124           *
   1125           */
   1126          int32_t connsys_bus_set_block_size(struct connsys_func *func, uint32_t blksz)
   1127          {
   1128              int32_t ret;
   1129          
   1130              //ret = mmc_io_rw_direct(func->card, 1, 0,
   1131              //	SDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE,
   1132              //	blksz & 0xff, NULL);
   1133          
   1134              connsys_bus_fn0_write_byte(func, (blksz & 0xff),
   1135                                         SDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE, &ret);
   1136          
   1137              if (ret) {
   1138                  return ret;
   1139              }
   1140          
   1141              connsys_bus_fn0_write_byte(func, ((blksz >> 8) & 0xff),
   1142                                         SDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE + 1, &ret);
   1143          
   1144              if (ret) {
   1145                  return ret;
   1146              }
   1147              func->blksize = blksz;
   1148              return 0;
   1149          }
   1150          
   1151          /**
   1152           *	connsys_claim_irq - claim the IRQ for a SDIO function
   1153           *	@func: SDIO function
   1154           *	@handler: IRQ handler callback
   1155           *
   1156           *	Claim and activate the IRQ for the given SDIO function. The provided
   1157           *	handler will be called when that IRQ is asserted.  The host is always
   1158           *	claimed already when the handler is called so the handler must not
   1159           *	call connsys_claim_host() nor connsys_release_host().
   1160           */
   1161          int32_t connsys_bus_get_irq(struct connsys_func *func, connsys_irq_handler_t handler)
   1162          {
   1163              int32_t ret;
   1164              uint8_t reg = 0;
   1165          
   1166              INFO(connsys, "SDIO: Enabling IRQ for func%d...\n", (int)func->num);
   1167          
   1168              if (func->irq_callback) {
   1169                  ERR(connsys, "SDIO: IRQ for func%d already in use.\n", (int)func->num);
   1170                  return -2; //-EBUSY;
   1171              }
   1172          
   1173              reg = connsys_bus_fn0_read_byte(func, SDIO_CCCR_IENx, &ret);
   1174              if (ret) {
   1175                  return ret;
   1176              }
   1177          
   1178              reg |= 1 << func->num;
   1179          
   1180              reg |= 1; /* Master interrupt enable */
   1181              INFO(connsys, "Write IENx=0x%x\n", reg);
   1182              connsys_bus_fn0_write_byte(func, reg, SDIO_CCCR_IENx, &ret);
   1183              if (ret) {
   1184                  return ret;
   1185              }
   1186          
   1187              func->irq_callback = handler;
   1188          
   1189              reg = connsys_bus_fn0_read_byte(func, SDIO_CCCR_IENx, &ret);
   1190              if (ret) {
   1191                  return ret;
   1192              }
   1193              INFO(connsys, "===> IENx=0x%x\n", reg);
   1194              return ret;
   1195          }
   1196          
   1197          /**
   1198           *	connsys_bus_release_irq - release the IRQ for a SDIO function
   1199           *	@func: SDIO function
   1200           *
   1201           *	Disable and release the IRQ for the given SDIO function.
   1202           */
   1203          int32_t connsys_bus_release_irq(struct connsys_func *func)
   1204          {
   1205              int32_t ret;
   1206              uint8_t reg = 0;
   1207          
   1208              INFO(connsys, "SDIO: Disabling IRQ for func%d...\n", (int)func->num);
   1209          
   1210              if (func->irq_callback) {
   1211                  func->irq_callback = NULL;
   1212              }
   1213          
   1214              connsys_bus_fn0_read_byte(func, SDIO_CCCR_IENx, &ret);
   1215              if (ret) {
   1216                  return ret;
   1217              }
   1218          
   1219              reg &= ~(1 << func->num);
   1220          
   1221              /* Disable master interrupt with the last function interrupt */
   1222              if (!(reg & 0xFE)) {
   1223                  reg = 0;
   1224              }
   1225          
   1226              connsys_bus_fn0_write_byte(func, reg, SDIO_CCCR_IENx, &ret);
   1227              if (ret) {
   1228                  return ret;
   1229              }
   1230          
   1231              return 0;
   1232          }
   1233          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   connsys_bus_disable_func
        32   -- Indirect call
        32   -> connsys_bus_fn0_read_byte
        32   -> connsys_bus_fn0_write_byte
      40   connsys_bus_enable_func
        40   -- Indirect call
        40   -> connsys_bus_fn0_read_byte
        40   -> connsys_bus_fn0_write_byte
       0   connsys_bus_fn0_read_byte
      24   connsys_bus_fn0_write_byte
        24   -- Indirect call
       0   connsys_bus_get_bus
      40   connsys_bus_get_irq
        40   -- Indirect call
        40   -> connsys_bus_fn0_read_byte
        40   -> connsys_bus_fn0_write_byte
      32   connsys_bus_read_port
        32   -- Indirect call
        32   -> connsys_bus_read_port_dma
        32   -> connsys_bus_read_port_garbage
        32   -> connsys_bus_read_port_pio
       4   connsys_bus_read_port_dma
      16   connsys_bus_read_port_garbage
        16   -> connsys_bus_read_port_pio_garbage
      12   connsys_bus_read_port_pio
       0   connsys_bus_read_port_pio_garbage
       0   connsys_bus_readl
       0   connsys_bus_release_bus
      24   connsys_bus_release_irq
        24   -- Indirect call
        24   -> connsys_bus_fn0_read_byte
        24   -> connsys_bus_fn0_write_byte
      16   connsys_bus_set_block_size
        16   -> connsys_bus_fn0_write_byte
      40   connsys_bus_write_port
        40   -- Indirect call
        40   -> connsys_bus_write_port_dma
        40   -> connsys_bus_write_port_pio
        40   -> printf
       4   connsys_bus_write_port_dma
      16   connsys_bus_write_port_pio
        16   -> connsys_dump_cmd53_info
        16   -> printf
       8   connsys_bus_write_port_transfer
         0   -> connsys_bus_write_port_dma
         0   -> connsys_bus_write_port_pio
       4   connsys_bus_writel
      32   connsys_dump_cmd53_info
        32   -- Indirect call
      48   connsys_dump_tx_scatter_info
        48   -- Indirect call
       4   connsys_get_rx_buffer_size
      72   connsys_write_data
        72   -- Indirect call
        72   -> __aeabi_memcpy
        72   -> connsys_dump_cmd53_info
        72   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable56
       4  ??DataTable62
       4  ??DataTable62_1
       4  ??DataTable62_2
       4  ??DataTable62_3
       4  ??DataTable62_4
       4  ??DataTable62_5
       4  ??DataTable62_6
       4  ??DataTable62_7
       8  ?_0
      52  ?_1
      64  ?_10
      48  ?_11
      24  ?_12
       4  ?_13
      88  ?_14
       8  ?_15
       8  ?_16
      24  ?_17
     136  ?_18
      28  ?_19
      12  ?_2
      32  ?_20
      28  ?_21
      24  ?_22
      28  ?_23
      36  ?_24
      32  ?_25
      28  ?_26
      40  ?_27
      36  ?_28
      40  ?_29
      24  ?_3
      20  ?_30
      16  ?_31
      36  ?_32
      24  ?_4
      16  ?_5
      20  ?_6
      24  ?_7
      16  ?_8
      56  ?_9
     138  connsys_bus_disable_func
     230  connsys_bus_enable_func
      34  connsys_bus_fn0_read_byte
      70  connsys_bus_fn0_write_byte
       2  connsys_bus_get_bus
     208  connsys_bus_get_irq
     200  connsys_bus_read_port
     104  connsys_bus_read_port_dma
     122  connsys_bus_read_port_garbage
      72  connsys_bus_read_port_pio
      36  connsys_bus_read_port_pio_garbage
      48  connsys_bus_readl
       2  connsys_bus_release_bus
      78  connsys_bus_release_irq
      58  connsys_bus_set_block_size
     250  connsys_bus_write_port
      94  connsys_bus_write_port_dma
     100  connsys_bus_write_port_pio
      26  connsys_bus_write_port_transfer
      56  connsys_bus_writel
     206  connsys_dump_cmd53_info
     174  connsys_dump_tx_scatter_info
      46  connsys_get_rx_buffer_size
     604  connsys_write_data
      16  log_control_block_connsys
     248  -- Other

 
    16 bytes in section .data
    12 bytes in section .rodata
 4 310 bytes in section .text
 
 4 310 bytes of CODE  memory
    12 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: none
