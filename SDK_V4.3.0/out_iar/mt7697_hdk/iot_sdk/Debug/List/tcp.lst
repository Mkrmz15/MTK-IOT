###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:42
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\third_party\lwip\src\core\tcp.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EWB697.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\third_party\lwip\src\core\tcp.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\tcp.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\tcp.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\third_party\lwip\src\core\tcp.c
      1          /**
      2           * @file
      3           * Transmission Control Protocol for IP
      4           *
      5           * This file contains common functions for the TCP implementation, such as functinos
      6           * for manipulating the data structures and the TCP timer functions. TCP functions
      7           * related to input and output is found in tcp_in.c and tcp_out.c respectively.
      8           *
      9           */
     10          
     11          /*
     12           * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
     13           * All rights reserved. 
     14           * 
     15           * Redistribution and use in source and binary forms, with or without modification, 
     16           * are permitted provided that the following conditions are met:
     17           *
     18           * 1. Redistributions of source code must retain the above copyright notice,
     19           *    this list of conditions and the following disclaimer.
     20           * 2. Redistributions in binary form must reproduce the above copyright notice,
     21           *    this list of conditions and the following disclaimer in the documentation
     22           *    and/or other materials provided with the distribution.
     23           * 3. The name of the author may not be used to endorse or promote products
     24           *    derived from this software without specific prior written permission. 
     25           *
     26           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
     27           * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
     28           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
     29           * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
     30           * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
     31           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
     32           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
     33           * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
     34           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
     35           * OF SUCH DAMAGE.
     36           *
     37           * This file is part of the lwIP TCP/IP stack.
     38           * 
     39           * Author: Adam Dunkels <adam@sics.se>
     40           *
     41           */
     42          
     43          #include "lwip/opt.h"
     44          
     45          #if LWIP_TCP /* don't build if not configured for use in lwipopts.h */
     46          
     47          #include "lwip/def.h"
     48          #include "lwip/mem.h"
     49          #include "lwip/memp.h"
     50          #include "lwip/snmp.h"
     51          #include "lwip/tcp.h"
     52          #include "lwip/tcp_impl.h"
     53          #include "lwip/debug.h"
     54          #include "lwip/stats.h"
     55          #include "lwip/ip6.h"
     56          #include "lwip/ip6_addr.h"
     57          #include "lwip/nd6.h"
     58          
     59          #include <string.h>
     60          
     61          #ifndef TCP_LOCAL_PORT_RANGE_START
     62          /* From http://www.iana.org/assignments/port-numbers:
     63             "The Dynamic and/or Private Ports are those from 49152 through 65535" */
     64          #define TCP_LOCAL_PORT_RANGE_START        0xc000
     65          #define TCP_LOCAL_PORT_RANGE_END          0xffff
     66          #define TCP_ENSURE_LOCAL_PORT_RANGE(port) ((u16_t)(((port) & ~TCP_LOCAL_PORT_RANGE_START) + TCP_LOCAL_PORT_RANGE_START))
     67          #endif
     68          
     69          #if LWIP_TCP_KEEPALIVE
     70          #define TCP_KEEP_DUR(pcb)   ((pcb)->keep_cnt * (pcb)->keep_intvl)
     71          #define TCP_KEEP_INTVL(pcb) ((pcb)->keep_intvl)
     72          #else /* LWIP_TCP_KEEPALIVE */
     73          #define TCP_KEEP_DUR(pcb)   TCP_MAXIDLE
     74          #define TCP_KEEP_INTVL(pcb) TCP_KEEPINTVL_DEFAULT
     75          #endif /* LWIP_TCP_KEEPALIVE */
     76          
     77          const char * const tcp_state_str[] = {
     78            "CLOSED",      
     79            "LISTEN",      
     80            "SYN_SENT",    
     81            "SYN_RCVD",    
     82            "ESTABLISHED", 
     83            "FIN_WAIT_1",  
     84            "FIN_WAIT_2",  
     85            "CLOSE_WAIT",  
     86            "CLOSING",     
     87            "LAST_ACK",    
     88            "TIME_WAIT"   
     89          };
     90          
     91          /* last local TCP port */
     92          static u16_t tcp_port = TCP_LOCAL_PORT_RANGE_START;
     93          
     94          /* Incremented every coarse grained timer shot (typically every 500 ms). */
     95          u32_t tcp_ticks;
     96          const u8_t tcp_backoff[13] =
     97              { 1, 2, 3, 4, 5, 6, 7, 7, 7, 7, 7, 7, 7};
     98           /* Times per slowtmr hits */
     99          const u8_t tcp_persist_backoff[7] = { 3, 6, 12, 24, 48, 96, 120 };
    100          
    101          /* The TCP PCB lists. */
    102          
    103          /** List of all TCP PCBs bound but not yet (connected || listening) */
    104          struct tcp_pcb *tcp_bound_pcbs;
    105          /** List of all TCP PCBs in LISTEN state */
    106          union tcp_listen_pcbs_t tcp_listen_pcbs;
    107          /** List of all TCP PCBs that are in a state in which
    108           * they accept or send data. */
    109          struct tcp_pcb *tcp_active_pcbs;
    110          /** List of all TCP PCBs in TIME-WAIT state */
    111          struct tcp_pcb *tcp_tw_pcbs;
    112          
    113          #define NUM_TCP_PCB_LISTS               4
    114          #define NUM_TCP_PCB_LISTS_NO_TIME_WAIT  3
    115          /** An array with all (non-temporary) PCB lists, mainly used for smaller code size */
    116          struct tcp_pcb ** const tcp_pcb_lists[] = {&tcp_listen_pcbs.pcbs, &tcp_bound_pcbs,
    117            &tcp_active_pcbs, &tcp_tw_pcbs};
    118          
    119          /** Only used for temporary storage. */
    120          struct tcp_pcb *tcp_tmp_pcb;
    121          
    122          u8_t tcp_active_pcbs_changed;
    123          
    124          /** Timer counter to handle calling slow-timer from tcp_tmr() */ 
    125          //static u8_t tcp_timer;
    126          static u8_t tcp_timer_ctr;
    127          static u16_t tcp_new_port(void);
    128          
    129          /**
    130           * Initialize this module.
    131           */
    132          void
    133          tcp_init(void)
    134          {
    135          #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
    136            tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
    137          #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
    138          }
    139          
    140          /**
    141           * Called periodically to dispatch TCP timers.
    142           */
    143          void
    144          tcp_tmr(void)
    145          {
    146            /* Call tcp_fasttmr() every 250 ms */
    147            tcp_fasttmr();
    148          
    149            //if (++tcp_timer & 1) {
    150              /* Call tcp_slowtmr() every 500 ms, i.e., every other timer
    151                 tcp_tmr() is called. */
    152              tcp_slowtmr();
    153            //}
    154          }
    155          
    156          /**
    157           * Closes the TX side of a connection held by the PCB.
    158           * For tcp_close(), a RST is sent if the application didn't receive all data
    159           * (tcp_recved() not called for all data passed to recv callback).
    160           *
    161           * Listening pcbs are freed and may not be referenced any more.
    162           * Connection pcbs are freed if not yet connected and may not be referenced
    163           * any more. If a connection is established (at least SYN received or in
    164           * a closing state), the connection is closed, and put in a closing state.
    165           * The pcb is then automatically freed in tcp_slowtmr(). It is therefore
    166           * unsafe to reference it.
    167           *
    168           * @param pcb the tcp_pcb to close
    169           * @return ERR_OK if connection has been closed
    170           *         another err_t if closing failed and pcb is not freed
    171           */
    172          static err_t
    173          tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
    174          {
    175            err_t err;
    176          
    177            if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    178              if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
    179                /* Not all data received by application, send RST to tell the remote
    180                   side about this. */
    181                LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
    182          
    183                /* don't call tcp_abort here: we must not deallocate the pcb since
    184                   that might not be expected when calling tcp_close */
    185                tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    186                         pcb->local_port, pcb->remote_port);
    187          
    188                tcp_pcb_purge(pcb);
    189                TCP_RMV_ACTIVE(pcb);
    190                if (pcb->state == ESTABLISHED) {
    191                  /* move to TIME_WAIT since we close actively */
    192                  pcb->state = TIME_WAIT;
    193                  TCP_REG(&tcp_tw_pcbs, pcb);
    194                } else {
    195                  /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
    196                  if (tcp_input_pcb == pcb) {
    197                    /* prevent using a deallocated pcb: free it from tcp_input later */
    198                    tcp_trigger_input_pcb_close();
    199                  } else {
    200                    memp_free(MEMP_TCP_PCB, pcb);
    201                  }
    202                }
    203                return ERR_OK;
    204              }
    205            }
    206          
    207            switch (pcb->state) {
    208            case CLOSED:
    209              /* Closing a pcb in the CLOSED state might seem erroneous,
    210               * however, it is in this state once allocated and as yet unused
    211               * and the user needs some way to free it should the need arise.
    212               * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
    213               * or for a pcb that has been used and then entered the CLOSED state 
    214               * is erroneous, but this should never happen as the pcb has in those cases
    215               * been freed, and so any remaining handles are bogus. */
    216              err = ERR_OK;
    217              if (pcb->local_port != 0) {
    218                TCP_RMV(&tcp_bound_pcbs, pcb);
    219              }
    220              memp_free(MEMP_TCP_PCB, pcb);
    221              pcb = NULL;
    222              break;
    223            case LISTEN:
    224              err = ERR_OK;
    225              tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
    226              memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    227              pcb = NULL;
    228              break;
    229            case SYN_SENT:
    230              err = ERR_OK;
    231              TCP_PCB_REMOVE_ACTIVE(pcb);
    232              memp_free(MEMP_TCP_PCB, pcb);
    233              pcb = NULL;
    234              snmp_inc_tcpattemptfails();
    235              break;
    236            case SYN_RCVD:
    237              err = tcp_send_fin(pcb);
    238              if (err == ERR_OK) {
    239                snmp_inc_tcpattemptfails();
    240                pcb->state = FIN_WAIT_1;
    241              }
    242              break;
    243            case ESTABLISHED:
    244              err = tcp_send_fin(pcb);
    245              if (err == ERR_OK) {
    246                snmp_inc_tcpestabresets();
    247                pcb->state = FIN_WAIT_1;
    248              }
    249              break;
    250            case CLOSE_WAIT:
    251              err = tcp_send_fin(pcb);
    252              if (err == ERR_OK) {
    253                snmp_inc_tcpestabresets();
    254                pcb->state = LAST_ACK;
    255              }
    256              break;
    257            default:
    258              /* Has already been closed, do nothing. */
    259              err = ERR_OK;
    260              pcb = NULL;
    261              break;
    262            }
    263          
    264            if (pcb != NULL && err == ERR_OK) {
    265              /* To ensure all data has been sent when tcp_close returns, we have
    266                 to make sure tcp_output doesn't fail.
    267                 Since we don't really have to ensure all data has been sent when tcp_close
    268                 returns (unsent data is sent from tcp timer functions, also), we don't care
    269                 for the return value of tcp_output for now. */
    270              tcp_output(pcb);
    271            }
    272            return err;
    273          }
    274          
    275          /**
    276           * Closes the connection held by the PCB.
    277           *
    278           * Listening pcbs are freed and may not be referenced any more.
    279           * Connection pcbs are freed if not yet connected and may not be referenced
    280           * any more. If a connection is established (at least SYN received or in
    281           * a closing state), the connection is closed, and put in a closing state.
    282           * The pcb is then automatically freed in tcp_slowtmr(). It is therefore
    283           * unsafe to reference it (unless an error is returned).
    284           *
    285           * @param pcb the tcp_pcb to close
    286           * @return ERR_OK if connection has been closed
    287           *         another err_t if closing failed and pcb is not freed
    288           */
    289          err_t
    290          tcp_close(struct tcp_pcb *pcb)
    291          {
    292            LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
    293            tcp_debug_print_state(pcb->state);
    294          
    295            if (pcb->state != LISTEN) {
    296              /* Set a flag not to receive any more data... */
    297              pcb->flags |= TF_RXCLOSED;
    298            }
    299            /* ... and close */
    300            return tcp_close_shutdown(pcb, 1);
    301          }
    302          
    303          /**
    304           * Causes all or part of a full-duplex connection of this PCB to be shut down.
    305           * This doesn't deallocate the PCB unless shutting down both sides!
    306           * Shutting down both sides is the same as calling tcp_close, so if it succeds,
    307           * the PCB should not be referenced any more.
    308           *
    309           * @param pcb PCB to shutdown
    310           * @param shut_rx shut down receive side if this is != 0
    311           * @param shut_tx shut down send side if this is != 0
    312           * @return ERR_OK if shutdown succeeded (or the PCB has already been shut down)
    313           *         another err_t on error.
    314           */
    315          err_t
    316          tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
    317          {
    318            if (pcb->state == LISTEN) {
    319              return ERR_CONN;
    320            }
    321            if (shut_rx) {
    322              /* shut down the receive side: set a flag not to receive any more data... */
    323              pcb->flags |= TF_RXCLOSED;
    324              if (shut_tx) {
    325                /* shutting down the tx AND rx side is the same as closing for the raw API */
    326                return tcp_close_shutdown(pcb, 1);
    327              }
    328              /* ... and free buffered data */
    329              if (pcb->refused_data != NULL) {
    330                pbuf_free(pcb->refused_data);
    331                pcb->refused_data = NULL;
    332              }
    333            }
    334            if (shut_tx) {
    335              /* This can't happen twice since if it succeeds, the pcb's state is changed.
    336                 Only close in these states as the others directly deallocate the PCB */
    337              switch (pcb->state) {
    338              case SYN_RCVD:
    339              case ESTABLISHED:
    340              case CLOSE_WAIT:
    341                return tcp_close_shutdown(pcb, (u8_t)shut_rx);
    342              default:
    343                /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
    344                  into CLOSED state, where the PCB is deallocated. */
    345                return ERR_CONN;
    346              }
    347            }
    348            return ERR_OK;
    349          }
    350          
    351          /**
    352           * Abandons a connection and optionally sends a RST to the remote
    353           * host.  Deletes the local protocol control block. This is done when
    354           * a connection is killed because of shortage of memory.
    355           *
    356           * @param pcb the tcp_pcb to abort
    357           * @param reset boolean to indicate whether a reset should be sent
    358           */
    359          void
    360          tcp_abandon(struct tcp_pcb *pcb, int reset)
    361          {
    362            u32_t seqno, ackno;
    363          #if LWIP_CALLBACK_API
    364            tcp_err_fn errf;
    365          #endif /* LWIP_CALLBACK_API */
    366            void *errf_arg;
    367          
    368            /* pcb->state LISTEN not allowed here */
    369            LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
    370              pcb->state != LISTEN);
    371            /* Figure out on which TCP PCB list we are, and remove us. If we
    372               are in an active state, call the receive function associated with
    373               the PCB with a NULL argument, and send an RST to the remote end. */
    374            if (pcb->state == TIME_WAIT) {
    375              tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    376              memp_free(MEMP_TCP_PCB, pcb);
    377            } else {
    378              int send_rst = 0;
    379              u16_t local_port = 0;
    380              seqno = pcb->snd_nxt;
    381              ackno = pcb->rcv_nxt;
    382          #if LWIP_CALLBACK_API
    383              errf = pcb->errf;
    384          #endif /* LWIP_CALLBACK_API */
    385              errf_arg = pcb->callback_arg;
    386              if ((pcb->state == CLOSED) && (pcb->local_port != 0)) {
    387                /* bound, not yet opened */
    388                TCP_RMV(&tcp_bound_pcbs, pcb);
    389              } else {
    390                send_rst = reset;
    391                local_port = pcb->local_port;
    392                TCP_PCB_REMOVE_ACTIVE(pcb);
    393              }
    394              if (pcb->unacked != NULL) {
    395                tcp_segs_free(pcb->unacked);
    396              }
    397              if (pcb->unsent != NULL) {
    398                tcp_segs_free(pcb->unsent);
    399              }
    400          #if TCP_QUEUE_OOSEQ
    401              if (pcb->ooseq != NULL) {
    402                tcp_segs_free(pcb->ooseq);
    403              }
    404          #endif /* TCP_QUEUE_OOSEQ */
    405              if (send_rst) {
    406                LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
    407                tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
    408              }
    409              memp_free(MEMP_TCP_PCB, pcb);
    410              TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    411            }
    412          }
    413          
    414          /**
    415           * Aborts the connection by sending a RST (reset) segment to the remote
    416           * host. The pcb is deallocated. This function never fails.
    417           *
    418           * ATTENTION: When calling this from one of the TCP callbacks, make
    419           * sure you always return ERR_ABRT (and never return ERR_ABRT otherwise
    420           * or you will risk accessing deallocated memory or memory leaks!
    421           *
    422           * @param pcb the tcp pcb to abort
    423           */
    424          void
    425          tcp_abort(struct tcp_pcb *pcb)
    426          {
    427            tcp_abandon(pcb, 1);
    428          }
    429          
    430          /**
    431           * Binds the connection to a local port number and IP address. If the
    432           * IP address is not given (i.e., ipaddr == NULL), the IP address of
    433           * the outgoing network interface is used instead.
    434           *
    435           * @param pcb the tcp_pcb to bind (no check is done whether this pcb is
    436           *        already bound!)
    437           * @param ipaddr the local ip address to bind to (use IP_ADDR_ANY to bind
    438           *        to any local address
    439           * @param port the local port to bind to
    440           * @return ERR_USE if the port is already in use
    441           *         ERR_VAL if bind failed because the PCB is not in a valid state
    442           *         ERR_OK if bound
    443           */
    444          err_t
    445          tcp_bind(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
    446          {
    447            int i;
    448            int max_pcb_list = NUM_TCP_PCB_LISTS;
    449            struct tcp_pcb *cpcb;
    450          
    451            if ((pcb == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, ipaddr)) {
    452              return ERR_VAL;
    453            }
    454          
    455            LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
    456          
    457          #if SO_REUSE
    458            /* Unless the REUSEADDR flag is set,
    459               we have to check the pcbs in TIME-WAIT state, also.
    460               We do not dump TIME_WAIT pcb's; they can still be matched by incoming
    461               packets using both local and remote IP addresses and ports to distinguish.
    462             */
    463            if (ip_get_option(pcb, SOF_REUSEADDR)) {
    464              max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
    465            }
    466          #endif /* SO_REUSE */
    467          
    468            if (port == 0) {
    469              port = tcp_new_port();
    470              if (port == 0) {
    471                return ERR_BUF;
    472              }
    473            }
    474          
    475            /* Check if the address already is in use (on all lists) */
    476            for (i = 0; i < max_pcb_list; i++) {
    477              for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
    478                if (cpcb->local_port == port) {
    479          #if SO_REUSE
    480                  /* Omit checking for the same port if both pcbs have REUSEADDR set.
    481                     For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
    482                     tcp_connect. */
    483                  if (!ip_get_option(pcb, SOF_REUSEADDR) ||
    484                      !ip_get_option(cpcb, SOF_REUSEADDR))
    485          #endif /* SO_REUSE */
    486                  {
    487                    /* @todo: check accept_any_ip_version */
    488                    if (IP_PCB_IPVER_EQ(pcb, cpcb) &&
    489                        (ip_addr_isany(&cpcb->local_ip) ||
    490                        ip_addr_isany(ipaddr) ||
    491                        ip_addr_cmp(&cpcb->local_ip, ipaddr))) {
    492                      return ERR_USE;
    493                    }
    494                  }
    495                }
    496              }
    497            }
    498          
    499            if (!ip_addr_isany(ipaddr)) {
    500              ip_addr_set(&pcb->local_ip, ipaddr);
    501            }
    502            pcb->local_port = port;
    503            TCP_REG(&tcp_bound_pcbs, pcb);
    504            LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
    505            return ERR_OK;
    506          }
    507          #if LWIP_CALLBACK_API
    508          /**
    509           * Default accept callback if no accept callback is specified by the user.
    510           */
    511          static err_t
    512          tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
    513          {
    514            LWIP_UNUSED_ARG(arg);
    515            LWIP_UNUSED_ARG(err);
    516          
    517            tcp_abort(pcb);
    518          
    519            return ERR_ABRT;
    520          }
    521          #endif /* LWIP_CALLBACK_API */
    522          
    523          /**
    524           * Set the state of the connection to be LISTEN, which means that it
    525           * is able to accept incoming connections. The protocol control block
    526           * is reallocated in order to consume less memory. Setting the
    527           * connection to LISTEN is an irreversible process.
    528           *
    529           * @param pcb the original tcp_pcb
    530           * @param backlog the incoming connections queue limit
    531           * @return tcp_pcb used for listening, consumes less memory.
    532           *
    533           * @note The original tcp_pcb is freed. This function therefore has to be
    534           *       called like this:
    535           *             tpcb = tcp_listen(tpcb);
    536           */
    537          struct tcp_pcb *
    538          tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
    539          {
    540            struct tcp_pcb_listen *lpcb;
    541          
    542            LWIP_UNUSED_ARG(backlog);
    543            LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
    544          
    545            /* already listening? */
    546            if (pcb->state == LISTEN) {
    547              return pcb;
    548            }
    549          #if SO_REUSE
    550            if (ip_get_option(pcb, SOF_REUSEADDR)) {
    551              /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
    552                 is declared (listen-/connection-pcb), we have to make sure now that
    553                 this port is only used once for every local IP. */
    554              for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    555                if ((lpcb->local_port == pcb->local_port) &&
    556                    IP_PCB_IPVER_EQ(pcb, lpcb)) {
    557                  if (ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
    558                    /* this address/port is already used */
    559                    return NULL;
    560                  }
    561                }
    562              }
    563            }
    564          #endif /* SO_REUSE */
    565            lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
    566            if (lpcb == NULL) {
    567              return NULL;
    568            }
    569            lpcb->callback_arg = pcb->callback_arg;
    570            lpcb->local_port = pcb->local_port;
    571            lpcb->state = LISTEN;
    572            lpcb->prio = pcb->prio;
    573            lpcb->so_options = pcb->so_options;
    574            lpcb->ttl = pcb->ttl;
    575            lpcb->tos = pcb->tos;
    576          #if LWIP_IPV4 && LWIP_IPV6
    577            PCB_ISIPV6(lpcb) = PCB_ISIPV6(pcb);
    578            lpcb->accept_any_ip_version = 0;
    579          #endif /* LWIP_IPV4 && LWIP_IPV6 */
    580            ip_addr_copy(lpcb->local_ip, pcb->local_ip);
    581            if (pcb->local_port != 0) {
    582              TCP_RMV(&tcp_bound_pcbs, pcb);
    583            }
    584            memp_free(MEMP_TCP_PCB, pcb);
    585          #if LWIP_CALLBACK_API
    586            lpcb->accept = tcp_accept_null;
    587          #endif /* LWIP_CALLBACK_API */
    588          #if TCP_LISTEN_BACKLOG
    589            lpcb->accepts_pending = 0;
    590            lpcb->backlog = (backlog ? backlog : 1);
    591          #endif /* TCP_LISTEN_BACKLOG */
    592            TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
    593            return (struct tcp_pcb *)lpcb;
    594          }
    595          
    596          #if LWIP_IPV4 && LWIP_IPV6
    597          /**
    598           * Same as tcp_listen_with_backlog, but allows to accept IPv4 and IPv6
    599           * connections, if the pcb's local address is set to ANY.
    600           */
    601          struct tcp_pcb *
    602          tcp_listen_dual_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
    603          {
    604            struct tcp_pcb *lpcb;
    605            struct tcp_pcb_listen *l;
    606          
    607            if (pcb->local_port != 0) {
    608              /* Check that there's noone listening on this port already
    609                 (don't check the IP address since we'll set it to ANY */
    610              for(l = tcp_listen_pcbs.listen_pcbs; l != NULL; l = l->next) {
    611                if (l->local_port == pcb->local_port) {
    612                  /* this port is already used */
    613                  return NULL;
    614                }
    615              }
    616            }
    617          
    618            lpcb = tcp_listen_with_backlog(pcb, backlog);
    619            if ((lpcb != NULL) &&
    620                ip_addr_isany(&pcb->local_ip)) {
    621              /* The default behavior is to accept connections on either
    622               * IPv4 or IPv6, if not bound. */
    623              /* @see NETCONN_FLAG_IPV6_V6ONLY for changing this behavior */
    624              ((struct tcp_pcb_listen*)lpcb)->accept_any_ip_version = 1;
    625            }
    626            return lpcb;
    627          }
    628          #endif /* LWIP_IPV4 && LWIP_IPV6 */
    629          
    630          /**
    631           * Update the state that tracks the available window space to advertise.
    632           *
    633           * Returns how much extra window would be advertised if we sent an
    634           * update now.
    635           */
    636          u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
    637          {
    638            u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    639          
    640            if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    641              /* we can advertise more window */
    642              pcb->rcv_ann_wnd = pcb->rcv_wnd;
    643              return new_right_edge - pcb->rcv_ann_right_edge;
    644            } else {
    645              if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
    646                /* Can happen due to other end sending out of advertised window,
    647                 * but within actual available (but not yet advertised) window */
    648                pcb->rcv_ann_wnd = 0;
    649              } else {
    650                /* keep the right edge of window constant */
    651                u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
    652          #if !LWIP_WND_SCALE
    653                LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
    654          #endif
    655                pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
    656              }
    657              return 0;
    658            }
    659          }
    660          
    661          /**
    662           * This function should be called by the application when it has
    663           * processed the data. The purpose is to advertise a larger window
    664           * when the data has been processed.
    665           *
    666           * @param pcb the tcp_pcb for which data is read
    667           * @param len the amount of bytes that have been read by the application
    668           */
    669          void
    670          tcp_recved(struct tcp_pcb *pcb, u16_t len)
    671          {
    672            int wnd_inflation;
    673          
    674            /* pcb->state LISTEN not allowed here */
    675            LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    676              pcb->state != LISTEN);
    677          
    678            pcb->rcv_wnd += len;
    679            if (pcb->rcv_wnd > TCP_WND_MAX(pcb)) {
    680              pcb->rcv_wnd = TCP_WND_MAX(pcb);
    681            } else if(pcb->rcv_wnd == 0) {
    682              /* rcv_wnd overflowed */
    683              if ((pcb->state == CLOSE_WAIT) || (pcb->state == LAST_ACK)) {
    684                /* In passive close, we allow this, since the FIN bit is added to rcv_wnd
    685                   by the stack itself, since it is not mandatory for an application
    686                   to call tcp_recved() for the FIN bit, but e.g. the netconn API does so. */
    687                pcb->rcv_wnd = TCP_WND_MAX(pcb);
    688              } else {
    689                LWIP_ASSERT("tcp_recved: len wrapped rcv_wnd\n", 0);
    690              }
    691            }
    692          
    693            wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    694          
    695            /* If the change in the right edge of window is significant (default
    696             * watermark is TCP_WND/4), then send an explicit update now.
    697             * Otherwise wait for a packet to be sent in the normal course of
    698             * events (or more window to be available later) */
    699            if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    700              tcp_ack_now(pcb);
    701              tcp_output(pcb);
    702            }
    703          
    704            LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: received %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
    705                   len, pcb->rcv_wnd, TCP_WND_MAX(pcb) - pcb->rcv_wnd));
    706          }
    707          
    708          /**
    709           * Allocate a new local TCP port.
    710           *
    711           * @return a new (free) local TCP port number
    712           */
    713          static u16_t
    714          tcp_new_port(void)
    715          {
    716            u8_t i;
    717            u16_t n = 0;
    718            struct tcp_pcb *pcb;
    719            
    720          again:
    721            if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    722              tcp_port = TCP_LOCAL_PORT_RANGE_START;
    723            }
    724            /* Check all PCB lists. */
    725            for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    726              for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
    727                if (pcb->local_port == tcp_port) {
    728                  if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
    729                    return 0;
    730                  }
    731                  goto again;
    732                }
    733              }
    734            }
    735            return tcp_port;
    736          }
    737          
    738          /**
    739           * Connects to another host. The function given as the "connected"
    740           * argument will be called when the connection has been established.
    741           *
    742           * @param pcb the tcp_pcb used to establish the connection
    743           * @param ipaddr the remote ip address to connect to
    744           * @param port the remote tcp port to connect to
    745           * @param connected callback function to call when connected (on error,
    746                              the err calback will be called)
    747           * @return ERR_VAL if invalid arguments are given
    748           *         ERR_OK if connect request has been sent
    749           *         other err_t values if connect request couldn't be sent
    750           */
    751          err_t
    752          tcp_connect(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port,
    753                tcp_connected_fn connected)
    754          {
    755            err_t ret;
    756            u32_t iss;
    757            u16_t old_local_port;
    758          #if LWIP_IPV4 && LWIP_IPV6
    759            ip_addr_t local_ip_tmp;
    760          #endif /* LWIP_IPV4 && LWIP_IPV6 */
    761          
    762            if ((pcb == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, ipaddr)) {
    763              return ERR_VAL;
    764            }
    765          
    766            LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
    767          
    768            LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
    769            if (ipaddr != NULL) {
    770              ip_addr_set(&pcb->remote_ip, ipaddr);
    771            } else {
    772              return ERR_VAL;
    773            }
    774            pcb->remote_port = port;
    775          
    776            /* check if we have a route to the remote host */
    777            if (ip_addr_isany(&pcb->local_ip)) {
    778              /* no local IP address set, yet. */
    779              struct netif *netif;
    780              ip_addr_t *local_ip;
    781              ip_route_get_local_ip(PCB_ISIPV6(pcb), &pcb->local_ip, &pcb->remote_ip, netif, local_ip, &local_ip_tmp);
    782              if ((netif == NULL) || (local_ip == NULL)) {
    783                /* Don't even try to send a SYN packet if we have no route
    784                   since that will fail. */
    785                return ERR_RTE;
    786              }
    787              /* Use the address as local address of the pcb. */
    788              ip_addr_copy(pcb->local_ip, *local_ip);
    789            }
    790          
    791            old_local_port = pcb->local_port;
    792            if (pcb->local_port == 0) {
    793              pcb->local_port = tcp_new_port();
    794              if (pcb->local_port == 0) {
    795                return ERR_BUF;
    796              }
    797            }
    798          #if SO_REUSE
    799            if (ip_get_option(pcb, SOF_REUSEADDR)) {
    800              /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
    801                 now that the 5-tuple is unique. */
    802              struct tcp_pcb *cpcb;
    803              int i;
    804              /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    805              for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
    806                for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
    807                  if ((cpcb->local_port == pcb->local_port) &&
    808                      (cpcb->remote_port == port) &&
    809                      IP_PCB_IPVER_EQ(cpcb, pcb) &&
    810                      ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
    811                      ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
    812                    /* linux returns EISCONN here, but ERR_USE should be OK for us */
    813                    return ERR_USE;
    814                  }
    815                }
    816              }
    817            }
    818          #endif /* SO_REUSE */
    819            iss = tcp_next_iss();
    820            pcb->rcv_nxt = 0;
    821            pcb->snd_nxt = iss;
    822            pcb->lastack = iss - 1;
    823            pcb->snd_lbb = iss - 1;
    824            /* Start with a window that does not need scaling. When window scaling is
    825               enabled and used, the window is enlarged when both sides agree on scaling. */
    826            pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
    827            pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    828            pcb->snd_wnd = TCP_WND;
    829            /* As initial send MSS, we use TCP_MSS but limit it to 536.
    830               The send MSS is updated when an MSS option is received. */
    831            pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    832          #if TCP_CALCULATE_EFF_SEND_MSS
    833            pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip, PCB_ISIPV6(pcb));
    834          #endif /* TCP_CALCULATE_EFF_SEND_MSS */
    835            pcb->cwnd = 1;
    836            pcb->ssthresh = TCP_WND;
    837          #if LWIP_CALLBACK_API
    838            pcb->connected = connected;
    839          #else /* LWIP_CALLBACK_API */
    840            LWIP_UNUSED_ARG(connected);
    841          #endif /* LWIP_CALLBACK_API */
    842          
    843            /* Send a SYN together with the MSS option. */
    844            ret = tcp_enqueue_flags(pcb, TCP_SYN);
    845            if (ret == ERR_OK) {
    846              /* SYN segment was enqueued, changed the pcbs state now */
    847              pcb->state = SYN_SENT;
    848              if (old_local_port != 0) {
    849                TCP_RMV(&tcp_bound_pcbs, pcb);
    850              }
    851              TCP_REG_ACTIVE(pcb);
    852              snmp_inc_tcpactiveopens();
    853          
    854              tcp_output(pcb);
    855            }
    856            return ret;
    857          }
    858          
    859          /**
    860           * Called every 500 ms and implements the retransmission timer and the timer that
    861           * removes PCBs that have been in TIME-WAIT for enough time. It also increments
    862           * various timers such as the inactivity timer in each PCB.
    863           *
    864           * Automatically called from tcp_tmr().
    865           */
    866          void
    867          tcp_slowtmr(void)
    868          {
    869            struct tcp_pcb *pcb, *prev;
    870            tcpwnd_size_t eff_wnd;
    871            u8_t pcb_remove;      /* flag if a PCB should be removed */
    872            u8_t pcb_reset;       /* flag if a RST should be sent when removing */
    873            err_t err;
    874          
    875            err = ERR_OK;
    876          
    877            ++tcp_ticks;
    878            ++tcp_timer_ctr;
    879          
    880          tcp_slowtmr_start:
    881            /* Steps through all of the active PCBs. */
    882            prev = NULL;
    883            pcb = tcp_active_pcbs;
    884            if (pcb == NULL) {
    885              LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
    886            }
    887            while (pcb != NULL) {
    888              LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    889              LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    890              LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    891              LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    892              if (pcb->last_timer == tcp_timer_ctr) {
    893                /* skip this pcb, we have already processed it */
    894                pcb = pcb->next;
    895                continue;
    896              }
    897              pcb->last_timer = tcp_timer_ctr;
    898          
    899              pcb_remove = 0;
    900              pcb_reset = 0;
    901          
    902              if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    903                ++pcb_remove;
    904                LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    905              }
    906              else if (pcb->nrtx == TCP_MAXRTX) {
    907                ++pcb_remove;
    908                LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    909              } else {
    910                if (pcb->persist_backoff > 0) {
    911                  /* If snd_wnd is zero, use persist timer to send 1 byte probes
    912                   * instead of using the standard retransmission mechanism. */
    913                  u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff-1];
    914                  if (pcb->persist_cnt < backoff_cnt) {
    915                    pcb->persist_cnt++;
    916                  }
    917                  if (pcb->persist_cnt >= backoff_cnt) {
    918                    if (tcp_zero_window_probe(pcb) == ERR_OK) {
    919                      pcb->persist_cnt = 0;
    920                      if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
    921                        pcb->persist_backoff++;
    922                      }
    923                    }
    924                  }
    925                } else {
    926                  /* Increase the retransmission timer if it is running */
    927                  if(pcb->rtime >= 0) {
    928                    ++pcb->rtime;
    929                  }
    930          
    931                  if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
    932                    /* Time for a retransmission. */
    933                    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
    934                                                " pcb->rto %"S16_F"\n",
    935                                                pcb->rtime, pcb->rto));
    936          
    937                    /* Double retransmission time-out unless we are trying to
    938                     * connect to somebody (i.e., we are in SYN_SENT). */
    939                    if (pcb->state != SYN_SENT) {
    940                      pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
    941                    }
    942          
    943                    /* Reset the retransmission timer. */
    944                    pcb->rtime = 0;
    945          
    946                    /* Reduce congestion window and ssthresh. */
    947                    eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    948                    pcb->ssthresh = eff_wnd >> 1;
    949                    if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
    950                      pcb->ssthresh = (pcb->mss << 1);
    951                    }
    952                    pcb->cwnd = pcb->mss;
    953                    LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"TCPWNDSIZE_F
    954                                                 " ssthresh %"TCPWNDSIZE_F"\n",
    955                                                 pcb->cwnd, pcb->ssthresh));
    956          
    957                    /* The following needs to be called AFTER cwnd is set to one
    958                       mss - STJ */
    959                    tcp_rexmit_rto(pcb);
    960                  }
    961                }
    962              }
    963              /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    964              if (pcb->state == FIN_WAIT_2) {
    965                /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
    966                if (pcb->flags & TF_RXCLOSED) {
    967                  /* PCB was fully closed (either through close() or SHUT_RDWR):
    968                     normal FIN-WAIT timeout handling. */
    969                  if ((u32_t)(tcp_ticks - pcb->tmr) >
    970                      TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
    971                    ++pcb_remove;
    972                    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
    973                  }
    974                }
    975              }
    976          
    977              /* Check if KEEPALIVE should be sent */
    978              if(ip_get_option(pcb, SOF_KEEPALIVE) &&
    979                 ((pcb->state == ESTABLISHED) ||
    980                  (pcb->state == CLOSE_WAIT))) {
    981                if((u32_t)(tcp_ticks - pcb->tmr) >
    982                   (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
    983                {
    984                  LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to "));
    985                  ip_addr_debug_print(TCP_DEBUG, &pcb->remote_ip);
    986                  LWIP_DEBUGF(TCP_DEBUG, ("\n"));
    987                  
    988                  ++pcb_remove;
    989                  ++pcb_reset;
    990                } else if ((u32_t)(tcp_ticks - pcb->tmr) >
    991                        (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
    992                        / TCP_SLOW_INTERVAL)
    993                {
    994                  err = tcp_keepalive(pcb);
    995                  if (err == ERR_OK) {
    996                    pcb->keep_cnt_sent++;
    997                  }
    998                }
    999              }
   1000          
   1001              /* If this PCB has queued out of sequence data, but has been
   1002                 inactive for too long, will drop the data (it will eventually
   1003                 be retransmitted). */
   1004          #if TCP_QUEUE_OOSEQ
   1005              if (pcb->ooseq != NULL &&
   1006                  (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
   1007                tcp_segs_free(pcb->ooseq);
   1008                pcb->ooseq = NULL;
   1009                LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
   1010              }
   1011          #endif /* TCP_QUEUE_OOSEQ */
   1012          
   1013              /* Check if this PCB has stayed too long in SYN-RCVD */
   1014              if (pcb->state == SYN_RCVD) {
   1015                if ((u32_t)(tcp_ticks - pcb->tmr) >
   1016                    TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
   1017                  ++pcb_remove;
   1018                  LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
   1019                }
   1020              }
   1021          
   1022              /* Check if this PCB has stayed too long in LAST-ACK */
   1023              if (pcb->state == LAST_ACK) {
   1024                if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
   1025                  ++pcb_remove;
   1026                  LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
   1027                }
   1028              }
   1029          
   1030              /* If the PCB should be removed, do it. */
   1031              if (pcb_remove) {
   1032                struct tcp_pcb *pcb2;
   1033                tcp_err_fn err_fn;
   1034                void *err_arg;
   1035                tcp_pcb_purge(pcb);
   1036                /* Remove PCB from tcp_active_pcbs list. */
   1037                if (prev != NULL) {
   1038                  LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
   1039                  prev->next = pcb->next;
   1040                } else {
   1041                  /* This PCB was the first. */
   1042                  LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
   1043                  tcp_active_pcbs = pcb->next;
   1044                }
   1045          
   1046                if (pcb_reset) {
   1047                  tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
   1048                           pcb->local_port, pcb->remote_port);
   1049                }
   1050          
   1051                err_fn = pcb->errf;
   1052                err_arg = pcb->callback_arg;
   1053                pcb2 = pcb;
   1054                pcb = pcb->next;
   1055                memp_free(MEMP_TCP_PCB, pcb2);
   1056          
   1057                tcp_active_pcbs_changed = 0;
   1058                TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
   1059                if (tcp_active_pcbs_changed) {
   1060                  goto tcp_slowtmr_start;
   1061                }
   1062              } else {
   1063                /* get the 'next' element now and work with 'prev' below (in case of abort) */
   1064                prev = pcb;
   1065                pcb = pcb->next;
   1066          
   1067                /* We check if we should poll the connection. */
   1068                ++prev->polltmr;
   1069                if (prev->polltmr >= prev->pollinterval) {
   1070                  prev->polltmr = 0;
   1071                  LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
   1072                  tcp_active_pcbs_changed = 0;
   1073                  TCP_EVENT_POLL(prev, err);
   1074                  if (tcp_active_pcbs_changed) {
   1075                    goto tcp_slowtmr_start;
   1076                  }
   1077                  /* if err == ERR_ABRT, 'prev' is already deallocated */
   1078                  if (err == ERR_OK) {
   1079                    tcp_output(prev);
   1080                  }
   1081                }
   1082              }
   1083            }
   1084          
   1085            
   1086            /* Steps through all of the TIME-WAIT PCBs. */
   1087            prev = NULL;
   1088            pcb = tcp_tw_pcbs;
   1089            while (pcb != NULL) {
   1090              LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
   1091              pcb_remove = 0;
   1092          
   1093              /* Check if this PCB has stayed long enough in TIME-WAIT */
   1094              if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
   1095                ++pcb_remove;
   1096              }
   1097              
   1098              /* If the PCB should be removed, do it. */
   1099              if (pcb_remove) {
   1100                struct tcp_pcb *pcb2;
   1101                tcp_pcb_purge(pcb);
   1102                /* Remove PCB from tcp_tw_pcbs list. */
   1103                if (prev != NULL) {
   1104                  LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
   1105                  prev->next = pcb->next;
   1106                } else {
   1107                  /* This PCB was the first. */
   1108                  LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
   1109                  tcp_tw_pcbs = pcb->next;
   1110                }
   1111                pcb2 = pcb;
   1112                pcb = pcb->next;
   1113                memp_free(MEMP_TCP_PCB, pcb2);
   1114              } else {
   1115                prev = pcb;
   1116                pcb = pcb->next;
   1117              }
   1118            }
   1119          }
   1120          
   1121          /**
   1122           * Is called every TCP_FAST_INTERVAL (250 ms) and process data previously
   1123           * "refused" by upper layer (application) and sends delayed ACKs.
   1124           *
   1125           * Automatically called from tcp_tmr().
   1126           */
   1127          void
   1128          tcp_fasttmr(void)
   1129          {
   1130            struct tcp_pcb *pcb;
   1131          
   1132            ++tcp_timer_ctr;
   1133          
   1134          tcp_fasttmr_start:
   1135            pcb = tcp_active_pcbs;
   1136          
   1137            while(pcb != NULL) {
   1138              if (pcb->last_timer != tcp_timer_ctr) {
   1139                struct tcp_pcb *next;
   1140                pcb->last_timer = tcp_timer_ctr;
   1141                /* send delayed ACKs */
   1142                if (pcb->flags & TF_ACK_DELAY) {
   1143                  LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
   1144                  tcp_ack_now(pcb);
   1145                  tcp_output(pcb);
   1146                  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
   1147                }
   1148          
   1149                next = pcb->next;
   1150          
   1151                /* If there is data which was previously "refused" by upper layer */
   1152                if (pcb->refused_data != NULL) {
   1153                  tcp_active_pcbs_changed = 0;
   1154                  tcp_process_refused_data(pcb);
   1155                  if (tcp_active_pcbs_changed) {
   1156                    /* application callback has changed the pcb list: restart the loop */
   1157                    goto tcp_fasttmr_start;
   1158                  }
   1159                }
   1160                pcb = next;
   1161              } else {
   1162                pcb = pcb->next;
   1163              }
   1164            }
   1165          }
   1166          
   1167          /** Call tcp_output for all active pcbs that have TF_NAGLEMEMERR set */
   1168          void
   1169          tcp_txnow(void)
   1170          {
   1171            struct tcp_pcb *pcb;
   1172          
   1173            for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
   1174              if (pcb->flags & TF_NAGLEMEMERR) {
   1175                tcp_output(pcb);
   1176              }
   1177            }
   1178          }
   1179          
   1180          /** Pass pcb->refused_data to the recv callback */
   1181          err_t
   1182          tcp_process_refused_data(struct tcp_pcb *pcb)
   1183          {
   1184          #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
   1185            struct pbuf *rest;
   1186            while (pcb->refused_data != NULL)
   1187          #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
   1188            {
   1189              err_t err;
   1190              u8_t refused_flags = pcb->refused_data->flags;
   1191              /* set pcb->refused_data to NULL in case the callback frees it and then
   1192                 closes the pcb */
   1193              struct pbuf *refused_data = pcb->refused_data;
   1194          #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
   1195              pbuf_split_64k(refused_data, &rest);
   1196              pcb->refused_data = rest;
   1197          #else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
   1198              pcb->refused_data = NULL;
   1199          #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
   1200              /* Notify again application with data previously received. */
   1201              LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
   1202              TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
   1203              if (err == ERR_OK) {
   1204                /* did refused_data include a FIN? */
   1205                if (refused_flags & PBUF_FLAG_TCP_FIN
   1206          #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
   1207                    && (rest == NULL)
   1208          #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
   1209                   ) {
   1210                  /* correct rcv_wnd as the application won't call tcp_recved()
   1211                     for the FIN's seqno */
   1212                  if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
   1213                    pcb->rcv_wnd++;
   1214                  }
   1215                  TCP_EVENT_CLOSED(pcb, err);
   1216                  if (err == ERR_ABRT) {
   1217                    return ERR_ABRT;
   1218                  }
   1219                }
   1220              } else if (err == ERR_ABRT) {
   1221                /* if err == ERR_ABRT, 'pcb' is already deallocated */
   1222                /* Drop incoming packets because pcb is "full" (only if the incoming
   1223                   segment contains data). */
   1224                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
   1225                return ERR_ABRT;
   1226              } else {
   1227                /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
   1228          #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
   1229                if (rest != NULL) {
   1230                  pbuf_cat(refused_data, rest);
   1231                }
   1232          #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
   1233                pcb->refused_data = refused_data;
   1234                return ERR_INPROGRESS;
   1235              }
   1236            }
   1237            return ERR_OK;
   1238          }
   1239          
   1240          /**
   1241           * Deallocates a list of TCP segments (tcp_seg structures).
   1242           *
   1243           * @param seg tcp_seg list of TCP segments to free
   1244           */
   1245          void
   1246          tcp_segs_free(struct tcp_seg *seg)
   1247          {
   1248            while (seg != NULL) {
   1249              struct tcp_seg *next = seg->next;
   1250              tcp_seg_free(seg);
   1251              seg = next;
   1252            }
   1253          }
   1254          
   1255          /**
   1256           * Frees a TCP segment (tcp_seg structure).
   1257           *
   1258           * @param seg single tcp_seg to free
   1259           */
   1260          void
   1261          tcp_seg_free(struct tcp_seg *seg)
   1262          {
   1263            if (seg != NULL) {
   1264              if (seg->p != NULL) {
   1265                pbuf_free(seg->p);
   1266          #if TCP_DEBUG
   1267                seg->p = NULL;
   1268          #endif /* TCP_DEBUG */
   1269              }
   1270              memp_free(MEMP_TCP_SEG, seg);
   1271            }
   1272          }
   1273          
   1274          /**
   1275           * Sets the priority of a connection.
   1276           *
   1277           * @param pcb the tcp_pcb to manipulate
   1278           * @param prio new priority
   1279           */
   1280          void
   1281          tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
   1282          {
   1283            pcb->prio = prio;
   1284          }
   1285          
   1286          #if TCP_QUEUE_OOSEQ
   1287          /**
   1288           * Returns a copy of the given TCP segment.
   1289           * The pbuf and data are not copied, only the pointers
   1290           *
   1291           * @param seg the old tcp_seg
   1292           * @return a copy of seg
   1293           */ 
   1294          struct tcp_seg *
   1295          tcp_seg_copy(struct tcp_seg *seg)
   1296          {
   1297            struct tcp_seg *cseg;
   1298          
   1299            cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
   1300            if (cseg == NULL) {
   1301              return NULL;
   1302            }
   1303            SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
   1304            pbuf_ref(cseg->p);
   1305            return cseg;
   1306          }
   1307          #endif /* TCP_QUEUE_OOSEQ */
   1308          
   1309          #if LWIP_CALLBACK_API
   1310          /**
   1311           * Default receive callback that is called if the user didn't register
   1312           * a recv callback for the pcb.
   1313           */
   1314          err_t
   1315          tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
   1316          {
   1317            LWIP_UNUSED_ARG(arg);
   1318            if (p != NULL) {
   1319              tcp_recved(pcb, p->tot_len);
   1320              pbuf_free(p);
   1321            } else if (err == ERR_OK) {
   1322              return tcp_close(pcb);
   1323            }
   1324            return ERR_OK;
   1325          }
   1326          #endif /* LWIP_CALLBACK_API */
   1327          
   1328          /**
   1329           * Kills the oldest active connection that has the same or lower priority than
   1330           * 'prio'.
   1331           *
   1332           * @param prio minimum priority
   1333           */
   1334          static void
   1335          tcp_kill_prio(u8_t prio)
   1336          {
   1337            struct tcp_pcb *pcb, *inactive;
   1338            u32_t inactivity;
   1339            u8_t mprio;
   1340          
   1341            mprio = TCP_PRIO_MAX;
   1342            
   1343            /* We kill the oldest active connection that has lower priority than prio. */
   1344            inactivity = 0;
   1345            inactive = NULL;
   1346            for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
   1347              if (pcb->prio <= prio &&
   1348                 pcb->prio <= mprio &&
   1349                 (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
   1350                inactivity = tcp_ticks - pcb->tmr;
   1351                inactive = pcb;
   1352                mprio = pcb->prio;
   1353              }
   1354            }
   1355            if (inactive != NULL) {
   1356              LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
   1357                     (void *)inactive, inactivity));
   1358              tcp_abort(inactive);
   1359            }
   1360          }
   1361          
   1362          /**
   1363           * Kills the oldest connection that is in specific state.
   1364           * Called from tcp_alloc() for LAST_ACK and CLOSING if no more connections are available.
   1365           */
   1366          static void
   1367          tcp_kill_state(enum tcp_state state)
   1368          {
   1369            struct tcp_pcb *pcb, *inactive;
   1370            u32_t inactivity;
   1371          
   1372            LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
   1373          
   1374            inactivity = 0;
   1375            inactive = NULL;
   1376            /* Go through the list of active pcbs and get the oldest pcb that is in state
   1377               CLOSING/LAST_ACK. */
   1378            for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
   1379              if (pcb->state == state) {
   1380                if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
   1381                  inactivity = tcp_ticks - pcb->tmr;
   1382                  inactive = pcb;
   1383                }
   1384              }
   1385            }
   1386            if (inactive != NULL) {
   1387              LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_closing: killing oldest %s PCB %p (%"S32_F")\n",
   1388                     tcp_state_str[state], (void *)inactive, inactivity));
   1389              /* Don't send a RST, since no data is lost. */
   1390              tcp_abandon(inactive, 0);
   1391            }
   1392          }
   1393          
   1394          /**
   1395           * Kills the oldest connection that is in TIME_WAIT state.
   1396           * Called from tcp_alloc() if no more connections are available.
   1397           */
   1398          static void
   1399          tcp_kill_timewait(void)
   1400          {
   1401            struct tcp_pcb *pcb, *inactive;
   1402            u32_t inactivity;
   1403          
   1404            inactivity = 0;
   1405            inactive = NULL;
   1406            /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
   1407            for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
   1408              if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
   1409                inactivity = tcp_ticks - pcb->tmr;
   1410                inactive = pcb;
   1411              }
   1412            }
   1413            if (inactive != NULL) {
   1414              LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
   1415                     (void *)inactive, inactivity));
   1416              tcp_abort(inactive);
   1417            }
   1418          }
   1419          
   1420          /**
   1421           * Allocate a new tcp_pcb structure.
   1422           *
   1423           * @param prio priority for the new pcb
   1424           * @return a new tcp_pcb that initially is in state CLOSED
   1425           */
   1426          struct tcp_pcb *
   1427          tcp_alloc(u8_t prio)
   1428          {
   1429            struct tcp_pcb *pcb;
   1430            u32_t iss;
   1431          
   1432            pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
   1433            if (pcb == NULL) {
   1434              /* Try killing oldest connection in TIME-WAIT. */
   1435              LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
   1436              tcp_kill_timewait();
   1437              /* Try to allocate a tcp_pcb again. */
   1438              pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
   1439              if (pcb == NULL) {
   1440                /* Try killing oldest connection in LAST-ACK (these wouldn't go to TIME-WAIT). */
   1441                LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest LAST-ACK connection\n"));
   1442                tcp_kill_state(LAST_ACK);
   1443                /* Try to allocate a tcp_pcb again. */
   1444                pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
   1445                if (pcb == NULL) {
   1446                  /* Try killing oldest connection in CLOSING. */
   1447                  LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest CLOSING connection\n"));
   1448                  tcp_kill_state(CLOSING);
   1449                  /* Try to allocate a tcp_pcb again. */
   1450                  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
   1451                  if (pcb == NULL) {
   1452                    /* Try killing active connections with lower priority than the new one. */
   1453                    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
   1454                    tcp_kill_prio(prio);
   1455                    /* Try to allocate a tcp_pcb again. */
   1456                    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
   1457                    if (pcb != NULL) {
   1458                      /* adjust err stats: memp_malloc failed multiple times before */
   1459                      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
   1460                    }
   1461                  }
   1462                  if (pcb != NULL) {
   1463                    /* adjust err stats: memp_malloc failed multiple times before */
   1464                    MEMP_STATS_DEC(err, MEMP_TCP_PCB);
   1465                  }
   1466                }
   1467                if (pcb != NULL) {
   1468                  /* adjust err stats: memp_malloc failed multiple times before */
   1469                  MEMP_STATS_DEC(err, MEMP_TCP_PCB);
   1470                }
   1471              }
   1472              if (pcb != NULL) {
   1473                /* adjust err stats: memp_malloc failed above */
   1474                MEMP_STATS_DEC(err, MEMP_TCP_PCB);
   1475              }
   1476            }
   1477            if (pcb != NULL) {
   1478              memset(pcb, 0, sizeof(struct tcp_pcb));
   1479              pcb->prio = prio;
   1480              pcb->snd_buf = TCP_SND_BUF;
   1481              pcb->snd_queuelen = 0;
   1482              /* Start with a window that does not need scaling. When window scaling is
   1483                 enabled and used, the window is enlarged when both sides agree on scaling. */
   1484              pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
   1485          #if LWIP_WND_SCALE
   1486              /* snd_scale and rcv_scale are zero unless both sides agree to use scaling */
   1487              pcb->snd_scale = 0;
   1488              pcb->rcv_scale = 0;
   1489          #endif
   1490              pcb->tos = 0;
   1491              pcb->ttl = TCP_TTL;
   1492              /* As initial send MSS, we use TCP_MSS but limit it to 536.
   1493                 The send MSS is updated when an MSS option is received. */
   1494              pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
   1495              pcb->rto = 1;
   1496              pcb->sa = 0;
   1497              pcb->sv = 1;
   1498              pcb->rtime = -1;
   1499              pcb->cwnd = 1;
   1500              iss = tcp_next_iss();
   1501              pcb->snd_wl2 = iss;
   1502              pcb->snd_nxt = iss;
   1503              pcb->lastack = iss;
   1504              pcb->snd_lbb = iss;   
   1505              pcb->tmr = tcp_ticks;
   1506              pcb->last_timer = tcp_timer_ctr;
   1507          
   1508              pcb->polltmr = 0;
   1509          
   1510          #if LWIP_CALLBACK_API
   1511              pcb->recv = tcp_recv_null;
   1512          #endif /* LWIP_CALLBACK_API */  
   1513              
   1514              /* Init KEEPALIVE timer */
   1515              pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
   1516              
   1517          #if LWIP_TCP_KEEPALIVE
   1518              pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
   1519              pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
   1520          #endif /* LWIP_TCP_KEEPALIVE */
   1521          
   1522              pcb->keep_cnt_sent = 0;
   1523            }
   1524            return pcb;
   1525          }
   1526          
   1527          /**
   1528           * Creates a new TCP protocol control block but doesn't place it on
   1529           * any of the TCP PCB lists.
   1530           * The pcb is not put on any list until binding using tcp_bind().
   1531           *
   1532           * @internal: Maybe there should be a idle TCP PCB list where these
   1533           * PCBs are put on. Port reservation using tcp_bind() is implemented but
   1534           * allocated pcbs that are not bound can't be killed automatically if wanting
   1535           * to allocate a pcb with higher prio (@see tcp_kill_prio())
   1536           *
   1537           * @return a new tcp_pcb that initially is in state CLOSED
   1538           */
   1539          struct tcp_pcb *
   1540          tcp_new(void)
   1541          {
   1542            return tcp_alloc(TCP_PRIO_NORMAL);
   1543          }
   1544          
   1545          #if LWIP_IPV6
   1546          /**
   1547           * Creates a new TCP-over-IPv6 protocol control block but doesn't
   1548           * place it on any of the TCP PCB lists.
   1549           * The pcb is not put on any list until binding using tcp_bind().
   1550           *
   1551           * @return a new tcp_pcb that initially is in state CLOSED
   1552           */
   1553          struct tcp_pcb *
   1554          tcp_new_ip6(void)
   1555          {
   1556            struct tcp_pcb * pcb;
   1557            pcb = tcp_alloc(TCP_PRIO_NORMAL);
   1558          #if LWIP_IPV4
   1559            ip_set_v6(pcb, 1);
   1560          #endif /* LWIP_IPV4 */
   1561            return pcb;
   1562          }
   1563          #endif /* LWIP_IPV6 */
   1564          
   1565          /**
   1566           * Used to specify the argument that should be passed callback
   1567           * functions.
   1568           *
   1569           * @param pcb tcp_pcb to set the callback argument
   1570           * @param arg void pointer argument to pass to callback functions
   1571           */ 
   1572          void
   1573          tcp_arg(struct tcp_pcb *pcb, void *arg)
   1574          {
   1575            /* This function is allowed to be called for both listen pcbs and
   1576               connection pcbs. */
   1577            pcb->callback_arg = arg;
   1578          }
   1579          #if LWIP_CALLBACK_API
   1580          
   1581          /**
   1582           * Used to specify the function that should be called when a TCP
   1583           * connection receives data.
   1584           *
   1585           * @param pcb tcp_pcb to set the recv callback
   1586           * @param recv callback function to call for this pcb when data is received
   1587           */ 
   1588          void
   1589          tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
   1590          {
   1591            LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
   1592            pcb->recv = recv;
   1593          }
   1594          
   1595          /**
   1596           * Used to specify the function that should be called when TCP data
   1597           * has been successfully delivered to the remote host.
   1598           *
   1599           * @param pcb tcp_pcb to set the sent callback
   1600           * @param sent callback function to call for this pcb when data is successfully sent
   1601           */ 
   1602          void
   1603          tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
   1604          {
   1605            LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
   1606            pcb->sent = sent;
   1607          }
   1608          
   1609          /**
   1610           * Used to specify the function that should be called when a fatal error
   1611           * has occurred on the connection.
   1612           *
   1613           * @param pcb tcp_pcb to set the err callback
   1614           * @param err callback function to call for this pcb when a fatal error
   1615           *        has occurred on the connection
   1616           */ 
   1617          void
   1618          tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
   1619          {
   1620            LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
   1621            pcb->errf = err;
   1622          }
   1623          
   1624          /**
   1625           * Used for specifying the function that should be called when a
   1626           * LISTENing connection has been connected to another host.
   1627           *
   1628           * @param pcb tcp_pcb to set the accept callback
   1629           * @param accept callback function to call for this pcb when LISTENing
   1630           *        connection has been connected to another host
   1631           */ 
   1632          void
   1633          tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
   1634          {
   1635            /* This function is allowed to be called for both listen pcbs and
   1636               connection pcbs. */
   1637            pcb->accept = accept;
   1638          }
   1639          #endif /* LWIP_CALLBACK_API */
   1640          
   1641          
   1642          /**
   1643           * Used to specify the function that should be called periodically
   1644           * from TCP. The interval is specified in terms of the TCP coarse
   1645           * timer interval, which is called twice a second.
   1646           *
   1647           */ 
   1648          void
   1649          tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
   1650          {
   1651            LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
   1652          #if LWIP_CALLBACK_API
   1653            pcb->poll = poll;
   1654          #else /* LWIP_CALLBACK_API */  
   1655            LWIP_UNUSED_ARG(poll);
   1656          #endif /* LWIP_CALLBACK_API */  
   1657            pcb->pollinterval = interval;
   1658          }
   1659          
   1660          /**
   1661           * Purges a TCP PCB. Removes any buffered data and frees the buffer memory
   1662           * (pcb->ooseq, pcb->unsent and pcb->unacked are freed).
   1663           *
   1664           * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
   1665           */
   1666          void
   1667          tcp_pcb_purge(struct tcp_pcb *pcb)
   1668          {
   1669            if (pcb->state != CLOSED &&
   1670               pcb->state != TIME_WAIT &&
   1671               pcb->state != LISTEN) {
   1672          
   1673              LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
   1674          
   1675          #if TCP_LISTEN_BACKLOG
   1676              if (pcb->state == SYN_RCVD) {
   1677                /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
   1678                struct tcp_pcb_listen *lpcb;
   1679                LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
   1680                  tcp_listen_pcbs.listen_pcbs != NULL);
   1681                for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
   1682                  if ((lpcb->local_port == pcb->local_port) &&
   1683                      IP_PCB_IPVER_EQ(pcb, lpcb) &&
   1684                      (ip_addr_isany(&lpcb->local_ip) ||
   1685                       ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
   1686                      /* port and address of the listen pcb match the timed-out pcb */
   1687                      LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
   1688                        lpcb->accepts_pending > 0);
   1689                      lpcb->accepts_pending--;
   1690                      break;
   1691                    }
   1692                }
   1693              }
   1694          #endif /* TCP_LISTEN_BACKLOG */
   1695          
   1696          
   1697              if (pcb->refused_data != NULL) {
   1698                LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
   1699                pbuf_free(pcb->refused_data);
   1700                pcb->refused_data = NULL;
   1701              }
   1702              if (pcb->unsent != NULL) {
   1703                LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
   1704              }
   1705              if (pcb->unacked != NULL) {
   1706                LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
   1707              }
   1708          #if TCP_QUEUE_OOSEQ
   1709              if (pcb->ooseq != NULL) {
   1710                LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
   1711              }
   1712              tcp_segs_free(pcb->ooseq);
   1713              pcb->ooseq = NULL;
   1714          #endif /* TCP_QUEUE_OOSEQ */
   1715          
   1716              /* Stop the retransmission timer as it will expect data on unacked
   1717                 queue if it fires */
   1718              pcb->rtime = -1;
   1719          
   1720              tcp_segs_free(pcb->unsent);
   1721              tcp_segs_free(pcb->unacked);
   1722              pcb->unacked = pcb->unsent = NULL;
   1723          #if TCP_OVERSIZE
   1724              pcb->unsent_oversize = 0;
   1725          #endif /* TCP_OVERSIZE */
   1726            }
   1727          }
   1728          
   1729          /**
   1730           * Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.
   1731           *
   1732           * @param pcblist PCB list to purge.
   1733           * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
   1734           */
   1735          void
   1736          tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
   1737          {
   1738            TCP_RMV(pcblist, pcb);
   1739          
   1740            tcp_pcb_purge(pcb);
   1741          
   1742            /* if there is an outstanding delayed ACKs, send it */
   1743            if (pcb->state != TIME_WAIT &&
   1744               pcb->state != LISTEN &&
   1745               pcb->flags & TF_ACK_DELAY) {
   1746              pcb->flags |= TF_ACK_NOW;
   1747              tcp_output(pcb);
   1748            }
   1749          
   1750            if (pcb->state != LISTEN) {
   1751              LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
   1752              LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
   1753          #if TCP_QUEUE_OOSEQ
   1754              LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
   1755          #endif /* TCP_QUEUE_OOSEQ */
   1756            }
   1757          
   1758            pcb->state = CLOSED;
   1759            /* reset the local port to prevent the pcb from being 'bound' */
   1760            pcb->local_port = 0;
   1761          
   1762            LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
   1763          }
   1764          
   1765          /**
   1766           * Calculates a new initial sequence number for new connections.
   1767           *
   1768           * @return u32_t pseudo random sequence number
   1769           */
   1770          u32_t
   1771          tcp_next_iss(void)
   1772          {
   1773            static u32_t iss = 6510;
   1774            
   1775            iss += tcp_ticks;       /* XXX */
   1776            return iss;
   1777          }
   1778          
   1779          #if TCP_CALCULATE_EFF_SEND_MSS
   1780          /**
   1781           * Calculates the effective send mss that can be used for a specific IP address
   1782           * by using ip_route to determine the netif used to send to the address and
   1783           * calculating the minimum of TCP_MSS and that netif's mtu (if set).
   1784           */
   1785          u16_t
   1786          tcp_eff_send_mss_impl(u16_t sendmss, const ip_addr_t *dest
   1787          #if LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING
   1788                               , const ip_addr_t *src
   1789          #endif /* LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING */
   1790          #if LWIP_IPV6 && LWIP_IPV4
   1791                               , u8_t isipv6
   1792          #endif /* LWIP_IPV6 && LWIP_IPV4 */
   1793                               )
   1794          {
   1795            u16_t mss_s;
   1796            struct netif *outif;
   1797            s16_t mtu;
   1798          
   1799            outif = ip_route(isipv6, src, dest);
   1800          #if LWIP_IPV6
   1801          #if LWIP_IPV4
   1802            if (isipv6)
   1803          #endif /* LWIP_IPV4 */
   1804            {
   1805              /* First look in destination cache, to see if there is a Path MTU. */
   1806              mtu = nd6_get_destination_mtu(ip_2_ip6(dest), outif);
   1807            }
   1808          #if LWIP_IPV4
   1809            else
   1810          #endif /* LWIP_IPV4 */
   1811          #endif /* LWIP_IPV6 */
   1812          #if LWIP_IPV4
   1813            {
   1814              if (outif == NULL) {
   1815                return sendmss;
   1816              }
   1817              mtu = outif->mtu;
   1818            }
   1819          #endif /* LWIP_IPV4 */
   1820          
   1821            if (mtu != 0) {
   1822          #if LWIP_IPV6
   1823          #if LWIP_IPV4
   1824              if (isipv6)
   1825          #endif /* LWIP_IPV4 */
   1826              {
   1827                mss_s = mtu - IP6_HLEN - TCP_HLEN;
   1828              }
   1829          #if LWIP_IPV4
   1830              else
   1831          #endif /* LWIP_IPV4 */
   1832          #endif /* LWIP_IPV6 */
   1833          #if LWIP_IPV4
   1834              {
   1835                mss_s = mtu - IP_HLEN - TCP_HLEN;
   1836              }
   1837          #endif /* LWIP_IPV4 */
   1838              /* RFC 1122, chap 4.2.2.6:
   1839               * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
   1840               * We correct for TCP options in tcp_write(), and don't support IP options.
   1841               */
   1842              sendmss = LWIP_MIN(sendmss, mss_s);
   1843            }
   1844            return sendmss;
   1845          }
   1846          #endif /* TCP_CALCULATE_EFF_SEND_MSS */
   1847          
   1848          #if LWIP_IPV4
   1849          /** Helper function for tcp_netif_ipv4_addr_changed() that iterates a pcb list */
   1850          static void
   1851          tcp_netif_ipv4_addr_changed_pcblist(const ip4_addr_t* old_addr, struct tcp_pcb* pcb_list)
   1852          {
   1853            struct tcp_pcb *pcb;
   1854            pcb = pcb_list;
   1855            while (pcb != NULL) {
   1856              /* PCB bound to current local interface address? */
   1857              if (!IP_IS_V6_VAL(pcb->local_ip) && ip4_addr_cmp(ip_2_ip4(&pcb->local_ip), old_addr)
   1858          #if LWIP_AUTOIP
   1859                /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
   1860                && !ip4_addr_islinklocal(ip_2_ip4(&pcb->local_ip))
   1861          #endif /* LWIP_AUTOIP */
   1862                ) {
   1863                /* this connection must be aborted */
   1864                struct tcp_pcb *next = pcb->next;
   1865                LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
   1866                tcp_abort(pcb);
   1867                pcb = next;
   1868              } else {
   1869                pcb = pcb->next;
   1870              }
   1871            }
   1872          }
   1873          
   1874          /** This function is called from netif.c when address is changed or netif is removed
   1875           *
   1876           * @param old_addr IPv4 address of the netif before change
   1877           * @param new_addr IPv4 address of the netif after change or NULL if netif has been removed
   1878           */
   1879          void tcp_netif_ipv4_addr_changed(const ip4_addr_t* old_addr, const ip4_addr_t* new_addr)
   1880          {
   1881            struct tcp_pcb_listen *lpcb, *next;
   1882          
   1883            tcp_netif_ipv4_addr_changed_pcblist(old_addr, tcp_active_pcbs);
   1884            tcp_netif_ipv4_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
   1885          
   1886            if (!ip4_addr_isany(new_addr)) {
   1887              /* PCB bound to current local interface address? */
   1888              for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = next) {
   1889                next = lpcb->next;
   1890                /* Is this an IPv4 pcb? */
   1891                if (!IP_IS_V6_VAL(lpcb->local_ip)) {
   1892                  /* PCB bound to current local interface address? */
   1893                  if ((!(ip4_addr_isany(ip_2_ip4(&lpcb->local_ip)))) &&
   1894                      (ip4_addr_cmp(ip_2_ip4(&lpcb->local_ip), old_addr))) {
   1895                    /* The PCB is listening to the old ipaddr and
   1896                     * is set to listen to the new one instead */
   1897                        ip_addr_copy_from_ip4(lpcb->local_ip, *new_addr);
   1898                  }
   1899                  }
   1900              }
   1901            }
   1902          }
   1903          #endif /* LWIP_IPV4 */
   1904          
   1905          const char*
   1906          tcp_debug_state_str(enum tcp_state s)
   1907          {
   1908            return tcp_state_str[s];
   1909          }
   1910          
   1911          #if TCP_DEBUG || TCP_INPUT_DEBUG || TCP_OUTPUT_DEBUG
   1912          /**
   1913           * Print a tcp header for debugging purposes.
   1914           *
   1915           * @param tcphdr pointer to a struct tcp_hdr
   1916           */
   1917          void
   1918          tcp_debug_print(struct tcp_hdr *tcphdr)
   1919          {
   1920            LWIP_DEBUGF(TCP_DEBUG, ("TCP header:\n"));
   1921            LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
   1922            LWIP_DEBUGF(TCP_DEBUG, ("|    %5"U16_F"      |    %5"U16_F"      | (src port, dest port)\n",
   1923                   ntohs(tcphdr->src), ntohs(tcphdr->dest)));
   1924            LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
   1925            LWIP_DEBUGF(TCP_DEBUG, ("|           %010"U32_F"          | (seq no)\n",
   1926                    ntohl(tcphdr->seqno)));
   1927            LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
   1928            LWIP_DEBUGF(TCP_DEBUG, ("|           %010"U32_F"          | (ack no)\n",
   1929                   ntohl(tcphdr->ackno)));
   1930            LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
   1931            LWIP_DEBUGF(TCP_DEBUG, ("| %2"U16_F" |   |%"U16_F"%"U16_F"%"U16_F"%"U16_F"%"U16_F"%"U16_F"|     %5"U16_F"     | (hdrlen, flags (",
   1932                 TCPH_HDRLEN(tcphdr),
   1933                   TCPH_FLAGS(tcphdr) >> 5 & 1,
   1934                   TCPH_FLAGS(tcphdr) >> 4 & 1,
   1935                   TCPH_FLAGS(tcphdr) >> 3 & 1,
   1936                   TCPH_FLAGS(tcphdr) >> 2 & 1,
   1937                   TCPH_FLAGS(tcphdr) >> 1 & 1,
   1938                   TCPH_FLAGS(tcphdr) & 1,
   1939                   ntohs(tcphdr->wnd)));
   1940            tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
   1941            LWIP_DEBUGF(TCP_DEBUG, ("), win)\n"));
   1942            LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
   1943            LWIP_DEBUGF(TCP_DEBUG, ("|    0x%04"X16_F"     |     %5"U16_F"     | (chksum, urgp)\n",
   1944                   ntohs(tcphdr->chksum), ntohs(tcphdr->urgp)));
   1945            LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
   1946          }
   1947          
   1948          /**
   1949           * Print a tcp state for debugging purposes.
   1950           *
   1951           * @param s enum tcp_state to print
   1952           */
   1953          void
   1954          tcp_debug_print_state(enum tcp_state s)
   1955          {
   1956            LWIP_DEBUGF(TCP_DEBUG, ("State: %s\n", tcp_state_str[s]));
   1957          }
   1958          
   1959          /**
   1960           * Print tcp flags for debugging purposes.
   1961           *
   1962           * @param flags tcp flags, all active flags are printed
   1963           */
   1964          void
   1965          tcp_debug_print_flags(u8_t flags)
   1966          {
   1967            if (flags & TCP_FIN) {
   1968              LWIP_DEBUGF(TCP_DEBUG, ("FIN "));
   1969            }
   1970            if (flags & TCP_SYN) {
   1971              LWIP_DEBUGF(TCP_DEBUG, ("SYN "));
   1972            }
   1973            if (flags & TCP_RST) {
   1974              LWIP_DEBUGF(TCP_DEBUG, ("RST "));
   1975            }
   1976            if (flags & TCP_PSH) {
   1977              LWIP_DEBUGF(TCP_DEBUG, ("PSH "));
   1978            }
   1979            if (flags & TCP_ACK) {
   1980              LWIP_DEBUGF(TCP_DEBUG, ("ACK "));
   1981            }
   1982            if (flags & TCP_URG) {
   1983              LWIP_DEBUGF(TCP_DEBUG, ("URG "));
   1984            }
   1985            if (flags & TCP_ECE) {
   1986              LWIP_DEBUGF(TCP_DEBUG, ("ECE "));
   1987            }
   1988            if (flags & TCP_CWR) {
   1989              LWIP_DEBUGF(TCP_DEBUG, ("CWR "));
   1990            }
   1991            LWIP_DEBUGF(TCP_DEBUG, ("\n"));
   1992          }
   1993          
   1994          /**
   1995           * Print all tcp_pcbs in every list for debugging purposes.
   1996           */
   1997          void
   1998          tcp_debug_print_pcbs(void)
   1999          {
   2000            struct tcp_pcb *pcb;
   2001            LWIP_DEBUGF(TCP_DEBUG, ("Active PCB states:\n"));
   2002            for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
   2003              LWIP_DEBUGF(TCP_DEBUG, ("Local port %"U16_F", foreign port %"U16_F" snd_nxt %"U32_F" rcv_nxt %"U32_F" ",
   2004                                 pcb->local_port, pcb->remote_port,
   2005                                 pcb->snd_nxt, pcb->rcv_nxt));
   2006              tcp_debug_print_state(pcb->state);
   2007            }    
   2008            LWIP_DEBUGF(TCP_DEBUG, ("Listen PCB states:\n"));
   2009            for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
   2010              LWIP_DEBUGF(TCP_DEBUG, ("Local port %"U16_F", foreign port %"U16_F" snd_nxt %"U32_F" rcv_nxt %"U32_F" ",
   2011                                 pcb->local_port, pcb->remote_port,
   2012                                 pcb->snd_nxt, pcb->rcv_nxt));
   2013              tcp_debug_print_state(pcb->state);
   2014            }    
   2015            LWIP_DEBUGF(TCP_DEBUG, ("TIME-WAIT PCB states:\n"));
   2016            for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
   2017              LWIP_DEBUGF(TCP_DEBUG, ("Local port %"U16_F", foreign port %"U16_F" snd_nxt %"U32_F" rcv_nxt %"U32_F" ",
   2018                                 pcb->local_port, pcb->remote_port,
   2019                                 pcb->snd_nxt, pcb->rcv_nxt));
   2020              tcp_debug_print_state(pcb->state);
   2021            }
   2022          }
   2023          
   2024          /**
   2025           * Check state consistency of the tcp_pcb lists.
   2026           */
   2027          s16_t
   2028          tcp_pcbs_sane(void)
   2029          {
   2030            struct tcp_pcb *pcb;
   2031            for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
   2032              LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != CLOSED", pcb->state != CLOSED);
   2033              LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != LISTEN", pcb->state != LISTEN);
   2034              LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
   2035            }
   2036            for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
   2037              LWIP_ASSERT("tcp_pcbs_sane: tw pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
   2038            }
   2039            return 1;
   2040          }
   2041          #endif /* TCP_DEBUG */
   2042          
   2043          #endif /* LWIP_TCP */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   tcp_abandon
        48   -- Indirect call
         0   -> mem_free
        48   -> mem_free
        48   -> printf
        48   -> tcp_pcb_remove
        48   -> tcp_rst
        48   -> tcp_segs_free
       0   tcp_abort
         0   -> tcp_abandon
       0   tcp_accept
       8   tcp_accept_null
         8   -> tcp_abort
      24   tcp_alloc
        24   -> __aeabi_memset4
        24   -> mem_malloc
        24   -> tcp_kill_prio
        24   -> tcp_kill_state
        24   -> tcp_kill_timewait
        24   -> tcp_next_iss
       0   tcp_arg
      24   tcp_bind
        24   -> printf
        24   -> tcp_new_port
        24   -> tcp_timer_needed
       0   tcp_close
         0   -> tcp_close_shutdown
      24   tcp_close_shutdown
        24   -> mem_free
        24   -> printf
        24   -> tcp_output
        24   -> tcp_pcb_purge
        24   -> tcp_pcb_remove
        24   -> tcp_rst
        24   -> tcp_send_fin
        24   -> tcp_timer_needed
        24   -> tcp_trigger_input_pcb_close
      24   tcp_connect
        24   -> ip4_route
        24   -> printf
        24   -> tcp_eff_send_mss_impl
        24   -> tcp_enqueue_flags
        24   -> tcp_new_port
        24   -> tcp_next_iss
        24   -> tcp_output
        24   -> tcp_timer_needed
       0   tcp_debug_state_str
       8   tcp_eff_send_mss_impl
         8   -> ip4_route
      16   tcp_err
        16   -> printf
      16   tcp_fasttmr
        16   -> tcp_output
        16   -> tcp_process_refused_data
       8   tcp_init
         8   -> rand
      16   tcp_kill_prio
         0   -> tcp_abort
      16   tcp_kill_state
        16   -> printf
         0   -> tcp_abandon
       8   tcp_kill_timewait
         0   -> tcp_abort
      16   tcp_listen_with_backlog
        16   -> mem_free
        16   -> mem_malloc
        16   -> printf
        16   -> tcp_timer_needed
      16   tcp_netif_ipv4_addr_changed
        16   -> tcp_netif_ipv4_addr_changed_pcblist
      16   tcp_netif_ipv4_addr_changed_pcblist
        16   -> tcp_abort
       0   tcp_new
         0   -> tcp_alloc
       8   tcp_new_port
       0   tcp_next_iss
      16   tcp_pcb_purge
        16   -> pbuf_free
        16   -> tcp_segs_free
      16   tcp_pcb_remove
        16   -> printf
        16   -> tcp_output
        16   -> tcp_pcb_purge
      24   tcp_poll
        24   -> printf
      32   tcp_process_refused_data
        32   -- Indirect call
        32   -> pbuf_cat
        32   -> pbuf_split_64k
        32   -> tcp_recv_null
      16   tcp_recv
        16   -> printf
       8   tcp_recv_null
         8   -> pbuf_free
         0   -> tcp_close
         8   -> tcp_recved
      16   tcp_recved
        16   -> printf
         0   -> tcp_output
        16   -> tcp_update_rcv_ann_wnd
      16   tcp_seg_copy
        16   -> __aeabi_memcpy
        16   -> mem_malloc
        16   -> pbuf_ref
       8   tcp_seg_free
         0   -> mem_free
         8   -> pbuf_free
       8   tcp_segs_free
         8   -> tcp_seg_free
      16   tcp_sent
        16   -> printf
       0   tcp_setprio
      16   tcp_shutdown
        16   -> pbuf_free
         0   -> tcp_close_shutdown
      48   tcp_slowtmr
        48   -- Indirect call
        48   -> mem_free
        48   -> printf
        48   -> tcp_keepalive
        48   -> tcp_output
        48   -> tcp_pcb_purge
        48   -> tcp_rexmit_rto
        48   -> tcp_rst
        48   -> tcp_segs_free
        48   -> tcp_zero_window_probe
       8   tcp_tmr
         8   -> tcp_fasttmr
         0   -> tcp_slowtmr
       8   tcp_txnow
         8   -> tcp_output
      12   tcp_update_rcv_ann_wnd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable49
       4  ??DataTable49_1
       4  ??DataTable49_2
       4  ??DataTable50
       4  ??DataTable50_1
       4  ??DataTable50_2
       4  ??DataTable54
       4  ??DataTable55
       4  ??DataTable57
       4  ??DataTable57_1
       4  ??DataTable58
       4  ??DataTable58_1
       4  ??DataTable58_2
       4  ??DataTable58_3
       8  ?_0
       8  ?_1
      12  ?_10
      40  ?_11
      28  ?_12
      76  ?_13
      52  ?_14
      40  ?_15
      36  ?_16
      40  ?_17
      36  ?_18
      48  ?_19
      12  ?_2
      44  ?_20
      44  ?_21
      48  ?_22
      44  ?_23
      44  ?_24
      48  ?_25
      40  ?_26
      40  ?_27
      16  ?_28
      40  ?_29
      12  ?_3
      40  ?_30
      40  ?_31
      32  ?_32
      24  ?_33
      28  ?_34
      24  ?_35
      12  ?_4
      12  ?_5
      12  ?_6
      12  ?_7
       8  ?_8
      12  ?_9
     240  tcp_abandon
       4  tcp_abort
       4  tcp_accept
      14  tcp_accept_null
      32  tcp_active_pcbs_changed
          tcp_timer_ctr
          tcp_ticks
          tcp_bound_pcbs
          tcp_listen_pcbs
          tcp_active_pcbs
          tcp_tw_pcbs
          tcp_tmp_pcb
          iss
     206  tcp_alloc
       4  tcp_arg
      16  tcp_backoff
     190  tcp_bind
      18  tcp_close
     378  tcp_close_shutdown
     350  tcp_connect
      10  tcp_debug_state_str
      38  tcp_eff_send_mss_impl
      38  tcp_err
      94  tcp_fasttmr
      22  tcp_init
      72  tcp_kill_prio
      88  tcp_kill_state
      46  tcp_kill_timewait
     202  tcp_listen_with_backlog
      66  tcp_netif_ipv4_addr_changed
      34  tcp_netif_ipv4_addr_changed_pcblist
       4  tcp_new
      88  tcp_new_port
      12  tcp_next_iss
      16  tcp_pcb_lists
      76  tcp_pcb_purge
     176  tcp_pcb_remove
       8  tcp_persist_backoff
      46  tcp_poll
       2  tcp_port
     156  tcp_process_refused_data
      38  tcp_recv
      36  tcp_recv_null
     120  tcp_recved
      40  tcp_seg_copy
      28  tcp_seg_free
      18  tcp_segs_free
      38  tcp_sent
       4  tcp_setprio
      96  tcp_shutdown
     940  tcp_slowtmr
      44  tcp_state_str
      14  tcp_tmr
      28  tcp_txnow
      62  tcp_update_rcv_ann_wnd

 
    34 bytes in section .data
   120 bytes in section .rodata
 5 270 bytes in section .text
 
 5 270 bytes of CODE  memory
   120 bytes of CONST memory
    34 bytes of DATA  memory

Errors: none
Warnings: 5
