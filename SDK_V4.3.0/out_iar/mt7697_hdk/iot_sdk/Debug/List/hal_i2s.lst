###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:25
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\hal_i2s.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW73E7.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\hal_i2s.c -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\hal_i2s.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\hal_i2s.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\hal_i2s.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          #include "hal_i2s.h"
     36          #ifdef HAL_I2S_MODULE_ENABLED
     37          #include "hal_i2s_internal.h"
     38          #include "hal_log.h"
     39          
     40          #ifdef HAL_SLEEP_MANAGER_ENABLED
     41          #include "hal_sleep_manager.h"
     42          #include "hal_sleep_driver.h"
     43          #endif
     44          
     45          #define     I2S_CHECK_BIT(var,pos)       ((var) & (1<<(pos)))
     46          
     47          static i2s_internal_t      i2s_internal_cfg;
     48          static hal_i2s_status_t    i2s_is_sample_rate(hal_i2s_sample_rate_t sample_rate, bool blinput);
     49          static void                i2s_dma_callback(bool is_rx);
     50          static void                i2x_tx_handler(void);
     51          static void                i2x_rx_handler(void);
     52          
     53          #ifdef HAL_SLEEP_MANAGER_ENABLED
     54          static uint8_t             sleep_handler = 0;
     55          void                       i2s_enter_suspend(void);
     56          void                       i2s_enter_resume(void);
     57          #endif
     58          
     59          static void i2s_query_tx_vfifo_empty(void)
     60          {
     61              //log_hal_info("i2s_query_tx_vfifo_empty\r\n");
     62              while (1) {
     63                  if ((I2S_CHECK_BIT(i2s_internal_cfg.i2s_state, I2S_STATE_TX_RUNNING) != 0) &&
     64                          (i2s_internal_cfg.i2s_vfifo.tx_dma_configured == true) &&
     65                          (i2s_internal_cfg.i2s_audiotop_enabled == true)) {
     66                      if (I2sGetVdmaTxFifoCnt() == 0) {
     67                          break;
     68                      }
     69                  } else {
     70                      break;
     71                  }
     72              }
     73          }
     74          
     75          hal_i2s_status_t hal_i2s_init(hal_i2s_initial_type_t i2s_initial_type)
     76          {
     77          
     78              if (i2s_internal_cfg.i2s_state != I2S_STATE_IDLE) {
     79                  return HAL_I2S_STATUS_ERROR;
     80              }
     81          
     82              switch (i2s_initial_type) {
     83          
     84                  //---only for test case use----
     85                  case HAL_I2S_TYPE_INTERNAL_LOOPBACK_MODE:
     86                      i2s_internal_cfg.I2S_INITIAL_TYPE = I2S_INTERNAL_LOOPBACK_MODE;
     87                      i2s_internal_cfg.i2s_initial_type = HAL_I2S_TYPE_INTERNAL_LOOPBACK_MODE;
     88                      break;
     89                  //external codec , i2s slave mode
     90                  case HAL_I2S_TYPE_EXTERNAL_MODE:
     91                      i2s_internal_cfg.I2S_INITIAL_TYPE = I2S_EXTERNAL_MODE;
     92                      i2s_internal_cfg.i2s_initial_type = HAL_I2S_TYPE_EXTERNAL_MODE;
     93                      break;
     94                  case HAL_I2S_TYPE_INTERNAL_MODE:
     95                  case HAL_I2S_TYPE_EXTERNAL_TDM_MODE:
     96                      return HAL_I2S_STATUS_INVALID_PARAMETER;
     97          
     98                  default:
     99                      return HAL_I2S_STATUS_INVALID_PARAMETER;
    100              }
    101          
    102          
    103              if (I2sCfgInitialSetting(
    104                          i2s_internal_cfg.I2S_INITIAL_TYPE,
    105                          &i2s_internal_cfg.I2SGblCfg,
    106                          &i2s_internal_cfg.I2SDLCfg,
    107                          &i2s_internal_cfg.I2SULCfg)) {
    108                  i2s_internal_cfg.i2s_state = I2S_STATE_INIT;
    109                  i2s_internal_cfg.i2s_configured = false;
    110                  i2s_internal_cfg.i2s_audiotop_enabled = false;
    111                  return HAL_I2S_STATUS_OK;
    112              } else {
    113                  return HAL_I2S_STATUS_ERROR;
    114              }
    115          
    116          }
    117          
    118          
    119          hal_i2s_status_t hal_i2s_deinit(void)
    120          {
    121              if (i2s_internal_cfg.i2s_state != I2S_STATE_INIT) {
    122                  return HAL_I2S_STATUS_ERROR;
    123              }
    124          
    125              //xpllClose();
    126              i2s_internal_cfg.i2s_state =  I2S_STATE_IDLE;
    127              i2s_internal_cfg.i2s_configured = false;
    128              i2s_internal_cfg.i2s_audiotop_enabled = false;
    129              if (I2sReset()) {
    130                  return HAL_I2S_STATUS_OK;
    131              } else {
    132                  return HAL_I2S_STATUS_ERROR;
    133              }
    134          }
    135          
    136          
    137          hal_i2s_status_t hal_i2s_get_config(hal_i2s_config_t *config)
    138          {
    139          
    140              *config = i2s_internal_cfg.i2s_user_config;
    141              return HAL_I2S_STATUS_OK;
    142          }
    143          
    144          
    145          hal_i2s_status_t hal_i2s_set_config(const hal_i2s_config_t *config)
    146          {
    147          
    148              if (i2s_internal_cfg.i2s_state != I2S_STATE_INIT) {
    149                  log_hal_error("i2s_state != I2S_STATE_INIT , i2s_state =%d\r\n", (unsigned char)i2s_internal_cfg.i2s_state);
    150                  return HAL_I2S_STATUS_ERROR;
    151              }
    152          
    153              if (NULL == config) {
    154                  return HAL_I2S_STATUS_INVALID_PARAMETER;
    155              }
    156          
    157              //enable DMA for i2s
    158              DMA_Init();
    159              DMA_Vfifo_init();
    160          
    161              //---check Both sample rates are same value
    162              if ((config->i2s_out.sample_rate) != (config->i2s_in.sample_rate)) {
    163                  return HAL_I2S_STATUS_INVALID_PARAMETER;
    164              }
    165          
    166              //----set tx sample rate----
    167              if (i2s_is_sample_rate(config->i2s_out.sample_rate, false) != HAL_I2S_STATUS_OK) {
    168                  return HAL_I2S_STATUS_INVALID_PARAMETER;
    169              }
    170          
    171              //----set rx sample rate----
    172              if (i2s_is_sample_rate(config->i2s_in.sample_rate, true) != HAL_I2S_STATUS_OK) {
    173                  return HAL_I2S_STATUS_INVALID_PARAMETER;
    174              }
    175          
    176              //---check whether both tx channerl number and tx mode are set to enable at same time
    177              if ((config->i2s_out.channel_number == HAL_I2S_STEREO) && (config->tx_mode == HAL_I2S_TX_MONO_DUPLICATE_ENABLE)) {
    178                  return HAL_I2S_STATUS_INVALID_PARAMETER;
    179              }
    180          
    181              //----set tx channel number----
    182              switch (config->i2s_out.channel_number) {
    183                  case HAL_I2S_MONO:
    184                      i2s_internal_cfg.I2SGblCfg.ucI2SDLMonoStereoSel = I2S_DL_MONO_MODE;
    185                      break;
    186                  case HAL_I2S_STEREO:
    187                      i2s_internal_cfg.I2SGblCfg.ucI2SDLMonoStereoSel = I2S_DL_STEREO_MODE;
    188                      break;
    189                  default:
    190                      return HAL_I2S_STATUS_INVALID_PARAMETER;
    191              }
    192          
    193              //----set rx down rate mode----(disable this function)
    194              switch (config->rx_down_rate) {
    195                  case HAL_I2S_RX_DOWN_RATE_ENABLE:
    196                      //i2s_internal_cfg.I2SULCfg.bI2SDownRateEn = I2S_UL_DOWN_RATE_EN;
    197                      i2s_internal_cfg.I2SULCfg.bI2SDownRateEn = I2S_UL_DOWN_RATE_DIS;
    198                      break;
    199                  default:
    200                      i2s_internal_cfg.I2SULCfg.bI2SDownRateEn = I2S_UL_DOWN_RATE_DIS;
    201                      break;
    202              }
    203          
    204              //----set tx mode----
    205              switch (config->tx_mode) {
    206                  case HAL_I2S_TX_MONO_DUPLICATE_ENABLE:
    207                      i2s_internal_cfg.I2SGblCfg.bI2SDLMonoDupEn = I2S_DL_MONO_DUP_EN;
    208                      break;
    209                  default:
    210                      i2s_internal_cfg.I2SGblCfg.bI2SDLMonoDupEn = I2S_DL_MONO_DUP_DIS;
    211                      break;
    212              }
    213          
    214              //----set clock mode----
    215              //----default: slave mode
    216              switch (config->clock_mode) {
    217                  case HAL_I2S_MASTER:
    218                      //reserve for internal loopback mode test
    219                      i2s_internal_cfg.I2SDLCfg.ucI2SSRC = I2S_DL_SRC_MASTER;
    220                      i2s_internal_cfg.I2SULCfg.ucI2SSRC = I2S_UL_SRC_MASTER;
    221                      break;
    222                  case HAL_I2S_SLAVE:
    223                      i2s_internal_cfg.I2SDLCfg.ucI2SSRC = I2S_DL_SRC_SLAVE;
    224                      i2s_internal_cfg.I2SULCfg.ucI2SSRC = I2S_UL_SRC_SLAVE;
    225                      break;
    226                  default:
    227                      return HAL_I2S_STATUS_INVALID_PARAMETER;
    228              }
    229          
    230              //sample width
    231              //fix for 7687 i2s
    232              i2s_internal_cfg.i2s_user_config.sample_width = HAL_I2S_SAMPLE_WIDTH_16BIT;
    233              //frame sync width
    234              i2s_internal_cfg.i2s_user_config.frame_sync_width = HAL_I2S_FRAME_SYNC_WIDTH_32;
    235          
    236              //---set TX LR swap----
    237              //---default: disable
    238              switch (config->i2s_out.lr_swap) {
    239                  case HAL_I2S_LR_SWAP_ENABLE:
    240                      i2s_internal_cfg.I2SGblCfg.ucI2SDLSwapLR = 1;
    241                      break;
    242                  default:
    243                      i2s_internal_cfg.I2SGblCfg.ucI2SDLSwapLR = 0;
    244                      break;
    245              }
    246          
    247              //---set RX LR swap----
    248              //---default: disable
    249              switch (config->i2s_in.lr_swap) {
    250                  case HAL_I2S_LR_SWAP_ENABLE:
    251                      i2s_internal_cfg.I2SULCfg.u4I2SLRSwap = 1;
    252                      break;
    253                  default:
    254                      i2s_internal_cfg.I2SULCfg.u4I2SLRSwap = 0;
    255                      break;
    256              }
    257          
    258              //---set BCLK clock inverse---
    259              //Enable or disable BCLK clock inverting
    260              //i2s_internal_cfg.I2SGblCfg.bI2SClkInvEn=config->bclk_inv;
    261          
    262              //---set Negative edge capture RX data---
    263              //Enable or disable the read data can be captured either on the positive or negative edge of BCLK
    264              //i2s_internal_cfg.I2SGblCfg.bI2SNegCapEn=config->neg_cap;
    265          
    266              //---set BCLK clock inverse---
    267          
    268              //---set TX msb_offset----
    269              i2s_internal_cfg.I2SDLCfg.u4I2SMsbOffset = config->i2s_out.msb_offset;
    270          
    271              //---set RX msb_offset----
    272              i2s_internal_cfg.I2SULCfg.u4I2SMsbOffset = config->i2s_in.msb_offset;
    273          
    274              //---set TX word_select_inverse----
    275              switch (config->i2s_out.word_select_inverse) {
    276                  case HAL_I2S_WORD_SELECT_INVERSE_EBABLE:
    277                      i2s_internal_cfg.I2SDLCfg.ucI2SWordSelInv = 1;
    278                      break;
    279                  default:
    280                      i2s_internal_cfg.I2SDLCfg.ucI2SWordSelInv = 0;
    281                      break;
    282              }
    283          
    284              //---set RX word_select_inverse----
    285              switch (config->i2s_in.word_select_inverse) {
    286                  case HAL_I2S_WORD_SELECT_INVERSE_EBABLE:
    287                      i2s_internal_cfg.I2SULCfg.ucI2SWordSelInv = 1;
    288                      break;
    289                  default:
    290                      i2s_internal_cfg.I2SULCfg.ucI2SWordSelInv = 0;
    291                      break;
    292              }
    293          
    294              I2sSetGblCfg(&i2s_internal_cfg.I2SGblCfg);
    295              I2sSetDlCfg(&i2s_internal_cfg.I2SDLCfg);
    296              I2sSetUlCfg(&i2s_internal_cfg.I2SULCfg);
    297          
    298              i2s_internal_cfg.i2s_user_config = *config;
    299              /*
    300               //dump register and setting
    301               printf("i2s_internal_cfg.i2s_user_config.clock_mode=%d\r\n",i2s_internal_cfg.i2s_user_config.clock_mode);
    302               printf("i2s_internal_cfg.i2s_user_config.rx_down_rate=%d\r\n",i2s_internal_cfg.i2s_user_config.rx_down_rate);
    303               printf("i2s_internal_cfg.i2s_user_config.tx_mode=%d\r\n",i2s_internal_cfg.i2s_user_config.tx_mode);
    304               printf("i2s_internal_cfg.i2s_user_config.i2s_in.channel_number=%d\r\n",i2s_internal_cfg.i2s_user_config.i2s_in.channel_number);
    305               printf("i2s_internal_cfg.i2s_user_config.i2s_in.lr_swap=%d\r\n",i2s_internal_cfg.i2s_user_config.i2s_in.lr_swap);
    306               printf("i2s_internal_cfg.i2s_user_config.i2s_in.msb_offset=%d\r\n",i2s_internal_cfg.i2s_user_config.i2s_in.msb_offset);
    307               printf("i2s_internal_cfg.i2s_user_config.i2s_in.sample_rate=%d\r\n",i2s_internal_cfg.i2s_user_config.i2s_in.sample_rate);
    308               printf("i2s_internal_cfg.i2s_user_config.i2s_in.word_select_inverse=%d\r\n",i2s_internal_cfg.i2s_user_config.i2s_in.word_select_inverse);
    309               printf("i2s_internal_cfg.i2s_user_config.i2s_out.channel_number=%d\r\n",i2s_internal_cfg.i2s_user_config.i2s_out.channel_number);
    310               printf("i2s_internal_cfg.i2s_user_config.i2s_out.lr_swap=%d\r\n",i2s_internal_cfg.i2s_user_config.i2s_out.lr_swap);
    311               printf("i2s_internal_cfg.i2s_user_config.i2s_out.msb_offset=%d\r\n",i2s_internal_cfg.i2s_user_config.i2s_out.msb_offset);
    312               printf("i2s_internal_cfg.i2s_user_config.i2s_out.sample_rate=%d\r\n",i2s_internal_cfg.i2s_user_config.i2s_out.sample_rate);
    313               printf("i2s_internal_cfg.i2s_user_config.i2s_out.word_select_inverse=%d\r\n",i2s_internal_cfg.i2s_user_config.i2s_out.word_select_inverse);
    314          
    315               printf("I2S_GLB_CONTROL_ADDR=%x\r\n",DRV_Reg32(I2S_GLB_CONTROL_ADDR));
    316               printf("I2S_DL_CONTROL_ADDR=%x\r\n",DRV_Reg32(I2S_DL_CONTROL_ADDR));
    317               printf("I2S_UL_CONTROL_ADDR=%x\r\n",DRV_Reg32(I2S_UL_CONTROL_ADDR));
    318               */
    319              i2s_internal_cfg.i2s_configured = true;
    320          
    321              return HAL_I2S_STATUS_OK;
    322          
    323          }
    324          
    325          
    326          hal_i2s_status_t  hal_i2s_enable_audio_top(void)
    327          {
    328              //----Enable  audio_top----
    329              xpllOpen();
    330              I2sClkFifoEn(I2S_TRUE);
    331              i2s_internal_cfg.i2s_audiotop_enabled = true;
    332          
    333              return HAL_I2S_STATUS_OK;
    334          }
    335          
    336          
    337          hal_i2s_status_t  hal_i2s_disable_audio_top(void)
    338          {
    339              //----Disable audio_top----
    340              I2sClkFifoEn(I2S_FALSE);
    341              xpllClose();
    342              i2s_internal_cfg.i2s_audiotop_enabled = false;
    343          
    344              return HAL_I2S_STATUS_OK;
    345          }
    346          
    347          
    348          hal_i2s_status_t  hal_i2s_enable_tx_dma_interrupt(void)
    349          {
    350              if (i2s_internal_cfg.user_tx_callback_func == NULL) {
    351                  return HAL_I2S_STATUS_ERROR;
    352              }
    353          
    354              //----Enable DMA interrupt for TX----
    355              I2sSetVdmaTxIntrEn(I2S_DMA_INTR_EN);
    356              i2s_internal_cfg.i2s_vfifo.tx_dma_interrupt = true;
    357          
    358              return HAL_I2S_STATUS_OK;
    359          }
    360          
    361          
    362          hal_i2s_status_t  hal_i2s_disable_tx_dma_interrupt(void)
    363          {
    364          
    365              //----Disable DMA interrupt for TX----
    366              I2sSetVdmaTxIntrEn(I2S_DMA_INTR_DIS);
    367              i2s_internal_cfg.i2s_vfifo.tx_dma_interrupt = false;
    368          
    369              return HAL_I2S_STATUS_OK;
    370          }
    371          
    372          
    373          hal_i2s_status_t  hal_i2s_enable_rx_dma_interrupt(void)
    374          {
    375          
    376              if (i2s_internal_cfg.user_rx_callback_func == NULL) {
    377                  return HAL_I2S_STATUS_ERROR;
    378              }
    379          
    380              //----Enable  DMA interrupt for RX----
    381              I2sSetVdmaRxIntrEn(I2S_DMA_INTR_EN);
    382              i2s_internal_cfg.i2s_vfifo.rx_dma_interrupt = true;
    383          
    384              return HAL_I2S_STATUS_OK;
    385          }
    386          
    387          hal_i2s_status_t  hal_i2s_disable_rx_dma_interrupt(void)
    388          {
    389          
    390              //----Disable DMA interrupt for RX----
    391              I2sSetVdmaRxIntrEn(I2S_DMA_INTR_DIS);
    392              i2s_internal_cfg.i2s_vfifo.rx_dma_interrupt = false;
    393          
    394              return HAL_I2S_STATUS_OK;
    395          }
    396          
    397          
    398          
    399          hal_i2s_status_t hal_i2s_get_tx_sample_count(uint32_t *sample_count)
    400          {
    401              if (i2s_internal_cfg.i2s_vfifo.tx_vfifo_length == 0) {
    402                  return HAL_I2S_STATUS_ERROR;
    403              }
    404          
    405              //---get free space in tx vfifo
    406              *sample_count = i2s_internal_cfg.i2s_vfifo.tx_vfifo_length - I2sGetVdmaTxFifoCnt();
    407          
    408              return HAL_I2S_STATUS_OK;
    409          }
    410          
    411          
    412          hal_i2s_status_t hal_i2s_get_rx_sample_count(uint32_t *sample_count)
    413          {
    414              //---get the length to the received data in rx vfifo
    415              *sample_count = I2sGetVdmaRxFifoCnt();
    416          
    417              return HAL_I2S_STATUS_OK;
    418          }
    419          
    420          
    421          hal_i2s_status_t hal_i2s_setup_tx_vfifo(uint32_t *buffer, uint32_t threshold, uint32_t buffer_length)
    422          {
    423          
    424              if (NULL == buffer) {
    425                  return HAL_I2S_STATUS_INVALID_PARAMETER;
    426              }
    427          
    428              if (i2s_internal_cfg.i2s_state != I2S_STATE_INIT) {
    429                  log_hal_error("i2s_state != I2S_STATE_INIT , i2s_state =%d\r\n", (unsigned char)i2s_internal_cfg.i2s_state);
    430                  return HAL_I2S_STATUS_ERROR;
    431              }
    432          
    433              //----Initialize I2S hardware with Virtual FIFO DMA Tx----
    434              I2sVdmaTxStart((UINT32)buffer, buffer_length, (DMA_VFIFO_CHANNEL) 0, I2S_DMA_CVFF_DIS);
    435          
    436              //----Set the threshold  for Tx VDMA----
    437              I2sSetVdmaTxThreshold(threshold);
    438          
    439              i2s_internal_cfg.i2s_vfifo.tx_vfifo_base = (uint32_t *)buffer;
    440              i2s_internal_cfg.i2s_vfifo.tx_vfifo_length = buffer_length;
    441              i2s_internal_cfg.i2s_vfifo.tx_vfifo_threshold = threshold;
    442              i2s_internal_cfg.i2s_vfifo.tx_dma_configured = true;
    443          
    444              return HAL_I2S_STATUS_OK;
    445          }
    446          
    447          
    448          hal_i2s_status_t hal_i2s_setup_rx_vfifo(uint32_t *buffer, uint32_t threshold, uint32_t buffer_length)
    449          {
    450          
    451              if (NULL == buffer) {
    452                  return HAL_I2S_STATUS_INVALID_PARAMETER;
    453              }
    454          
    455              if (i2s_internal_cfg.i2s_state != I2S_STATE_INIT) {
    456                  log_hal_error("i2s_state != I2S_STATE_INIT , i2s_state =%d\r\n", (unsigned char)i2s_internal_cfg.i2s_state);
    457                  return HAL_I2S_STATUS_ERROR;
    458              }
    459          
    460              //----Initialize I2S hardware with Virtual FIFO DMA Rx----
    461              I2sVdmaRxStart((UINT32)buffer, buffer_length, (DMA_VFIFO_CHANNEL)0, I2S_DMA_CVFF_DIS);
    462          
    463              //----Set the threshold  for Rx VDMA----
    464              I2sSetVdmaRxThreshold(threshold);
    465          
    466              i2s_internal_cfg.i2s_vfifo.rx_vfifo_base = (uint32_t *)buffer;
    467              i2s_internal_cfg.i2s_vfifo.rx_vfifo_length = buffer_length;
    468              i2s_internal_cfg.i2s_vfifo.rx_vfifo_threshold = threshold;
    469              i2s_internal_cfg.i2s_vfifo.rx_dma_configured = true;
    470          
    471              return HAL_I2S_STATUS_OK;
    472          
    473          }
    474          
    475          
    476          hal_i2s_status_t hal_i2s_stop_tx_vfifo(void)
    477          {
    478          
    479              if (i2s_internal_cfg.i2s_vfifo.tx_dma_configured) {
    480                  DMA_Stop((UINT8)VDMA_I2S_TX_CH);
    481              }
    482          
    483              return HAL_I2S_STATUS_OK;
    484          }
    485          
    486          
    487          hal_i2s_status_t hal_i2s_stop_rx_vfifo(void)
    488          {
    489              if (i2s_internal_cfg.i2s_vfifo.rx_dma_configured) {
    490                  DMA_Stop((UINT8)VDMA_I2S_RX_CH);
    491              }
    492          
    493              return HAL_I2S_STATUS_OK;
    494          }
    495          
    496          
    497          hal_i2s_status_t hal_i2s_register_tx_vfifo_callback(hal_i2s_tx_callback_t tx_callback, void *user_data)
    498          {
    499          
    500              if (NULL == tx_callback) {
    501                  return HAL_I2S_STATUS_INVALID_PARAMETER;
    502              }
    503          
    504              i2s_internal_cfg.user_tx_callback_func = tx_callback;
    505              i2s_internal_cfg.user_tx_data = user_data;
    506          
    507              DMA_Vfifo_Register_Callback(VDMA_I2S_TX_CH, i2x_tx_handler);
    508          
    509              return HAL_I2S_STATUS_OK;
    510          
    511          }
    512          
    513          
    514          hal_i2s_status_t hal_i2s_register_rx_vfifo_callback(hal_i2s_rx_callback_t rx_callback, void *user_data)
    515          {
    516          
    517              if (NULL == rx_callback) {
    518                  return HAL_I2S_STATUS_INVALID_PARAMETER;
    519              }
    520          
    521              i2s_internal_cfg.user_rx_callback_func = rx_callback;
    522              i2s_internal_cfg.user_rx_data = user_data;
    523          
    524              DMA_Vfifo_Register_Callback(VDMA_I2S_RX_CH, i2x_rx_handler);
    525          
    526              return HAL_I2S_STATUS_OK;
    527          }
    528          
    529          
    530          hal_i2s_status_t  hal_i2s_enable_tx(void)
    531          {
    532          
    533              i2s_internal_cfg.i2s_state |= (1 << I2S_STATE_TX_RUNNING);
    534          
    535              I2sDlEn(KAL_TRUE);
    536          
    537          #ifdef HAL_SLEEP_MANAGER_ENABLED
    538              /*get sleep handler, just lock once*/
    539              if (sleep_handler == 0) {
    540                  sleep_handler = hal_sleep_manager_set_sleep_handle("I2S");
    541                  if (sleep_handler == INVALID_SLEEP_HANDLE) {
    542                      log_hal_info("there's no available handle when I2S get sleep handle");
    543                      return HAL_I2S_STATUS_ERROR;
    544                  } else {
    545                      hal_sleep_manager_lock_sleep(sleep_handler);/*lock sleep mode*/
    546                      log_hal_info("[I2S] lock sleep successfully");
    547                  }
    548              }
    549          #endif
    550              return HAL_I2S_STATUS_OK;
    551          }
    552          
    553          
    554          hal_i2s_status_t  hal_i2s_enable_rx(void)
    555          {
    556              i2s_internal_cfg.i2s_state |= (1 << I2S_STATE_RX_RUNNING);
    557          
    558              I2sUlEn(KAL_TRUE);
    559          
    560          #ifdef HAL_SLEEP_MANAGER_ENABLED
    561              /*get sleep handler, just lock once*/
    562              if (sleep_handler == 0) {
    563                  sleep_handler = hal_sleep_manager_set_sleep_handle("I2S");
    564                  if (sleep_handler == INVALID_SLEEP_HANDLE) {
    565                      log_hal_info("there's no available handle when I2S get sleep handle");
    566                      return HAL_I2S_STATUS_ERROR;
    567                  } else {
    568                      hal_sleep_manager_lock_sleep(sleep_handler);/*lock sleep mode*/
    569                      log_hal_info("[I2S] lock sleep successfully");
    570                  }
    571              }
    572          #endif
    573          
    574              return HAL_I2S_STATUS_OK;
    575          
    576          }
    577          
    578          
    579          hal_i2s_status_t  hal_i2s_disable_tx(void)
    580          {
    581              //wait until data counts in tx vfifo is empty
    582              i2s_query_tx_vfifo_empty();
    583          
    584              i2s_internal_cfg.i2s_state &=  ~(1 << I2S_STATE_TX_RUNNING);
    585          
    586              I2sDlEn(KAL_FALSE);
    587          #ifdef HAL_SLEEP_MANAGER_ENABLED
    588              if ((I2S_CHECK_BIT(i2s_internal_cfg.i2s_state, I2S_STATE_TX_RUNNING) == 0) && (I2S_CHECK_BIT(i2s_internal_cfg.i2s_state, I2S_STATE_RX_RUNNING) == 0)) {
    589                  /*unlock sleep mode*/
    590                  hal_sleep_manager_unlock_sleep(sleep_handler);
    591                  /*release sleep hander*/
    592                  hal_sleep_manager_release_sleep_handle(sleep_handler);
    593                  sleep_handler = 0;
    594                  log_hal_info("[I2S] unlock sleep successfully");
    595              }
    596          #endif
    597          
    598              return HAL_I2S_STATUS_OK;
    599          }
    600          
    601          
    602          hal_i2s_status_t hal_i2s_disable_rx(void)
    603          {
    604          
    605              i2s_internal_cfg.i2s_state &= ~(1 << I2S_STATE_RX_RUNNING);
    606          
    607              I2sUlEn(KAL_FALSE);
    608          #ifdef HAL_SLEEP_MANAGER_ENABLED
    609              if ((I2S_CHECK_BIT(i2s_internal_cfg.i2s_state, I2S_STATE_TX_RUNNING) == 0) && (I2S_CHECK_BIT(i2s_internal_cfg.i2s_state, I2S_STATE_RX_RUNNING) == 0)) {
    610                  /*unlock sleep mode*/
    611                  hal_sleep_manager_unlock_sleep(sleep_handler);
    612                  /*release sleep hander*/
    613                  hal_sleep_manager_release_sleep_handle(sleep_handler);
    614                  sleep_handler = 0;
    615                  log_hal_info("[I2S] unlock sleep successfully");
    616              }
    617          #endif
    618          
    619              return HAL_I2S_STATUS_OK;
    620          
    621          }
    622          
    623          
    624          hal_i2s_status_t hal_i2s_tx_write(uint32_t data)
    625          {
    626          
    627              DRV_Reg32(I2S_DMA_TX_FIFO) = data;
    628          
    629              return HAL_I2S_STATUS_OK;
    630          }
    631          
    632          
    633          hal_i2s_status_t hal_i2s_rx_read(uint32_t *data)
    634          {
    635          
    636              *data = DRV_Reg32(I2S_DMA_RX_FIFO);
    637          
    638              return HAL_I2S_STATUS_OK;
    639          
    640          }
    641          
    642          
    643          static void i2s_dma_callback(bool is_rx)
    644          {
    645              if (is_rx) {
    646                  //----notify user to get data from RX VFIFO----
    647                  i2s_internal_cfg.user_rx_callback_func(HAL_I2S_EVENT_DATA_NOTIFICATION,
    648                                                         i2s_internal_cfg.user_rx_data);
    649              } else {
    650                  //notify user to refill data to TX VFIFO
    651                  i2s_internal_cfg.user_tx_callback_func(HAL_I2S_EVENT_DATA_REQUEST,
    652                                                         i2s_internal_cfg.user_tx_data);
    653              }
    654          }
    655          
    656          
    657          static void i2x_tx_handler(void)
    658          {
    659              i2s_dma_callback(0);
    660          }
    661          
    662          
    663          static void i2x_rx_handler(void)
    664          {
    665              i2s_dma_callback(1);
    666          }
    667          
    668          
    669          static hal_i2s_status_t i2s_is_sample_rate(hal_i2s_sample_rate_t sample_rate, bool IsRx)
    670          {
    671              switch (sample_rate) {
    672                  case HAL_I2S_SAMPLE_RATE_8K:
    673                      if (IsRx) {
    674                          i2s_internal_cfg.I2SULCfg.u4I2SSampleRate = I2S_SAMPLE_RATE_8K;
    675                      } else {
    676                          i2s_internal_cfg.I2SDLCfg.u4I2SSampleRate = I2S_SAMPLE_RATE_8K;
    677                      }
    678                      break;
    679                  case HAL_I2S_SAMPLE_RATE_12K:
    680                      if (IsRx) {
    681                          i2s_internal_cfg.I2SULCfg.u4I2SSampleRate = I2S_SAMPLE_RATE_12K;
    682                      } else {
    683                          i2s_internal_cfg.I2SDLCfg.u4I2SSampleRate = I2S_SAMPLE_RATE_12K;
    684                      }
    685                      break;
    686                  case HAL_I2S_SAMPLE_RATE_16K:
    687                      if (IsRx) {
    688                          i2s_internal_cfg.I2SULCfg.u4I2SSampleRate = I2S_SAMPLE_RATE_16K;
    689                      } else {
    690                          i2s_internal_cfg.I2SDLCfg.u4I2SSampleRate = I2S_SAMPLE_RATE_16K;
    691                      }
    692                      break;
    693                  case HAL_I2S_SAMPLE_RATE_24K:
    694                      if (IsRx) {
    695                          i2s_internal_cfg.I2SULCfg.u4I2SSampleRate = I2S_SAMPLE_RATE_24K;
    696                      } else {
    697                          i2s_internal_cfg.I2SDLCfg.u4I2SSampleRate = I2S_SAMPLE_RATE_24K;
    698                      }
    699                      break;
    700                  case HAL_I2S_SAMPLE_RATE_32K:
    701                      if (IsRx) {
    702                          i2s_internal_cfg.I2SULCfg.u4I2SSampleRate = I2S_SAMPLE_RATE_32K;
    703                      } else {
    704                          i2s_internal_cfg.I2SDLCfg.u4I2SSampleRate = I2S_SAMPLE_RATE_32K;
    705                      }
    706                      break;
    707                  case HAL_I2S_SAMPLE_RATE_48K:
    708                      if (IsRx) {
    709                          i2s_internal_cfg.I2SULCfg.u4I2SSampleRate = I2S_SAMPLE_RATE_48K;
    710                      } else {
    711                          i2s_internal_cfg.I2SDLCfg.u4I2SSampleRate = I2S_SAMPLE_RATE_48K;
    712                      }
    713                      break;
    714                  default:
    715                      return HAL_I2S_STATUS_INVALID_PARAMETER;
    716              }
    717          
    718              return HAL_I2S_STATUS_OK;
    719          }
    720          
    721          
    722          #ifdef HAL_SLEEP_MANAGER_ENABLED
    723          void i2s_enter_suspend(void)
    724          {
    725              //we do not need to anything(backup setting, disable i2s and clock) now,
    726              //because i2s can not allow to enter sleep when i2s tx or rx is enabled
    727              //and all settings are already stored by static global structure
    728              return;
    729          
    730          }
    731          
    732          void i2s_enter_resume(void)
    733          {
    734              if ((i2s_internal_cfg.i2s_state == I2S_STATE_INIT) && (i2s_internal_cfg.i2s_configured)) {
    735                  /*reinit and reconfig when i2s resume back*/
    736                  hal_i2s_set_config(&i2s_internal_cfg.i2s_user_config);
    737          
    738                  /*reconfig vfifo*/
    739                  if (i2s_internal_cfg.i2s_vfifo.tx_dma_configured) {
    740                      hal_i2s_setup_tx_vfifo(
    741                          i2s_internal_cfg.i2s_vfifo.tx_vfifo_base,
    742                          i2s_internal_cfg.i2s_vfifo.tx_vfifo_threshold,
    743                          i2s_internal_cfg.i2s_vfifo.tx_vfifo_length);
    744                  }
    745          
    746                  if (i2s_internal_cfg.i2s_vfifo.rx_dma_configured) {
    747                      hal_i2s_setup_rx_vfifo(
    748                          i2s_internal_cfg.i2s_vfifo.rx_vfifo_base,
    749                          i2s_internal_cfg.i2s_vfifo.rx_vfifo_threshold,
    750                          i2s_internal_cfg.i2s_vfifo.rx_vfifo_length);
    751                  }
    752          
    753              }
    754          }
    755          #endif
    756          
    757          #endif//#ifdef HAL_I2S_MODULE_ENABLED

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   hal_i2s_deinit
         8   -> I2sReset
       8   hal_i2s_disable_audio_top
         8   -> I2sClkFifoEn
         8   -> xpllClose
       8   hal_i2s_disable_rx
         8   -> I2sUlEn
         8   -> hal_sleep_manager_release_sleep_handle
         8   -> hal_sleep_manager_unlock_sleep
         8   -> log_hal_info_internal
       8   hal_i2s_disable_rx_dma_interrupt
         8   -> I2sSetVdmaRxIntrEn
       8   hal_i2s_disable_tx
         8   -> I2sDlEn
         8   -> hal_sleep_manager_release_sleep_handle
         8   -> hal_sleep_manager_unlock_sleep
         8   -> i2s_query_tx_vfifo_empty
         8   -> log_hal_info_internal
       8   hal_i2s_disable_tx_dma_interrupt
         8   -> I2sSetVdmaTxIntrEn
       8   hal_i2s_enable_audio_top
         8   -> I2sClkFifoEn
         8   -> xpllOpen
       8   hal_i2s_enable_rx
         8   -> I2sUlEn
         8   -> hal_sleep_manager_lock_sleep
         8   -> hal_sleep_manager_set_sleep_handle
         8   -> log_hal_info_internal
       8   hal_i2s_enable_rx_dma_interrupt
         8   -> I2sSetVdmaRxIntrEn
       8   hal_i2s_enable_tx
         8   -> I2sDlEn
         8   -> hal_sleep_manager_lock_sleep
         8   -> hal_sleep_manager_set_sleep_handle
         8   -> log_hal_info_internal
       8   hal_i2s_enable_tx_dma_interrupt
         8   -> I2sSetVdmaTxIntrEn
       8   hal_i2s_get_config
         8   -> __aeabi_memcpy4
       8   hal_i2s_get_rx_sample_count
         8   -> I2sGetVdmaRxFifoCnt
      16   hal_i2s_get_tx_sample_count
        16   -> I2sGetVdmaTxFifoCnt
      16   hal_i2s_init
        16   -> I2sCfgInitialSetting
       8   hal_i2s_register_rx_vfifo_callback
         8   -> DMA_Vfifo_Register_Callback
       8   hal_i2s_register_tx_vfifo_callback
         8   -> DMA_Vfifo_Register_Callback
       0   hal_i2s_rx_read
      16   hal_i2s_set_config
        16   -> DMA_Init
        16   -> DMA_Vfifo_init
        16   -> I2sSetDlCfg
        16   -> I2sSetGblCfg
        16   -> I2sSetUlCfg
        16   -> __aeabi_memcpy4
        16   -> i2s_is_sample_rate
        16   -> log_hal_error_internal
      24   hal_i2s_setup_rx_vfifo
        24   -> I2sSetVdmaRxThreshold
        24   -> I2sVdmaRxStart
        24   -> log_hal_error_internal
      24   hal_i2s_setup_tx_vfifo
        24   -> I2sSetVdmaTxThreshold
        24   -> I2sVdmaTxStart
        24   -> log_hal_error_internal
       8   hal_i2s_stop_rx_vfifo
         8   -> DMA_Stop
       8   hal_i2s_stop_tx_vfifo
         8   -> DMA_Stop
       0   hal_i2s_tx_write
       0   i2s_dma_callback
         0   -- Indirect call
      16   i2s_enter_resume
        16   -> hal_i2s_set_config
         0   -> hal_i2s_setup_rx_vfifo
        16   -> hal_i2s_setup_tx_vfifo
       0   i2s_enter_suspend
       0   i2s_is_sample_rate
       8   i2s_query_tx_vfifo_empty
         8   -> I2sGetVdmaTxFifoCnt
       0   i2x_rx_handler
         0   -> i2s_dma_callback
       0   i2x_tx_handler
         0   -> i2s_dma_callback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable37_10
       4  ??DataTable37_2
       4  ??DataTable37_3
       4  ??DataTable37_4
       4  ??DataTable37_5
       4  ??DataTable37_6
       4  ??DataTable37_7
       4  ??DataTable37_8
       4  ??DataTable37_9
      48  ?_0
       4  ?_1
      56  ?_2
      32  ?_3
      32  ?_4
      44  hal_i2s_deinit
      24  hal_i2s_disable_audio_top
      76  hal_i2s_disable_rx
      20  hal_i2s_disable_rx_dma_interrupt
      80  hal_i2s_disable_tx
      20  hal_i2s_disable_tx_dma_interrupt
      26  hal_i2s_enable_audio_top
      88  hal_i2s_enable_rx
      32  hal_i2s_enable_rx_dma_interrupt
      88  hal_i2s_enable_tx
      32  hal_i2s_enable_tx_dma_interrupt
      16  hal_i2s_get_config
      14  hal_i2s_get_rx_sample_count
      34  hal_i2s_get_tx_sample_count
      96  hal_i2s_init
      32  hal_i2s_register_rx_vfifo_callback
      32  hal_i2s_register_tx_vfifo_callback
      10  hal_i2s_rx_read
     308  hal_i2s_set_config
     102  hal_i2s_setup_rx_vfifo
      84  hal_i2s_setup_tx_vfifo
      22  hal_i2s_stop_rx_vfifo
      22  hal_i2s_stop_tx_vfifo
      10  hal_i2s_tx_write
      28  i2s_dma_callback
      66  i2s_enter_resume
       2  i2s_enter_suspend
     140  i2s_internal_cfg
     130  i2s_is_sample_rate
      34  i2s_query_tx_vfifo_empty
       4  i2x_rx_handler
       4  i2x_tx_handler
       1  sleep_handler
     148  -- Other

 
   141 bytes in section .bss
     4 bytes in section .rodata
 1 940 bytes in section .text
 
 1 940 bytes of CODE  memory
     4 bytes of CONST memory
   141 bytes of DATA  memory

Errors: none
Warnings: none
