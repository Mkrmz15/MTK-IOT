###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:29
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\third_party\lwip\src\core\ipv4\ip4.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW8389.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\third_party\lwip\src\core\ipv4\ip4.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\ip4.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\ip4.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\third_party\lwip\src\core\ipv4\ip4.c
      1          /**
      2           * @file
      3           * This is the IPv4 layer implementation for incoming and outgoing IP traffic.
      4           *
      5           * @see ip_frag.c
      6           *
      7           */
      8          
      9          /*
     10           * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
     11           * All rights reserved.
     12           *
     13           * Redistribution and use in source and binary forms, with or without modification,
     14           * are permitted provided that the following conditions are met:
     15           *
     16           * 1. Redistributions of source code must retain the above copyright notice,
     17           *    this list of conditions and the following disclaimer.
     18           * 2. Redistributions in binary form must reproduce the above copyright notice,
     19           *    this list of conditions and the following disclaimer in the documentation
     20           *    and/or other materials provided with the distribution.
     21           * 3. The name of the author may not be used to endorse or promote products
     22           *    derived from this software without specific prior written permission.
     23           *
     24           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
     25           * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     26           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
     27           * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     28           * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
     29           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     30           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     31           * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     32           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
     33           * OF SUCH DAMAGE.
     34           *
     35           * This file is part of the lwIP TCP/IP stack.
     36           *
     37           * Author: Adam Dunkels <adam@sics.se>
     38           *
     39           */
     40          
     41          #include "lwip/opt.h"
     42          
     43          #if LWIP_IPV4
     44          
     45          #include "lwip/ip.h"
     46          #include "lwip/def.h"
     47          #include "lwip/mem.h"
     48          #include "lwip/ip_frag.h"
     49          #include "lwip/inet_chksum.h"
     50          #include "lwip/netif.h"
     51          #include "lwip/icmp.h"
     52          #include "lwip/igmp.h"
     53          #include "lwip/raw.h"
     54          #include "lwip/udp.h"
     55          #include "lwip/tcp_impl.h"
     56          #include "lwip/snmp.h"
     57          #include "lwip/dhcp.h"
     58          #include "lwip/autoip.h"
     59          #include "lwip/stats.h"
     60          
     61          #include <string.h>
     62          
     63          /** Set this to 0 in the rare case of wanting to call an extra function to
     64           * generate the IP checksum (in contrast to calculating it on-the-fly). */
     65          #ifndef LWIP_INLINE_IP_CHKSUM
     66          #define LWIP_INLINE_IP_CHKSUM   1
     67          #endif
     68          #if LWIP_INLINE_IP_CHKSUM && CHECKSUM_GEN_IP
     69          #define CHECKSUM_GEN_IP_INLINE  1
     70          #else
     71          #define CHECKSUM_GEN_IP_INLINE  0
     72          #endif
     73          
     74          #if LWIP_DHCP || defined(LWIP_IP_ACCEPT_UDP_PORT)
     75          #define IP_ACCEPT_LINK_LAYER_ADDRESSING 1
     76          
     77          /** Some defines for DHCP to let link-layer-addressed packets through while the
     78           * netif is down.
     79           * To use this in your own application/protocol, define LWIP_IP_ACCEPT_UDP_PORT(port)
     80           * to return 1 if the port is accepted and 0 if the port is not accepted.
     81           */
     82          #if LWIP_DHCP && defined(LWIP_IP_ACCEPT_UDP_PORT)
     83          /* accept DHCP client port and custom port */
     84          #define IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(port) (((port) == PP_NTOHS(DHCP_CLIENT_PORT)) \
     85                   || (LWIP_IP_ACCEPT_UDP_PORT(port)))
     86          #elif defined(LWIP_IP_ACCEPT_UDP_PORT) /* LWIP_DHCP && defined(LWIP_IP_ACCEPT_UDP_PORT) */
     87          /* accept custom port only */
     88          #define IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(port) (LWIP_IP_ACCEPT_UDP_PORT(port))
     89          #else /* LWIP_DHCP && defined(LWIP_IP_ACCEPT_UDP_PORT) */
     90          /* accept DHCP client port only */
     91          #define IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(port) ((port) == PP_NTOHS(DHCP_CLIENT_PORT))
     92          #endif /* LWIP_DHCP && defined(LWIP_IP_ACCEPT_UDP_PORT) */
     93          
     94          #else /* LWIP_DHCP */
     95          #define IP_ACCEPT_LINK_LAYER_ADDRESSING 0
     96          #endif /* LWIP_DHCP */
     97          
     98          /** Global data for both IPv4 and IPv6 */
     99          struct ip_globals ip_data;
    100          
    101          /** The IP header ID of the next outgoing IP packet */
    102          static u16_t ip_id;
    103          
    104          #if LWIP_MULTICAST_TX_OPTIONS
    105          /** The default netif used for multicast */
    106          static struct netif* ip4_default_multicast_netif;
    107          
    108          /** Set a default netif for IPv4 multicast. */
    109          void
    110          ip4_set_default_multicast_netif(struct netif* default_multicast_netif)
    111          {
    112            ip4_default_multicast_netif = default_multicast_netif;
    113          }
    114          #endif /* LWIP_MULTICAST_TX_OPTIONS */
    115          
    116          #ifdef LWIP_HOOK_IP4_ROUTE_SRC
    117          /**
    118           * Source based IPv4 routing must be fully implemented in
    119           * LWIP_HOOK_IP4_ROUTE_SRC(). This function only provides he parameters.
    120           */
    121          struct netif *
    122          ip4_route_src(const ip4_addr_t *dest, const ip4_addr_t *src)
    123          {
    124            if (src != NULL) {
    125              struct netif *netif = LWIP_HOOK_IP4_ROUTE_SRC(dest, src);
    126              if (netif != NULL) {
    127                return netif;
    128              }
    129            }
    130            return ip4_route(dest);
    131          }
    132          #endif /* LWIP_HOOK_IP4_ROUTE_SRC */
    133          
    134          /**
    135           * Finds the appropriate network interface for a given IP address. It
    136           * searches the list of network interfaces linearly. A match is found
    137           * if the masked IP address of the network interface equals the masked
    138           * IP address given to the function.
    139           *
    140           * @param dest the destination IP address for which to find the route
    141           * @return the netif on which to send to reach dest
    142           */
    143          struct netif *
    144          ip4_route(const ip4_addr_t *dest)
    145          {
    146            struct netif *netif;
    147          
    148          #ifdef LWIP_HOOK_IP4_ROUTE_SRC
    149            netif = LWIP_HOOK_IP4_ROUTE_SRC(dest, NULL);
    150            if (netif != NULL) {
    151              return netif;
    152            }
    153          #elif defined(LWIP_HOOK_IP4_ROUTE)
    154            netif = LWIP_HOOK_IP4_ROUTE(dest);
    155            if (netif != NULL) {
    156              return netif;
    157            }
    158          #endif
    159          
    160          #if LWIP_MULTICAST_TX_OPTIONS
    161            /* Use administratively selected interface for multicast by default */
    162            if (ip4_addr_ismulticast(dest) && ip4_default_multicast_netif) {
    163              return ip4_default_multicast_netif;
    164            }
    165          #endif /* LWIP_MULTICAST_TX_OPTIONS */
    166          
    167            /* iterate through netifs */
    168            for (netif = netif_list; netif != NULL; netif = netif->next) {
    169              /* is the netif up, does it have a link and a valid address? */
    170              if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
    171                /* network mask matches? */
    172                if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
    173                  /* return netif on which to forward IP packet */
    174                  #ifdef MTK_TCPIP_FOR_EXTERNAL_MODULE_ENABLE
    175                  if (netif_default != NULL && netif_is_belong_to_md(netif) == 1 && netif_is_link_up(netif_default) == 1) {
    176                      continue;
    177                  }
    178                  #endif
    179                  return netif;
    180                }
    181              }
    182            }
    183          
    184            if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
    185                ip4_addr_isany_val(*netif_ip4_addr(netif_default))) {
    186              /* No matching netif found an default netif is not usable.
    187                 If this is not good enough for you, use LWIP_HOOK_IP4_ROUTE() */
    188              LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
    189                ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    190              IP_STATS_INC(ip.rterr);
    191              snmp_inc_ipoutnoroutes();
    192              return NULL;
    193            }
    194          
    195          #if LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF
    196            /* loopif is disabled, looopback traffic is passed through any netif */
    197            if (ip4_addr_isloopback(dest)) {
    198              /* don't check for link on loopback traffic */
    199              if (netif_is_up(netif_default)) {
    200                return netif_default;
    201              }
    202              /* default netif is not up, just use any netif for loopback traffic */
    203              for (netif = netif_list; netif != NULL; netif = netif->next) {
    204                if (netif_is_up(netif)) {
    205                  return netif;
    206                }
    207              }
    208              return NULL;
    209            }
    210          #endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
    211          
    212            /* no matching netif found, use default netif */
    213            if (!netif_is_up(netif_default) || !netif_is_link_up(netif_default)) {
    214              return NULL;
    215            }
    216            return netif_default;
    217          }
    218          
    219          #if IP_FORWARD
    220          /**
    221           * Determine whether an IP address is in a reserved set of addresses
    222           * that may not be forwarded, or whether datagrams to that destination
    223           * may be forwarded.
    224           * @param p the packet to forward
    225           * @param dest the destination IP address
    226           * @return 1: can forward 0: discard
    227           */
    228          static int
    229          ip4_canforward(struct pbuf *p)
    230          {
    231            u32_t addr = htonl(ip4_addr_get_u32(ip4_current_dest_addr()));
    232          
    233            if (p->flags & PBUF_FLAG_LLBCAST) {
    234              /* don't route link-layer broadcasts */
    235              return 0;
    236            }
    237            if ((p->flags & PBUF_FLAG_LLMCAST) && !IP_MULTICAST(addr)) {
    238              /* don't route link-layer multicasts unless the destination address is an IP
    239                 multicast address */
    240              return 0;
    241            }
    242            if (IP_EXPERIMENTAL(addr)) {
    243              return 0;
    244            }
    245            if (IP_CLASSA(addr)) {
    246              u32_t net = addr & IP_CLASSA_NET;
    247              if ((net == 0) || (net == ((u32_t)IP_LOOPBACKNET << IP_CLASSA_NSHIFT))) {
    248                /* don't route loopback packets */
    249                return 0;
    250              }
    251            }
    252            return 1;
    253          }
    254          
    255          /**
    256           * Forwards an IP packet. It finds an appropriate route for the
    257           * packet, decrements the TTL value of the packet, adjusts the
    258           * checksum and outputs the packet on the appropriate interface.
    259           *
    260           * @param p the packet to forward (p->payload points to IP header)
    261           * @param iphdr the IP header of the input packet
    262           * @param inp the netif on which this packet was received
    263           */
    264          static void
    265          ip4_forward(struct pbuf *p, struct ip_hdr *iphdr, struct netif *inp)
    266          {
    267            struct netif *netif;
    268          
    269            PERF_START;
    270          
    271            if (!ip4_canforward(p)) {
    272              goto return_noroute;
    273            }
    274          
    275            /* RFC3927 2.7: do not forward link-local addresses */
    276            if (ip4_addr_islinklocal(ip4_current_dest_addr())) {
    277              LWIP_DEBUGF(IP_DEBUG, ("ip_forward: not forwarding LLA %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
    278                ip4_addr1_16(ip4_current_dest_addr()), ip4_addr2_16(ip4_current_dest_addr()),
    279                ip4_addr3_16(ip4_current_dest_addr()), ip4_addr4_16(ip4_current_dest_addr())));
    280              goto return_noroute;
    281            }
    282          
    283            /* Find network interface where to forward this IP packet to. */
    284            netif = ip4_route_src(ip4_current_dest_addr(), ip4_current_src_addr());
    285            if (netif == NULL) {
    286              LWIP_DEBUGF(IP_DEBUG, ("ip_forward: no forwarding route for %"U16_F".%"U16_F".%"U16_F".%"U16_F" found\n",
    287                ip4_addr1_16(ip4_current_dest_addr()), ip4_addr2_16(ip4_current_dest_addr()),
    288                ip4_addr3_16(ip4_current_dest_addr()), ip4_addr4_16(ip4_current_dest_addr())));
    289              /* @todo: send ICMP_DUR_NET? */
    290              goto return_noroute;
    291            }
    292          #if !IP_FORWARD_ALLOW_TX_ON_RX_NETIF
    293            /* Do not forward packets onto the same network interface on which
    294             * they arrived. */
    295            if (netif == inp) {
    296              LWIP_DEBUGF(IP_DEBUG, ("ip_forward: not bouncing packets back on incoming interface.\n"));
    297              goto return_noroute;
    298            }
    299          #endif /* IP_FORWARD_ALLOW_TX_ON_RX_NETIF */
    300          
    301            /* decrement TTL */
    302            IPH_TTL_SET(iphdr, IPH_TTL(iphdr) - 1);
    303            /* send ICMP if TTL == 0 */
    304            if (IPH_TTL(iphdr) == 0) {
    305              snmp_inc_ipinhdrerrors();
    306          #if LWIP_ICMP
    307              /* Don't send ICMP messages in response to ICMP messages */
    308              if (IPH_PROTO(iphdr) != IP_PROTO_ICMP) {
    309                icmp_time_exceeded(p, ICMP_TE_TTL);
    310              }
    311          #endif /* LWIP_ICMP */
    312              return;
    313            }
    314          
    315            /* Incrementally update the IP checksum. */
    316            if (IPH_CHKSUM(iphdr) >= PP_HTONS(0xffffU - 0x100)) {
    317              IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + PP_HTONS(0x100) + 1);
    318            } else {
    319              IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + PP_HTONS(0x100));
    320            }
    321          
    322            LWIP_DEBUGF(IP_DEBUG, ("ip_forward: forwarding packet to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
    323              ip4_addr1_16(ip4_current_dest_addr()), ip4_addr2_16(ip4_current_dest_addr()),
    324              ip4_addr3_16(ip4_current_dest_addr()), ip4_addr4_16(ip4_current_dest_addr())));
    325          
    326            IP_STATS_INC(ip.fw);
    327            IP_STATS_INC(ip.xmit);
    328            snmp_inc_ipforwdatagrams();
    329          
    330            PERF_STOP("ip_forward");
    331            /* don't fragment if interface has mtu set to 0 [loopif] */
    332            if (netif->mtu && (p->tot_len > netif->mtu)) {
    333              if ((IPH_OFFSET(iphdr) & PP_NTOHS(IP_DF)) == 0) {
    334          #if IP_FRAG
    335                ip4_frag(p, netif, ip4_current_dest_addr());
    336          #else /* IP_FRAG */
    337                /* @todo: send ICMP Destination Unreachable code 13 "Communication administratively prohibited"? */
    338          #endif /* IP_FRAG */
    339              } else {
    340          #if LWIP_ICMP
    341                /* send ICMP Destination Unreachable code 4: "Fragmentation Needed and DF Set" */
    342                icmp_dest_unreach(p, ICMP_DUR_FRAG);
    343          #endif /* LWIP_ICMP */
    344              }
    345              return;
    346            }
    347            /* transmit pbuf on chosen interface */
    348            netif->output(netif, p, ip4_current_dest_addr());
    349            return;
    350          return_noroute:
    351            snmp_inc_ipoutnoroutes();
    352          }
    353          #endif /* IP_FORWARD */
    354          
    355          /* If both IP versions are enabled, this function can dispatch packets to the correct one.
    356           * If only IPv4 is enabled, this directly maps at ip4_input.
    357          * May be used as netif input function.
    358          */
    359          err_t
    360          ip_input(struct pbuf *p, struct netif *inp)
    361          {
    362          #if LWIP_IPV6
    363            if (p != NULL) {
    364              if (IP_HDR_GET_VERSION(p->payload) == 6) {
    365                return ip6_input(p, inp);
    366              }
    367              return ip4_input(p, inp);
    368            }
    369            return ERR_VAL;
    370          #else /* LWIP_IPV6 */
    371            return ip4_input(p, inp);
    372          #endif /* LWIP_IPV6 */
    373          }
    374          
    375          /**
    376           * This function is called by the network interface device driver when
    377           * an IP packet is received. The function does the basic checks of the
    378           * IP header such as packet size being at least larger than the header
    379           * size etc. If the packet was not destined for us, the packet is
    380           * forwarded (using ip_forward). The IP checksum is always checked.
    381           *
    382           * Finally, the packet is sent to the upper layer protocol input function.
    383           *
    384           * @param p the received IP packet (p->payload points to IP header)
    385           * @param inp the netif on which this packet was received
    386           * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
    387           *         processed, but currently always returns ERR_OK)
    388           */
    389          err_t
    390          ip4_input(struct pbuf *p, struct netif *inp)
    391          {
    392            struct ip_hdr *iphdr;
    393            struct netif *netif;
    394            u16_t iphdr_hlen;
    395            u16_t iphdr_len;
    396          #if IP_ACCEPT_LINK_LAYER_ADDRESSING || LWIP_IGMP
    397            int check_ip_src = 1;
    398          #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING || LWIP_IGMP */
    399          
    400            IP_STATS_INC(ip.recv);
    401            snmp_inc_ipinreceives();
    402          
    403            /* identify the IP header */
    404            iphdr = (struct ip_hdr *)p->payload;
    405            if (IPH_V(iphdr) != 4) {
    406              LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    407              ip4_debug_print(p);
    408              pbuf_free(p);
    409              IP_STATS_INC(ip.err);
    410              IP_STATS_INC(ip.drop);
    411              snmp_inc_ipinhdrerrors();
    412              return ERR_OK;
    413            }
    414          
    415          #ifdef LWIP_HOOK_IP4_INPUT
    416            if (LWIP_HOOK_IP4_INPUT(p, inp)) {
    417              /* the packet has been eaten */
    418              return ERR_OK;
    419            }
    420          #endif
    421          
    422            /* obtain IP header length in number of 32-bit words */
    423            iphdr_hlen = IPH_HL(iphdr);
    424            /* calculate IP header length in bytes */
    425            iphdr_hlen *= 4;
    426            /* obtain ip length in bytes */
    427            iphdr_len = ntohs(IPH_LEN(iphdr));
    428          
    429            /* Trim pbuf. This is especially required for packets < 60 bytes. */
    430            if (iphdr_len < p->tot_len) {
    431              pbuf_realloc(p, iphdr_len);
    432            }
    433          
    434            /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
    435            if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    436              if (iphdr_hlen > p->len) {
    437                LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
    438                  ("IP header (len %"U16_F") does not fit in first pbuf (len %"U16_F"), IP packet dropped.\n",
    439                  iphdr_hlen, p->len));
    440              }
    441              if (iphdr_len > p->tot_len) {
    442                LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
    443                  ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
    444                  iphdr_len, p->tot_len));
    445              }
    446              /* free (drop) packet pbufs */
    447              pbuf_free(p);
    448              IP_STATS_INC(ip.lenerr);
    449              IP_STATS_INC(ip.drop);
    450              snmp_inc_ipindiscards();
    451              return ERR_OK;
    452            }
    453          
    454            /* verify checksum */
    455          #if CHECKSUM_CHECK_IP
    456            if (inet_chksum(iphdr, iphdr_hlen) != 0) {
    457          
    458              LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
    459                ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    460              ip4_debug_print(p);
    461              pbuf_free(p);
    462              IP_STATS_INC(ip.chkerr);
    463              IP_STATS_INC(ip.drop);
    464              snmp_inc_ipinhdrerrors();
    465              return ERR_OK;
    466            }
    467          #endif
    468          
    469            /* copy IP addresses to aligned ip_addr_t */
    470            ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
    471            ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
    472          
    473            /* match packet against an interface, i.e. is this packet for us? */
    474          #if LWIP_IGMP
    475            if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
    476              if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, ip4_current_dest_addr()))) {
    477                /* IGMP snooping switches need 0.0.0.0 to be allowed as source address (RFC 4541) */
    478                ip4_addr_t allsystems;
    479                IP4_ADDR(&allsystems, 224, 0, 0, 1);
    480                if (ip4_addr_cmp(ip4_current_dest_addr(), &allsystems) &&
    481                    ip_addr_isany(ip_current_src_addr())) {
    482                  check_ip_src = 0;
    483                }
    484                netif = inp;
    485              } else {
    486                netif = NULL;
    487              }
    488            } else
    489          #endif /* LWIP_IGMP */
    490            {
    491              /* start trying with inp. if that's not acceptable, start walking the
    492                 list of configured netifs.
    493                 'first' is used as a boolean to mark whether we started walking the list */
    494              int first = 1;
    495              netif = inp;
    496              do {
    497                LWIP_DEBUGF(IP_DEBUG, ("ip_input: iphdr->dest 0x%"X32_F" netif->ip_addr 0x%"X32_F" (0x%"X32_F", 0x%"X32_F", 0x%"X32_F")\n",
    498                    ip4_addr_get_u32(&iphdr->dest), ip4_addr_get_u32(netif_ip4_addr(netif)),
    499                    ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
    500                    ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
    501                    ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));
    502          
    503                /* interface is up and configured? */
    504                if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
    505                  /* unicast to this interface address? */
    506                  if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
    507                      /* or broadcast on this interface network address? */
    508                      ip_addr_isbroadcast(ip_current_dest_addr(), netif)
    509          #if LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF
    510                      || (ip4_addr_get_u32(ip4_current_dest_addr()) == PP_HTONL(IPADDR_LOOPBACK))
    511          #endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
    512                      ) {
    513                    LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
    514                        netif->name[0], netif->name[1]));
    515                    /* break out of for loop */
    516                    break;
    517                  }
    518          #if LWIP_AUTOIP
    519                  /* connections to link-local addresses must persist after changing
    520                     the netif's address (RFC3927 ch. 1.9) */
    521                  if ((netif->autoip != NULL) &&
    522                      ip4_addr_cmp(ip4_current_dest_addr(), &(netif->autoip->llipaddr))) {
    523                    LWIP_DEBUGF(IP_DEBUG, ("ip_input: LLA packet accepted on interface %c%c\n",
    524                        netif->name[0], netif->name[1]));
    525                    /* break out of for loop */
    526                    break;
    527                  }
    528          #endif /* LWIP_AUTOIP */
    529                }
    530                if (first) {
    531                  first = 0;
    532                  netif = netif_list;
    533                } else {
    534                  netif = netif->next;
    535                }
    536                if (netif == inp) {
    537                  netif = netif->next;
    538                }
    539              } while(netif != NULL);
    540            }
    541          
    542          #if IP_ACCEPT_LINK_LAYER_ADDRESSING
    543            /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
    544             * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
    545             * According to RFC 1542 section 3.1.1, referred by RFC 2131).
    546             *
    547             * If you want to accept private broadcast communication while a netif is down,
    548             * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
    549             *
    550             * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
    551             */
    552            if (netif == NULL) {
    553              /* remote port is DHCP server? */
    554              if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
    555                struct udp_hdr *udphdr = (struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen);
    556                LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
    557                  ntohs(udphdr->dest)));
    558                if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
    559                  LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: DHCP packet accepted.\n"));
    560                  netif = inp;
    561                  check_ip_src = 0;
    562                }
    563              }
    564            }
    565          #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
    566          
    567            /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
    568          #if LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING
    569            if (check_ip_src
    570          #if IP_ACCEPT_LINK_LAYER_ADDRESSING
    571            /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
    572                && !ip_addr_isany_val(*ip_current_src_addr())
    573          #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
    574               )
    575          #endif /* LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING */
    576            {  if ((ip_addr_isbroadcast(ip_current_src_addr(), inp)) ||
    577                   (ip_addr_ismulticast(ip_current_src_addr()))) {
    578                /* packet source is not valid */
    579                LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
    580                /* free (drop) packet pbufs */
    581                pbuf_free(p);
    582                IP_STATS_INC(ip.drop);
    583                snmp_inc_ipinaddrerrors();
    584                snmp_inc_ipindiscards();
    585                return ERR_OK;
    586              }
    587            }
    588          
    589            /* packet not for us? */
    590            if (netif == NULL) {
    591              /* packet not for us, route or discard */
    592              LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: packet not for us.\n"));
    593          #if IP_FORWARD
    594              /* non-broadcast packet? */
    595              if (!ip_addr_isbroadcast(ip_current_dest_addr(), inp)) {
    596                /* try to forward IP packet on (other) interfaces */
    597                ip4_forward(p, iphdr, inp);
    598              } else
    599          #endif /* IP_FORWARD */
    600              {
    601                snmp_inc_ipinaddrerrors();
    602                snmp_inc_ipindiscards();
    603              }
    604              pbuf_free(p);
    605              return ERR_OK;
    606            }
    607            /* packet consists of multiple fragments? */
    608            if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
    609          #if IP_REASSEMBLY /* packet fragment reassembly code present? */
    610              LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
    611                ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    612              /* reassemble the packet*/
    613              p = ip4_reass(p);
    614              /* packet not fully reassembled yet? */
    615              if (p == NULL) {
    616                return ERR_OK;
    617              }
    618              iphdr = (struct ip_hdr *)p->payload;
    619          #else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
    620              pbuf_free(p);
    621              LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since it was fragmented (0x%"X16_F") (while IP_REASSEMBLY == 0).\n",
    622                ntohs(IPH_OFFSET(iphdr))));
    623              IP_STATS_INC(ip.opterr);
    624              IP_STATS_INC(ip.drop);
    625              /* unsupported protocol feature */
    626              snmp_inc_ipinunknownprotos();
    627              return ERR_OK;
    628          #endif /* IP_REASSEMBLY */
    629            }
    630          
    631          #if IP_OPTIONS_ALLOWED == 0 /* no support for IP options in the IP header? */
    632          
    633          #if LWIP_IGMP
    634            /* there is an extra "router alert" option in IGMP messages which we allow for but do not police */
    635            if((iphdr_hlen > IP_HLEN) &&  (IPH_PROTO(iphdr) != IP_PROTO_IGMP)) {
    636          #else
    637            if (iphdr_hlen > IP_HLEN) {
    638          #endif /* LWIP_IGMP */
    639              LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since there were IP options (while IP_OPTIONS_ALLOWED == 0).\n"));
    640              pbuf_free(p);
    641              IP_STATS_INC(ip.opterr);
    642              IP_STATS_INC(ip.drop);
    643              /* unsupported protocol feature */
    644              snmp_inc_ipinunknownprotos();
    645              return ERR_OK;
    646            }
    647          #endif /* IP_OPTIONS_ALLOWED == 0 */
    648          
    649            /* send to upper layers */
    650            LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
    651            ip4_debug_print(p);
    652            LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));
    653          
    654            ip_data.current_netif = netif;
    655            ip_data.current_input_netif = inp;
    656            ip_data.current_ip4_header = iphdr;
    657            ip_data.current_ip_header_tot_len = IPH_HL(iphdr) * 4;
    658          
    659          #if LWIP_RAW
    660            /* raw input did not eat the packet? */
    661            if (raw_input(p, inp) == 0)
    662          #endif /* LWIP_RAW */
    663            {
    664              pbuf_header(p, -(s16_t)iphdr_hlen); /* Move to payload, no check necessary. */
    665          
    666              switch (IPH_PROTO(iphdr)) {
    667          #if LWIP_UDP
    668              case IP_PROTO_UDP:
    669          #if LWIP_UDPLITE
    670              case IP_PROTO_UDPLITE:
    671          #endif /* LWIP_UDPLITE */
    672                snmp_inc_ipindelivers();
    673                udp_input(p, inp);
    674                break;
    675          #endif /* LWIP_UDP */
    676          #if LWIP_TCP
    677              case IP_PROTO_TCP:
    678                snmp_inc_ipindelivers();
    679                tcp_input(p, inp);
    680                break;
    681          #endif /* LWIP_TCP */
    682          #if LWIP_ICMP
    683              case IP_PROTO_ICMP:
    684                snmp_inc_ipindelivers();
    685                icmp_input(p, inp);
    686                break;
    687          #endif /* LWIP_ICMP */
    688          #if LWIP_IGMP
    689              case IP_PROTO_IGMP:
    690                igmp_input(p, inp, ip4_current_dest_addr());
    691                break;
    692          #endif /* LWIP_IGMP */
    693              default:
    694          #if LWIP_ICMP
    695                /* send ICMP destination protocol unreachable unless is was a broadcast */
    696                if (!ip_addr_isbroadcast(ip_current_dest_addr(), netif) &&
    697                    !ip_addr_ismulticast(ip_current_dest_addr())) {
    698                  pbuf_header_force(p, iphdr_hlen); /* Move to ip header, no check necessary. */
    699                  p->payload = iphdr;
    700                  icmp_dest_unreach(p, ICMP_DUR_PROTO);
    701                }
    702          #endif /* LWIP_ICMP */
    703                pbuf_free(p);
    704          
    705                LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));
    706          
    707                IP_STATS_INC(ip.proterr);
    708                IP_STATS_INC(ip.drop);
    709                snmp_inc_ipinunknownprotos();
    710              }
    711            }
    712          
    713            /* @todo: this is not really necessary... */
    714            ip_data.current_netif = NULL;
    715            ip_data.current_input_netif = NULL;
    716            ip_data.current_ip4_header = NULL;
    717            ip_data.current_ip_header_tot_len = 0;
    718            ip4_addr_set_any(ip4_current_src_addr());
    719            ip4_addr_set_any(ip4_current_dest_addr());
    720          
    721            return ERR_OK;
    722          }
    723          
    724          /**
    725           * Sends an IP packet on a network interface. This function constructs
    726           * the IP header and calculates the IP header checksum. If the source
    727           * IP address is NULL, the IP address of the outgoing network
    728           * interface is filled in as source address.
    729           * If the destination IP address is IP_HDRINCL, p is assumed to already
    730           * include an IP header and p->payload points to it instead of the data.
    731           *
    732           * @param p the packet to send (p->payload points to the data, e.g. next
    733                      protocol header; if dest == IP_HDRINCL, p already includes an IP
    734                      header and p->payload points to that IP header)
    735           * @param src the source IP address to send from (if src == IP_ADDR_ANY, the
    736           *         IP  address of the netif used to send is used as source address)
    737           * @param dest the destination IP address to send the packet to
    738           * @param ttl the TTL value to be set in the IP header
    739           * @param tos the TOS value to be set in the IP header
    740           * @param proto the PROTOCOL to be set in the IP header
    741           * @param netif the netif on which to send this packet
    742           * @return ERR_OK if the packet was sent OK
    743           *         ERR_BUF if p doesn't have enough space for IP/LINK headers
    744           *         returns errors returned by netif->output
    745           *
    746           * @note ip_id: RFC791 "some host may be able to simply use
    747           *  unique identifiers independent of destination"
    748           */
    749          err_t
    750          ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
    751                       u8_t ttl, u8_t tos,
    752                       u8_t proto, struct netif *netif)
    753          {
    754          #if IP_OPTIONS_SEND
    755            return ip4_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
    756          }
    757          
    758          /**
    759           * Same as ip_output_if() but with the possibility to include IP options:
    760           *
    761           * @ param ip_options pointer to the IP options, copied into the IP header
    762           * @ param optlen length of ip_options
    763           */
    764          err_t ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
    765                 u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
    766                 u16_t optlen)
    767          {
    768          #endif /* IP_OPTIONS_SEND */
    769            const ip4_addr_t *src_used = src;
    770            if (dest != IP_HDRINCL) {
    771              if (ip4_addr_isany(src)) {
    772                src_used = netif_ip4_addr(netif);
    773              }
    774            }
    775          
    776          #if IP_OPTIONS_SEND
    777            return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
    778              ip_options, optlen);
    779          #else /* IP_OPTIONS_SEND */
    780            return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
    781          #endif /* IP_OPTIONS_SEND */
    782          }
    783          
    784          /**
    785           * Same as ip_output_if() but 'src' address is not replaced by netif address
    786           * when it is 'any'.
    787           */
    788          err_t
    789          ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
    790                       u8_t ttl, u8_t tos,
    791                       u8_t proto, struct netif *netif)
    792          {
    793          #if IP_OPTIONS_SEND
    794            return ip4_output_if_opt_src(p, src, dest, ttl, tos, proto, netif, NULL, 0);
    795          }
    796          
    797          /**
    798           * Same as ip_output_if_opt() but 'src' address is not replaced by netif address
    799           * when it is 'any'.
    800           */
    801          err_t ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
    802                 u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
    803                 u16_t optlen)
    804          {
    805          #endif /* IP_OPTIONS_SEND */
    806            struct ip_hdr *iphdr;
    807            ip4_addr_t dest_addr;
    808          #if CHECKSUM_GEN_IP_INLINE
    809            u32_t chk_sum = 0;
    810          #endif /* CHECKSUM_GEN_IP_INLINE */
    811          
    812            LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
    813          
    814            snmp_inc_ipoutrequests();
    815          
    816            /* Should the IP header be generated or is it already included in p? */
    817            if (dest != IP_HDRINCL) {
    818              u16_t ip_hlen = IP_HLEN;
    819          #if IP_OPTIONS_SEND
    820              u16_t optlen_aligned = 0;
    821              if (optlen != 0) {
    822          #if CHECKSUM_GEN_IP_INLINE
    823                int i;
    824          #endif /* CHECKSUM_GEN_IP_INLINE */
    825                /* round up to a multiple of 4 */
    826                optlen_aligned = ((optlen + 3) & ~3);
    827                ip_hlen += optlen_aligned;
    828                /* First write in the IP options */
    829                if (pbuf_header(p, optlen_aligned)) {
    830                  LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output_if_opt: not enough room for IP options in pbuf\n"));
    831                  IP_STATS_INC(ip.err);
    832                  snmp_inc_ipoutdiscards();
    833                  return ERR_BUF;
    834                }
    835                MEMCPY(p->payload, ip_options, optlen);
    836                if (optlen < optlen_aligned) {
    837                  /* zero the remaining bytes */
    838                  memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
    839                }
    840          #if CHECKSUM_GEN_IP_INLINE
    841                for (i = 0; i < optlen_aligned/2; i++) {
    842                  chk_sum += ((u16_t*)p->payload)[i];
    843                }
    844          #endif /* CHECKSUM_GEN_IP_INLINE */
    845              }
    846          #endif /* IP_OPTIONS_SEND */
    847              /* generate IP header */
    848              if (pbuf_header(p, IP_HLEN)) {
    849                LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));
    850          
    851                IP_STATS_INC(ip.err);
    852                snmp_inc_ipoutdiscards();
    853                return ERR_BUF;
    854              }
    855          
    856              iphdr = (struct ip_hdr *)p->payload;
    857              LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
    858                         (p->len >= sizeof(struct ip_hdr)));
    859          
    860              IPH_TTL_SET(iphdr, ttl);
    861              IPH_PROTO_SET(iphdr, proto);
    862          #if CHECKSUM_GEN_IP_INLINE
    863              chk_sum += LWIP_MAKE_U16(proto, ttl);
    864          #endif /* CHECKSUM_GEN_IP_INLINE */
    865          
    866              /* dest cannot be NULL here */
    867              ip4_addr_copy(iphdr->dest, *dest);
    868          #if CHECKSUM_GEN_IP_INLINE
    869              chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    870              chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
    871          #endif /* CHECKSUM_GEN_IP_INLINE */
    872          
    873              IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    874              IPH_TOS_SET(iphdr, tos);
    875          #if CHECKSUM_GEN_IP_INLINE
    876              chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    877          #endif /* CHECKSUM_GEN_IP_INLINE */
    878              IPH_LEN_SET(iphdr, htons(p->tot_len));
    879          #if CHECKSUM_GEN_IP_INLINE
    880              chk_sum += iphdr->_len;
    881          #endif /* CHECKSUM_GEN_IP_INLINE */
    882              IPH_OFFSET_SET(iphdr, 0);
    883              IPH_ID_SET(iphdr, htons(ip_id));
    884          #if CHECKSUM_GEN_IP_INLINE
    885              chk_sum += iphdr->_id;
    886          #endif /* CHECKSUM_GEN_IP_INLINE */
    887              ++ip_id;
    888          
    889              if (src == NULL) {
    890                ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY);
    891              } else {
    892                /* src cannot be NULL here */
    893                ip4_addr_copy(iphdr->src, *src);
    894              }
    895          
    896          #if CHECKSUM_GEN_IP_INLINE
    897              chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
    898              chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
    899              chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
    900              chk_sum = (chk_sum >> 16) + chk_sum;
    901              chk_sum = ~chk_sum;
    902              iphdr->_chksum = (u16_t)chk_sum; /* network order */
    903          #else /* CHECKSUM_GEN_IP_INLINE */
    904              IPH_CHKSUM_SET(iphdr, 0);
    905          #if CHECKSUM_GEN_IP
    906              IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
    907          #endif
    908          #endif /* CHECKSUM_GEN_IP_INLINE */
    909            } else {
    910              /* IP header already included in p */
    911              iphdr = (struct ip_hdr *)p->payload;
    912              ip4_addr_copy(dest_addr, iphdr->dest);
    913              dest = &dest_addr;
    914            }
    915          
    916            IP_STATS_INC(ip.xmit);
    917          
    918            LWIP_DEBUGF(IP_DEBUG, ("ip_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], netif->num));
    919            ip4_debug_print(p);
    920          
    921          #if ENABLE_LOOPBACK
    922            if (ip4_addr_cmp(dest, netif_ip4_addr(netif))
    923          #if !LWIP_HAVE_LOOPIF
    924                || ip4_addr_isloopback(dest)
    925          #endif /* !LWIP_HAVE_LOOPIF */
    926                ) {
    927              /* Packet to self, enqueue it for loopback */
    928              LWIP_DEBUGF(IP_DEBUG, ("netif_loop_output()"));
    929              return netif_loop_output(netif, p);
    930            }
    931          #if LWIP_MULTICAST_TX_OPTIONS
    932            if ((p->flags & PBUF_FLAG_MCASTLOOP) != 0) {
    933              netif_loop_output(netif, p);
    934            }
    935          #endif /* LWIP_MULTICAST_TX_OPTIONS */
    936          #endif /* ENABLE_LOOPBACK */
    937          #if IP_FRAG
    938            /* don't fragment if interface has mtu set to 0 [loopif] */
    939            if (netif->mtu && (p->tot_len > netif->mtu)) {
    940              return ip4_frag(p, netif, dest);
    941            }
    942          #endif /* IP_FRAG */
    943          
    944            LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
    945            return netif->output(netif, p, dest);
    946          }
    947          
    948          /**
    949           * Simple interface to ip_output_if. It finds the outgoing network
    950           * interface and calls upon ip_output_if to do the actual work.
    951           *
    952           * @param p the packet to send (p->payload points to the data, e.g. next
    953                      protocol header; if dest == IP_HDRINCL, p already includes an IP
    954                      header and p->payload points to that IP header)
    955           * @param src the source IP address to send from (if src == IP_ADDR_ANY, the
    956           *         IP  address of the netif used to send is used as source address)
    957           * @param dest the destination IP address to send the packet to
    958           * @param ttl the TTL value to be set in the IP header
    959           * @param tos the TOS value to be set in the IP header
    960           * @param proto the PROTOCOL to be set in the IP header
    961           *
    962           * @return ERR_RTE if no route is found
    963           *         see ip_output_if() for more return values
    964           */
    965          err_t
    966          ip4_output(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
    967                    u8_t ttl, u8_t tos, u8_t proto)
    968          {
    969            struct netif *netif;
    970          
    971            LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
    972          
    973            if ((netif = ip4_route_src(dest, src)) == NULL) {
    974              LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
    975                ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    976              IP_STATS_INC(ip.rterr);
    977              return ERR_RTE;
    978            }
    979          
    980            return ip4_output_if(p, src, dest, ttl, tos, proto, netif);
    981          }
    982          
    983          #if LWIP_NETIF_HWADDRHINT
    984          /** Like ip_output, but takes and addr_hint pointer that is passed on to netif->addr_hint
    985           *  before calling ip_output_if.
    986           *
    987           * @param p the packet to send (p->payload points to the data, e.g. next
    988                      protocol header; if dest == IP_HDRINCL, p already includes an IP
    989                      header and p->payload points to that IP header)
    990           * @param src the source IP address to send from (if src == IP_ADDR_ANY, the
    991           *         IP  address of the netif used to send is used as source address)
    992           * @param dest the destination IP address to send the packet to
    993           * @param ttl the TTL value to be set in the IP header
    994           * @param tos the TOS value to be set in the IP header
    995           * @param proto the PROTOCOL to be set in the IP header
    996           * @param addr_hint address hint pointer set to netif->addr_hint before
    997           *        calling ip_output_if()
    998           *
    999           * @return ERR_RTE if no route is found
   1000           *         see ip_output_if() for more return values
   1001           */
   1002          err_t
   1003          ip4_output_hinted(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
   1004                    u8_t ttl, u8_t tos, u8_t proto, u8_t *addr_hint)
   1005          {
   1006            struct netif *netif;
   1007            err_t err;
   1008          
   1009            LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
   1010          
   1011            if ((netif = ip4_route_src(dest, src)) == NULL) {
   1012              LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
   1013                ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
   1014              IP_STATS_INC(ip.rterr);
   1015              return ERR_RTE;
   1016            }
   1017          
   1018            NETIF_SET_HWADDRHINT(netif, addr_hint);
   1019            err = ip4_output_if(p, src, dest, ttl, tos, proto, netif);
   1020            NETIF_SET_HWADDRHINT(netif, NULL);
   1021          
   1022            return err;
   1023          }
   1024          #endif /* LWIP_NETIF_HWADDRHINT*/
   1025          
   1026          #if IP_DEBUG
   1027          /* Print an IP header by using LWIP_DEBUGF
   1028           * @param p an IP packet, p->payload pointing to the IP header
   1029           */
   1030          void
   1031          ip4_debug_print(struct pbuf *p)
   1032          {
   1033            struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
   1034          
   1035            LWIP_DEBUGF(IP_DEBUG, ("IP header:\n"));
   1036            LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
   1037            LWIP_DEBUGF(IP_DEBUG, ("|%2"S16_F" |%2"S16_F" |  0x%02"X16_F" |     %5"U16_F"     | (v, hl, tos, len)\n",
   1038                              IPH_V(iphdr),
   1039                              IPH_HL(iphdr),
   1040                              IPH_TOS(iphdr),
   1041                              ntohs(IPH_LEN(iphdr))));
   1042            LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
   1043            LWIP_DEBUGF(IP_DEBUG, ("|    %5"U16_F"      |%"U16_F"%"U16_F"%"U16_F"|    %4"U16_F"   | (id, flags, offset)\n",
   1044                              ntohs(IPH_ID(iphdr)),
   1045                              ntohs(IPH_OFFSET(iphdr)) >> 15 & 1,
   1046                              ntohs(IPH_OFFSET(iphdr)) >> 14 & 1,
   1047                              ntohs(IPH_OFFSET(iphdr)) >> 13 & 1,
   1048                              ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK));
   1049            LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
   1050            LWIP_DEBUGF(IP_DEBUG, ("|  %3"U16_F"  |  %3"U16_F"  |    0x%04"X16_F"     | (ttl, proto, chksum)\n",
   1051                              IPH_TTL(iphdr),
   1052                              IPH_PROTO(iphdr),
   1053                              ntohs(IPH_CHKSUM(iphdr))));
   1054            LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
   1055            LWIP_DEBUGF(IP_DEBUG, ("|  %3"U16_F"  |  %3"U16_F"  |  %3"U16_F"  |  %3"U16_F"  | (src)\n",
   1056                              ip4_addr1_16(&iphdr->src),
   1057                              ip4_addr2_16(&iphdr->src),
   1058                              ip4_addr3_16(&iphdr->src),
   1059                              ip4_addr4_16(&iphdr->src)));
   1060            LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
   1061            LWIP_DEBUGF(IP_DEBUG, ("|  %3"U16_F"  |  %3"U16_F"  |  %3"U16_F"  |  %3"U16_F"  | (dest)\n",
   1062                              ip4_addr1_16(&iphdr->dest),
   1063                              ip4_addr2_16(&iphdr->dest),
   1064                              ip4_addr3_16(&iphdr->dest),
   1065                              ip4_addr4_16(&iphdr->dest)));
   1066            LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
   1067          }
   1068          #endif /* IP_DEBUG */
   1069          
   1070          #endif /* LWIP_IPV4 */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   ip4_input
        40   -> icmp_dest_unreach
        40   -> icmp_input
        40   -> inet_chksum
        40   -> ip4_addr_isbroadcast_u32
        40   -> ip4_reass
        40   -> lwip_ntohs
        40   -> pbuf_free
        40   -> pbuf_header
        40   -> pbuf_header_force
        40   -> pbuf_realloc
        40   -> raw_input
        40   -> tcp_input
        40   -> udp_input
      32   ip4_output
        32   -> ip4_output_if
        32   -> ip4_route
        32   -> printf
      32   ip4_output_if
        32   -> ip4_output_if_src
      32   ip4_output_if_src
        32   -- Indirect call
        32   -> ip4_frag
        32   -> lwip_htons
        32   -> netif_loop_output
        32   -> pbuf_header
        32   -> printf
       4   ip4_route
       0   ip_input
         0   -> ip4_input


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
      40  ?_0
      12  ?_1
      80  ?_2
      48  ?_3
     604  ip4_input
      88  ip4_output
      44  ip4_output_if
     308  ip4_output_if_src
     110  ip4_route
      24  ip_data
       2  ip_id
       2  ip_input

 
    26 bytes in section .bss
 1 368 bytes in section .text
 
 1 368 bytes of CODE memory
    26 bytes of DATA memory

Errors: none
Warnings: 7
