###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:22
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\hal_aes.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW6BDB.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\hal_aes.c -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\hal_aes.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\hal_aes.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\hal_aes.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          #include "hal_aes.h"
     36          
     37          #ifdef HAL_AES_MODULE_ENABLED
     38          
     39          #include <string.h>
     40          #include "hal_define.h"
     41          #include "mt7687.h"
     42          #include "crypt_aes.h"
     43          #include "hal_log.h"
     44          #include "hal_crypt_internal.h"
     45          #include "hal_nvic.h"
     46          
     47          /* global lock used to protect the crypto engine */
     48          bool g_crypt_lock = CRYPT_UNLOCK;
     49          
     50          /* internal function for getting lock, -100 means the crypto engine is not available */
     51          int32_t hal_crypt_lock_take(void)
     52          {
     53              uint32_t irq_status;
     54              irq_status = save_and_set_interrupt_mask();
     55              if (g_crypt_lock == CRYPT_LOCK) {
     56                  restore_interrupt_mask(irq_status);
     57                  return -100;
     58              }
     59              g_crypt_lock = CRYPT_LOCK;
     60              restore_interrupt_mask(irq_status);
     61              return 0;
     62          }
     63          
     64          
     65          /* internal function for releasing lock */
     66          void hal_crypt_lock_give(void)
     67          {
     68              g_crypt_lock = CRYPT_UNLOCK;
     69          }
     70          
     71          volatile static bool g_aes_op_done = false;
     72          
     73          /* It's about 10s at 192MHz CPU clock */
     74          #define HAL_AES_MAX_WAIT_COUNT 0x10000000
     75          
     76          static void aes_operation_done(hal_nvic_irq_t irq_number)
     77          {
     78              NVIC_DisableIRQ((IRQn_Type)CM4_MTK_CRYPTO_IRQ);
     79              NVIC_ClearPendingIRQ((IRQn_Type)CM4_MTK_CRYPTO_IRQ);
     80          
     81              g_aes_op_done = true;
     82          
     83              NVIC_EnableIRQ((IRQn_Type)CM4_MTK_CRYPTO_IRQ);
     84          }
     85          
     86          static hal_aes_status_t do_aes_encrypt(uint8_t *encrypt_buffer,
     87                                                 uint32_t encrypt_buffer_length,
     88                                                 uint8_t *plain_buffer,
     89                                                 uint32_t plain_buffer_length,
     90                                                 uint8_t init_vector[HAL_AES_CBC_IV_LENGTH])
     91          {
     92              g_aes_op_done = false;
     93              int32_t ret_val = aes_operate(encrypt_buffer,
     94                                            encrypt_buffer_length,
     95                                            plain_buffer,
     96                                            plain_buffer_length,
     97                                            init_vector,
     98                                            AES_MODE_ENCRYPT);
     99              if (ret_val < 0) {
    100                  log_hal_error("aes_operate fail.");
    101                  return HAL_AES_STATUS_ERROR;
    102              }
    103              uint32_t wait_count = 0;
    104              while (!g_aes_op_done) {
    105                  //simple wait
    106                  wait_count++;
    107                  if (wait_count > HAL_AES_MAX_WAIT_COUNT) {
    108                      log_hal_error("wait for encrypt timeout.");
    109                      return HAL_AES_STATUS_ERROR;
    110                  }
    111              }
    112              return HAL_AES_STATUS_OK;
    113          }
    114          
    115          static hal_aes_status_t do_aes_decrypt(hal_aes_buffer_t *plain_text,
    116                                                 hal_aes_buffer_t *encrypted_text,
    117                                                 uint8_t init_vector[HAL_AES_CBC_IV_LENGTH])
    118          {
    119              g_aes_op_done = false;
    120          
    121              int32_t ret_val = aes_operate(encrypted_text->buffer,
    122                                            encrypted_text->length,
    123                                            plain_text->buffer,
    124                                            plain_text->length,
    125                                            init_vector,
    126                                            AES_MODE_DECRYPT);
    127              if (ret_val < 0) {
    128                  log_hal_error("aes_operate fail.");
    129                  return HAL_AES_STATUS_ERROR;
    130              }
    131              uint32_t wait_count = 0;
    132              while (!g_aes_op_done) {
    133                  //simple wait
    134                  wait_count++;
    135                  if (wait_count > HAL_AES_MAX_WAIT_COUNT) {
    136                      log_hal_error("wait for decrypt timeout.");
    137                      return HAL_AES_STATUS_ERROR;
    138                  }
    139              }
    140              return HAL_AES_STATUS_OK;
    141          }
    142          
    143          /* internal common function */
    144          hal_aes_status_t hal_aes_encrypt_with_padding(hal_aes_buffer_t *encrypted_text,
    145                  hal_aes_buffer_t *plain_text,
    146                  hal_aes_buffer_t *key,
    147                  uint8_t init_vector[HAL_AES_CBC_IV_LENGTH],
    148                  uint8_t mode)
    149          {
    150              if ((NULL == encrypted_text)
    151                      || (NULL == plain_text)
    152                      || (NULL == key)
    153                      || (NULL == init_vector)) {
    154                  log_hal_error("NULL input.");
    155                  return HAL_AES_STATUS_ERROR;
    156              }
    157              uint32_t last_block_size = plain_text->length % HAL_AES_BLOCK_SIZES;
    158              uint32_t block_num = plain_text->length / HAL_AES_BLOCK_SIZES;
    159              uint8_t padding_size = HAL_AES_BLOCK_SIZES - last_block_size;
    160              uint8_t *iv;
    161          
    162              if (encrypted_text->length < (plain_text->length + padding_size)) {
    163                  log_hal_error("Inadequate encrypted buffer.");
    164                  return HAL_AES_STATUS_ERROR;
    165              }
    166          
    167              hal_crypt_lock_take();
    168          
    169              hal_nvic_register_isr_handler((IRQn_Type)CM4_MTK_CRYPTO_IRQ, aes_operation_done);
    170              NVIC_SetPriority((IRQn_Type)CM4_MTK_CRYPTO_IRQ, CM4_MTK_CRYPTO_PRI);
    171              NVIC_EnableIRQ((IRQn_Type)CM4_MTK_CRYPTO_IRQ);
    172          
    173              aes_set_key((uint8_t)key->length, key->buffer);
    174          
    175              if (AES_TYPE_CBC == mode) { /* AES_TYPE_CBC */
    176                  aes_configure(1, 1); /* 1:software 0:ECB and 1:CBC */
    177              } else { /* AES_TYPE_CBC */
    178                  aes_configure(1, 0); /* 1:software 0:ECB and 1:CBC */
    179              }
    180          
    181              if (block_num > 0) {
    182                  uint32_t first_encypt_size = block_num * HAL_AES_BLOCK_SIZES;
    183                  if (HAL_AES_STATUS_OK != do_aes_encrypt(encrypted_text->buffer,
    184                                                          encrypted_text->length,
    185                                                          plain_text->buffer,
    186                                                          first_encypt_size,
    187                                                          init_vector)) {
    188                      log_hal_error("do_aes_encrypt fail.");
    189                      hal_crypt_lock_give();
    190                      return HAL_AES_STATUS_ERROR;
    191                  }
    192          
    193                  uint8_t data_block[HAL_AES_BLOCK_SIZES] = {0};
    194                  memcpy(data_block, plain_text->buffer + first_encypt_size, last_block_size);
    195                  memset(data_block + last_block_size, padding_size, padding_size);
    196          
    197                  uint8_t *init_vector2;
    198                  if (AES_TYPE_CBC == mode) { /* do 2nd aes cbc operation need to input newer iv */
    199                      init_vector2 = encrypted_text->buffer + first_encypt_size - HAL_AES_BLOCK_SIZES;
    200                      iv = init_vector2;
    201                  } else {
    202                      iv = init_vector;
    203                  }
    204          
    205                  if (HAL_AES_STATUS_OK != do_aes_encrypt(encrypted_text->buffer + first_encypt_size,
    206                                                          encrypted_text->length,
    207                                                          data_block,
    208                                                          HAL_AES_BLOCK_SIZES,
    209                                                          iv)) {
    210                      log_hal_error("do_aes_encrypt fail.");
    211                      hal_crypt_lock_give();
    212                      return HAL_AES_STATUS_ERROR;
    213                  }
    214              } else {
    215                  uint8_t data_block[HAL_AES_BLOCK_SIZES] = {0};
    216                  memcpy(data_block, plain_text->buffer, plain_text->length);
    217                  memset(data_block + last_block_size, padding_size, padding_size);
    218                  if (HAL_AES_STATUS_OK != do_aes_encrypt(encrypted_text->buffer,
    219                                                          encrypted_text->length,
    220                                                          data_block,
    221                                                          HAL_AES_BLOCK_SIZES,
    222                                                          init_vector)) {
    223                      log_hal_error("do_aes_encrypt fail.");
    224                      hal_crypt_lock_give();
    225                      return HAL_AES_STATUS_ERROR;
    226                  }
    227              }
    228          
    229              encrypted_text->length = (block_num + 1) * HAL_AES_BLOCK_SIZES;
    230          
    231              hal_crypt_lock_give();
    232              return HAL_AES_STATUS_OK;
    233          }
    234          
    235          hal_aes_status_t hal_aes_decrypt(hal_aes_buffer_t *plain_text,
    236                                           hal_aes_buffer_t *encrypted_text,
    237                                           hal_aes_buffer_t *key,
    238                                           uint8_t init_vector[HAL_AES_CBC_IV_LENGTH],
    239                                           uint8_t mode)
    240          {
    241              if ((NULL == plain_text)
    242                      || (NULL == encrypted_text)
    243                      || (NULL == key)
    244                      || (NULL == init_vector)) {
    245                  log_hal_error("NULL input.");
    246                  return HAL_AES_STATUS_ERROR;
    247              }
    248          
    249              if ((encrypted_text->length % HAL_AES_BLOCK_SIZES) != 0) {
    250                  log_hal_error("Invalid encrypted text length: %lu.", encrypted_text->length);
    251                  return HAL_AES_STATUS_ERROR;
    252              }
    253              if (plain_text->length < (encrypted_text->length - HAL_AES_BLOCK_SIZES)) {
    254                  log_hal_error("Plain text buffer lengthL %lu is too small, encrypted length is: %lu",
    255                                encrypted_text->length, encrypted_text->length);
    256                  return HAL_AES_STATUS_ERROR;
    257              }
    258              if ((key->length != HAL_AES_KEY_LENGTH_128)
    259                      && (key->length != HAL_AES_KEY_LENGTH_192)
    260                      && (key->length != HAL_AES_KEY_LENGTH_256)) {
    261                  log_hal_error("key length is %lu, invalid. It has to be 16, 24 or 32.", key->length);
    262                  return HAL_AES_STATUS_ERROR;
    263              }
    264          
    265              hal_crypt_lock_take();
    266          
    267              hal_nvic_register_isr_handler((IRQn_Type)CM4_MTK_CRYPTO_IRQ, aes_operation_done);
    268              NVIC_SetPriority((IRQn_Type)CM4_MTK_CRYPTO_IRQ, CM4_MTK_CRYPTO_PRI);
    269              NVIC_EnableIRQ((IRQn_Type)CM4_MTK_CRYPTO_IRQ);
    270          
    271              aes_set_key(key->length, key->buffer);
    272              if (AES_TYPE_CBC == mode) { /* AES_TYPE_CBC */
    273                  aes_configure(1, 1); /* 1:software 0:ECB and 1:CBC */
    274              } else { /* AES_TYPE_CBC */
    275                  aes_configure(1, 0); /* 1:software 0:ECB and 1:CBC */
    276              }
    277          
    278          
    279              if (HAL_AES_STATUS_OK != do_aes_decrypt(plain_text, encrypted_text, init_vector)) {
    280                  log_hal_error("do_aes_decrypt fail");
    281                  hal_crypt_lock_give();
    282                  return HAL_AES_STATUS_ERROR;
    283              }
    284          
    285              uint8_t padding_size = plain_text->buffer[encrypted_text->length - 1];
    286              log_hal_dump("Decrypted raw data(AES %s): ", plain_text->buffer, encrypted_text->length, (mode == AES_TYPE_CBC) ? "CBC" : "ECB");
    287              plain_text->length = encrypted_text->length - padding_size;
    288          
    289              hal_crypt_lock_give();
    290              return HAL_AES_STATUS_OK;
    291          }
    292          
    293          hal_aes_status_t hal_aes_cbc_encrypt(hal_aes_buffer_t *encrypted_text,
    294                                               hal_aes_buffer_t *plain_text,
    295                                               hal_aes_buffer_t *key,
    296                                               uint8_t init_vector[HAL_AES_CBC_IV_LENGTH])
    297          {
    298              return hal_aes_encrypt_with_padding(encrypted_text, plain_text, key, init_vector, AES_TYPE_CBC);
    299          }
    300          
    301          hal_aes_status_t hal_aes_cbc_decrypt(hal_aes_buffer_t *plain_text,
    302                                               hal_aes_buffer_t *encrypted_text,
    303                                               hal_aes_buffer_t *key,
    304                                               uint8_t init_vector[HAL_AES_CBC_IV_LENGTH])
    305          {
    306              return hal_aes_decrypt(plain_text, encrypted_text, key, init_vector, AES_TYPE_CBC);
    307          }
    308          
    309          hal_aes_status_t hal_aes_ecb_encrypt(hal_aes_buffer_t *encrypted_text,
    310                                               hal_aes_buffer_t *plain_text,
    311                                               hal_aes_buffer_t *key)
    312          {
    313              uint8_t init_vector[16] = {0};
    314          
    315              return hal_aes_encrypt_with_padding(encrypted_text, plain_text, key, init_vector, AES_TYPE_ECB);
    316          }
    317          
    318          hal_aes_status_t hal_aes_ecb_decrypt(hal_aes_buffer_t *plain_text,
    319                                               hal_aes_buffer_t *encrypted_text,
    320                                               hal_aes_buffer_t *key)
    321          {
    322              uint8_t init_vector[HAL_AES_CBC_IV_LENGTH] = {0};
    323          
    324              return hal_aes_decrypt(plain_text, encrypted_text, key, init_vector, AES_TYPE_ECB);
    325          }
    326          
    327          #endif /* HAL_AES_MODULE_ENABLED */
    328          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_ClearPendingIRQ
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       4   NVIC_SetPriority
       8   aes_operation_done
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_DisableIRQ
         0   -> NVIC_EnableIRQ
      24   do_aes_decrypt
        24   -> aes_operate
        24   -> log_hal_error_internal
      24   do_aes_encrypt
        24   -> aes_operate
        24   -> log_hal_error_internal
      16   hal_aes_cbc_decrypt
        16   -> hal_aes_decrypt
      16   hal_aes_cbc_encrypt
        16   -> hal_aes_encrypt_with_padding
      32   hal_aes_decrypt
        32   -> NVIC_EnableIRQ
        32   -> NVIC_SetPriority
        32   -> aes_configure
        32   -> aes_set_key
        32   -> do_aes_decrypt
        32   -> hal_crypt_lock_give
        32   -> hal_crypt_lock_take
        32   -> hal_nvic_register_isr_handler
        32   -> log_hal_dump_internal
        32   -> log_hal_error_internal
      40   hal_aes_ecb_decrypt
        40   -> __aeabi_memclr4
        40   -> hal_aes_decrypt
      40   hal_aes_ecb_encrypt
        40   -> __aeabi_memclr4
        40   -> hal_aes_encrypt_with_padding
      56   hal_aes_encrypt_with_padding
        56   -> NVIC_EnableIRQ
        56   -> NVIC_SetPriority
        56   -> __aeabi_memclr4
        56   -> __aeabi_memcpy
        56   -> __aeabi_memset
        56   -> aes_configure
        56   -> aes_set_key
        56   -> do_aes_encrypt
        56   -> hal_crypt_lock_give
        56   -> hal_crypt_lock_take
        56   -> hal_nvic_register_isr_handler
        56   -> log_hal_error_internal
       0   hal_crypt_lock_give
       8   hal_crypt_lock_take
         8   -> restore_interrupt_mask
         8   -> save_and_set_interrupt_mask


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_10
       4  ??DataTable31_2
       4  ??DataTable31_3
       4  ??DataTable31_4
       4  ??DataTable31_5
       4  ??DataTable31_6
       4  ??DataTable31_7
       4  ??DataTable31_8
       4  ??DataTable31_9
      20  ?_0
      28  ?_1
      56  ?_10
      20  ?_11
      32  ?_12
       4  ?_13
       4  ?_14
      16  ?_15
      16  ?_16
      28  ?_2
      12  ?_3
      32  ?_4
      24  ?_5
      16  ?_6
      16  ?_7
      36  ?_8
      72  ?_9
      20  NVIC_ClearPendingIRQ
      20  NVIC_DisableIRQ
      20  NVIC_EnableIRQ
      34  NVIC_SetPriority
      30  aes_operation_done
      96  do_aes_decrypt
      90  do_aes_encrypt
       1  g_aes_op_done
       1  g_crypt_lock
      14  hal_aes_cbc_decrypt
      14  hal_aes_cbc_encrypt
     306  hal_aes_decrypt
      38  hal_aes_ecb_decrypt
      38  hal_aes_ecb_encrypt
     390  hal_aes_encrypt_with_padding
      10  hal_crypt_lock_give
      38  hal_crypt_lock_take
      80  -- Other

 
     2 bytes in section .bss
    72 bytes in section .rodata
 1 642 bytes in section .text
 
 1 642 bytes of CODE  memory
    72 bytes of CONST memory
     2 bytes of DATA  memory

Errors: none
Warnings: none
