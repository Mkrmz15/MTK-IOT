###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:23
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\hal_eint.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW6DE3.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\hal_eint.c -D
#        MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\hal_eint.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\hal_eint.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\hal_eint.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          #include "hal_eint.h"
     36          #ifdef HAL_EINT_MODULE_ENABLED
     37          
     38          #include <string.h>
     39          #include "hal_eint.h"
     40          #include "hal_gpio.h"
     41          #include "hal_log.h"
     42          #include "low_hal_gpio.h"
     43          #include "hal_gpio_7687.h"
     44          #include "nvic.h"
     45          #include "stdbool.h"
     46          
     47          typedef struct {
     48              bool callback_present;
     49              hal_eint_callback_t callback;
     50              void *user_data;
     51          } hal_eint_callback_context_t;
     52          
     53          
     54          #define HAL_EINT_COUNT (11)
     55          
     56          static hal_eint_callback_context_t g_eint_callback_context[HAL_EINT_COUNT];
     57          static uint32_t is_eint_callback_registered[HAL_EINT_COUNT];
     58          static uint32_t is_eint_masked[HAL_EINT_COUNT];
     59          
     60          typedef struct {
     61              hal_eint_number_t eint_number;
     62              ENUM_IOT_GPIO_NAME_T gpio_pin;
     63          } hal_eint_gpio_map_t;
     64          
     65          
     66          static const hal_eint_gpio_map_t eint_gpio_table[] = {
     67              {HAL_EINT_NUMBER_0,  eIOT_GPIO_IDX_0},
     68              {HAL_EINT_NUMBER_1,  eIOT_GPIO_IDX_1},
     69              {HAL_EINT_NUMBER_2,  eIOT_GPIO_IDX_3},
     70              {HAL_EINT_NUMBER_3,  eIOT_GPIO_IDX_4},
     71              {HAL_EINT_NUMBER_4,  eIOT_GPIO_IDX_5},
     72              {HAL_EINT_NUMBER_5,  eIOT_GPIO_IDX_6},
     73              {HAL_EINT_NUMBER_6,  eIOT_GPIO_IDX_7},
     74              {HAL_EINT_NUMBER_19, eIOT_GPIO_IDX_35},
     75              {HAL_EINT_NUMBER_20, eIOT_GPIO_IDX_37},
     76              {HAL_EINT_NUMBER_21, eIOT_GPIO_IDX_38},
     77              {HAL_EINT_NUMBER_22, eIOT_GPIO_IDX_39}
     78          };
     79          
     80          static uint32_t get_index_from_gpio_pin(ENUM_IOT_GPIO_NAME_T gpio_pin)
     81          {
     82              uint32_t count = sizeof(eint_gpio_table) / sizeof(eint_gpio_table[0]);
     83              uint32_t index = 0;
     84              for (index = 0; index < count; index++) {
     85                  if (eint_gpio_table[index].gpio_pin == gpio_pin) {
     86                      return index;
     87                  }
     88              }
     89              return (0xFFFFFFFF);
     90          }
     91          
     92          static int32_t hal_eint_convert_for_gpio(hal_eint_number_t eint_number, ENUM_IOT_GPIO_NAME_T *gpio_pin)
     93          {
     94              uint32_t count = sizeof(eint_gpio_table) / sizeof(eint_gpio_table[0]);
     95              uint32_t index = 0;
     96              for (index = 0; index < count; index++) {
     97                  if (eint_gpio_table[index].eint_number == eint_number) {
     98                      *gpio_pin = eint_gpio_table[index].gpio_pin;
     99                      return 0;
    100                  }
    101              }
    102              return -1;
    103          }
    104          
    105          static void hal_eint_calc_debounce_parameters(uint32_t debounce_time,
    106                  ENUM_DEBOUNCE_PRESCALER_T *sample_rate,
    107                  uint32_t *sample_count)
    108          {
    109              /*
    110                  We prefer a higher sample rate for debouncing, i.e. check a number of times
    111                  to make sure any interference to be detected and filtered.
    112                  But checking too many times doesn't help much, so a threshold is defined,
    113                  to scale among different sample rates.
    114              */
    115              uint32_t const threshold = 10;
    116              uint32_t target_count = 0;
    117              if ((target_count = debounce_time * 8) <= threshold) {
    118                  *sample_rate = eDebounce_Prescaler_8K;
    119              } else if ((target_count = debounce_time * 4) <= threshold) {
    120                  *sample_rate = eDebounce_Prescaler_4K;
    121              } else if ((target_count = debounce_time * 2) <= threshold) {
    122                  *sample_rate = eDebounce_Prescaler_2K;
    123              } else if ((target_count = debounce_time * 1) <= threshold) {
    124                  *sample_rate = eDebounce_Prescaler_1K;
    125              } else if ((target_count = debounce_time / 2) <= threshold) {
    126                  *sample_rate = eDebounce_Prescaler_Dot5K;
    127              } else if ((target_count = debounce_time / 4) <= threshold) {
    128                  *sample_rate = eDebounce_Prescaler_Dot25K;
    129              } else if ((target_count = debounce_time / 8) <= threshold) {
    130                  *sample_rate = eDebounce_Prescaler_Dot125K;
    131              } else {
    132                  *sample_rate = eDebounce_Prescaler_Dot0625K;
    133                  *sample_count = debounce_time / 16;
    134              }
    135              *sample_count = target_count;
    136          }
    137          
    138          static void hal_eint_isr(ENUM_IOT_GPIO_NAME_T gpio_name)
    139          {
    140              hal_eint_callback_context_t *callback_context = &g_eint_callback_context[get_index_from_gpio_pin(gpio_name)];
    141              if ((true == callback_context->callback_present)
    142                      && (NULL != callback_context->callback)) {
    143                  callback_context->callback(callback_context->user_data);
    144              }
    145          }
    146          
    147          static hal_eint_status_t hal_eint_apply_config(ENUM_IOT_GPIO_NAME_T gpio_pin,
    148                  const hal_eint_config_t *eint_config)
    149          {
    150              uint32_t sample_count;
    151              int32_t ret_value;
    152              ENUM_NVIC_SENSE_T trigger_mode;
    153              ENUM_DEBOUNCE_POL_T trigger_polarity;
    154              ENUM_DEBOUNCE_PRESCALER_T sample_rate;
    155              ENUM_DEBOUNCE_DUAL_T dual_edge;
    156          
    157              dual_edge = eDebounce_Dual_No;
    158              switch (eint_config->trigger_mode) {
    159                  case  HAL_EINT_LEVEL_LOW : {
    160                      trigger_mode = eLevel_Trigger;
    161                      trigger_polarity = eDebounce_Positive_Pol;
    162                      break;
    163                  }
    164                  case  HAL_EINT_LEVEL_HIGH : {
    165                      trigger_mode = eLevel_Trigger;
    166                      trigger_polarity = eDebounce_Negative_Pol;
    167                      break;
    168                  }
    169                  case  HAL_EINT_EDGE_FALLING : {
    170                      trigger_mode = eEdge_Trigger;
    171                      trigger_polarity = eDebounce_Positive_Pol;
    172                      break;
    173                  }
    174                  case  HAL_EINT_EDGE_RISING : {
    175                      trigger_mode = eEdge_Trigger;
    176                      trigger_polarity = eDebounce_Negative_Pol;
    177                      break;
    178                  }
    179                  case  HAL_EINT_EDGE_FALLING_AND_RISING : {
    180                      trigger_mode = eEdge_Trigger;
    181                      trigger_polarity = eDebounce_Negative_Pol;
    182                      dual_edge = eDebounce_Dual_Yes;
    183                      break;
    184                  }
    185                  default :
    186                      return HAL_EINT_STATUS_ERROR;
    187              }
    188          
    189              hal_eint_calc_debounce_parameters(eint_config->debounce_time,
    190                                                &sample_rate,
    191                                                &sample_count);
    192              if (sample_count == 0) {
    193                  ret_value = gpio_int(gpio_pin,
    194                                       trigger_mode,
    195                                       eDebounce_Disable,
    196                                       trigger_polarity,
    197                                       dual_edge,
    198                                       sample_rate,
    199                                       sample_count,
    200                                       hal_eint_isr);
    201                  log_hal_error("hal_eint_init: debounce disable.");
    202              } else {
    203                  ret_value = gpio_int(gpio_pin,
    204                                       trigger_mode,
    205                                       eDebounce_Enable,
    206                                       trigger_polarity,
    207                                       dual_edge,
    208                                       sample_rate,
    209                                       sample_count,
    210                                       hal_eint_isr);
    211              }
    212          
    213              return (ret_value >= 0) ? HAL_EINT_STATUS_OK : HAL_EINT_STATUS_ERROR;
    214          }
    215          
    216          hal_eint_status_t hal_eint_mask(hal_eint_number_t eint_number)
    217          {
    218              ENUM_IOT_GPIO_NAME_T gpio_pin;
    219              if (0 != hal_eint_convert_for_gpio(eint_number, &gpio_pin)) {
    220                  log_hal_error("hal_eint_convert_for_gpio fail.");
    221                  return HAL_EINT_STATUS_ERROR;
    222              }
    223              eint_set_mask(gpio_pin);
    224              is_eint_masked[eint_number] = true;
    225              return HAL_EINT_STATUS_OK;
    226          }
    227          
    228          hal_eint_status_t hal_eint_unmask(hal_eint_number_t eint_number)
    229          {
    230              ENUM_IOT_GPIO_NAME_T gpio_pin;
    231              if (0 != hal_eint_convert_for_gpio(eint_number, &gpio_pin)) {
    232                  log_hal_error("hal_eint_convert_for_gpio fail.");
    233                  return HAL_EINT_STATUS_ERROR;
    234              }
    235               eint_set_unmask(gpio_pin);
    236               is_eint_masked[eint_number] = false;
    237               return HAL_EINT_STATUS_OK;
    238          }
    239          
    240          hal_eint_status_t hal_eint_init(hal_eint_number_t eint_number, const hal_eint_config_t *eint_config)
    241          {
    242              ENUM_IOT_GPIO_NAME_T gpio_pin;
    243              hal_eint_status_t    ret_status;
    244              if (0 != hal_eint_convert_for_gpio(eint_number, &gpio_pin)) {
    245                  log_hal_error("hal_eint_convert_for_gpio fail.");
    246                  return HAL_EINT_STATUS_ERROR;
    247              }
    248              if (NULL == eint_config) {
    249                  log_hal_error("eint_config is NULL.");
    250                  return HAL_EINT_STATUS_INVALID_PARAMETER;
    251              }
    252              
    253              if (is_eint_callback_registered[eint_number] == true) {
    254                   ret_status = hal_eint_apply_config(gpio_pin, eint_config);
    255                   if (ret_status != HAL_EINT_STATUS_OK) {
    256                      return ret_status;
    257                   }
    258                   
    259                   ret_status = hal_eint_unmask(eint_number); // align with orignal behavior
    260                   if (ret_status != HAL_EINT_STATUS_OK) {
    261                      return ret_status;
    262                   }
    263              }
    264              else {
    265                   hal_eint_callback_context_t *callback_context = &g_eint_callback_context[get_index_from_gpio_pin(gpio_pin)];
    266                   memset(callback_context, 0, sizeof(hal_eint_callback_context_t));
    267          
    268                   ret_status = hal_eint_apply_config(gpio_pin, eint_config);
    269                   if (ret_status != HAL_EINT_STATUS_OK) {
    270                      return ret_status;
    271                   }
    272          
    273                   ret_status = hal_eint_mask(eint_number);
    274                   if (ret_status != HAL_EINT_STATUS_OK) {
    275                      return ret_status;
    276                   }
    277              }
    278             
    279              return HAL_EINT_STATUS_OK;
    280              
    281          }
    282          
    283          hal_eint_status_t hal_eint_deinit(hal_eint_number_t eint_number)
    284          {
    285              ENUM_IOT_GPIO_NAME_T gpio_pin;
    286              hal_eint_status_t    ret_status;
    287              
    288              if (0 != hal_eint_convert_for_gpio(eint_number, &gpio_pin)) {
    289                  log_hal_error("hal_eint_convert_for_gpio fail.");
    290                  return HAL_EINT_STATUS_ERROR;
    291              }
    292          
    293              ret_status = hal_eint_mask(eint_number);
    294              if (ret_status != HAL_EINT_STATUS_OK) {
    295              return ret_status;
    296              }
    297              
    298              hal_eint_callback_context_t *callback_context = &g_eint_callback_context[get_index_from_gpio_pin(gpio_pin)];
    299              memset(callback_context, 0, sizeof(hal_eint_callback_context_t));
    300              is_eint_callback_registered[eint_number] = false;
    301              
    302              return HAL_EINT_STATUS_OK;
    303          }
    304          
    305          
    306          hal_eint_status_t hal_eint_register_callback(hal_eint_number_t eint_number,
    307                  hal_eint_callback_t callback,
    308                  void *user_data)
    309          {
    310              ENUM_IOT_GPIO_NAME_T gpio_pin;
    311              hal_eint_status_t    ret_status;
    312              
    313              if (0 != hal_eint_convert_for_gpio(eint_number, &gpio_pin)) {
    314                  log_hal_error("hal_eint_convert_for_gpio fail.");
    315                  return HAL_EINT_STATUS_ERROR;
    316              }
    317              hal_eint_callback_context_t *callback_context = &g_eint_callback_context[get_index_from_gpio_pin(gpio_pin)];
    318              callback_context->callback = callback;
    319              callback_context->user_data = user_data;
    320              callback_context->callback_present = true;
    321              
    322              is_eint_callback_registered[eint_number] = true;
    323          
    324              if (is_eint_masked[eint_number] == true) {
    325                  ret_status = hal_eint_unmask(eint_number);
    326                  if (ret_status != HAL_EINT_STATUS_OK) {
    327                      return ret_status;
    328                  }
    329          
    330              }
    331              
    332              return HAL_EINT_STATUS_OK;
    333              
    334          }
    335          
    336          hal_eint_status_t hal_eint_set_trigger_mode(hal_eint_number_t eint_number, hal_eint_trigger_mode_t trigger_mode)
    337          {
    338              ENUM_IOT_GPIO_NAME_T gpio_pin;
    339              if (0 != hal_eint_convert_for_gpio(eint_number, &gpio_pin)) {
    340                  log_hal_error("hal_eint_convert_for_gpio fail.");
    341                  return HAL_EINT_STATUS_ERROR;
    342              } else {
    343                  ENUM_NVIC_SENSE_T trigger;
    344                  ENUM_DEBOUNCE_POL_T pol;
    345                  ENUM_DEBOUNCE_DUAL_T dual_en;
    346                  
    347                  switch (trigger_mode) {
    348                      case  HAL_EINT_LEVEL_LOW : {
    349                          trigger = eLevel_Trigger;
    350                          pol = eDebounce_Positive_Pol;
    351                          dual_en = eDebounce_Dual_No;
    352                          break;
    353                      }
    354                      case  HAL_EINT_LEVEL_HIGH : {
    355                             trigger = eLevel_Trigger;
    356                          pol = eDebounce_Negative_Pol;
    357                          dual_en = eDebounce_Dual_No;
    358                          break;
    359                      }
    360                      case  HAL_EINT_EDGE_FALLING : {
    361                             trigger = eEdge_Trigger;
    362                          pol = eDebounce_Positive_Pol;
    363                          dual_en = eDebounce_Dual_No; 
    364                          break;
    365                      }
    366                      case  HAL_EINT_EDGE_RISING : {
    367                             trigger = eEdge_Trigger;
    368                          pol = eDebounce_Negative_Pol;
    369                          dual_en = eDebounce_Dual_No; 
    370                          break;
    371                      }
    372                      case  HAL_EINT_EDGE_FALLING_AND_RISING : {
    373                             trigger = eLevel_Trigger;
    374                          pol = eDebounce_Negative_Pol;
    375                          dual_en = eDebounce_Dual_Yes;
    376                          break;
    377                      }
    378                      default : {
    379                          return HAL_EINT_STATUS_ERROR;
    380                      }
    381                  }
    382                  eint_set_trigger_mode(gpio_pin, trigger, pol, dual_en);
    383                  }
    384          
    385              return HAL_EINT_STATUS_OK;
    386          
    387          }
    388          
    389          hal_eint_status_t hal_eint_set_debounce_time(hal_eint_number_t eint_number, uint32_t time_ms)
    390          {
    391              ENUM_IOT_GPIO_NAME_T gpio_pin;
    392              uint32_t sample_count;
    393              ENUM_DEBOUNCE_PRESCALER_T sample_rate;
    394              ENUM_DEBOUNCE_EN_T debounce_en;
    395              if (0 != hal_eint_convert_for_gpio(eint_number, &gpio_pin)) {
    396                  log_hal_error("hal_eint_convert_for_gpio fail.");
    397                  return HAL_EINT_STATUS_ERROR;
    398              }
    399          
    400              /*
    401                    7687 EINT spec
    402                     3 bit          |                      |      4bit counter(1 to 16)
    403                     pre-scaler      clock(KHz)      |   min(ms)           max (ms)
    404                        000                8                      0.13                  2.00
    405                        001                4                      0.25                  4.00
    406                        010                2                      0.50                  8.00
    407                        011                1                      1.00                  16.00
    408                        100                0.5                   2.00                  32.00
    409                        101                0.25                 4.00                   64.00
    410                        110                0.125                8.00                  128.00
    411                        111                0.0625              16.00                 256.00
    412              */
    413              hal_eint_calc_debounce_parameters(time_ms, &sample_rate, &sample_count);
    414          
    415              if (time_ms != 0) {
    416                  debounce_en = eDebounce_Enable;
    417              } else {
    418                  debounce_en = eDebounce_Disable;
    419              }
    420              eint_set_debounce(gpio_pin, debounce_en, sample_rate, sample_count);
    421              return HAL_EINT_STATUS_OK;
    422          }
    423          
    424          
    425          hal_eint_status_t hal_eint_set_software_trigger(hal_eint_number_t eint_number)
    426          {
    427              ENUM_IOT_GPIO_NAME_T gpio_pin;
    428              if (0 != hal_eint_convert_for_gpio(eint_number, &gpio_pin)) {
    429                  log_hal_error("hal_eint_convert_for_gpio fail.");
    430                  return HAL_EINT_STATUS_ERROR;
    431              }
    432              eint_set_software_trigger(gpio_pin);
    433              return HAL_EINT_STATUS_OK;
    434          }
    435          
    436          hal_eint_status_t hal_eint_clear_software_trigger(hal_eint_number_t eint_number)
    437          {
    438              ENUM_IOT_GPIO_NAME_T gpio_pin;
    439              if (0 != hal_eint_convert_for_gpio(eint_number, &gpio_pin)) {
    440                  log_hal_error("hal_eint_convert_for_gpio fail.");
    441                  return HAL_EINT_STATUS_ERROR;
    442              }
    443              eint_clear_software_trigger(gpio_pin);
    444              return HAL_EINT_STATUS_OK;
    445          }
    446          
    447          #endif
    448          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   get_index_from_gpio_pin
      48   hal_eint_apply_config
        48   -> gpio_int
        48   -> hal_eint_calc_debounce_parameters
        48   -> log_hal_error_internal
       4   hal_eint_calc_debounce_parameters
       8   hal_eint_clear_software_trigger
         8   -> eint_clear_software_trigger
         8   -> hal_eint_convert_for_gpio
         8   -> log_hal_error_internal
       8   hal_eint_convert_for_gpio
      16   hal_eint_deinit
        16   -> __aeabi_memset4
        16   -> get_index_from_gpio_pin
        16   -> hal_eint_convert_for_gpio
        16   -> hal_eint_mask
        16   -> log_hal_error_internal
      24   hal_eint_init
        24   -> __aeabi_memset4
        24   -> get_index_from_gpio_pin
        24   -> hal_eint_apply_config
        24   -> hal_eint_convert_for_gpio
        24   -> hal_eint_mask
        24   -> hal_eint_unmask
        24   -> log_hal_error_internal
       8   hal_eint_isr
         0   -- Indirect call
         8   -> get_index_from_gpio_pin
      16   hal_eint_mask
        16   -> eint_set_mask
        16   -> hal_eint_convert_for_gpio
        16   -> log_hal_error_internal
      24   hal_eint_register_callback
        24   -> get_index_from_gpio_pin
        24   -> hal_eint_convert_for_gpio
        24   -> hal_eint_unmask
        24   -> log_hal_error_internal
      16   hal_eint_set_debounce_time
        16   -> eint_set_debounce
        16   -> hal_eint_calc_debounce_parameters
        16   -> hal_eint_convert_for_gpio
        16   -> log_hal_error_internal
       8   hal_eint_set_software_trigger
         8   -> eint_set_software_trigger
         8   -> hal_eint_convert_for_gpio
         8   -> log_hal_error_internal
      16   hal_eint_set_trigger_mode
        16   -> eint_set_trigger_mode
        16   -> hal_eint_convert_for_gpio
        16   -> log_hal_error_internal
      16   hal_eint_unmask
        16   -> eint_set_unmask
        16   -> hal_eint_convert_for_gpio
        16   -> log_hal_error_internal


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable21
       4  ??DataTable21_1
      36  ?_0
      32  ?_1
      24  ?_2
      24  eint_gpio_table
      36  get_index_from_gpio_pin
     168  hal_eint_apply_config
     104  hal_eint_calc_debounce_parameters
      46  hal_eint_clear_software_trigger
      46  hal_eint_convert_for_gpio
      82  hal_eint_deinit
     152  hal_eint_init
      40  hal_eint_isr
      58  hal_eint_mask
      98  hal_eint_register_callback
      78  hal_eint_set_debounce_time
      46  hal_eint_set_software_trigger
     108  hal_eint_set_trigger_mode
      56  hal_eint_unmask
     220  is_eint_callback_registered
          is_eint_masked
          g_eint_callback_context
     236  -- Other

 
   220 bytes in section .bss
 1 478 bytes in section .text
 
 1 478 bytes of CODE memory
   220 bytes of DATA memory

Errors: none
Warnings: none
