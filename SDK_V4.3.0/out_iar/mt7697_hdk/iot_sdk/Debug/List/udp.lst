###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:43
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\third_party\lwip\src\core\udp.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EWBE41.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\third_party\lwip\src\core\udp.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\udp.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\udp.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\third_party\lwip\src\core\udp.c
      1          /**
      2           * @file
      3           * User Datagram Protocol module
      4           *
      5           */
      6          
      7          /*
      8           * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
      9           * All rights reserved.
     10           *
     11           * Redistribution and use in source and binary forms, with or without modification,
     12           * are permitted provided that the following conditions are met:
     13           *
     14           * 1. Redistributions of source code must retain the above copyright notice,
     15           *    this list of conditions and the following disclaimer.
     16           * 2. Redistributions in binary form must reproduce the above copyright notice,
     17           *    this list of conditions and the following disclaimer in the documentation
     18           *    and/or other materials provided with the distribution.
     19           * 3. The name of the author may not be used to endorse or promote products
     20           *    derived from this software without specific prior written permission.
     21           *
     22           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
     23           * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     24           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
     25           * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     26           * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
     27           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     28           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     29           * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     30           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
     31           * OF SUCH DAMAGE.
     32           *
     33           * This file is part of the lwIP TCP/IP stack.
     34           *
     35           * Author: Adam Dunkels <adam@sics.se>
     36           *
     37           */
     38          
     39          
     40          /* udp.c
     41           *
     42           * The code for the User Datagram Protocol UDP & UDPLite (RFC 3828).
     43           *
     44           */
     45          
     46          /* @todo Check the use of '(struct udp_pcb).chksum_len_rx'!
     47           */
     48          
     49          #include "lwip/opt.h"
     50          
     51          #if LWIP_UDP /* don't build if not configured for use in lwipopts.h */
     52          
     53          #include "lwip/udp.h"
     54          #include "lwip/def.h"
     55          #include "lwip/memp.h"
     56          #include "lwip/inet_chksum.h"
     57          #include "lwip/ip_addr.h"
     58          #include "lwip/ip6.h"
     59          #include "lwip/ip6_addr.h"
     60          #include "lwip/inet_chksum.h"
     61          #include "lwip/netif.h"
     62          #include "lwip/icmp.h"
     63          #include "lwip/icmp6.h"
     64          #include "lwip/stats.h"
     65          #include "lwip/snmp.h"
     66          #include "lwip/dhcp.h"
     67          
     68          #include <string.h>
     69          
     70          #ifndef UDP_LOCAL_PORT_RANGE_START
     71          /* From http://www.iana.org/assignments/port-numbers:
     72             "The Dynamic and/or Private Ports are those from 49152 through 65535" */
     73          #define UDP_LOCAL_PORT_RANGE_START  0xc000
     74          #define UDP_LOCAL_PORT_RANGE_END    0xffff
     75          #define UDP_ENSURE_LOCAL_PORT_RANGE(port) ((u16_t)(((port) & ~UDP_LOCAL_PORT_RANGE_START) + UDP_LOCAL_PORT_RANGE_START))
     76          #endif
     77          
     78          /* last local UDP port */
     79          static u16_t udp_port = UDP_LOCAL_PORT_RANGE_START;
     80          
     81          /* The list of UDP PCBs */
     82          /* exported in udp.h (was static) */
     83          struct udp_pcb *udp_pcbs;
     84          
     85          /**
     86           * Initialize this module.
     87           */
     88          void
     89          udp_init(void)
     90          {
     91          #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
     92            udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
     93          #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
     94          }
     95          
     96          /**
     97           * Allocate a new local UDP port.
     98           *
     99           * @return a new (free) local UDP port number
    100           */
    101          static u16_t
    102          udp_new_port(void)
    103          {
    104            u16_t n = 0;
    105            struct udp_pcb *pcb;
    106            
    107          again:
    108            if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    109              udp_port = UDP_LOCAL_PORT_RANGE_START;
    110            }
    111            /* Check all PCBs. */
    112            for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    113              if (pcb->local_port == udp_port) {
    114                if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
    115                  return 0;
    116                }
    117                goto again;
    118              }
    119            }
    120            return udp_port;
    121          #if 0
    122            struct udp_pcb *ipcb = udp_pcbs;
    123            while ((ipcb != NULL) && (udp_port != UDP_LOCAL_PORT_RANGE_END)) {
    124              if (ipcb->local_port == udp_port) {
    125                /* port is already used by another udp_pcb */
    126                udp_port++;
    127                /* restart scanning all udp pcbs */
    128                ipcb = udp_pcbs;
    129              } else {
    130                /* go on with next udp pcb */
    131                ipcb = ipcb->next;
    132              }
    133            }
    134            if (ipcb != NULL) {
    135              return 0;
    136            }
    137            return udp_port;
    138          #endif
    139          }
    140          
    141          /**
    142           * Process an incoming UDP datagram.
    143           *
    144           * Given an incoming UDP datagram (as a chain of pbufs) this function
    145           * finds a corresponding UDP PCB and hands over the pbuf to the pcbs
    146           * recv function. If no pcb is found or the datagram is incorrect, the
    147           * pbuf is freed.
    148           *
    149           * @param p pbuf to be demultiplexed to a UDP PCB (p->payload pointing to the UDP header)
    150           * @param inp network interface on which the datagram was received.
    151           *
    152           */
    153          void
    154          udp_input(struct pbuf *p, struct netif *inp)
    155          {
    156            struct udp_hdr *udphdr;
    157            struct udp_pcb *pcb, *prev;
    158            struct udp_pcb *uncon_pcb;
    159            u16_t src, dest;
    160            u8_t local_match;
    161          #if LWIP_IPV4
    162            u8_t broadcast;
    163          #endif /* LWIP_IPV4 */
    164            u8_t for_us;
    165          
    166            LWIP_UNUSED_ARG(inp);
    167          
    168            PERF_START;
    169          
    170            UDP_STATS_INC(udp.recv);
    171          
    172            /* Check minimum length (UDP header) */
    173            if (p->len < UDP_HLEN) {
    174              /* drop short packets */
    175              LWIP_DEBUGF(UDP_DEBUG,
    176                          ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    177              UDP_STATS_INC(udp.lenerr);
    178              UDP_STATS_INC(udp.drop);
    179              snmp_inc_udpinerrors();
    180              pbuf_free(p);
    181              goto end;
    182            }
    183          
    184            udphdr = (struct udp_hdr *)p->payload;
    185          
    186          #if LWIP_IPV4
    187            /* is broadcast packet ? */
    188            broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
    189          #endif /* LWIP_IPV4 */
    190          
    191            LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));
    192          
    193            /* convert src and dest ports to host byte order */
    194            src = ntohs(udphdr->src);
    195            dest = ntohs(udphdr->dest);
    196          
    197            udp_debug_print(udphdr);
    198          
    199            /* print the UDP source and destination */
    200            LWIP_DEBUGF(UDP_DEBUG, ("udp ("));
    201            ip_addr_debug_print(UDP_DEBUG, ip_current_dest_addr());
    202            LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", ntohs(udphdr->dest)));
    203            ip_addr_debug_print(UDP_DEBUG, ip_current_src_addr());
    204            LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", ntohs(udphdr->src)));
    205          
    206          #if LWIP_DHCP
    207            pcb = NULL;
    208            /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
    209               the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
    210            if (dest == DHCP_CLIENT_PORT) {
    211              /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    212              if (src == DHCP_SERVER_PORT) {
    213                if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
    214                  /* accept the packet if
    215                     (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
    216                     - inp->dhcp->pcb->remote == ANY or iphdr->src
    217                     (no need to check for IPv6 since the dhcp struct always uses IPv4) */
    218                  if (ip_addr_isany_val(inp->dhcp->pcb->remote_ip) ||
    219                      ip_addr_cmp(&inp->dhcp->pcb->remote_ip, ip_current_src_addr())) {
    220                    pcb = inp->dhcp->pcb;
    221                  }
    222                }
    223              }
    224            } else
    225          #endif /* LWIP_DHCP */
    226            {
    227              prev = NULL;
    228              local_match = 0;
    229              uncon_pcb = NULL;
    230              /* Iterate through the UDP pcb list for a matching pcb.
    231               * 'Perfect match' pcbs (connected to the remote port & ip address) are
    232               * preferred. If no perfect match is found, the first unconnected pcb that
    233               * matches the local port and ip address gets the datagram. */
    234              for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    235                local_match = 0;
    236                /* print the PCB local and remote address */
    237                LWIP_DEBUGF(UDP_DEBUG, ("pcb ("));
    238                ip_addr_debug_print(UDP_DEBUG, &pcb->local_ip);
    239                LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
    240                ip_addr_debug_print(UDP_DEBUG, &pcb->remote_ip);
    241                LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));
    242          
    243                /* compare PCB local addr+port to UDP destination addr+port */
    244                if (pcb->local_port == dest) {
    245                  if (
    246          #if LWIP_IPV6
    247                    (PCB_ISIPV6(pcb) && (ip_current_is_v6()) &&
    248                      (ip6_addr_isany(ip_2_ip6(&pcb->local_ip)) ||
    249          #if LWIP_IPV6_MLD
    250                      ip6_addr_ismulticast(ip6_current_dest_addr()) ||
    251          #endif /* LWIP_IPV6_MLD */
    252                      ip6_addr_cmp(ip_2_ip6(&pcb->local_ip), ip6_current_dest_addr())))
    253          #endif /* LWIP_IPV6 */
    254          #if LWIP_IPV4 && LWIP_IPV6
    255                     || (!PCB_ISIPV6(pcb) &&
    256                      (ip4_current_header() != NULL) &&
    257          #endif /* LWIP_IPV4 && LWIP_IPV6 */
    258          #if LWIP_IPV4
    259          #if !LWIP_IPV6
    260                      (
    261          #endif /* !LWIP_IPV6 */
    262                      ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
    263                      ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr()) ||
    264          #if LWIP_IGMP
    265                      (ip_addr_isany(&pcb->local_ip) && ip_addr_ismulticast(ip_current_dest_addr())) ||
    266          #endif /* LWIP_IGMP */
    267          #if IP_SOF_BROADCAST_RECV
    268                      (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
    269                       (ip_addr_isany(&pcb->local_ip) ||
    270                        ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), netif_ip4_netmask(inp))))))
    271          #else /* IP_SOF_BROADCAST_RECV */
    272                      (broadcast &&
    273                       (ip_addr_isany(&pcb->local_ip) ||
    274                        ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), netif_ip4_netmask(inp))))))
    275          #endif /* IP_SOF_BROADCAST_RECV */
    276          #endif /* LWIP_IPV4 */
    277                        ) {
    278                    local_match = 1;
    279                    if ((uncon_pcb == NULL) && 
    280                        ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
    281                      /* the first unconnected matching PCB */
    282                      uncon_pcb = pcb;
    283                    }
    284                  }
    285                }
    286                /* compare PCB remote addr+port to UDP source addr+port */
    287                if ((local_match != 0) &&
    288                    (pcb->remote_port == src) && IP_PCB_IPVER_INPUT_MATCH(pcb) &&
    289                      (ip_addr_isany_val(pcb->remote_ip) ||
    290                        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
    291                  /* the first fully matching PCB */
    292                  if (prev != NULL) {
    293                    /* move the pcb to the front of udp_pcbs so that is
    294                       found faster next time */
    295                    prev->next = pcb->next;
    296                    pcb->next = udp_pcbs;
    297                    udp_pcbs = pcb;
    298                  } else {
    299                    UDP_STATS_INC(udp.cachehit);
    300                  }
    301                  break;
    302                }
    303                prev = pcb;
    304              }
    305              /* no fully matching pcb found? then look for an unconnected pcb */
    306              if (pcb == NULL) {
    307                pcb = uncon_pcb;
    308              }
    309            }
    310          
    311            /* Check checksum if this is a match or if it was directed at us. */
    312            if (pcb != NULL) {
    313              for_us = 1;
    314            } else {
    315          #if LWIP_IPV6
    316              if (ip_current_is_v6()) {
    317                for_us = netif_get_ip6_addr_match(inp, ip6_current_dest_addr()) >= 0;
    318              }
    319          #if LWIP_IPV4
    320              else
    321          #endif /* LWIP_IPV4 */
    322          #endif /* LWIP_IPV6 */
    323          #if LWIP_IPV4
    324              {
    325                for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
    326              }
    327          #endif /* LWIP_IPV4 */
    328            }
    329            if (for_us) {
    330              LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: calculating checksum\n"));
    331          #if CHECKSUM_CHECK_UDP
    332          #if LWIP_UDPLITE
    333              if (ip_current_header_proto() == IP_PROTO_UDPLITE) {
    334                /* Do the UDP Lite checksum */
    335                u16_t chklen = ntohs(udphdr->len);
    336                if (chklen < sizeof(struct udp_hdr)) {
    337                  if (chklen == 0) {
    338                    /* For UDP-Lite, checksum length of 0 means checksum
    339                       over the complete packet (See RFC 3828 chap. 3.1) */
    340                    chklen = p->tot_len;
    341                  } else {
    342                    /* At least the UDP-Lite header must be covered by the
    343                       checksum! (Again, see RFC 3828 chap. 3.1) */
    344                    goto chkerr;
    345                  }
    346                }
    347                if (ip_chksum_pseudo_partial(p, IP_PROTO_UDPLITE,
    348                             p->tot_len, chklen,
    349                             ip_current_src_addr(), ip_current_dest_addr()) != 0) {
    350                  goto chkerr;
    351                }
    352              } else
    353          #endif /* LWIP_UDPLITE */
    354              {
    355                if (udphdr->chksum != 0) {
    356                  if (ip_chksum_pseudo(p, IP_PROTO_UDP, p->tot_len,
    357                                       ip_current_src_addr(),
    358                                       ip_current_dest_addr()) != 0) {
    359                    goto chkerr;
    360                  }
    361                }
    362              }
    363          #endif /* CHECKSUM_CHECK_UDP */
    364              if(pbuf_header(p, -UDP_HLEN)) {
    365                /* Can we cope with this failing? Just assert for now */
    366                LWIP_ASSERT("pbuf_header failed\n", 0);
    367                UDP_STATS_INC(udp.drop);
    368                snmp_inc_udpinerrors();
    369                pbuf_free(p);
    370                goto end;
    371              }
    372              if (pcb != NULL) {
    373                snmp_inc_udpindatagrams();
    374          #if SO_REUSE && SO_REUSE_RXTOALL
    375                if ((
    376          #if LWIP_IPV4
    377                  broadcast ||
    378          #endif /* LWIP_IPV4 */
    379          #if LWIP_IPV6
    380                    ip6_addr_ismulticast(ip6_current_dest_addr()) ||
    381          #endif /* LWIP_IPV6 */
    382                     ip_addr_ismulticast(ip_current_dest_addr())) &&
    383                    ip_get_option(pcb, SOF_REUSEADDR)) {
    384                  /* pass broadcast- or multicast packets to all multicast pcbs
    385                     if SOF_REUSEADDR is set on the first match */
    386                  struct udp_pcb *mpcb;
    387                  u8_t p_header_changed = 0;
    388                  s16_t hdrs_len = (s16_t)(ip_current_header_tot_len() + UDP_HLEN);
    389                  for (mpcb = udp_pcbs; mpcb != NULL; mpcb = mpcb->next) {
    390                    if (mpcb != pcb) {
    391                      /* compare PCB local addr+port to UDP destination addr+port */
    392                      if ((mpcb->local_port == dest) &&
    393          #if LWIP_IPV6
    394                          ((PCB_ISIPV6(mpcb) &&
    395                            (ip6_addr_ismulticast(ip6_current_dest_addr()) ||
    396                             ip6_addr_cmp(ip_2_ip6(&mpcb->local_ip), ip6_current_dest_addr()))) ||
    397                           (!PCB_ISIPV6(mpcb) &&
    398          #else /* LWIP_IPV6 */
    399                          ((
    400          #endif /* LWIP_IPV6 */
    401                            ((
    402          #if LWIP_IPV4
    403                            !broadcast &&
    404          #endif /* LWIP_IPV4 */
    405                            ip_addr_isany(&mpcb->local_ip)) ||
    406                             ip_addr_cmp(&mpcb->local_ip, ip_current_dest_addr()) ||
    407          #if LWIP_IGMP
    408                             (ip_addr_isany(&pcb->local_ip) && ip_addr_ismulticast(ip_current_dest_addr())) ||
    409          #endif /* LWIP_IGMP */
    410          #if IP_SOF_BROADCAST_RECV
    411                             (
    412          #if LWIP_IPV4
    413                             broadcast &&
    414          #endif /* LWIP_IPV4 */
    415                             ip_get_option(mpcb, SOF_BROADCAST)))))) {
    416          #else  /* IP_SOF_BROADCAST_RECV */
    417                             (broadcast))))) {
    418          #endif /* IP_SOF_BROADCAST_RECV */
    419                        /* pass a copy of the packet to all local matches */
    420                        if (mpcb->recv != NULL) {
    421                          struct pbuf *q;
    422                          /* for that, move payload to IP header again */
    423                          if (p_header_changed == 0) {
    424                            pbuf_header_force(p, hdrs_len);
    425                            p_header_changed = 1;
    426                          }
    427                          q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
    428                          if (q != NULL) {
    429                            err_t err = pbuf_copy(q, p);
    430                            if (err == ERR_OK) {
    431                              /* move payload to UDP data */
    432                              pbuf_header(q, -hdrs_len);
    433                              mpcb->recv(mpcb->recv_arg, mpcb, q, ip_current_src_addr(), src);
    434                            }
    435                          }
    436                        }
    437                      }
    438                    }
    439                  }
    440                  if (p_header_changed) {
    441                    /* and move payload to UDP data again */
    442                    pbuf_header(p, -hdrs_len);
    443                  }
    444                }
    445          #endif /* SO_REUSE && SO_REUSE_RXTOALL */
    446                /* callback */
    447                if (pcb->recv != NULL) {
    448                  /* now the recv function is responsible for freeing p */
    449                  pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
    450                } else {
    451                  /* no recv function registered? then we have to free the pbuf! */
    452                  pbuf_free(p);
    453                  goto end;
    454                }
    455              } else {
    456                LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));
    457          
    458          #if LWIP_ICMP || LWIP_ICMP6
    459                /* No match was found, send ICMP destination port unreachable unless
    460                   destination address was broadcast/multicast. */
    461                if (
    462          #if LWIP_IPV4
    463                    !broadcast && !ip_addr_ismulticast(ip_current_dest_addr())
    464          #if LWIP_IPV6
    465                    &&
    466          #endif /* LWIP_IPV6 */
    467          #endif /* LWIP_IPV4 */
    468          #if LWIP_IPV6
    469                    !ip6_addr_ismulticast(ip6_current_dest_addr())
    470          #endif /* LWIP_IPV6 */
    471                    ) {
    472                  /* move payload pointer back to ip header */
    473                  pbuf_header_force(p, ip_current_header_tot_len() + UDP_HLEN);
    474                  icmp_port_unreach(ip_current_is_v6(), p);
    475                }
    476          #endif /* LWIP_ICMP || LWIP_ICMP6 */
    477                UDP_STATS_INC(udp.proterr);
    478                UDP_STATS_INC(udp.drop);
    479                snmp_inc_udpnoports();
    480                pbuf_free(p);
    481              }
    482            } else {
    483              pbuf_free(p);
    484            }
    485          end:
    486            PERF_STOP("udp_input");
    487            return;
    488          #if CHECKSUM_CHECK_UDP
    489          chkerr:
    490            LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
    491                        ("udp_input: UDP (or UDP Lite) datagram discarded due to failing checksum\n"));
    492            UDP_STATS_INC(udp.chkerr);
    493            UDP_STATS_INC(udp.drop);
    494            snmp_inc_udpinerrors();
    495            pbuf_free(p);
    496            PERF_STOP("udp_input");
    497          #endif /* CHECKSUM_CHECK_UDP */
    498          }
    499          
    500          /**
    501           * Send data using UDP.
    502           *
    503           * @param pcb UDP PCB used to send the data.
    504           * @param p chain of pbuf's to be sent.
    505           *
    506           * The datagram will be sent to the current remote_ip & remote_port
    507           * stored in pcb. If the pcb is not bound to a port, it will
    508           * automatically be bound to a random port.
    509           *
    510           * @return lwIP error code.
    511           * - ERR_OK. Successful. No error occurred.
    512           * - ERR_MEM. Out of memory.
    513           * - ERR_RTE. Could not find route to destination address.
    514           * - More errors could be returned by lower protocol layers.
    515           *
    516           * @see udp_disconnect() udp_sendto()
    517           */
    518          err_t
    519          udp_send(struct udp_pcb *pcb, struct pbuf *p)
    520          {
    521            /* send to the packet using remote ip and port stored in the pcb */
    522            return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
    523          }
    524          
    525          #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
    526          /** Same as udp_send() but with checksum
    527           */
    528          err_t
    529          udp_send_chksum(struct udp_pcb *pcb, struct pbuf *p,
    530                          u8_t have_chksum, u16_t chksum)
    531          {
    532            /* send to the packet using remote ip and port stored in the pcb */
    533            return udp_sendto_chksum(pcb, p, &pcb->remote_ip, pcb->remote_port,
    534              have_chksum, chksum);
    535          }
    536          #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
    537          
    538          /**
    539           * Send data to a specified address using UDP.
    540           *
    541           * @param pcb UDP PCB used to send the data.
    542           * @param p chain of pbuf's to be sent.
    543           * @param dst_ip Destination IP address.
    544           * @param dst_port Destination UDP port.
    545           *
    546           * dst_ip & dst_port are expected to be in the same byte order as in the pcb.
    547           *
    548           * If the PCB already has a remote address association, it will
    549           * be restored after the data is sent.
    550           * 
    551           * @return lwIP error code (@see udp_send for possible error codes)
    552           *
    553           * @see udp_disconnect() udp_send()
    554           */
    555          err_t
    556          udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
    557            const ip_addr_t *dst_ip, u16_t dst_port)
    558          {
    559          #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
    560            return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
    561          }
    562          
    563          /** Same as udp_sendto(), but with checksum */
    564          err_t
    565          udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
    566                            u16_t dst_port, u8_t have_chksum, u16_t chksum)
    567          {
    568          #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
    569            struct netif *netif;
    570            const ip_addr_t *dst_ip_route = dst_ip;
    571          #if LWIP_IPV6 && LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS
    572            ip_addr_t dst_ip_tmp;
    573          #endif /* LWIP_IPV6 && LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS */
    574          
    575            if ((pcb == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
    576              return ERR_VAL;
    577            }
    578          
    579            LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));
    580          
    581          #if LWIP_IPV6 || (LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS)
    582            if (ip_addr_ismulticast(dst_ip_route)) {
    583          #if LWIP_IPV6
    584              if (PCB_ISIPV6(pcb)) {
    585                /* For multicast, find a netif based on source address. */
    586                if (!ip6_addr_isany(&pcb->multicast_ip6)) {
    587                  // For Keil
    588                  dst_ip_route = (const ip_addr_t*)&pcb->multicast_ip6;
    589                }
    590              } else
    591          #endif /* LWIP_IPV6 */
    592              {
    593          #if LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS
    594                /* IPv4 does not use source-based routing by default, so we use an
    595                   administratively selected interface for multicast by default.
    596                   However, this can be overridden by setting an interface address
    597                   in pcb->multicast_ip that is used for routing. */
    598                if (!ip4_addr_isany(&pcb->multicast_ip) &&
    599                    !ip4_addr_cmp(&pcb->multicast_ip, IP4_ADDR_BROADCAST)) {
    600                  dst_ip_route = ip4_2_ip(&pcb->multicast_ip, &dst_ip_tmp);
    601                }
    602          #endif /* LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS */
    603              }
    604            }
    605          #endif /* LWIP_IPV6 || (LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS) */
    606          
    607          
    608          #if ((defined MTK_TCPIP_FOR_EXTERNAL_MODULE_ENABLE) && (defined LWIP_SOCKET_OPTION_BINDTODEVICE))
    609            if (pcb->so_options & SO_BINDTODEVICE) {        
    610              u16_t netif_num;
    611              netif_num = (pcb->so_options) & (~SO_BINDTODEVICE);      
    612              if (netif_num > 0) {
    613              netif = netif_find_by_context_id(netif_num);
    614              } else {
    615                /* wifi netif_num == 0, ip_route */
    616                netif = ip_route(PCB_ISIPV6(pcb), &pcb->local_ip, dst_ip_route);
    617              }
    618            } else 
    619          #endif /* LWIP_SOCKET_OPTION_BINDTODEVICE */
    620            {
    621            /* find the outgoing network interface for this packet */
    622            netif = ip_route(PCB_ISIPV6(pcb), &pcb->local_ip, dst_ip_route);
    623            }
    624          
    625          
    626            /* no outgoing network interface could be found? */
    627            if (netif == NULL) {
    628              LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
    629              ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, dst_ip);
    630              LWIP_DEBUGF(UDP_DEBUG, ("\n"));
    631              UDP_STATS_INC(udp.rterr);
    632              return ERR_RTE;
    633            }
    634          #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
    635            return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
    636          #else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
    637            return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
    638          #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
    639          }
    640          
    641          /**
    642           * Send data to a specified address using UDP.
    643           * The netif used for sending can be specified.
    644           *
    645           * This function exists mainly for DHCP, to be able to send UDP packets
    646           * on a netif that is still down.
    647           *
    648           * @param pcb UDP PCB used to send the data.
    649           * @param p chain of pbuf's to be sent.
    650           * @param dst_ip Destination IP address.
    651           * @param dst_port Destination UDP port.
    652           * @param netif the netif used for sending.
    653           *
    654           * dst_ip & dst_port are expected to be in the same byte order as in the pcb.
    655           *
    656           * @return lwIP error code (@see udp_send for possible error codes)
    657           *
    658           * @see udp_disconnect() udp_send()
    659           */
    660          err_t
    661          udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
    662            const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
    663          {
    664          #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
    665            return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0);
    666          }
    667          
    668          /** Same as udp_sendto_if(), but with checksum */
    669          err_t
    670          udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
    671                               u16_t dst_port, struct netif *netif, u8_t have_chksum,
    672                               u16_t chksum)
    673          {
    674          #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
    675            const ip_addr_t *src_ip;
    676          #if LWIP_IPV6 && LWIP_IPV4
    677            ip_addr_t src_ip_tmp;
    678          #endif /* LWIP_IPV6 && LWIP_IPV4 */
    679          
    680            if ((pcb == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
    681              return ERR_VAL;
    682            }
    683          
    684            /* PCB local address is IP_ANY_ADDR? */
    685          #if LWIP_IPV6
    686            if (PCB_ISIPV6(pcb)) {
    687              if (ip6_addr_isany(ip_2_ip6(&pcb->local_ip))) {
    688                src_ip = ip6_2_ip(ip6_select_source_address(netif, ip_2_ip6(dst_ip)), &src_ip_tmp);
    689                if (src_ip == NULL) {
    690                  /* No suitable source address was found. */
    691                  return ERR_RTE;
    692                }
    693              } else {
    694                /* use UDP PCB local IPv6 address as source address, if still valid. */
    695                if (netif_get_ip6_addr_match(netif, ip_2_ip6(&pcb->local_ip)) < 0) {
    696                  /* Address isn't valid anymore. */
    697                  return ERR_RTE;
    698                }
    699                src_ip = &pcb->local_ip;
    700              }
    701            }
    702          #endif /* LWIP_IPV6 */
    703          #if LWIP_IPV4 && LWIP_IPV6
    704            else
    705          #endif /* LWIP_IPV4 && LWIP_IPV6 */
    706          #if LWIP_IPV4
    707            if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip))) {
    708              /* use outgoing network interface IP address as source address */
    709              src_ip = ip4_2_ip(netif_ip4_addr(netif), &src_ip_tmp);
    710            } else {
    711              /* check if UDP PCB local IP address is correct
    712               * this could be an old address if netif->ip_addr has changed */
    713              if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
    714                /* local_ip doesn't match, drop the packet */
    715                return ERR_VAL;
    716              }
    717              /* use UDP PCB local IP address as source address */
    718              src_ip = &pcb->local_ip;
    719            }
    720          #endif /* LWIP_IPV4 */
    721          #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
    722            return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum, src_ip);
    723          #else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
    724            return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
    725          #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
    726          }
    727          
    728          /** Same as udp_sendto_if(), but with source address */
    729          err_t
    730          udp_sendto_if_src(struct udp_pcb *pcb, struct pbuf *p,
    731            const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif, const ip_addr_t *src_ip)
    732          {
    733          #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
    734            return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0, src_ip);
    735          }
    736          
    737          /** Same as udp_sendto_if_src(), but with checksum */
    738          err_t
    739          udp_sendto_if_src_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
    740                               u16_t dst_port, struct netif *netif, u8_t have_chksum,
    741                               u16_t chksum, const ip_addr_t *src_ip)
    742          {
    743          #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
    744            struct udp_hdr *udphdr;
    745            err_t err;
    746            struct pbuf *q; /* q will be sent down the stack */
    747            u8_t ip_proto;
    748            u8_t ttl;
    749          
    750            if ((pcb == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, src_ip) ||
    751                !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
    752              return ERR_VAL;
    753            }
    754          
    755          #if LWIP_IPV4 && IP_SOF_BROADCAST
    756            /* broadcast filter? */
    757            if (!ip_get_option(pcb, SOF_BROADCAST) &&
    758          #if LWIP_IPV6
    759                !PCB_ISIPV6(pcb) &&
    760          #endif /* LWIP_IPV6 */
    761                ip_addr_isbroadcast(dst_ip, netif) ) {
    762              LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
    763                ("udp_sendto_if: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
    764              return ERR_VAL;
    765            }
    766          #endif /* LWIP_IPV4 && IP_SOF_BROADCAST */
    767          
    768            /* if the PCB is not yet bound to a port, bind it here */
    769            if (pcb->local_port == 0) {
    770              LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    771              err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    772              if (err != ERR_OK) {
    773                LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
    774                return err;
    775              }
    776            }
    777          
    778            /* not enough space to add an UDP header to first pbuf in given p chain? */
    779            if (pbuf_header(p, UDP_HLEN)) {
    780              /* allocate header in a separate new pbuf */
    781              q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    782              /* new header pbuf could not be allocated? */
    783              if (q == NULL) {
    784                LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
    785                return ERR_MEM;
    786              }
    787              if (p->tot_len != 0) {
    788                /* chain header q in front of given pbuf p (only if p contains data) */
    789                pbuf_chain(q, p);
    790              }
    791              /* first pbuf q points to header pbuf */
    792              LWIP_DEBUGF(UDP_DEBUG,
    793                          ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
    794            } else {
    795              /* adding space for header within p succeeded */
    796              /* first pbuf q equals given pbuf */
    797              q = p;
    798              LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
    799            }
    800            LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
    801                        (q->len >= sizeof(struct udp_hdr)));
    802            /* q now represents the packet to be sent */
    803            udphdr = (struct udp_hdr *)q->payload;
    804            udphdr->src = htons(pcb->local_port);
    805            udphdr->dest = htons(dst_port);
    806            /* in UDP, 0 checksum means 'no checksum' */
    807            udphdr->chksum = 0x0000;
    808          
    809            /* Multicast Loop? */
    810          #if (LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS) || (LWIP_IPV6 && LWIP_IPV6_MLD)
    811            if (((pcb->flags & UDP_FLAGS_MULTICAST_LOOP) != 0) && ip_addr_ismulticast(dst_ip)) {
    812              q->flags |= PBUF_FLAG_MCASTLOOP;
    813            }
    814          #endif /* (LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS) || (LWIP_IPV6 && LWIP_IPV6_MLD) */
    815          
    816            LWIP_DEBUGF(UDP_DEBUG, ("udp_send: sending datagram of length %"U16_F"\n", q->tot_len));
    817          
    818          #if LWIP_UDPLITE
    819            /* UDP Lite protocol? */
    820            if (pcb->flags & UDP_FLAGS_UDPLITE) {
    821              u16_t chklen, chklen_hdr;
    822              LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE packet length %"U16_F"\n", q->tot_len));
    823              /* set UDP message length in UDP header */
    824              chklen_hdr = chklen = pcb->chksum_len_tx;
    825              if ((chklen < sizeof(struct udp_hdr)) || (chklen > q->tot_len)) {
    826                if (chklen != 0) {
    827                  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE pcb->chksum_len is illegal: %"U16_F"\n", chklen));
    828                }
    829                /* For UDP-Lite, checksum length of 0 means checksum
    830                   over the complete packet. (See RFC 3828 chap. 3.1)
    831                   At least the UDP-Lite header must be covered by the
    832                   checksum, therefore, if chksum_len has an illegal
    833                   value, we generate the checksum over the complete
    834                   packet to be safe. */
    835                chklen_hdr = 0;
    836                chklen = q->tot_len;
    837              }
    838              udphdr->len = htons(chklen_hdr);
    839              /* calculate checksum */
    840          #if CHECKSUM_GEN_UDP
    841          #if LWIP_CHECKSUM_ON_COPY
    842              if (have_chksum) {
    843                chklen = UDP_HLEN;
    844              }
    845          #endif /* LWIP_CHECKSUM_ON_COPY */
    846              udphdr->chksum = ip_chksum_pseudo_partial(q, IP_PROTO_UDPLITE,
    847                q->tot_len, chklen, src_ip, dst_ip);
    848          #if LWIP_CHECKSUM_ON_COPY
    849              if (have_chksum) {
    850                u32_t acc;
    851                acc = udphdr->chksum + (u16_t)~(chksum);
    852                udphdr->chksum = FOLD_U32T(acc);
    853              }
    854          #endif /* LWIP_CHECKSUM_ON_COPY */
    855          
    856              /* chksum zero must become 0xffff, as zero means 'no checksum' */
    857              if (udphdr->chksum == 0x0000) {
    858                udphdr->chksum = 0xffff;
    859              }
    860          #endif /* CHECKSUM_GEN_UDP */
    861          
    862              ip_proto = IP_PROTO_UDPLITE;
    863            } else
    864          #endif /* LWIP_UDPLITE */
    865            {      /* UDP */
    866              LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    867              udphdr->len = htons(q->tot_len);
    868              /* calculate checksum */
    869          #if CHECKSUM_GEN_UDP
    870              /* Checksum is mandatory over IPv6. */
    871              if (PCB_ISIPV6(pcb) || (pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
    872                u16_t udpchksum;
    873          #if LWIP_CHECKSUM_ON_COPY
    874                if (have_chksum) {
    875                  u32_t acc;
    876                  udpchksum = ip_chksum_pseudo_partial(q, IP_PROTO_UDP,
    877                    q->tot_len, UDP_HLEN, src_ip, dst_ip);
    878                  acc = udpchksum + (u16_t)~(chksum);
    879                  udpchksum = FOLD_U32T(acc);
    880                } else
    881          #endif /* LWIP_CHECKSUM_ON_COPY */
    882                {
    883                  udpchksum = ip_chksum_pseudo(q, IP_PROTO_UDP, q->tot_len,
    884                    src_ip, dst_ip);
    885                }
    886          
    887                /* chksum zero must become 0xffff, as zero means 'no checksum' */
    888                if (udpchksum == 0x0000) {
    889                  udpchksum = 0xffff;
    890                }
    891                udphdr->chksum = udpchksum;
    892              }
    893          #endif /* CHECKSUM_GEN_UDP */
    894              ip_proto = IP_PROTO_UDP;
    895            }
    896          
    897            /* Determine TTL to use */
    898          #if LWIP_MULTICAST_TX_OPTIONS
    899            ttl = (ip_addr_ismulticast(dst_ip) ? pcb->mcast_ttl : pcb->ttl);
    900          #else /* LWIP_MULTICAST_TX_OPTIONS */
    901            ttl = pcb->ttl;
    902          #endif /* LWIP_MULTICAST_TX_OPTIONS */
    903          
    904            LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
    905            LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
    906            /* output to IP */
    907            NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    908            err = ip_output_if_src(PCB_ISIPV6(pcb), q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
    909            NETIF_SET_HWADDRHINT(netif, NULL);
    910          
    911            /* TODO: must this be increased even if error occurred? */
    912            snmp_inc_udpoutdatagrams();
    913          
    914            /* did we chain a separate header pbuf earlier? */
    915            if (q != p) {
    916              /* free the header pbuf */
    917              pbuf_free(q);
    918              q = NULL;
    919              /* p is still referenced by the caller, and will live on */
    920            }
    921          
    922            UDP_STATS_INC(udp.xmit);
    923            return err;
    924          }
    925          
    926          /**
    927           * Bind an UDP PCB.
    928           *
    929           * @param pcb UDP PCB to be bound with a local address ipaddr and port.
    930           * @param ipaddr local IP address to bind with. Use IP_ADDR_ANY to
    931           * bind to all local interfaces.
    932           * @param port local UDP port to bind with. Use 0 to automatically bind
    933           * to a random port between UDP_LOCAL_PORT_RANGE_START and
    934           * UDP_LOCAL_PORT_RANGE_END.
    935           *
    936           * ipaddr & port are expected to be in the same byte order as in the pcb.
    937           *
    938           * @return lwIP error code.
    939           * - ERR_OK. Successful. No error occurred.
    940           * - ERR_USE. The specified ipaddr and port are already bound to by
    941           * another UDP PCB.
    942           *
    943           * @see udp_disconnect()
    944           */
    945          err_t
    946          udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
    947          {
    948            struct udp_pcb *ipcb;
    949            u8_t rebind;
    950          
    951            if ((pcb == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, ipaddr)) {
    952              return ERR_VAL;
    953            }
    954          
    955            LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
    956            ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
    957            LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));
    958          
    959            rebind = 0;
    960            /* Check for double bind and rebind of the same pcb */
    961            for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    962              /* is this UDP PCB already on active list? */
    963              if (pcb == ipcb) {
    964                /* pcb may occur at most once in active list */
    965                LWIP_ASSERT("rebind == 0", rebind == 0);
    966                /* pcb already in list, just rebind */
    967                rebind = 1;
    968              }
    969          
    970              /* By default, we don't allow to bind to a port that any other udp
    971                 PCB is already bound to, unless *all* PCBs with that port have tha
    972                 REUSEADDR flag set. */
    973          #if SO_REUSE
    974              else if (!ip_get_option(pcb, SOF_REUSEADDR) &&
    975                       !ip_get_option(ipcb, SOF_REUSEADDR)) {
    976          #else /* SO_REUSE */
    977              /* port matches that of PCB in list and REUSEADDR not set -> reject */
    978              else {
    979          #endif /* SO_REUSE */
    980                if ((ipcb->local_port == port) && IP_PCB_IPVER_EQ(pcb, ipcb) &&
    981                    /* IP address matches, or one is IP_ADDR_ANY? */
    982                      (ip_addr_isany(&ipcb->local_ip) ||
    983                       ip_addr_isany(ipaddr) ||
    984                       ip_addr_cmp(&ipcb->local_ip, ipaddr))) {
    985                  /* other PCB already binds to this local IP and port */
    986                  LWIP_DEBUGF(UDP_DEBUG,
    987                              ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
    988                  return ERR_USE;
    989                }
    990              }
    991            }
    992          
    993            ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
    994          
    995            /* no port specified? */
    996            if (port == 0) {
    997              port = udp_new_port();
    998              if (port == 0) {
    999                /* no more ports available in local range */
   1000                LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
   1001                return ERR_USE;
   1002              }
   1003            }
   1004            pcb->local_port = port;
   1005            snmp_insert_udpidx_tree(pcb);
   1006            /* pcb not active yet? */
   1007            if (rebind == 0) {
   1008              /* place the PCB on the active list if not already there */
   1009              pcb->next = udp_pcbs;
   1010              udp_pcbs = pcb;
   1011            }
   1012            LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
   1013            ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, &pcb->local_ip);
   1014            LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
   1015            return ERR_OK;
   1016          }
   1017          
   1018          /**
   1019           * Connect an UDP PCB.
   1020           *
   1021           * This will associate the UDP PCB with the remote address.
   1022           *
   1023           * @param pcb UDP PCB to be connected with remote address ipaddr and port.
   1024           * @param ipaddr remote IP address to connect with.
   1025           * @param port remote UDP port to connect with.
   1026           *
   1027           * @return lwIP error code
   1028           *
   1029           * ipaddr & port are expected to be in the same byte order as in the pcb.
   1030           *
   1031           * The udp pcb is bound to a random local port if not already bound.
   1032           *
   1033           * @see udp_disconnect()
   1034           */
   1035          err_t
   1036          udp_connect(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
   1037          {
   1038            struct udp_pcb *ipcb;
   1039          
   1040            if ((pcb == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, ipaddr)) {
   1041              return ERR_VAL;
   1042            }
   1043          
   1044            if (pcb->local_port == 0) {
   1045              err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
   1046              if (err != ERR_OK) {
   1047                return err;
   1048              }
   1049            }
   1050          
   1051            ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
   1052            pcb->remote_port = port;
   1053            pcb->flags |= UDP_FLAGS_CONNECTED;
   1054          /** TODO: this functionality belongs in upper layers */
   1055          #ifdef LWIP_UDP_TODO
   1056          #if LWIP_IPV6
   1057            if (!PCB_ISIPV6(pcb))
   1058          #endif /* LWIP_IPV6 */
   1059            {
   1060              /* Nail down local IP for netconn_addr()/getsockname() */
   1061              if (ip_addr_isany(&pcb->local_ip) && !ip_addr_isany(&pcb->remote_ip)) {
   1062                struct netif *netif;
   1063          
   1064                if ((netif = ip_route(PCB_ISIPV6(pcb), (const ip_addr_t*)NULL, &pcb->remote_ip)) == NULL) {
   1065                  LWIP_DEBUGF(UDP_DEBUG, ("udp_connect: No route to %s\n", ipaddr_ntoa(&pcb->remote_ip)));
   1066                  UDP_STATS_INC(udp.rterr);
   1067                  return ERR_RTE;
   1068                }
   1069                /** TODO: this will bind the udp pcb locally, to the interface which
   1070                    is used to route output packets to the remote address. However, we
   1071                    might want to accept incoming packets on any interface! */
   1072                ip_netif_get_local_ip(PCB_ISIPV6(pcb), netif, &pcb->remote_ip, &pcb->local_ip);
   1073              } else if (ip_addr_isany(&pcb->remote_ip)) {
   1074                ip_addr_set_any(PCB_ISIPV6(pcb), &pcb->local_ip);
   1075              }
   1076            }
   1077          #endif
   1078            LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_connect: connected to "));
   1079            ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
   1080                                &pcb->remote_ip);
   1081            LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->remote_port));
   1082          
   1083            /* Insert UDP PCB into the list of active UDP PCBs. */
   1084            for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   1085              if (pcb == ipcb) {
   1086                /* already on the list, just return */
   1087                return ERR_OK;
   1088              }
   1089            }
   1090            /* PCB not yet on the list, add PCB now */
   1091            pcb->next = udp_pcbs;
   1092            udp_pcbs = pcb;
   1093            return ERR_OK;
   1094          }
   1095          
   1096          /**
   1097           * Disconnect a UDP PCB
   1098           *
   1099           * @param pcb the udp pcb to disconnect.
   1100           */
   1101          void
   1102          udp_disconnect(struct udp_pcb *pcb)
   1103          {
   1104            /* reset remote address association */
   1105            ip_addr_set_any(PCB_ISIPV6(pcb), &pcb->remote_ip);
   1106            pcb->remote_port = 0;
   1107            /* mark PCB as unconnected */
   1108            pcb->flags &= ~UDP_FLAGS_CONNECTED;
   1109          }
   1110          
   1111          /**
   1112           * Set a receive callback for a UDP PCB
   1113           *
   1114           * This callback will be called when receiving a datagram for the pcb.
   1115           *
   1116           * @param pcb the pcb for which to set the recv callback
   1117           * @param recv function pointer of the callback function
   1118           * @param recv_arg additional argument to pass to the callback function
   1119           */
   1120          void
   1121          udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
   1122          {
   1123            /* remember recv() callback and user data */
   1124            pcb->recv = recv;
   1125            pcb->recv_arg = recv_arg;
   1126          }
   1127          
   1128          /**
   1129           * Remove an UDP PCB.
   1130           *
   1131           * @param pcb UDP PCB to be removed. The PCB is removed from the list of
   1132           * UDP PCB's and the data structure is freed from memory.
   1133           *
   1134           * @see udp_new()
   1135           */
   1136          void
   1137          udp_remove(struct udp_pcb *pcb)
   1138          {
   1139            struct udp_pcb *pcb2;
   1140          
   1141            snmp_delete_udpidx_tree(pcb);
   1142            /* pcb to be removed is first in list? */
   1143            if (udp_pcbs == pcb) {
   1144              /* make list start at 2nd pcb */
   1145              udp_pcbs = udp_pcbs->next;
   1146              /* pcb not 1st in list */
   1147            } else {
   1148              for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
   1149                /* find pcb in udp_pcbs list */
   1150                if (pcb2->next != NULL && pcb2->next == pcb) {
   1151                  /* remove pcb from list */
   1152                  pcb2->next = pcb->next;
   1153                  break;
   1154                }
   1155              }
   1156            }
   1157            memp_free(MEMP_UDP_PCB, pcb);
   1158          }
   1159          
   1160          /**
   1161           * Create a UDP PCB.
   1162           *
   1163           * @return The UDP PCB which was created. NULL if the PCB data structure
   1164           * could not be allocated.
   1165           *
   1166           * @see udp_remove()
   1167           */
   1168          struct udp_pcb *
   1169          udp_new(void)
   1170          {
   1171            struct udp_pcb *pcb;
   1172            pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
   1173            /* could allocate UDP PCB? */
   1174            if (pcb != NULL) {
   1175              /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
   1176               * which means checksum is generated over the whole datagram per default
   1177               * (recommended as default by RFC 3828). */
   1178              /* initialize PCB to all zeroes */
   1179              memset(pcb, 0, sizeof(struct udp_pcb));
   1180              pcb->ttl = UDP_TTL;
   1181          #if LWIP_MULTICAST_TX_OPTIONS
   1182              pcb->mcast_ttl = UDP_TTL;
   1183          #endif /* LWIP_MULTICAST_TX_OPTIONS */
   1184            }
   1185            return pcb;
   1186          }
   1187          
   1188          #if LWIP_IPV6
   1189          /**
   1190           * Create a UDP PCB for IPv6.
   1191           *
   1192           * @return The UDP PCB which was created. NULL if the PCB data structure
   1193           * could not be allocated.
   1194           *
   1195           * @see udp_remove()
   1196           */
   1197          struct udp_pcb *
   1198          udp_new_ip6(void)
   1199          {
   1200            struct udp_pcb *pcb;
   1201            pcb = udp_new();
   1202          #if LWIP_IPV4
   1203            ip_set_v6(pcb, 1);
   1204          #endif /* LWIP_IPV4 */
   1205            return pcb;
   1206          }
   1207          #endif /* LWIP_IPV6 */
   1208          
   1209          #if LWIP_IPV4
   1210          /** This function is called from netif.c when address is changed
   1211           *
   1212           * @param old_addr IPv4 address of the netif before change
   1213           * @param new_addr IPv4 address of the netif after change
   1214           */
   1215          void udp_netif_ipv4_addr_changed(const ip4_addr_t* old_addr, const ip4_addr_t* new_addr)
   1216          {
   1217            struct udp_pcb* upcb;
   1218          
   1219            if (!ip4_addr_isany(new_addr)) {
   1220              for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
   1221                /* Is this an IPv4 pcb? */
   1222                if (!IP_IS_V6_VAL(upcb->local_ip)) {
   1223                  /* PCB bound to current local interface address? */
   1224                  if (!ip4_addr_isany(ip_2_ip4(&upcb->local_ip)) &&
   1225                      ip4_addr_cmp(ip_2_ip4(&upcb->local_ip), old_addr)) {
   1226                    /* The PCB is bound to the old ipaddr and
   1227                      * is set to bound to the new one instead */
   1228                    ip_addr_copy_from_ip4(upcb->local_ip, *new_addr);
   1229                  }
   1230                }
   1231              }
   1232            }
   1233          }
   1234          #endif /* LWIP_IPV4 */
   1235          
   1236          #if UDP_DEBUG
   1237          /**
   1238           * Print UDP header information for debug purposes.
   1239           *
   1240           * @param udphdr pointer to the udp header in memory.
   1241           */
   1242          void
   1243          udp_debug_print(struct udp_hdr *udphdr)
   1244          {
   1245            LWIP_DEBUGF(UDP_DEBUG, ("UDP header:\n"));
   1246            LWIP_DEBUGF(UDP_DEBUG, ("+-------------------------------+\n"));
   1247            LWIP_DEBUGF(UDP_DEBUG, ("|     %5"U16_F"     |     %5"U16_F"     | (src port, dest port)\n",
   1248                                    ntohs(udphdr->src), ntohs(udphdr->dest)));
   1249            LWIP_DEBUGF(UDP_DEBUG, ("+-------------------------------+\n"));
   1250            LWIP_DEBUGF(UDP_DEBUG, ("|     %5"U16_F"     |     0x%04"X16_F"    | (len, chksum)\n",
   1251                                    ntohs(udphdr->len), ntohs(udphdr->chksum)));
   1252            LWIP_DEBUGF(UDP_DEBUG, ("+-------------------------------+\n"));
   1253          }
   1254          #endif /* UDP_DEBUG */
   1255          
   1256          #endif /* LWIP_UDP */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   udp_bind
        32   -> printf
        32   -> udp_new_port
      16   udp_connect
        16   -> udp_bind
       0   udp_disconnect
       8   udp_init
         8   -> rand
      48   udp_input
        48   -- Indirect call
        48   -> icmp_dest_unreach
        48   -> ip4_addr_isbroadcast_u32
        48   -> ip_chksum_pseudo
        48   -> lwip_ntohs
         0   -> pbuf_free
        48   -> pbuf_header
        48   -> pbuf_header_force
        48   -> printf
       4   udp_netif_ipv4_addr_changed
       8   udp_new
         8   -> __aeabi_memset4
         8   -> mem_malloc
       4   udp_new_port
       0   udp_recv
       0   udp_remove
         0   -> mem_free
       0   udp_send
         0   -> udp_sendto
      24   udp_sendto
        24   -> ip4_route
        24   -> udp_sendto_if
      24   udp_sendto_if
        24   -> udp_sendto_if_src
      48   udp_sendto_if_src
        48   -> ip4_output_if_src
        48   -> ip_chksum_pseudo
        48   -> lwip_htons
        48   -> pbuf_alloc
        48   -> pbuf_chain
        48   -> pbuf_free
        48   -> pbuf_header
        48   -> printf
        48   -> udp_bind


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
      40  ?_0
      20  ?_1
      76  ?_2
      48  ?_3
      12  ?_4
     168  udp_bind
      86  udp_connect
      16  udp_disconnect
      22  udp_init
     570  udp_input
      48  udp_netif_ipv4_addr_changed
      30  udp_new
      62  udp_new_port
       8  udp_port
          udp_pcbs
       6  udp_recv
      38  udp_remove
       4  udp_send
      64  udp_sendto
      42  udp_sendto_if
     250  udp_sendto_if_src

 
     8 bytes in section .data
 1 622 bytes in section .text
 
 1 622 bytes of CODE memory
     8 bytes of DATA memory

Errors: none
Warnings: 8
