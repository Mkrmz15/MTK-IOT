###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:43
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\uart.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EWBD94.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\uart.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\uart.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\uart.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\uart.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          #include "uart.h"
     36          #include "uart_hw.h"
     37          #include "mem_util.h"
     38          #include "timer.h"
     39          
     40          #include "nvic.h"
     41          
     42          //#include "printf.h"
     43          #include "top.h"
     44          
     45          #include "type_def.h"
     46          #include "dma_hw.h"
     47          #include "dma_sw.h"
     48          
     49          #define    UART_BAUDRATE        115200        /* default baudrate */
     50          
     51          #define UART_BASE_ADDR(port_no) \
     52              ((port_no == UART_PORT0) ? CM4_UART1_BASE : CM4_UART2_BASE)
     53          
     54          uint32_t gUartClkFreq;
     55          
     56          #ifdef HAL_SLEEP_MANAGER_ENABLED
     57          const char *const g_uart_sleep_handler_name[] = {"uart0", "uart1"};
     58          const hal_nvic_irq_t g_uart_port_to_irq_num[] = {CM4_UART1_IRQ, CM4_UART2_IRQ};
     59          #endif
     60          
     61          /*****************************/
     62          /* Internal used function */
     63          /*****************************/
     64          /*
     65           *     get character from SW FIFO (interrupt based)
     66           *     (ROM code shall call getc_nowait() instead of this function)
     67           */
     68          int getc(void)
     69          {
     70              //int rc = rb_get_and_zap();
     71              int rc = getc_nowait();
     72              return rc;
     73          }
     74          
     75          /*****************************/
     76          
     77          /*
     78           *    get character from HW directly
     79           */
     80          int getc_nowait(void)
     81          {
     82              char c;
     83          
     84              if (HAL_REG_32(CONSOLE + UART_LSR) & 0x1) { //  DataReady bit
     85                  c = HAL_REG_32(CONSOLE + UART_RBR);
     86                  return c;
     87              } else {
     88                  return -1;
     89              }
     90          }
     91          
     92          /* MT7687 CM4 */
     93          void uart_output_char(UART_PORT port_no, unsigned char c)
     94          {
     95              unsigned int base = UART_BASE_ADDR(port_no);
     96          
     97              while (!(HAL_REG_32(base + UART_LSR) & 0x20 /* THRE bit */))
     98                  ;
     99              HAL_REG_32(base + UART_RBR) = c;
    100          
    101              return;
    102          }
    103          
    104          
    105          /* MT7687 CM4 */
    106          uint8_t uart_input_char(UART_PORT port_no)
    107          {
    108              unsigned int base = UART_BASE_ADDR(port_no);
    109              char         c;
    110          
    111              while (!(HAL_REG_32(base + UART_LSR) & 0x1)) //  DataReady bit
    112                  ;
    113          
    114              c = HAL_REG_32(base + UART_RBR);
    115          
    116              return c;
    117          }
    118          
    119          /*
    120           * Initial UART hardware
    121           */
    122          void halUART_HWInit(UART_PORT u_port)
    123          {
    124          
    125              halUART_SetFormat(u_port, UART_BAUDRATE, UART_WLS_8, UART_NONE_PARITY, UART_1_STOP);
    126              if (u_port == UART_PORT0) {
    127                  //UART_HWInit(CM4_UART1_BASE);    /*temp*/
    128                  HAL_REG_32(CM4_UART1_BASE + UART_VFIFO_EN_REG) |= 0x1;
    129          
    130                  /* ISR */
    131                  //NVIC_EnableIRQ(CM4_UART1_IRQ);
    132                  //NVIC_SetPriority(CM4_UART1_IRQ, CM4_UART1_PRI);
    133              } else if (u_port == UART_PORT1) {
    134                  //UART_HWInit(CM4_UART2_BASE);    /*temp*/
    135                  HAL_REG_32(CM4_UART2_BASE + UART_VFIFO_EN_REG) |= 0x1;
    136                  /* ISR */
    137                  //NVIC_EnableIRQ(CM4_UART2_IRQ);
    138                  //NVIC_SetPriority(CM4_UART2_IRQ, CM4_UART2_PRI);
    139              } else {
    140              }
    141          }
    142          
    143          
    144          void halUART_SetFormat(UART_PORT u_port, uint32_t baudrate, uint16_t databit, uint16_t parity, uint16_t stopbit)
    145          {
    146              uint16_t control_word;
    147              uint32_t UART_BASE = CM4_UART1_BASE;
    148              uint32_t data, uart_lcr, high_speed_div, sample_count, sample_point, fraction;
    149              uint16_t  fraction_L_mapping[] = {0x00, 0x10, 0x44, 0x92, 0x29, 0xaa, 0xb6, 0xdb, 0xad, 0xff, 0xff};
    150              uint16_t  fraction_M_mapping[] = {0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03};
    151              int32_t status = 0;
    152              gUartClkFreq = top_xtal_freq_get();
    153          
    154              if (u_port == UART_PORT0) {
    155                  UART_BASE = CM4_UART1_BASE;
    156              } else if (u_port == UART_PORT1) {
    157                  UART_BASE = CM4_UART2_BASE;
    158              } else {
    159              }
    160          
    161              // 100, 300, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 921600
    162              HAL_REG_32(UART_BASE + UART_RATE_STEP) = 0x3; // based on sampe_count * baud_pulse, baud_rate = system clock frequency / sampe_count
    163              uart_lcr = HAL_REG_32(UART_BASE + UART_LCR);     /* DLAB start */
    164              HAL_REG_32(UART_BASE + UART_LCR) = (uart_lcr | UART_LCR_DLAB);
    165              data = gUartClkFreq / baudrate;
    166              high_speed_div = (data >> 8) + 1; // divided by 256
    167              {
    168                  sample_count = data / high_speed_div - 1;
    169                  if (sample_count == 3) {
    170                      sample_point = 0;
    171                  } else {
    172                      sample_point = sample_count / 2 - 1;
    173                  }
    174                  if (!(data >= 4)) {
    175                      status = -1;
    176                  }
    177              }
    178              fraction = (gUartClkFreq * 10 / baudrate / data - (sample_count + 1) * 10) % 10;
    179              HAL_REG_32(UART_BASE + UART_DLL) = (high_speed_div & 0x00ff);
    180              HAL_REG_32(UART_BASE + UART_DLH) = ((high_speed_div >> 8) & 0x00ff);
    181              HAL_REG_32(UART_BASE + UART_STEP_COUNT) = sample_count;
    182              HAL_REG_32(UART_BASE + UART_SAMPLE_COUNT) = sample_point;
    183              HAL_REG_32(UART_BASE + UART_FRACDIV_M) = fraction_M_mapping[fraction];
    184              HAL_REG_32(UART_BASE + UART_FRACDIV_L) = fraction_L_mapping[fraction];
    185              HAL_REG_32(UART_BASE + UART_LCR) = (uart_lcr);   /* DLAB end */
    186              HAL_REG_32(UART_BASE + UART_FCR) = 0x47;
    187          
    188              control_word = DRV_Reg16(UART_BASE + UART_LCR);     /* DLAB start */
    189              control_word &= ~UART_DATA_MASK;
    190              control_word |= databit;
    191              control_word &= ~UART_STOP_MASK;
    192              control_word |= stopbit;
    193              control_word &= ~UART_PARITY_MASK;
    194              control_word |= parity;
    195              DRV_WriteReg16(UART_BASE + UART_LCR , control_word);           /* DLAB End */
    196              if (status != 0) {
    197                  return;
    198              }
    199          }
    200          
    201          void halUART_Get_VFIFO_Length(UART_PORT u_port, int32_t is_rx, uint32_t *length)
    202          {
    203              if (u_port == UART_PORT0) {
    204                  if (is_rx) {
    205                      *length = DMA_GetVFIFO_Avail(VDMA_UART1RX_CH);
    206                  } else {
    207                      *length = DMA_GetVFIFO_FFSIZE(VDMA_UART1TX_CH);
    208                      *length -= DMA_GetVFIFO_Avail(VDMA_UART1TX_CH);
    209                  }
    210              } else {
    211                  if (is_rx) {
    212                      *length = DMA_GetVFIFO_Avail(VDMA_UART2RX_CH);
    213                  } else {
    214                      *length = DMA_GetVFIFO_FFSIZE(VDMA_UART2TX_CH);
    215                      *length -= DMA_GetVFIFO_Avail(VDMA_UART2TX_CH);
    216                  }
    217              }
    218          
    219              return;
    220          }
    221          
    222          void halUART_Read_VFIFO_Data(UART_PORT u_port, uint8_t *data, uint32_t length)
    223          {
    224              UINT32 idx = 0;
    225              for (idx = 0; idx < length; idx++) {
    226                  if (u_port == UART_PORT0) {
    227                      data[idx] = (UINT8)(*(volatile UINT8 *)DMA_VPORT(VDMA_UART1RX_CH));
    228                  } else if (u_port == UART_PORT1) {
    229                      data[idx] = (UINT8)(*(volatile UINT8 *)DMA_VPORT(VDMA_UART2RX_CH));
    230                  } else {
    231                  }
    232              }
    233          
    234              return;
    235          }
    236          
    237          void halUART_Write_VFIFO_Data(UART_PORT u_port, const uint8_t *data, uint32_t length)
    238          {
    239              UINT32 idx = 0;
    240              for (idx = 0; idx < length; idx++) {
    241                  if (u_port == UART_PORT0) {
    242                      *(volatile UINT8 *)DMA_VPORT(VDMA_UART1TX_CH) = data[idx];
    243                  } else if (u_port == UART_PORT1) {
    244                      *(volatile UINT8 *)DMA_VPORT(VDMA_UART2TX_CH) = data[idx];
    245                  } else {
    246                  }
    247              }
    248          
    249              return;
    250          }
    251          
    252          void halUART_Tx_VFIFO_Initialize(UART_PORT u_port, uint8_t *vfifo_buffer, uint32_t buffer_length, uint32_t threshold)
    253          {
    254              if (u_port == UART_PORT0) {
    255                  DMA_Vfifo_SetAdrs((UINT32)vfifo_buffer, buffer_length, VDMA_UART1TX_CH, 0 /* alert length */, threshold /* threshold */, 0 /* timeout */);
    256                  DMA_Vfifo_Flush(VDMA_UART1TX_CH);
    257              } else if (u_port == UART_PORT1) {
    258                  DMA_Vfifo_SetAdrs((UINT32)vfifo_buffer, buffer_length, VDMA_UART2TX_CH, 0 /* alert length */, threshold /* threshold */, 0 /* timeout */);
    259                  DMA_Vfifo_Flush(VDMA_UART2TX_CH);
    260              } else {
    261              }
    262          }
    263          
    264          void halUART_Rx_VFIFO_Initialize(UART_PORT u_port, uint8_t *vfifo_buffer, uint32_t buffer_length, uint32_t alert_length, uint32_t threshold, uint32_t timeout)
    265          {
    266              if (u_port == UART_PORT0) {
    267                  DMA_Vfifo_SetAdrs((UINT32)vfifo_buffer, buffer_length, VDMA_UART1RX_CH, alert_length /* alert length */, threshold /* threshold */, timeout /* timeout */);
    268                  DMA_Vfifo_Flush(VDMA_UART1RX_CH);
    269              } else if (u_port == UART_PORT1) {
    270                  DMA_Vfifo_SetAdrs((UINT32)vfifo_buffer, buffer_length, VDMA_UART2RX_CH, alert_length /* alert length */, threshold /* threshold */, timeout /* timeout */);
    271                  DMA_Vfifo_Flush(VDMA_UART2RX_CH);
    272              } else {
    273              }
    274          }
    275          
    276          void halUART_VDMA_Rx_Register_Callback(UART_PORT u_port, VOID_FUNC func)
    277          {
    278              if (u_port == UART_PORT0) {
    279                  DMA_Vfifo_Register_Callback(VDMA_UART1RX_CH, func);
    280              } else if (u_port == UART_PORT1) {
    281                  DMA_Vfifo_Register_Callback(VDMA_UART2RX_CH, func);
    282              } else {
    283              }
    284          }
    285          
    286          void halUART_VDMA_Rx_Register_TO_Callback(UART_PORT u_port, VOID_FUNC func)
    287          {
    288              if (u_port == UART_PORT0) {
    289                  DMA_Vfifo_Register_TO_Callback(VDMA_UART1RX_CH, func);
    290              } else if (u_port == UART_PORT1) {
    291                  DMA_Vfifo_Register_TO_Callback(VDMA_UART2RX_CH, func);
    292              } else {
    293              }
    294          }
    295          
    296          void uart_set_hardware_flowcontrol(UART_PORT u_port)
    297          {
    298              unsigned int base = UART_BASE_ADDR(u_port);
    299              uint16_t EFR, LCR;
    300          
    301              LCR = HAL_REG_32(base + UART_LCR);
    302          
    303              HAL_REG_32(base + UART_LCR) = 0xbf;
    304              EFR = HAL_REG_32(base + UART_EFR);
    305              EFR |= 0x00d0;
    306              HAL_REG_32(base + UART_EFR) = EFR;
    307          
    308              HAL_REG_32(base + UART_ESCAPE_EN) = 0;
    309          
    310              HAL_REG_32(base + UART_LCR) = 0x00;
    311              HAL_REG_32(base + UART_MCR) = 0x02;
    312          
    313              HAL_REG_32(base + UART_LCR) = LCR;
    314          }
    315          
    316          void uart_set_software_flowcontrol(UART_PORT u_port, uint8_t xon, uint8_t xoff, uint8_t escape_character)
    317          {
    318              unsigned int base = UART_BASE_ADDR(u_port);
    319              uint16_t EFR, LCR;
    320          
    321              LCR = HAL_REG_32(base + UART_LCR);
    322          
    323              HAL_REG_32(base + UART_LCR) = 0xbf;
    324              HAL_REG_32(base + UART_XON1) = xon;
    325              HAL_REG_32(base + UART_XON2) = xon;
    326              HAL_REG_32(base + UART_XOFF1) = xoff;
    327              HAL_REG_32(base + UART_XOFF2) = xoff;
    328          
    329              EFR = HAL_REG_32(base + UART_EFR);
    330              EFR |= 0x000A;
    331              HAL_REG_32(base + UART_EFR) = EFR;
    332          
    333              HAL_REG_32(base + UART_LCR) = LCR;
    334          
    335              HAL_REG_32(base + UART_ESCAPE_DATA) = escape_character;
    336              HAL_REG_32(base + UART_ESCAPE_EN) = 1;
    337          }
    338          
    339          void uart_disable_flowcontrol(UART_PORT u_port)
    340          {
    341              unsigned int base = UART_BASE_ADDR(u_port);
    342              uint16_t LCR;
    343          
    344              LCR = HAL_REG_32(base + UART_LCR);
    345          
    346              HAL_REG_32(base + UART_LCR) = 0xbf;
    347          
    348              HAL_REG_32(base + UART_EFR) = 0x0;
    349          
    350              HAL_REG_32(base + UART_LCR) = 0x00;
    351          
    352              HAL_REG_32(base + UART_LCR) = LCR;
    353          }
    354          
    355          #ifdef HAL_SLEEP_MANAGER_ENABLED
    356          void uart_set_sleep_mode(UART_PORT u_port)
    357          {
    358              unsigned int base = UART_BASE_ADDR(u_port);
    359          
    360              HAL_REG_32(base + UART_SLEEP_EN) = 0x01;
    361          }
    362          
    363          void uart_unmask_send_interrupt(UART_PORT u_port)
    364          {
    365              unsigned int base = UART_BASE_ADDR(u_port);
    366              uint16_t IER, LCR;
    367          
    368              LCR = HAL_REG_32(base + UART_LCR);
    369              HAL_REG_32(base + UART_LCR) = 0x00;
    370          
    371              IER = HAL_REG_32(base + UART_IER);
    372              IER |= 0x02;
    373              HAL_REG_32(base + UART_IER) = IER;
    374          
    375              HAL_REG_32(base + UART_LCR) = LCR;
    376          
    377              HAL_REG_32(base + UART_SLEEP_EN) = 0x01;
    378          }
    379          
    380          void uart_mask_send_interrupt(UART_PORT u_port)
    381          {
    382              unsigned int base = UART_BASE_ADDR(u_port);
    383              uint16_t IER, LCR;
    384          
    385              LCR = HAL_REG_32(base + UART_LCR);
    386              HAL_REG_32(base + UART_LCR) = 0x00;
    387          
    388              IER = HAL_REG_32(base + UART_IER);
    389              IER &= ~0x02;
    390              HAL_REG_32(base + UART_IER) = IER;
    391          
    392              HAL_REG_32(base + UART_LCR) = LCR;
    393          
    394              HAL_REG_32(base + UART_SLEEP_EN) = 0x00;
    395          }
    396          
    397          void uart_interrupt_handler(hal_nvic_irq_t irq_number)
    398          {
    399              UART_PORT u_port;
    400              unsigned int base;
    401              uint16_t IIR;
    402          
    403              if (irq_number == CM4_UART1_IRQ) {
    404                  u_port = UART_PORT0;
    405                  base = UART_BASE_ADDR(u_port);
    406              } else {
    407                  u_port = UART_PORT1;
    408                  base = UART_BASE_ADDR(u_port);
    409              }
    410          
    411              IIR = HAL_REG_32(base + UART_IIR);
    412              switch (IIR & 0x3F) {
    413                  case 0x02:
    414                      uart_send_handler(u_port);
    415                      break;
    416                  default:
    417                      break;
    418              }
    419          }
    420          #endif
    421          
    422          void uart_reset_default_value(UART_PORT u_port)
    423          {
    424              unsigned int base = UART_BASE_ADDR(u_port);
    425          
    426              HAL_REG_32(base + UART_LCR) = 0xbf;
    427              HAL_REG_32(base + UART_EFR) = 0x10;
    428              HAL_REG_32(base + UART_XON1) = 0x00;
    429              HAL_REG_32(base + UART_XOFF1) = 0x00;
    430          
    431              HAL_REG_32(base + UART_LCR) = 0x80;
    432              HAL_REG_32(base + UART_DLL) = 0x00;
    433              HAL_REG_32(base + UART_DLH) = 0x00;
    434          
    435              HAL_REG_32(base + UART_LCR) = 0x00;
    436              HAL_REG_32(base + UART_IER) = 0x00;
    437              HAL_REG_32(base + UART_FCR) = 0x00;
    438          
    439              HAL_REG_32(base + UART_LCR) = 0xbf;
    440              HAL_REG_32(base + UART_EFR) = 0x00;
    441              HAL_REG_32(base + UART_LCR) = 0x00;
    442          
    443              HAL_REG_32(base + UART_MCR) = 0x00;
    444              HAL_REG_32(base + UART_SCR) = 0x00;
    445              HAL_REG_32(base + UART_RATE_STEP) = 0x00;
    446              HAL_REG_32(base + UART_STEP_COUNT) = 0x00;
    447              HAL_REG_32(base + UART_SAMPLE_COUNT) = 0x00;
    448              HAL_REG_32(base + UART_RATE_FIX_REG) = 0x00;
    449              HAL_REG_32(base + UART_GUARD) = 0x00;
    450              HAL_REG_32(base + UART_ESCAPE_DATA) = 0x00;
    451              HAL_REG_32(base + UART_ESCAPE_EN) = 0x00;
    452              HAL_REG_32(base + UART_SLEEP_EN) = 0x00;
    453              HAL_REG_32(base + UART_VFIFO_EN_REG) = 0x00;
    454              HAL_REG_32(base + UART_RX_TRIGGER_ADDR) = 0x00;
    455              HAL_REG_32(base + UART_FRACDIV_L) = 0x00;
    456              HAL_REG_32(base + UART_FRACDIV_M) = 0x00;
    457              HAL_REG_32(base + UART_TX_ACTIVE_EN) = 0x00;
    458          }
    459          
    460          void uart_query_empty(UART_PORT u_port)
    461          {
    462              unsigned int base = UART_BASE_ADDR(u_port);
    463          
    464              while (!(HAL_REG_32(base + UART_LSR) & 0x40));
    465          }
    466          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   getc
         0   -> getc_nowait
       0   getc_nowait
       0   halUART_Get_VFIFO_Length
      16   halUART_HWInit
        16   -> halUART_SetFormat
       4   halUART_Read_VFIFO_Data
      24   halUART_Rx_VFIFO_Initialize
         0   -> DMA_Vfifo_Flush
        24   -> DMA_Vfifo_SetAdrs
      80   halUART_SetFormat
        80   -> __aeabi_memcpy4
        80   -> top_xtal_freq_get
      16   halUART_Tx_VFIFO_Initialize
         0   -> DMA_Vfifo_Flush
        16   -> DMA_Vfifo_SetAdrs
       0   halUART_VDMA_Rx_Register_Callback
         0   -> DMA_Vfifo_Register_Callback
       0   halUART_VDMA_Rx_Register_TO_Callback
         0   -> DMA_Vfifo_Register_TO_Callback
       8   halUART_Write_VFIFO_Data
       0   uart_disable_flowcontrol
       0   uart_input_char
       0   uart_interrupt_handler
         0   -> uart_send_handler
       8   uart_mask_send_interrupt
       0   uart_output_char
       0   uart_query_empty
       8   uart_reset_default_value
       4   uart_set_hardware_flowcontrol
       0   uart_set_sleep_mode
      12   uart_set_software_flowcontrol
       4   uart_unmask_send_interrupt


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
       8  ?_0
       8  ?_1
      24  ?_2
      24  ?_3
       4  gUartClkFreq
       2  g_uart_port_to_irq_num
       8  g_uart_sleep_handler_name
       2  getc
      22  getc_nowait
      62  halUART_Get_VFIFO_Length
      60  halUART_HWInit
      38  halUART_Read_VFIFO_Data
      64  halUART_Rx_VFIFO_Initialize
     270  halUART_SetFormat
      68  halUART_Tx_VFIFO_Initialize
      22  halUART_VDMA_Rx_Register_Callback
      22  halUART_VDMA_Rx_Register_TO_Callback
      38  halUART_Write_VFIFO_Data
      36  uart_disable_flowcontrol
      30  uart_input_char
      34  uart_interrupt_handler
      48  uart_mask_send_interrupt
      28  uart_output_char
      22  uart_query_empty
     166  uart_reset_default_value
      60  uart_set_hardware_flowcontrol
      18  uart_set_sleep_mode
      80  uart_set_software_flowcontrol
      48  uart_unmask_send_interrupt

 
     4 bytes in section .bss
    26 bytes in section .rodata
 1 338 bytes in section .text
 
 1 338 bytes of CODE  memory
    26 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
