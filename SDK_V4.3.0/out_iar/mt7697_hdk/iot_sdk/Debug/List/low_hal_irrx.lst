###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:31
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\low_hal_irrx.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW8C61.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\low_hal_irrx.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\low_hal_irrx.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\low_hal_irrx.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\low_hal_irrx.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          /*
     36          ** $Log: low_hal_irrx.c $
     37          **
     38          **
     39          **
     40          */
     41          
     42          /*******************************************************************************
     43          *                         C O M P I L E R   F L A G S
     44          ********************************************************************************
     45          */
     46          
     47          
     48          /*******************************************************************************
     49          *                    E X T E R N A L   R E F E R E N C E S
     50          ********************************************************************************
     51          */
     52          
     53          #include "hal_platform.h"
     54          
     55          #ifdef HAL_IRRX_MODULE_ENABLED
     56          #include "hal_irrx.h"
     57          #include <stdio.h>
     58          #include <string.h>
     59          #include "type_def.h"
     60          #include "mt7687.h"
     61          #include "low_hal_irrx.h"
     62          #include "hal_nvic.h"
     63          
     64          /*******************************************************************************
     65          *                              C O N S T A N T S
     66          ********************************************************************************
     67          */
     68          
     69          /*******************************************************************************
     70          *                             D A T A   T Y P E S
     71          ********************************************************************************
     72          */
     73          
     74          
     75          /*******************************************************************************
     76          *                            P U B L I C   D A T A
     77          ********************************************************************************
     78          */
     79          
     80          
     81          /*
     82          ========================================================================
     83          Routine Description:
     84          
     85          Note:
     86          u2SamplePeriod
     87              12'h640	Set Sampling Period (800us for RC-5)
     88          ========================================================================
     89          */
     90          static irrx_user_callback_t s_low_hal_irrx_rc5_callback;
     91          static irrx_user_callback_t s_low_hal_irrx_pwd_callback;
     92          
     93          VOID halIrRxClearInterrupt(void)
     94          {
     95              P_IOT_IRRX_TypeDef pIRRXTypeDef = (P_IOT_IRRX_TypeDef)(CM4_IRDA_RX_BASE + 0x00);
     96          
     97              // Clear IRRX Interrupt
     98              // W   IRRX_BASE + 0x20    [0] IR_INTCLR   1'b1
     99              (pIRRXTypeDef->IR_INTCLR) |= BIT(IR_INTCLR_OFFSET);
    100          }
    101          
    102          
    103          static VOID halIrRxIsr(hal_nvic_irq_t irq_number)
    104          {
    105              P_IOT_IRRX_TypeDef pIRRXTypeDef = (P_IOT_IRRX_TypeDef)(CM4_IRDA_RX_BASE + 0x00);
    106          
    107              halIrRxClearInterrupt();
    108          
    109              if (((pIRRXTypeDef->IRCFGH) & (BIT(IRCFGH_CHK_EN_OFFSET)))) {
    110                  // Pulse width detection
    111                  if (s_low_hal_irrx_pwd_callback.func) {
    112                     s_low_hal_irrx_pwd_callback.func(s_low_hal_irrx_pwd_callback.argument);
    113                  }
    114              } else {
    115                  // RC5
    116                  if (s_low_hal_irrx_rc5_callback.func) {
    117                     s_low_hal_irrx_rc5_callback.func(s_low_hal_irrx_rc5_callback.argument);
    118                  }
    119              }
    120          }
    121          
    122          
    123          ENUM_HAL_RET_T halIrRxRegisterCallback(low_hal_irrx_mode_t mode, low_hal_irrx_callback_t callback,void *parameter)
    124          {
    125              ENUM_HAL_RET_T  ret = HAL_RET_SUCCESS;
    126          
    127              if (LOW_HAL_IRRX_MODE_RC5 == mode) {
    128                  s_low_hal_irrx_rc5_callback.func =callback;
    129          		  s_low_hal_irrx_rc5_callback.argument = parameter;	
    130              } else if (LOW_HAL_IRRX_MODE_PWD == mode) {
    131                    s_low_hal_irrx_pwd_callback.func =callback;
    132          		  s_low_hal_irrx_pwd_callback.argument = parameter;
    133              }
    134          
    135              hal_nvic_register_isr_handler(CM4_IRDA_RX_IRQ, halIrRxIsr);
    136              NVIC_SetPriority((IRQn_Type)CM4_IRDA_RX_IRQ, CM4_IRDA_RX_PRI);
    137              NVIC_EnableIRQ((IRQn_Type)CM4_IRDA_RX_IRQ);
    138          
    139              return ret;
    140          }
    141          
    142          
    143          VOID halIrRxRC5Read(PUINT8 pucBitNum, PUINT32 pu4DW0, PUINT32 pu4DW1)
    144          {
    145              UINT8 ucBitNum = 0;
    146              UINT8 format = 0;
    147              P_IOT_IRRX_TypeDef pIRRXTypeDef = (P_IOT_IRRX_TypeDef)(CM4_IRDA_RX_BASE + 0x00);
    148              ucBitNum = (((pIRRXTypeDef->IRH) & (IRH_BIT_CNT_MASK)) >> (IRH_BIT_CNT_OFFSET));
    149              format = ((pIRRXTypeDef->IRCFGH) & (IRCFGH_ORDINV_MASK));
    150              if (ucBitNum > 0) {
    151                  (*pucBitNum) = (ucBitNum - 1); // last terminated bit is non-valid
    152                  (*pu4DW0) = (pIRRXTypeDef->IRM);
    153                  (*pu4DW1) = (pIRRXTypeDef->IRL);
    154              } else {
    155                  (*pucBitNum) = ucBitNum;
    156              }
    157              if (format == HAL_IRRX_RC5_RECEIVE_FORMAT_BIT_REVERSE){
    158                 if (*pucBitNum < 32){
    159                  (*pu4DW0) = (pIRRXTypeDef->IRM) & ~ (IRM_DATA_MASK << (*pucBitNum + 7));
    160                  } else {
    161                  (*pu4DW1) = (pIRRXTypeDef->IRL) & ~ (IRM_DATA_MASK << (*pucBitNum +7));
    162                   }
    163                }
    164              halIrRxReset();
    165          }
    166          
    167          
    168          VOID halIrRxPWDRead(PUINT8 pucPWNum, PUINT8 pucPWBuf, UINT8 ucBufLen)
    169          {
    170              P_IOT_IRRX_TypeDef pIRRXTypeDef = (P_IOT_IRRX_TypeDef)(CM4_IRDA_RX_BASE + 0x00);
    171              UINT8   ucNum = 0;
    172              UINT32  u4RegVal = 0;
    173              UINT32  u4RegAddr = (UINT32)(&(pIRRXTypeDef->CHK_DATA0));
    174          
    175              do {
    176                  u4RegVal = HAL_REG_32(u4RegAddr);
    177                  if ((0xFF != (u4RegVal & 0xFF)) && (0x00 != (u4RegVal & 0xFF))) {
    178                      pucPWBuf[ucNum] = (u4RegVal & 0xFF);
    179                      //printf("0x%02X\n", pucPWBuf[ucNum]);
    180                      ucNum++;
    181                  } else {
    182                      break;
    183                  }
    184          
    185                  if ((0xFF != ((u4RegVal >> 8) & 0xFF)) && (0x00 != ((u4RegVal >> 8) & 0xFF))) {
    186                      pucPWBuf[ucNum] = ((u4RegVal >> 8) & 0xFF);
    187                      //printf("0x%02X\n", pucPWBuf[ucNum]);
    188                      ucNum++;
    189                  } else {
    190                      break;
    191                  }
    192          
    193                  if ((0xFF != ((u4RegVal >> 16) & 0xFF)) && (0x00 != ((u4RegVal >> 16) & 0xFF))) {
    194                      pucPWBuf[ucNum] = ((u4RegVal >> 16) & 0xFF);
    195                      //printf("0x%02X\n", pucPWBuf[ucNum]);
    196                      ucNum++;
    197                  } else {
    198                      break;
    199                  }
    200          
    201                  if ((0xFF != ((u4RegVal >> 24) & 0xFF)) && (0x00 != ((u4RegVal >> 24) & 0xFF))) {
    202                      pucPWBuf[ucNum] = ((u4RegVal >> 24) & 0xFF);
    203                      //printf("0x%02X\n", pucPWBuf[ucNum]);
    204                      ucNum++;
    205                  } else {
    206                      break;
    207                  }
    208          
    209                  u4RegAddr = u4RegAddr + 4;
    210              } while (1);
    211          
    212              (*pucPWNum) = ucNum;
    213          
    214              halIrRxReset();
    215          }
    216          
    217          
    218          VOID halIrRxReset(void)
    219          {
    220              P_IOT_IRRX_TypeDef pIRRXTypeDef = (P_IOT_IRRX_TypeDef)(CM4_IRDA_RX_BASE + 0x00);
    221          
    222              // Reset IRRX (All the states are cleared)
    223              // W   IRRX_BASE + 0x18    [0] IRCLR   1'b1
    224              (pIRRXTypeDef->IRCLR) |= BIT(IRCLR_OFFSET);
    225          }
    226          
    227          ENUM_HAL_RET_T halIrRxRC5(UINT8 ucInverse, UINT8 ucBitReverse, UINT8 ucIgnoreEmpty, UINT16 u2SamplePeriod)
    228          {
    229              // IR RX Sequence for RC-5
    230              P_IOT_IRRX_TypeDef pIRRXTypeDef = (P_IOT_IRRX_TypeDef)(CM4_IRDA_RX_BASE + 0x00);
    231              UINT32 u4Val = 0;
    232              UINT32 u4DeGlitchCnt = 0x1F;
    233              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    234          
    235              // Set IRCFGH  W   IRRX_BASE + 0x0C
    236              u4Val = (pIRRXTypeDef->IRCFGH);
    237          
    238              // [0] IREN    1'b1    Enable IRRX module
    239              u4Val |= BIT(IRCFGH_IREN_OFFSET);
    240          
    241              // [1] IRINV   1'b0    Disable IR inverse
    242              if (0 == ucInverse) {
    243                  u4Val &= (~BIT(IRCFGH_IRINV_OFFSET));
    244              } else {
    245                  u4Val |= (BIT(IRCFGH_IRINV_OFFSET));
    246              }
    247          
    248              // [4] ORDINV  USER_DEFINED    Set the order within each byte
    249              // 0: Keep the order of decoded bit
    250              // 1: Inverse the order of decoded bit
    251              if (0 == ucBitReverse) {
    252                  u4Val &= (~BIT(IRCFGH_ORDINV_OFFSET));
    253              } else {
    254                  u4Val |= (BIT(IRCFGH_ORDINV_OFFSET));
    255              }
    256          
    257              // [7:6]   DISL/DISH   2'b00   Disable DISL/DISH
    258              u4Val &= (~BIT(IRCFGH_DISL_OFFSET));
    259              u4Val &= (~BIT(IRCFGH_DISH_OFFSET));
    260          
    261              // [13]    CHK_EN  1'b0    Disable Pulse-Width Detection
    262              u4Val &= (~BIT(IRCFGH_CHK_EN_OFFSET));
    263          
    264              // [14]    IGB0    1'b0    Disable ignore bit 0
    265              if (0 == ucIgnoreEmpty) {
    266                  u4Val &= (~BIT(IRCFGH_IGB0_OFFSET));
    267              } else {
    268                  u4Val |= (BIT(IRCFGH_IGB0_OFFSET));
    269              }
    270          
    271              // [23:16] OK_PERIOD   7'd3    Set END pattern length to 3 for RC-5
    272              u4Val &= (~IRCFGH_OK_PERIOD_MASK);
    273              u4Val |= (IRRX_RC5_DEFAULT_OK_PERIOD << IRCFGH_OK_PERIOD_OFFSET);
    274          
    275              (pIRRXTypeDef->IRCFGH) = u4Val;
    276          
    277          
    278              // Set IRCFGL	W	IRRX_BASE + 0x10
    279              // [11:0]	SA_PERIOD	12'h640	Set Sampling Period (800us for RC-5)
    280              (pIRRXTypeDef->IRCFGL) &= (~IRCFGL_SAPERIOD_MASK);
    281              (pIRRXTypeDef->IRCFGL) |= (u2SamplePeriod << IRCFGL_SAPERIOD_OFFSET);
    282          
    283              // Set IRTHD	W	IRRX_BASE + 0x14
    284              // [7]	INTCLR_IRCLR	USER_DEFINED	Whether to clear IRRX along with interrupt
    285              (pIRRXTypeDef->IRTHD) &= (~BIT(IRTHD_INTCLR_IRCLR_OFFSET));
    286          
    287              // [12:8]	DG_SEL	USER_DEFINED	Set the de-glitch counter
    288              (pIRRXTypeDef->IRTHD) &= (~IRTHD_DG_SEL_MASK);
    289              (pIRRXTypeDef->IRTHD) |= (u4DeGlitchCnt << IRTHD_DG_SEL_OFFSET);
    290          
    291          
    292              // Reset IRRX	W	IRRX_BASE + 0x18
    293              // [0]	IRCLR	1'b1	Reset IRRX
    294              (pIRRXTypeDef->IRCLR) |= BIT(IRCLR_OFFSET);
    295          
    296              return ret;
    297          }
    298          
    299          
    300          /*
    301              (u4TherminateThresholdUs / u4DetectPrecesionUs) <= 0xFF (8bit)
    302          */
    303          
    304          ENUM_HAL_RET_T halIrRxPulseWidthDetect(
    305              UINT32  u4DeGlitchCnt,
    306              UINT8   ucInverse,
    307              UINT32  u4TherminateThresholdUs,
    308              UINT32  *pu4DetectPrecesionUs
    309          )
    310          {
    311              // IR RX Sequence for Pulse-Width Detection Mode
    312              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    313              P_IOT_IRRX_TypeDef pIRRXTypeDef = (P_IOT_IRRX_TypeDef)(CM4_IRDA_RX_BASE + 0x00);
    314              UINT32  u4Val = 0;
    315              UINT32  u4OKPeriod = 0;
    316              UINT32  u4SAPeriod = 0;
    317              UINT32  u4ChkPeriod = 0;
    318          //    UINT8   ucFixSAPeriod = 0;
    319          
    320              /*
    321                  CR: OK_PERIOD, SA_PERIOD, CHK_PERIOD
    322          
    323                  SA_us * OK_Period = threshold_us
    324                  (SA_Period * OPER_time_uint_us) = threshold_us / OK_Period
    325                  (SA_Period * (1,000,000 / OPER_Freq_Hz)) = threshold_us / OK_Period
    326                  SA_Period = (threshold_us / OK_Period) * (OPER_Freq_KHz / 1,000)
    327                  --> SA_Period = (threshold_us * OPER_Freq_KHz) / (OK_Period * 1,000)
    328                  (OK_Period * 1,000) = (threshold_us * OPER_Freq_KHz) / SA_Period
    329                  --> OK_Period = (threshold_us * OPER_Freq_KHz) / (SA_Period * 1000)
    330              */
    331              /*
    332                  DectectPrecision_us = (CHK_Period * BUS_Period)
    333                  DectectPrecision_us = (CHK_Period * (1,000 / BUS_FREQ_KHZ))
    334                  CHK_Period = DectectPrecision_us * (BUS_FREQ_KHZ / 1000);
    335          
    336              */
    337              /*
    338                  threshold_us = DectectPrecision_us * 255 // 8bits=255
    339                  threshold_us = (CHK_Period * BUS_Period) * 255
    340                  OK_Period = (threshold_us * OPER_Freq_KHz) / (SA_Period * 1000)
    341                  --> OK_Period = (((CHK_Period * BUS_Period) * 255) * OPER_Freq_KHz) / (SA_Period * 1000)
    342                  (((CHK_Period * BUS_Period) * 255) * OPER_Freq_KHz) = (OK_Period * (SA_Period * 1000))
    343                  (CHK_Period * BUS_Period) = (OK_Period * (SA_Period * 1000)) / (255 * OPER_Freq_KHz)
    344                  CHK_Period = (OK_Period * (SA_Period * 1000)) / ((255 * OPER_Freq_KHz) * BUS_Period_us)
    345                  CHK_Period = (OK_Period * (SA_Period * 1000)) / ((255 * OPER_Freq_KHz) * (1,000 / BUS_FREQ_KHz))
    346                  CHK_Period = (OK_Period * (SA_Period * 1000) * BUS_Period_KHz) / ((255 * OPER_Freq_KHz) * 1,000 )
    347                  --> CHK_Period = (OK_Period * (SA_Period ) * BUS_FREQ_KHz) / ((255 * OPER_Freq_KHz))
    348          
    349              */
    350          
    351              u4OKPeriod = IRRX_PWD_OK_PERIOD;
    352              do {
    353                  u4SAPeriod = ((u4TherminateThresholdUs * IRRX_OPER_FREQ) / (u4OKPeriod * 1000));
    354                  if (0 != (u4SAPeriod & 0xFFFFF000)) {
    355                      // Saturate
    356                      // 11  0   SAPERIOD    RW  12'hfff
    357                      printf("[Saturate]u4SAPeriod = 0x%08X\n", u4SAPeriod);
    358                      u4OKPeriod = (u4OKPeriod << 1);
    359                      continue;
    360                  }
    361          
    362                  u4ChkPeriod = (u4OKPeriod * u4SAPeriod * IRRX_BUS_FREQ) / (0xFF * IRRX_OPER_FREQ);
    363                  if (0 != (u4ChkPeriod & 0xFFFF0000)) {
    364                      // Saturate,
    365                      //31  16  CHK_PERIOD  RW  16'hffff
    366                      printf("[Saturate]u4ChkPeriod = 0x%08X\n", u4ChkPeriod);
    367                      return HAL_RET_FAIL;
    368          
    369                  } else {
    370                      break;
    371                  }
    372              } while (1);
    373          
    374          #if 0 // debug 
    375              {
    376                  UINT32  u4CalTherminateThresholdUs = 0;
    377                  UINT32  u4CalPrecesionUs = 0;
    378          
    379                  // threshold_us = (SA_Period * (1,000 / OPER_Freq_KHz)) * OK_Period
    380                  u4CalTherminateThresholdUs = (((u4SAPeriod * u4OKPeriod) * 1000) / IRRX_OPER_FREQ);
    381                  u4CalPrecesionUs = ((u4ChkPeriod * 1000) / IRRX_BUS_FREQ);
    382          
    383                  printf("u4SAPeriod = 0x%08X, u4ChkPeriod = 0x%08X, u4OKPeriod = 0x%08X\n", u4SAPeriod, u4ChkPeriod, u4OKPeriod);
    384                  printf("u4CalTherminateThresholdUs = %u, u4CalPrecesionUs = %u\n", u4CalTherminateThresholdUs, u4CalPrecesionUs);
    385          
    386              }
    387          #endif //#if 1 // debug 
    388          
    389              // Set IRCFGH  W   IRRX_BASE + 0x0C
    390              u4Val = (pIRRXTypeDef->IRCFGH);
    391          
    392              // [0] IREN    1'b1    Enable IRRX module
    393              u4Val |= BIT(IRCFGH_IREN_OFFSET);
    394          
    395              // [1] IRINV   1'b0    Disable IR inverse
    396              if (0 == ucInverse) {
    397                  u4Val &= (~BIT(IRCFGH_IRINV_OFFSET));
    398              } else {
    399                  u4Val |= (BIT(IRCFGH_IRINV_OFFSET));
    400              }
    401          
    402          
    403              // [7:6]   DISL/DISH   2'b00   Disable DISL/DISH
    404              u4Val &= (~BIT(IRCFGH_DISL_OFFSET));
    405              u4Val &= (~BIT(IRCFGH_DISH_OFFSET));
    406          
    407              // [13]    CHK_EN  1'b1    Enable Pulse-Width Detection
    408              u4Val |= (BIT(IRCFGH_CHK_EN_OFFSET));
    409          
    410              // [14]    IGB0    1'b0    Disable ignore bit 0
    411              u4Val &= (~BIT(IRCFGH_IGB0_OFFSET));
    412          
    413              // [23:16] OK_PERIOD   USER_DEFINED    Set END pattern length
    414              u4Val &= (~IRCFGH_OK_PERIOD_MASK);
    415              u4Val |= (u4OKPeriod << IRCFGH_OK_PERIOD_OFFSET);
    416          
    417              (pIRRXTypeDef->IRCFGH) = u4Val;
    418          
    419              // Set IRCFGL	W	IRRX_BASE + 0x10
    420              // [11:0]  SA_PERIOD   USER_DEFINED    Set Sampling Period
    421              // [11:0]	SA_PERIOD	12'h640	Set Sampling Period (800us for RC-5)
    422              (pIRRXTypeDef->IRCFGL) &= (~IRCFGL_SAPERIOD_MASK);
    423              (pIRRXTypeDef->IRCFGL) |= (u4SAPeriod << IRCFGL_SAPERIOD_OFFSET);
    424          
    425              (pIRRXTypeDef->IRCFGL) &= (~IRCFGL_CHK_PERIOD_MASK);
    426              (pIRRXTypeDef->IRCFGL) |= (u4ChkPeriod << IRCFGL_CHK_PERIOD_OFFSET);
    427          
    428          
    429              // Set IRTHD	W	IRRX_BASE + 0x14
    430              // [7]	INTCLR_IRCLR	USER_DEFINED	Whether to clear IRRX along with interrupt
    431              (pIRRXTypeDef->IRTHD) &= (~BIT(IRTHD_INTCLR_IRCLR_OFFSET));
    432          
    433              // [12:8]	DG_SEL	USER_DEFINED	Set the de-glitch counter
    434              (pIRRXTypeDef->IRTHD) &= (~IRTHD_DG_SEL_MASK);
    435              (pIRRXTypeDef->IRTHD) |= (u4DeGlitchCnt << IRTHD_DG_SEL_OFFSET);
    436          
    437          
    438              // Reset IRRX	W	IRRX_BASE + 0x18
    439              // [0]	IRCLR	1'b1	Reset IRRX
    440              (pIRRXTypeDef->IRCLR) |= BIT(IRCLR_OFFSET);
    441          
    442              // DectectPrecision_us = (CHK_Period * BUS_Period)
    443              (*pu4DetectPrecesionUs) = ((u4ChkPeriod * 1000) / IRRX_BUS_FREQ);
    444          
    445              return ret;
    446          }
    447          
    448          /*
    449              (u4TherminateThresholdUs / u4DetectPrecesionUs) <= 0xFF (8bit)
    450          */
    451          
    452          ENUM_HAL_RET_T halIrRxPulseWidthDetect_DVT(
    453              UINT32  u4DeGlitchCnt,
    454              UINT8   ucInverse,
    455              UINT32  u4OKPeriod,
    456              UINT32  u4SAPeriod,
    457              UINT32  u4ChkPeriod,
    458              UINT8   ucLowTerminate,
    459              UINT8   ucHighTerminate
    460          )
    461          {
    462              // IR RX Sequence for Pulse-Width Detection Mode
    463              ENUM_HAL_RET_T ret = HAL_RET_SUCCESS;
    464              P_IOT_IRRX_TypeDef pIRRXTypeDef = (P_IOT_IRRX_TypeDef)(CM4_IRDA_RX_BASE + 0x00);
    465              UINT32  u4Val = 0;
    466          
    467          #if 1 // debug 
    468              {
    469                  UINT32  u4CalTherminateThresholdUs = 0;
    470                  UINT32  u4CalPrecesionUs = 0;
    471          
    472                  // threshold_us = (SA_Period * (1,000 / OPER_Freq_KHz)) * OK_Period
    473                  u4CalTherminateThresholdUs = (((u4SAPeriod * u4OKPeriod) * 1000) / IRRX_OPER_FREQ);
    474                  u4CalPrecesionUs = ((u4ChkPeriod * 1000) / IRRX_BUS_FREQ);
    475          
    476                  printf("u4SAPeriod = 0x%08X, u4ChkPeriod = 0x%08X, u4OKPeriod = 0x%08X\n", u4SAPeriod, u4ChkPeriod, u4OKPeriod);
    477                  printf("u4CalTherminateThresholdUs = %u, u4CalPrecesionUs = %u\n", u4CalTherminateThresholdUs, u4CalPrecesionUs);
    478          
    479              }
    480          #endif //#if 1 // debug 
    481          
    482          
    483              // Set IRCFGH  W   IRRX_BASE + 0x0C
    484              u4Val = (pIRRXTypeDef->IRCFGH);
    485          
    486              // [0] IREN    1'b1    Enable IRRX module
    487              u4Val |= BIT(IRCFGH_IREN_OFFSET);
    488          
    489              // [1] IRINV   1'b0    Disable IR inverse
    490              if (0 == ucInverse) {
    491                  u4Val &= (~BIT(IRCFGH_IRINV_OFFSET));
    492              } else {
    493                  u4Val |= (BIT(IRCFGH_IRINV_OFFSET));
    494              }
    495          
    496              // [7:6]   DISL/DISH   2'b00   Disable DISL/DISH
    497              // [7:6]   DISL/DISH   2'b00   Disable DISL/DISH
    498              if (0 == ucLowTerminate) {
    499                  u4Val |= (BIT(IRCFGH_DISL_OFFSET));
    500              } else {
    501                  u4Val &= (~BIT(IRCFGH_DISL_OFFSET));
    502              }
    503          
    504              if (0 == ucHighTerminate) {
    505                  u4Val |= (BIT(IRCFGH_DISH_OFFSET));
    506              } else {
    507                  u4Val &= (~BIT(IRCFGH_DISH_OFFSET));
    508              }
    509          
    510              // [13]    CHK_EN  1'b1    Enable Pulse-Width Detection
    511              u4Val |= (BIT(IRCFGH_CHK_EN_OFFSET));
    512          
    513              // [14]    IGB0    1'b0    Disable ignore bit 0
    514              u4Val &= (~BIT(IRCFGH_IGB0_OFFSET));
    515          
    516              // [23:16] OK_PERIOD   USER_DEFINED    Set END pattern length
    517              u4Val &= (~IRCFGH_OK_PERIOD_MASK);
    518              u4Val |= (u4OKPeriod << IRCFGH_OK_PERIOD_OFFSET);
    519          
    520              (pIRRXTypeDef->IRCFGH) = u4Val;
    521          
    522              // Set IRCFGL	W	IRRX_BASE + 0x10
    523              // [11:0]  SA_PERIOD   USER_DEFINED    Set Sampling Period
    524              // [11:0]	SA_PERIOD	12'h640	Set Sampling Period (800us for RC-5)
    525              (pIRRXTypeDef->IRCFGL) &= (~IRCFGL_SAPERIOD_MASK);
    526              (pIRRXTypeDef->IRCFGL) |= (u4SAPeriod << IRCFGL_SAPERIOD_OFFSET);
    527          
    528              (pIRRXTypeDef->IRCFGL) &= (~IRCFGL_CHK_PERIOD_MASK);
    529              (pIRRXTypeDef->IRCFGL) |= (u4ChkPeriod << IRCFGL_CHK_PERIOD_OFFSET);
    530          
    531          
    532              // Set IRTHD	W	IRRX_BASE + 0x14
    533              // [7]	INTCLR_IRCLR	USER_DEFINED	Whether to clear IRRX along with interrupt
    534              (pIRRXTypeDef->IRTHD) &= (~BIT(IRTHD_INTCLR_IRCLR_OFFSET));
    535          
    536              // [12:8]	DG_SEL	USER_DEFINED	Set the de-glitch counter
    537              (pIRRXTypeDef->IRTHD) &= (~IRTHD_DG_SEL_MASK);
    538              (pIRRXTypeDef->IRTHD) |= (u4DeGlitchCnt << IRTHD_DG_SEL_OFFSET);
    539          
    540          
    541              // Reset IRRX	W	IRRX_BASE + 0x18
    542              // [0]	IRCLR	1'b1	Reset IRRX
    543              (pIRRXTypeDef->IRCLR) |= BIT(IRCLR_OFFSET);
    544          
    545              return ret;
    546          }
    547          
    548          #endif
    549          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_EnableIRQ
       4   NVIC_SetPriority
       0   halIrRxClearInterrupt
       8   halIrRxIsr
         0   -- Indirect call
         8   -> halIrRxClearInterrupt
      16   halIrRxPWDRead
         0   -> halIrRxReset
      32   halIrRxPulseWidthDetect
        32   -> printf
        32   -> top_xtal_freq_get
      32   halIrRxPulseWidthDetect_DVT
        32   -> printf
        32   -> top_xtal_freq_get
       8   halIrRxRC5
      16   halIrRxRC5Read
         0   -> halIrRxReset
       8   halIrRxRegisterCallback
         8   -> NVIC_EnableIRQ
         8   -> NVIC_SetPriority
         8   -> hal_nvic_register_isr_handler
       0   halIrRxReset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      32  ?_0
      32  ?_1
      64  ?_2
      56  ?_3
      20  NVIC_EnableIRQ
      34  NVIC_SetPriority
      14  halIrRxClearInterrupt
      50  halIrRxIsr
      96  halIrRxPWDRead
     226  halIrRxPulseWidthDetect
     212  halIrRxPulseWidthDetect_DVT
     118  halIrRxRC5
      76  halIrRxRC5Read
      50  halIrRxRegisterCallback
      12  halIrRxReset
      16  s_low_hal_irrx_rc5_callback
          s_low_hal_irrx_pwd_callback

 
    16 bytes in section .bss
 1 144 bytes in section .text
 
 1 144 bytes of CODE memory
    16 bytes of DATA memory

Errors: none
Warnings: none
