###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:47
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\wifi_service\combo\src\init\wifi_init.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EWCA22.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\wifi_service\combo\src\init\wifi_init.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\wifi_init.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\wifi_init.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\MTK\wifi_service\combo\src\init\wifi_init.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          #include "os.h"
     36          #include "wifi_api.h"
     37          #include "wifi_private_api.h"
     38          #include "connsys_driver.h"
     39          #include "wifi_scan.h"
     40          #include "inband_queue.h"
     41          #include "net_task.h"
     42          #include "wifi_init.h"
     43          #include "syslog.h"
     44          #include "nvdm.h"
     45          #include "wifi_profile.h"
     46          #include "get_profile_string.h"
     47          #include "wifi_default_config.h"
     48          #include "wifi_inband.h"
     49          #include "wifi_channel.h"
     50          #include "hal_efuse.h"
     51          
     52          #ifdef MTK_MINISUPP_ENABLE
     53          #include "wpa_supplicant_task.h"
     54          #endif
     55          
     56          #ifdef MTK_CM4_WIFI_TASK_ENABLE
     57          #include "wifi_firmware_task.h"
     58          #endif
     59          
     60          #if (PRODUCT_VERSION == 5932) || (PRODUCT_VERSION == 7682) || (PRODUCT_VERSION == 7686)
     61          uint32_t MACLPSState = 0, MACLPNum = 0;
     62          #endif
     63          
     64          log_create_module(wifi, PRINT_LEVEL_ERROR);
     65          
     66          #if (PRODUCT_VERSION == 7687) || (PRODUCT_VERSION == 7697)
     67          static int32_t wifi_is_mac_address_valid(uint8_t *mac_addr)
     68          {
     69              uint32_t byte_sum = 0;
     70              for (uint32_t index = 0; index < WIFI_MAC_ADDRESS_LENGTH; index++) {
     71                  byte_sum += mac_addr[index];
     72              }
     73              return (byte_sum != 0);
     74          }
     75          #endif
     76          
     77          wifi_phy_mode_t wifi_change_wireless_mode_5g_to_2g(wifi_phy_mode_t wirelessmode)
     78          {
     79              if (WIFI_PHY_11A == wirelessmode) {
     80                  return WIFI_PHY_11B;
     81              } else if (WIFI_PHY_11ABG_MIXED == wirelessmode) {
     82                  return WIFI_PHY_11BG_MIXED;
     83              } else if (WIFI_PHY_11ABGN_MIXED == wirelessmode) {
     84                  return WIFI_PHY_11BGN_MIXED;
     85              } else if (WIFI_PHY_11AN_MIXED == wirelessmode) {
     86                  return WIFI_PHY_11N_2_4G;
     87              } else if (WIFI_PHY_11AGN_MIXED == wirelessmode) {
     88                  return WIFI_PHY_11GN_MIXED;
     89              } else if (WIFI_PHY_11N_5G == wirelessmode) {
     90                  return WIFI_PHY_11N_2_4G;
     91              } else {
     92                  return wirelessmode;
     93              }
     94          }
     95          
     96          /**
     97          * @brief get mac address from efuse
     98          */
     99          static int32_t wifi_get_mac_addr_from_efuse(uint8_t port, uint8_t *mac_addr)
    100          {
    101          #if (PRODUCT_VERSION == 5932) || (PRODUCT_VERSION == 7682) || (PRODUCT_VERSION == 7686)
    102              if (wifi_config_get_mac_from_register(port, mac_addr) < 0) {
    103          #if (PRODUCT_VERSION == 5932)
    104          	  uint8_t tmp_mac[WIFI_MAC_ADDRESS_LENGTH]={0x00, 0x0c, 0x43, 0x76, 0x86, 0x08};
    105          	  tmp_mac[WIFI_MAC_ADDRESS_LENGTH-1] += port; /* STA/AP use different MAC address */
    106          
    107          	  os_memcpy(mac_addr, tmp_mac, WIFI_MAC_ADDRESS_LENGTH);
    108                  LOG_E(wifi, "Get mac from efuse/CR fail! Apply temp MAC addr");
    109                  return 0;
    110          #elif (PRODUCT_VERSION == 7682) || (PRODUCT_VERSION == 7686)
    111                  return -1;
    112          #endif
    113              }
    114          #elif (PRODUCT_VERSION == 7687) || (PRODUCT_VERSION == 7697)
    115              uint8_t buf[16] = {0};//efuse is 16 byte aligned
    116              uint16_t mac_offset = 0x00;//mac addr offset in efuse
    117              if (HAL_EFUSE_OK != hal_efuse_read(mac_offset, buf, sizeof(buf))) {
    118                  return -1;
    119              }
    120              if (!wifi_is_mac_address_valid(buf+4)) {
    121                  LOG_HEXDUMP_W(wifi, "data in efuse is invalid", buf, sizeof(buf));
    122                  return -1;
    123              }
    124              if (WIFI_PORT_STA == port) {
    125                  /* original efuse MAC address for STA */
    126                  os_memcpy(mac_addr, buf+4, WIFI_MAC_ADDRESS_LENGTH);
    127              } else {
    128                  /* original efuse MAC address with byte[5]+1 for AP */
    129                  os_memcpy(mac_addr, buf+4, WIFI_MAC_ADDRESS_LENGTH);
    130                  mac_addr[WIFI_MAC_ADDRESS_LENGTH-1] += 1;
    131              }
    132          #endif
    133              return 0;
    134          }
    135          
    136          
    137          #ifdef MTK_NVDM_ENABLE
    138          /**
    139          * @brief get mac address from nvdm
    140          */
    141          static int32_t wifi_get_mac_addr_from_nvdm(uint8_t port, uint8_t *mac_addr)
    142          {
    143              uint8_t buff[PROFILE_BUF_LEN] = {0};
    144              uint32_t len = sizeof(buff);
    145              char *group_name = (WIFI_PORT_STA == port) ? "STA" : "AP";
    146          
    147              if (NVDM_STATUS_OK != nvdm_read_data_item(group_name, "MacAddr", buff, &len)) {
    148                  return -1;
    149              }
    150          
    151              wifi_conf_get_mac_from_str((char *)mac_addr, (char *)buff);
    152              return 0;
    153          }
    154          #endif
    155          
    156          /**
    157          * @brief Get WiFi Interface MAC Address.
    158          *
    159          */
    160          int32_t wifi_config_get_mac_address(uint8_t port, uint8_t *address)
    161          {
    162              if (NULL == address) {
    163                  LOG_E(wifi, "address is null.");
    164                  return WIFI_ERR_PARA_INVALID;
    165              }
    166          
    167              if (!wifi_is_port_valid(port)) {
    168                  LOG_E(wifi, "port is invalid: %d", port);
    169                  return WIFI_ERR_PARA_INVALID;
    170              }
    171              if (0 == wifi_get_mac_addr_from_efuse(port, address)) {
    172                  return 0;
    173              }
    174          
    175              LOG_W(wifi, "wifi_get_mac_addr_from_efuse fail.");
    176          #ifdef MTK_NVDM_ENABLE
    177              if (0 == wifi_get_mac_addr_from_nvdm(port, address)) {
    178                  return 0;
    179              }
    180              LOG_E(wifi, "wifi_get_mac_addr_from_nvdm fail.");
    181          #endif
    182              return -1;
    183          
    184          }
    185          
    186          uint8_t wifi_get_ps_mode(void)
    187          {
    188          #ifdef MTK_WIFI_PROFILE_ENABLE
    189              uint8_t buff[PROFILE_BUF_LEN];
    190              uint32_t len = sizeof(buff);
    191              nvdm_read_data_item("STA", "PSMode", buff, &len);
    192              return (uint8_t)atoi((char *)buff);
    193          #else
    194              return WIFI_DEFAULT_STA_POWER_SAVE_MODE;
    195          #endif
    196          }
    197          
    198          static void wifi_save_sta_ext_config(sys_cfg_t *syscfg, wifi_config_ext_t *config_ext)
    199          {
    200              if (NULL != config_ext) {
    201                  if (config_ext->sta_wep_key_index_present) {
    202                      syscfg->sta_default_key_id = config_ext->sta_wep_key_index;
    203                  }
    204                  if (config_ext->sta_bandwidth_present) {
    205                      syscfg->sta_bw = config_ext->sta_bandwidth;
    206                  }
    207                  if (config_ext->sta_wireless_mode_present) {
    208                      syscfg->sta_wireless_mode = config_ext->sta_wireless_mode;
    209                  }
    210                  if (config_ext->sta_listen_interval_present) {
    211                      syscfg->sta_listen_interval = config_ext->sta_listen_interval;
    212                  }
    213                  if (config_ext->sta_power_save_mode_present) {
    214                      syscfg->sta_ps_mode = config_ext->sta_power_save_mode;
    215                  }
    216          
    217              }
    218          }
    219          
    220          static void wifi_save_ap_ext_config(sys_cfg_t *syscfg, wifi_config_ext_t *config_ext)
    221          {
    222              if (NULL != config_ext) {
    223                  if (config_ext->ap_wep_key_index_present) {
    224                      syscfg->ap_default_key_id = config_ext->ap_wep_key_index;
    225                  }
    226                  if (config_ext->ap_hidden_ssid_enable_present) {
    227                      syscfg->ap_hide_ssid = config_ext->ap_hidden_ssid_enable;
    228                  }
    229                  if (config_ext->ap_wireless_mode_present) {
    230                      syscfg->ap_wireless_mode = config_ext->ap_wireless_mode;
    231                  }
    232                  if (config_ext->ap_dtim_interval_present) {
    233                      syscfg->ap_dtim_period = config_ext->ap_dtim_interval;
    234                  }
    235              }
    236          }
    237          
    238          static void wifi_apply_sta_config(sys_cfg_t *syscfg, wifi_config_t *config, wifi_config_ext_t *config_ext)
    239          {
    240              os_memcpy(syscfg->sta_ssid, config->sta_config.ssid, WIFI_MAX_LENGTH_OF_SSID);
    241          
    242              syscfg->sta_ssid_len = config->sta_config.ssid_length;
    243          
    244              os_memcpy(syscfg->sta_wpa_psk, config->sta_config.password, WIFI_LENGTH_PASSPHRASE);
    245          
    246              syscfg->sta_wpa_psk_len = config->sta_config.password_length;
    247          
    248              /* save extension config */
    249              wifi_save_sta_ext_config(syscfg, config_ext);
    250          }
    251          
    252          static void wifi_apply_ap_config(sys_cfg_t *syscfg, wifi_config_t *config, wifi_config_ext_t *config_ext)
    253          {
    254              os_memcpy(syscfg->ap_ssid, config->ap_config.ssid, WIFI_MAX_LENGTH_OF_SSID);
    255          
    256              syscfg->ap_ssid_len = config->ap_config.ssid_length;
    257          
    258              os_memcpy(syscfg->ap_wpa_psk, config->ap_config.password, WIFI_LENGTH_PASSPHRASE);
    259          
    260              syscfg->ap_wpa_psk_len = config->ap_config.password_length;
    261          
    262              syscfg->ap_auth_mode = config->ap_config.auth_mode;
    263          
    264              syscfg->ap_encryp_type = config->ap_config.encrypt_type;
    265          
    266              syscfg->ap_channel = config->ap_config.channel;
    267          
    268              syscfg->ap_bw = config->ap_config.bandwidth;
    269          
    270              syscfg->ap_ht_ext_ch = (WIFI_BANDWIDTH_EXT_40MHZ_UP == config->ap_config.bandwidth_ext) ? 1 : 3;
    271          
    272              /* save extension config */
    273              wifi_save_ap_ext_config(syscfg, config_ext);
    274          }
    275          
    276          static void wifi_apply_repeater_config(sys_cfg_t *syscfg, wifi_config_t *config, wifi_config_ext_t *config_ext)
    277          {
    278              wifi_apply_sta_config(syscfg, config, config_ext);
    279              wifi_apply_ap_config(syscfg, config, config_ext);
    280          }
    281          
    282          static void wifi_apply_p2p_config(sys_cfg_t *syscfg, wifi_config_t *config, wifi_config_ext_t *config_ext)
    283          {
    284              /* TBD */
    285          }
    286          
    287          #ifdef MTK_WIFI_PROFILE_ENABLE
    288          static void wifi_get_config_from_nvdm(sys_cfg_t *config)
    289          {
    290              // init wifi profile
    291              uint8_t buff[PROFILE_BUF_LEN];
    292              uint32_t len = sizeof(buff);
    293          
    294              // common
    295              len = sizeof(buff);
    296              nvdm_read_data_item("common", "OpMode", buff, &len);
    297              config->opmode = (uint8_t)atoi((char *)buff);
    298              len = sizeof(buff);
    299              nvdm_read_data_item("common", "CountryRegion", buff, &len);
    300              config->country_region = (uint8_t)atoi((char *)buff);
    301              len = sizeof(buff);
    302              nvdm_read_data_item("common", "CountryRegionABand", buff, &len);
    303              config->country_region_a_band = (uint8_t)atoi((char *)buff);
    304              len = sizeof(buff);
    305              nvdm_read_data_item("common", "CountryCode", buff, &len);
    306              os_memcpy(config->country_code, buff, 4);
    307              wifi_country_code_region_mapping(config->country_code, &(config->country_region), &(config->country_region_a_band));
    308              len = sizeof(buff);
    309              nvdm_read_data_item("common", "RadioOff", buff, &len);
    310              config->radio_off = (uint8_t)atoi((char *)buff);
    311              len = sizeof(buff);
    312              nvdm_read_data_item("common", "RTSThreshold", buff, &len);
    313              config->rts_threshold = (uint16_t)atoi((char *)buff);
    314              len = sizeof(buff);
    315              nvdm_read_data_item("common", "FragThreshold", buff, &len);
    316              config->frag_threshold = (uint16_t)atoi((char *)buff);
    317              len = sizeof(buff);
    318              nvdm_read_data_item("common", "DbgLevel", buff, &len);
    319              config->dbg_level = (uint8_t)atoi((char *)buff);
    320              len = sizeof(buff);
    321              nvdm_read_data_item("common", "IpAddr", buff, &len);
    322              wifi_conf_get_ip_from_str(config->ap_ip_addr, (char *)buff);
    323              wifi_conf_get_ip_from_str(config->sta_ip_addr, (char *)buff);
    324          
    325              // STA
    326              len = sizeof(buff);
    327              nvdm_read_data_item("STA", "LocalAdminMAC", buff, &len);
    328              config->sta_local_admin_mac = (uint8_t)atoi((char *)buff);
    329              len = sizeof(buff);
    330          
    331              //nvdm_read_data_item("STA", "MacAddr", buff, &len);
    332              //wifi_conf_get_mac_from_str((char *)config->sta_mac_addr, (char *)buff);
    333              wifi_config_get_mac_address(WIFI_PORT_STA, config->sta_mac_addr);
    334          
    335              len = sizeof(buff);
    336              nvdm_read_data_item("STA", "SsidLen", buff, &len);
    337              config->sta_ssid_len = (uint8_t)atoi((char *)buff);
    338              len = sizeof(buff);
    339              nvdm_read_data_item("STA", "Ssid", buff, &len);
    340              os_memcpy(config->sta_ssid, buff, config->sta_ssid_len);
    341              len = sizeof(buff);
    342              nvdm_read_data_item("STA", "BssType", buff, &len);
    343              config->sta_bss_type = (uint8_t)atoi((char *)buff);
    344              len = sizeof(buff);
    345              nvdm_read_data_item("STA", "Channel", buff, &len);
    346              config->sta_channel = (uint8_t)atoi((char *)buff);
    347              len = sizeof(buff);
    348              nvdm_read_data_item("STA", "BW", buff, &len);
    349              config->sta_bw = (uint8_t)atoi((char *)buff);
    350              len = sizeof(buff);
    351              nvdm_read_data_item("STA", "WirelessMode", buff, &len);
    352              if (wifi_5g_support() < 0) {
    353                  config->sta_wireless_mode = (uint8_t)wifi_change_wireless_mode_5g_to_2g((wifi_phy_mode_t)atoi((char *)buff));
    354              }else {
    355                  config->sta_wireless_mode = (uint8_t)atoi((char *)buff);
    356              }
    357              len = sizeof(buff);
    358              nvdm_read_data_item("STA", "BADecline", buff, &len);
    359              config->sta_ba_decline = (uint8_t)atoi((char *)buff);
    360              len = sizeof(buff);
    361              nvdm_read_data_item("STA", "AutoBA", buff, &len);
    362              config->sta_auto_ba = (uint8_t)atoi((char *)buff);
    363              len = sizeof(buff);
    364              nvdm_read_data_item("STA", "HT_MCS", buff, &len);
    365              config->sta_ht_mcs = (uint8_t)atoi((char *)buff);
    366              len = sizeof(buff);
    367              nvdm_read_data_item("STA", "HT_BAWinSize", buff, &len);
    368              config->sta_ht_ba_win_size = (uint8_t)atoi((char *)buff);
    369              len = sizeof(buff);
    370              nvdm_read_data_item("STA", "HT_GI", buff, &len);
    371              config->sta_ht_gi = (uint8_t)atoi((char *)buff);
    372              len = sizeof(buff);
    373              nvdm_read_data_item("STA", "HT_PROTECT", buff, &len);
    374              config->sta_ht_protect = (uint8_t)atoi((char *)buff);
    375              len = sizeof(buff);
    376              nvdm_read_data_item("STA", "HT_EXTCHA", buff, &len);
    377              config->sta_ht_ext_ch = (uint8_t)atoi((char *)buff);
    378              len = sizeof(buff);
    379              nvdm_read_data_item("STA", "WmmCapable", buff, &len);
    380              config->sta_wmm_capable = (uint8_t)atoi((char *)buff);
    381              len = sizeof(buff);
    382              nvdm_read_data_item("STA", "ListenInterval", buff, &len);
    383              config->sta_listen_interval = (uint8_t)atoi((char *)buff);
    384              len = sizeof(buff);
    385              nvdm_read_data_item("STA", "AuthMode", buff, &len);
    386              config->sta_auth_mode = (uint8_t)atoi((char *)buff);
    387              len = sizeof(buff);
    388              nvdm_read_data_item("STA", "EncrypType", buff, &len);
    389              config->sta_encryp_type = (uint8_t)atoi((char *)buff);
    390              len = sizeof(buff);
    391              nvdm_read_data_item("STA", "WpaPskLen", buff, &len);
    392              config->sta_wpa_psk_len = (uint8_t)atoi((char *)buff);
    393              len = sizeof(buff);
    394              nvdm_read_data_item("STA", "WpaPsk", buff, &len);
    395              os_memcpy(config->sta_wpa_psk, buff, config->sta_wpa_psk_len);
    396              len = sizeof(buff);
    397              nvdm_read_data_item("STA", "PMK", buff, &len);
    398              os_memcpy(config->sta_pmk, buff, 32); // TODO: How to save binary PMK value not ending by ' ; ' ?
    399              len = sizeof(buff);
    400              nvdm_read_data_item("STA", "PairCipher", buff, &len);
    401              config->sta_pair_cipher = (uint8_t)atoi((char *)buff);
    402              len = sizeof(buff);
    403              nvdm_read_data_item("STA", "GroupCipher", buff, &len);
    404              config->sta_group_cipher = (uint8_t)atoi((char *)buff);
    405              len = sizeof(buff);
    406              nvdm_read_data_item("STA", "DefaultKeyId", buff, &len);
    407              config->sta_default_key_id = (uint8_t)atoi((char *)buff);
    408              len = sizeof(buff);
    409              nvdm_read_data_item("STA", "PSMode", buff, &len);
    410              config->sta_ps_mode = (uint8_t)atoi((char *)buff);
    411              len = sizeof(buff);
    412              nvdm_read_data_item("STA", "KeepAlivePeriod", buff, &len);
    413              config->sta_keep_alive_period = (uint8_t)atoi((char *)buff);
    414              len = sizeof(buff);
    415              nvdm_read_data_item("STA", "BeaconLostTime", buff, &len);
    416              config->beacon_lost_time = (uint8_t)atoi((char *)buff);
    417              len = sizeof(buff);
    418              nvdm_read_data_item("STA", "ApcliBWAutoUpBelow", buff, &len);
    419              config->apcli_40mhz_auto_upbelow = (uint8_t)atoi((char *)buff);
    420          
    421              // AP
    422          #ifdef MTK_WIFI_REPEATER_ENABLE
    423              if (config->opmode == WIFI_MODE_REPEATER) {
    424                  len = sizeof(buff);
    425                  nvdm_read_data_item("STA", "Channel", buff, &len);
    426                  config->ap_channel = (uint8_t)atoi((char *)buff);
    427                  len = sizeof(buff);
    428                  nvdm_read_data_item("STA", "BW", buff, &len);
    429                  config->ap_bw = (uint8_t)atoi((char *)buff);
    430                  len = sizeof(buff);
    431                  nvdm_read_data_item("STA", "WirelessMode", buff, &len);
    432                  config->ap_wireless_mode = (uint8_t)atoi((char *)buff);
    433              } else {
    434          #endif
    435                  /* Use STA MAC/IP as AP MAC/IP for the time being, due to N9 dual interface not ready yet */
    436                  len = sizeof(buff);
    437                  nvdm_read_data_item("AP", "Channel", buff, &len);
    438                  config->ap_channel = (uint8_t)atoi((char *)buff);
    439                  len = sizeof(buff);
    440                  nvdm_read_data_item("AP", "BW", buff, &len);
    441                  config->ap_bw = (uint8_t)atoi((char *)buff);
    442                  len = sizeof(buff);
    443                  nvdm_read_data_item("AP", "WirelessMode", buff, &len);
    444                  if (wifi_5g_support() < 0) {
    445                      config->ap_wireless_mode = (uint8_t)wifi_change_wireless_mode_5g_to_2g((wifi_phy_mode_t)atoi((char *)buff));
    446                  }else {
    447                      config->ap_wireless_mode = (uint8_t)atoi((char *)buff);
    448                  }
    449          #ifdef MTK_WIFI_REPEATER_ENABLE
    450              }
    451          #endif /* MTK_WIFI_REPEATER_ENABLE */
    452              len = sizeof(buff);
    453              nvdm_read_data_item("AP", "LocalAdminMAC", buff, &len);
    454              config->ap_local_admin_mac = (uint8_t)atoi((char *)buff);
    455              len = sizeof(buff);
    456          
    457              //nvdm_read_data_item("AP", "MacAddr", buff, &len);
    458              //wifi_conf_get_mac_from_str((char *)config->ap_mac_addr, (char *)buff);
    459              wifi_config_get_mac_address(WIFI_PORT_AP, config->ap_mac_addr);
    460          
    461              len = sizeof(buff);
    462              nvdm_read_data_item("AP", "SsidLen", buff, &len);
    463              config->ap_ssid_len = (uint8_t)atoi((char *)buff);
    464              len = sizeof(buff);
    465              nvdm_read_data_item("AP", "Ssid", buff, &len);
    466              os_memcpy(config->ap_ssid, buff, config->ap_ssid_len);
    467              len = sizeof(buff);
    468              nvdm_read_data_item("AP", "AutoBA", buff, &len);
    469              config->ap_auto_ba = (uint8_t)atoi((char *)buff);
    470              len = sizeof(buff);
    471              nvdm_read_data_item("AP", "HT_MCS", buff, &len);
    472              config->ap_ht_mcs = (uint8_t)atoi((char *)buff);
    473              len = sizeof(buff);
    474              nvdm_read_data_item("AP", "HT_BAWinSize", buff, &len);
    475              config->ap_ht_ba_win_size = (uint8_t)atoi((char *)buff);
    476              len = sizeof(buff);
    477              nvdm_read_data_item("AP", "HT_GI", buff, &len);
    478              config->ap_ht_gi = (uint8_t)atoi((char *)buff);
    479              len = sizeof(buff);
    480              nvdm_read_data_item("AP", "HT_PROTECT", buff, &len);
    481              config->ap_ht_protect = (uint8_t)atoi((char *)buff);
    482              len = sizeof(buff);
    483              nvdm_read_data_item("AP", "HT_EXTCHA", buff, &len);
    484              config->ap_ht_ext_ch = (uint8_t)atoi((char *)buff);
    485              len = sizeof(buff);
    486              nvdm_read_data_item("AP", "WmmCapable", buff, &len);
    487              config->ap_wmm_capable = (uint8_t)atoi((char *)buff);
    488              len = sizeof(buff);
    489              nvdm_read_data_item("AP", "DtimPeriod", buff, &len);
    490              config->ap_dtim_period = (uint8_t)atoi((char *)buff);
    491              len = sizeof(buff);
    492              nvdm_read_data_item("AP", "HideSSID", buff, &len);
    493              config->ap_hide_ssid = (uint8_t)atoi((char *)buff);
    494              len = sizeof(buff);
    495              nvdm_read_data_item("AP", "AutoChannelSelect", buff, &len);
    496              config->ap_auto_channel_select = (uint8_t)atoi((char *)buff);
    497              len = sizeof(buff);
    498              nvdm_read_data_item("AP", "AuthMode", buff, &len);
    499              config->ap_auth_mode = (uint8_t)atoi((char *)buff);
    500              len = sizeof(buff);
    501              nvdm_read_data_item("AP", "EncrypType", buff, &len);
    502              config->ap_encryp_type = (uint8_t)atoi((char *)buff);
    503              len = sizeof(buff);
    504              nvdm_read_data_item("AP", "WpaPskLen", buff, &len);
    505              config->ap_wpa_psk_len = (uint8_t)atoi((char *)buff);
    506              len = sizeof(buff);
    507              nvdm_read_data_item("AP", "WpaPsk", buff, &len);
    508              os_memcpy(config->ap_wpa_psk, buff, config->ap_wpa_psk_len);
    509              len = sizeof(buff);
    510              nvdm_read_data_item("AP", "PMK", buff, &len);
    511              os_memcpy(config->ap_pmk, buff, 32); // TODO: How to save binary PMK value not ending by ' ; ' ?
    512              len = sizeof(buff);
    513              nvdm_read_data_item("AP", "PairCipher", buff, &len);
    514              config->ap_pair_cipher = (uint8_t)atoi((char *)buff);
    515              len = sizeof(buff);
    516              nvdm_read_data_item("AP", "GroupCipher", buff, &len);
    517              config->ap_group_cipher = (uint8_t)atoi((char *)buff);
    518              len = sizeof(buff);
    519              nvdm_read_data_item("AP", "DefaultKeyId", buff, &len);
    520              config->ap_default_key_id = (uint8_t)atoi((char *)buff);
    521              len = sizeof(buff);
    522              nvdm_read_data_item("AP", "BcnDisEn", buff, &len);
    523              config->ap_beacon_disable = (uint8_t)atoi((char *)buff);
    524          
    525              // scan channel table and regulatory table
    526              len = sizeof(buff);
    527              nvdm_read_data_item("common", "BGChannelTable", buff, &len);
    528              config->bg_band_entry_num = wifi_conf_get_ch_table_from_str(config->bg_band_triple, 10, (char *)buff, os_strlen((char *)buff));
    529          
    530              len = sizeof(buff);
    531              nvdm_read_data_item("common", "AChannelTable", buff, &len);
    532              config->a_band_entry_num = wifi_conf_get_ch_table_from_str(config->a_band_triple, 10, (char *)buff, os_strlen((char *)buff));
    533          
    534              config->forwarding_zero_copy = 1;
    535          
    536          #ifdef MTK_WIFI_CONFIGURE_FREE_ENABLE
    537              /* These are for MBSS support, but not exist trunk (it's customer feature), however,
    538                      we have to add them here due to N9 FW has them (only one version of N9 FW)
    539                   */
    540              // TODO: How to solve it in the future...Michael
    541              config->mbss_enable = 0;
    542              os_memset(config->mbss_ssid1, 0x0, sizeof(config->mbss_ssid1));;
    543              config->mbss_ssid_len1 = 0;
    544              os_memset(config->mbss_ssid2, 0x0, sizeof(config->mbss_ssid2));;
    545              config->mbss_ssid_len2 = 0;
    546          
    547              len = sizeof(buff);
    548              nvdm_read_data_item("common", "ConfigFree_Ready", buff, &len);
    549              config->config_free_ready = (uint8_t)atoi((char *)buff);
    550              len = sizeof(buff);
    551              nvdm_read_data_item("common", "ConfigFree_Enable", buff, &len);
    552              config->config_free_enable = (uint8_t)atoi((char *)buff);
    553          #endif /* MTK_WIFI_CONFIGURE_FREE_ENABLE */
    554              len = sizeof(buff);
    555              nvdm_read_data_item("common", "StaFastLink", buff, &len);
    556              config->sta_fast_link = (uint8_t)atoi((char *)buff);
    557          
    558          #ifdef MTK_WIFI_PRIVILEGE_ENABLE
    559              len = sizeof(buff);
    560              nvdm_read_data_item("common", "WiFiPrivilegeEnable", buff, &len);
    561              config->wifi_privilege_enable = (uint8_t)atoi((char *)buff);
    562          #else
    563              config->wifi_privilege_enable = 0;
    564          #endif
    565          }
    566          #endif
    567          static void wifi_apply_user_config(sys_cfg_t *syscfg, wifi_config_t *config, wifi_config_ext_t *config_ext)
    568          {
    569              syscfg->opmode = config->opmode;
    570              if ( config_ext!= NULL && config_ext->country_code_present) {
    571                  os_memcpy(syscfg->country_code, config_ext->country_code, 4);
    572                  wifi_country_code_region_mapping(syscfg->country_code, &(syscfg->country_region), &(syscfg->country_region_a_band));
    573              }
    574              if (WIFI_MODE_STA_ONLY == syscfg->opmode) {
    575                  wifi_apply_sta_config(syscfg, config, config_ext);
    576              } else if (WIFI_MODE_AP_ONLY == syscfg->opmode) {
    577                  wifi_apply_ap_config(syscfg, config, config_ext);
    578              } else if (WIFI_MODE_REPEATER == syscfg->opmode) {
    579                  wifi_apply_repeater_config(syscfg, config, config_ext);
    580              } else if (WIFI_MODE_P2P_ONLY == syscfg->opmode) {
    581                  wifi_apply_p2p_config(syscfg, config, config_ext);
    582              } else {
    583                  /* no configuration is required for Monitor Mode */
    584              }
    585          }
    586          
    587          /**
    588          * @brief build the whole configurations
    589          */
    590          static int32_t wifi_build_whole_config(sys_cfg_t *syscfg, wifi_config_t *config, wifi_config_ext_t *config_ext)
    591          {
    592          #ifdef MTK_WIFI_PROFILE_ENABLE
    593              wifi_get_config_from_nvdm(syscfg);
    594          #else
    595              if (0 != wifi_get_default_config(syscfg)) {
    596                  return -1;
    597              }
    598          #endif
    599              wifi_apply_user_config(syscfg, config, config_ext);
    600              return 0;
    601          }
    602          
    603          
    604          void wifi_sys_cfg_init(sys_cfg_t *config)
    605          {
    606               wifi_config_t *user_config = NULL;
    607               wifi_config_ext_t *user_config_ext = NULL;
    608          #ifdef MTK_WIFI_PROFILE_ENABLE
    609              wifi_get_config_from_nvdm(config);
    610          #else
    611              wifi_get_default_config(config);
    612          #endif
    613          
    614          #ifdef MTK_CM4_WIFI_TASK_ENABLE
    615              fw_get_user_config(&user_config,&user_config_ext); 
    616          #endif
    617              wifi_apply_user_config(config, user_config, user_config_ext); 
    618          }
    619          
    620          
    621          void wifi_init(wifi_config_t *config, wifi_config_ext_t *config_ext)
    622          {
    623              sys_cfg_t syscfg = {0};
    624          
    625              if (NULL == config) {
    626                  LOG_E(wifi, "config is null.");
    627                  return;
    628              }
    629          
    630              if (0 != wifi_build_whole_config(&syscfg, config, config_ext)) {
    631                  LOG_E(wifi, "wifi_build_whole_config fail. initial aborted!");
    632                  return;
    633              }
    634          
    635              wifi_channel_list_init(&syscfg);
    636          #if defined(MTK_WIFI_ROM_ENABLE) && !defined(MTK_WIFI_SLIM_ENABLE)
    637              connsys_set_wifi_profile(&syscfg);
    638              // connsys_init(); /* moved to  system_init() for early N9 FW download */
    639          #else
    640              connsys_init(&syscfg);
    641          #endif
    642          
    643              wifi_scan_init(config);
    644              inband_queue_init();
    645              NetTaskInit();
    646          
    647             /*Fix if SSID length = 0, switch to repeater mode from station mode, N9 will assert*/
    648              if(config->ap_config.ssid_length == 0) {
    649                  config->ap_config.ssid_length = syscfg.ap_ssid_len;
    650                  os_memcpy(config->ap_config.ssid, syscfg.ap_ssid, WIFI_MAX_LENGTH_OF_SSID);
    651              } else if(config->sta_config.ssid_length == 0) {
    652                  config->sta_config.ssid_length = syscfg.sta_ssid_len;
    653                  os_memcpy(config->sta_config.ssid, syscfg.sta_ssid, WIFI_MAX_LENGTH_OF_SSID);
    654              }
    655          #ifdef MTK_MINISUPP_ENABLE
    656              wpa_supplicant_task_init(config, config_ext);
    657          #endif
    658          #ifdef MTK_CM4_WIFI_TASK_ENABLE
    659              wifi_firmware_init(config, config_ext);
    660              if (wifi_firmware_task_start(config) != 0) {
    661                  LOG_E(wifi, "failed to start firmware Wi-Fi task");
    662              }
    663          #endif
    664          }
    665          
    666          
    667          static bool wifi_security_valid = false;
    668          bool wifi_get_security_valid(void)
    669          {
    670              return wifi_security_valid;
    671          }
    672          
    673          void wifi_set_security_valid(bool value)
    674          {
    675              wifi_security_valid = value;
    676              return;
    677          }
    678          
    679          /***************** Just for internal use **********************/
    680          #include "hal_sleep_manager.h"
    681          #ifdef HAL_SLEEP_MANAGER_ENABLED
    682          #define WIFI_MAX_SLEEP_HANDLE  32   // This define value should equal to MAX_SLEEP_HANDLE in hal_sleep_driver.h
    683          uint8_t locks[WIFI_MAX_SLEEP_HANDLE];
    684          #endif
    685          uint8_t wifi_set_sleep_handle(const char *handle_name)
    686          {
    687          #ifdef HAL_SLEEP_MANAGER_ENABLED
    688              return hal_sleep_manager_set_sleep_handle(handle_name);
    689          #else
    690              return 0xff;
    691          #endif
    692          }
    693          
    694          int32_t wifi_lock_sleep(uint8_t handle_index)
    695          {
    696          #ifdef HAL_SLEEP_MANAGER_ENABLED
    697              locks[handle_index] = 1;
    698              return hal_sleep_manager_lock_sleep(handle_index);
    699          #else
    700              return -1;
    701          #endif
    702          }
    703          
    704          int32_t wifi_unlock_sleep(uint8_t handle_index)
    705          {
    706          #ifdef HAL_SLEEP_MANAGER_ENABLED
    707              locks[handle_index] = 0;
    708              return hal_sleep_manager_unlock_sleep(handle_index);
    709          #else
    710              return -1;
    711          #endif
    712          }
    713          
    714          int32_t wifi_unlock_sleep_all(void)
    715          {
    716          #ifdef HAL_SLEEP_MANAGER_ENABLED
    717              int i = 0;
    718              for (i = 0; i < WIFI_MAX_SLEEP_HANDLE; i++) {
    719                  if (locks[i] == 1) {
    720                      hal_sleep_manager_unlock_sleep(i);
    721                  }
    722              }
    723              return 0;
    724          #else
    725              return -1;
    726          #endif
    727          }
    728          
    729          int32_t wifi_sleep_manager_get_lock_status(void)
    730          {
    731          #ifdef HAL_SLEEP_MANAGER_ENABLED
    732              return hal_sleep_manager_get_lock_status();
    733          #else
    734              return -1;
    735          #endif
    736          }
    737          
    738          int32_t wifi_release_sleep_handle(uint8_t handle)
    739          {
    740          #ifdef HAL_SLEEP_MANAGER_ENABLED
    741              return hal_sleep_manager_release_sleep_handle(handle);
    742          #else
    743              return -1;
    744          #endif
    745          }
    746          
    747          int32_t wifi_get_pmk_by_ssid_psk_from_pmkinfo(uint8_t *pmk,uint8_t *ssid,uint8_t ssid_len, uint8_t *psk,uint8_t psk_len)
    748          {
    749          #ifdef MTK_NVDM_ENABLE
    750          //if ((0 != ssid->auth_mode) && ((0 != ssid->encr_type) || (1 != ssid->encr_type))) {
    751              uint8_t pmk_info[WIFI_MAX_LENGTH_OF_SSID+WIFI_LENGTH_PASSPHRASE+32] = {0};
    752              uint8_t pmk_info_zero[WIFI_MAX_LENGTH_OF_SSID+WIFI_LENGTH_PASSPHRASE+32] = {0};
    753              uint32_t pmk_info_len = sizeof(pmk_info);
    754              nvdm_read_data_item(WIFI_PROFILE_BUFFER_STA, "PMK_INFO",
    755                                 (uint8_t *)pmk_info, &pmk_info_len);
    756              //hex_dump("pmk_info", pmk_info, 128);
    757              if ((0 == os_memcmp(pmk_info, ssid, ssid_len)) &&
    758                  (0 == os_memcmp(pmk_info+WIFI_MAX_LENGTH_OF_SSID, psk, psk_len)) &&
    759                  (0 == os_memcmp(pmk_info+ssid_len, pmk_info_zero, WIFI_MAX_LENGTH_OF_SSID - ssid_len)) &&
    760                  (0 == os_memcmp(pmk_info+WIFI_MAX_LENGTH_OF_SSID+psk_len, pmk_info_zero, WIFI_LENGTH_PASSPHRASE - psk_len))) {
    761                      os_memcpy(pmk, pmk_info+WIFI_MAX_LENGTH_OF_SSID+WIFI_LENGTH_PASSPHRASE, 32);
    762                      return 0;
    763              } else
    764          #endif
    765              {
    766                  return -1;
    767              }
    768          }
    769          
    770          /***************** Just for internal use **********************/
    771          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   wifi_apply_ap_config
        24   -> os_memcpy
         0   -> wifi_save_ap_ext_config
       0   wifi_apply_p2p_config
      16   wifi_apply_repeater_config
         0   -> wifi_apply_ap_config
        16   -> wifi_apply_sta_config
      16   wifi_apply_sta_config
        16   -> os_memcpy
         0   -> wifi_save_sta_ext_config
      16   wifi_apply_user_config
        16   -> os_memcpy
         0   -> wifi_apply_ap_config
         0   -> wifi_apply_p2p_config
         0   -> wifi_apply_repeater_config
         0   -> wifi_apply_sta_config
        16   -> wifi_country_code_region_mapping
      16   wifi_build_whole_config
        16   -> wifi_apply_user_config
        16   -> wifi_get_config_from_nvdm
       0   wifi_change_wireless_mode_5g_to_2g
      32   wifi_config_get_mac_address
        32   -- Indirect call
        32   -> wifi_get_mac_addr_from_efuse
        32   -> wifi_get_mac_addr_from_nvdm
        32   -> wifi_is_port_valid
     296   wifi_get_config_from_nvdm
       296   -> atoi
       296   -> nvdm_read_data_item
       296   -> os_memcpy
       296   -> os_strlen
       296   -> wifi_5g_support
       296   -> wifi_change_wireless_mode_5g_to_2g
       296   -> wifi_conf_get_ch_table_from_str
       296   -> wifi_conf_get_ip_from_str
       296   -> wifi_config_get_mac_address
       296   -> wifi_country_code_region_mapping
      40   wifi_get_mac_addr_from_efuse
        40   -- Indirect call
        40   -> __aeabi_memclr4
        40   -> hal_efuse_read
        40   -> os_memcpy
        40   -> wifi_is_mac_address_valid
     272   wifi_get_mac_addr_from_nvdm
       272   -> __aeabi_memclr4
       272   -> nvdm_read_data_item
       272   -> wifi_conf_get_mac_from_str
     280   wifi_get_pmk_by_ssid_psk_from_pmkinfo
       280   -> __aeabi_memclr4
       280   -> nvdm_read_data_item
       280   -> os_memcmp
       280   -> os_memcpy
     264   wifi_get_ps_mode
       264   -> atoi
       264   -> nvdm_read_data_item
       0   wifi_get_security_valid
     512   wifi_init
       512   -- Indirect call
       512   -> NetTaskInit
       512   -> __aeabi_memclr4
       512   -> connsys_init
       512   -> inband_queue_init
       512   -> os_memcpy
       512   -> wifi_build_whole_config
       512   -> wifi_channel_list_init
       512   -> wifi_scan_init
       512   -> wpa_supplicant_task_init
       0   wifi_is_mac_address_valid
       0   wifi_lock_sleep
         0   -> hal_sleep_manager_lock_sleep
       0   wifi_release_sleep_handle
         0   -> hal_sleep_manager_release_sleep_handle
       4   wifi_save_ap_ext_config
       4   wifi_save_sta_ext_config
       0   wifi_set_security_valid
       0   wifi_set_sleep_handle
         0   -> hal_sleep_manager_set_sleep_handle
       0   wifi_sleep_manager_get_lock_status
         0   -> hal_sleep_manager_get_lock_status
       8   wifi_sys_cfg_init
         0   -> wifi_apply_user_config
         8   -> wifi_get_config_from_nvdm
       0   wifi_unlock_sleep
         0   -> hal_sleep_manager_unlock_sleep
       8   wifi_unlock_sleep_all
         8   -> hal_sleep_manager_unlock_sleep


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable70
       4  ??DataTable70_1
       4  ??DataTable71
       4  ??DataTable78
       4  ??DataTable78_1
       4  ??DataTable78_2
       4  ??DataTable78_3
       4  ??DataTable78_4
       8  ?_0
      16  ?_1
      36  ?_10
       8  ?_11
       8  ?_12
       8  ?_13
      16  ?_14
      20  ?_15
      12  ?_16
      12  ?_17
      16  ?_18
      16  ?_19
      28  ?_2
      12  ?_20
       8  ?_21
      16  ?_22
       8  ?_23
       8  ?_24
       8  ?_25
       8  ?_26
       4  ?_27
      16  ?_28
      12  ?_29
     256  ?_3
       8  ?_30
       8  ?_31
      16  ?_32
       8  ?_33
      12  ?_34
      12  ?_35
      12  ?_36
      16  ?_37
      12  ?_38
      12  ?_39
       4  ?_4
      12  ?_40
       8  ?_41
       4  ?_42
      12  ?_43
      12  ?_44
      16  ?_45
      16  ?_46
      16  ?_47
      20  ?_48
      12  ?_49
       4  ?_5
      12  ?_50
      20  ?_51
      12  ?_52
      16  ?_53
      16  ?_54
      12  ?_55
      20  ?_56
     492  ?_57
      16  ?_58
      48  ?_59
       8  ?_6
     128  ?_60
     128  ?_61
      12  ?_62
      20  ?_7
      20  ?_8
      36  ?_9
      32  locks
      16  log_control_block_wifi
      96  wifi_apply_ap_config
       2  wifi_apply_p2p_config
      24  wifi_apply_repeater_config
      60  wifi_apply_sta_config
     122  wifi_apply_user_config
      26  wifi_build_whole_config
      50  wifi_change_wireless_mode_5g_to_2g
     160  wifi_config_get_mac_address
    1974  wifi_get_config_from_nvdm
     120  wifi_get_mac_addr_from_efuse
      70  wifi_get_mac_addr_from_nvdm
     134  wifi_get_pmk_by_ssid_psk_from_pmkinfo
      36  wifi_get_ps_mode
       6  wifi_get_security_valid
     180  wifi_init
      28  wifi_is_mac_address_valid
      10  wifi_lock_sleep
       4  wifi_release_sleep_handle
      76  wifi_save_ap_ext_config
      90  wifi_save_sta_ext_config
       1  wifi_security_valid
       6  wifi_set_security_valid
       4  wifi_set_sleep_handle
       4  wifi_sleep_manager_get_lock_status
      20  wifi_sys_cfg_init
      10  wifi_unlock_sleep
      32  wifi_unlock_sleep_all
      72  -- Other

 
    33 bytes in section .bss
    16 bytes in section .data
 1 044 bytes in section .rodata
 4 232 bytes in section .text
 
 4 232 bytes of CODE  memory
 1 044 bytes of CONST memory
    49 bytes of DATA  memory

Errors: none
Warnings: none
