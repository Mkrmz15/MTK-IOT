###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:27
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\kernel\rtos\FreeRTOS\Source\portable\MemMang\heap_4.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW7E3F.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\kernel\rtos\FreeRTOS\Source\portable\MemMang\heap_4.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\heap_4.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\heap_4.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\kernel\rtos\FreeRTOS\Source\portable\MemMang\heap_4.c
      1          /*
      2              FreeRTOS V8.2.0 - Copyright (C) 2015 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     12          
     13          	***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18          	***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40          	the FAQ page "My application does not run, what could be wrong?".  Have you
     41          	defined configASSERT()?
     42          
     43          	http://www.FreeRTOS.org/support - In return for receiving this top quality
     44          	embedded software for free we request you assist our global community by
     45          	participating in the support forum.
     46          
     47          	http://www.FreeRTOS.org/training - Investing in training allows your team to
     48          	be as productive as possible as early as possible.  Now you can receive
     49          	FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50          	Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /*
     71           * A sample implementation of pvPortMalloc() and vPortFree() that combines
     72           * (coalescences) adjacent memory blocks as they are freed, and in so doing
     73           * limits memory fragmentation.
     74           *
     75           * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the
     76           * memory management pages of http://www.FreeRTOS.org for more information.
     77           */
     78          #include <stdlib.h>
     79          #include <string.h>
     80          
     81          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     82          all the API functions to use the MPU wrappers.  That should only be done when
     83          task.h is included from an application file. */
     84          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     85          
     86          #include "FreeRTOS.h"
     87          #include "task.h"
     88          
     89          #include "hal_cache.h"
     90          
     91          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     92          
     93          /* Block sizes must not get too small. */
     94          #define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( xHeapStructSize * 2 ) )
     95          
     96          /* Assumes 8bit bytes! */
     97          #define heapBITS_PER_BYTE		( ( size_t ) 8 )
     98          
     99          /* Allocate the memory for the heap. */
    100          #if( configAPPLICATION_ALLOCATED_HEAP == 1 )
    101          	/* The application writer has already defined the array used for the RTOS
    102          	heap - probably so it can be placed in a special segment or address. */
    103          	extern uint8_t ucHeap[ 0 ];
    104          #else
    105          	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ] ;
    106          #endif /* configAPPLICATION_ALLOCATED_HEAP */
    107          
    108          /* Define the linked list structure.  This is used to link free blocks in order
    109          of their memory address. */
    110          typedef struct A_BLOCK_LINK
    111          {
    112          	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
    113          	size_t xBlockSize;						/*<< The size of the free block. */
    114          #ifdef MTK_SUPPORT_HEAP_DEBUG
    115          	uint32_t xLinkRegAddr;
    116          #endif /* MTK_SUPPORT_HEAP_DEBUG */
    117          } BlockLink_t;
    118          
    119          /*-----------------------------------------------------------*/
    120          
    121          /*
    122           * Inserts a block of memory that is being freed into the correct position in
    123           * the list of free memory blocks.  The block being freed will be merged with
    124           * the block in front it and/or the block behind it if the memory blocks are
    125           * adjacent to each other.
    126           */
    127          static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
    128          
    129          /*
    130           * Called automatically to setup the required heap structures the first time
    131           * pvPortMalloc() is called.
    132           */
    133          static void prvHeapInit( void );
    134          
    135          /*-----------------------------------------------------------*/
    136          
    137          /* The size of the structure placed at the beginning of each allocated memory
    138          block must by correctly byte aligned. */
    139          static const size_t xHeapStructSize	= ( ( sizeof( BlockLink_t ) + ( portBYTE_ALIGNMENT - 1 ) ) & ~portBYTE_ALIGNMENT_MASK );
    140          
    141          /* Create a couple of list links to mark the start and end of the list. */
    142          static BlockLink_t xStart, *pxEnd = NULL;
    143          
    144          /* Keeps track of the number of free bytes remaining, but says nothing about
    145          fragmentation. */
    146          static size_t xFreeBytesRemaining = 0U;
    147          static size_t xMinimumEverFreeBytesRemaining = 0U;
    148          
    149          /* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize
    150          member of an BlockLink_t structure is set then the block belongs to the
    151          application.  When the bit is free the block is still part of the free heap
    152          space. */
    153          static size_t xBlockAllocatedBit = 0;
    154          
    155          /*-----------------------------------------------------------*/
    156          
    157          #if defined(MTK_SUPPORT_HEAP_DEBUG) || defined(MTK_HEAP_SIZE_GUARD_ENABLE)
    158          /* record first block of heap for heap walk */
    159          BlockLink_t *pxFirstBlock;
    160          #endif
    161          
    162          void *pvPortMalloc( size_t xWantedSize )
    163          {
    164          BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
    165          void *pvReturn = NULL;
    166          
    167          	#ifdef MTK_SUPPORT_HEAP_DEBUG
    168          	/* Obtain the return address of caller from link register */
    169          	#if defined(__GNUC__) 
    170          	uint32_t xLinkRegAddr = (uint32_t)__builtin_return_address(0);
    171          	#elif defined(__CC_ARM)
    172          	uint32_t xLinkRegAddr = __return_address(); 
    173          	#elif defined(__ICCARM__)
    174          	uint32_t xLinkRegAddr = __get_LR();
    175          	#endif /* __GNUC__ */
    176          	#endif /* MTK_SUPPORT_HEAP_DEBUG */
    177          
    178          	vTaskSuspendAll();
    179          	{
    180          		/* If this is the first call to malloc then the heap will require
    181          		initialisation to setup the list of free blocks. */
    182          		if( pxEnd == NULL )
    183          		{
    184          			prvHeapInit();
    185          		}
    186          		else
    187          		{
    188          			mtCOVERAGE_TEST_MARKER();
    189          		}
    190          
    191          		/* Check the requested block size is not so large that the top bit is
    192          		set.  The top bit of the block size member of the BlockLink_t structure
    193          		is used to determine who owns the block - the application or the
    194          		kernel, so it must be free. */
    195          		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    196          		{
    197          			/* The wanted size is increased so it can contain a BlockLink_t
    198          			structure in addition to the requested amount of bytes. */
    199          			if( xWantedSize > 0 )
    200          			{
    201          				xWantedSize += xHeapStructSize;
    202          
    203          				/* Ensure that blocks are always aligned to the required number
    204          				of bytes. */
    205          				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    206          				{
    207          					/* Byte alignment required. */
    208          					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    209          					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
    210          				}
    211          				else
    212          				{
    213          					mtCOVERAGE_TEST_MARKER();
    214          				}
    215          			}
    216          			else
    217          			{
    218          				mtCOVERAGE_TEST_MARKER();
    219          			}
    220          
    221          			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    222          			{
    223          				/* Traverse the list from the start	(lowest address) block until
    224          				one	of adequate size is found. */
    225          				pxPreviousBlock = &xStart;
    226          				pxBlock = xStart.pxNextFreeBlock;
    227          				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    228          				{
    229          					pxPreviousBlock = pxBlock;
    230          					pxBlock = pxBlock->pxNextFreeBlock;
    231          				}
    232          
    233          				/* If the end marker was reached then a block of adequate size
    234          				was	not found. */
    235          				if( pxBlock != pxEnd )
    236          				{
    237          					/* Return the memory space pointed to - jumping over the
    238          					BlockLink_t structure at its start. */
    239          					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    240          					#ifdef MTK_SUPPORT_HEAP_DEBUG
    241          					pxPreviousBlock->pxNextFreeBlock->xLinkRegAddr = xLinkRegAddr;
    242          					#endif /* MTK_SUPPORT_HEAP_DEBUG */
    243          
    244          					/* This block is being returned for use so must be taken out
    245          					of the list of free blocks. */
    246          					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    247          
    248          					/* If the block is larger than required it can be split into
    249          					two. */
    250          					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    251          					{
    252          						/* This block is to be split into two.  Create a new
    253          						block following the number of bytes requested. The void
    254          						cast is used to prevent byte alignment warnings from the
    255          						compiler. */
    256          						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    257          						configASSERT( ( ( ( uint32_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
    258          
    259          						/* Calculate the sizes of two blocks split from the
    260          						single block. */
    261          						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    262          						pxBlock->xBlockSize = xWantedSize;
    263          
    264          						/* Insert the new block into the list of free blocks. */
    265          						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    266          					}
    267          					else
    268          					{
    269          						mtCOVERAGE_TEST_MARKER();
    270          					}
    271          
    272          					xFreeBytesRemaining -= pxBlock->xBlockSize;
    273          
    274          					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    275          					{
    276          						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    277          					}
    278          					else
    279          					{
    280          						mtCOVERAGE_TEST_MARKER();
    281          					}
    282          
    283          					/* The block is being returned - it is allocated and owned
    284          					by the application and has no "next" block. */
    285          					pxBlock->xBlockSize |= xBlockAllocatedBit;
    286          					pxBlock->pxNextFreeBlock = NULL;
    287          				}
    288          				else
    289          				{
    290          					mtCOVERAGE_TEST_MARKER();
    291          				}
    292          			}
    293          			else
    294          			{
    295          				mtCOVERAGE_TEST_MARKER();
    296          			}
    297          		}
    298          		else
    299          		{
    300          			mtCOVERAGE_TEST_MARKER();
    301          		}
    302          
    303          		traceMALLOC( pvReturn, xWantedSize );
    304          	}
    305          	( void ) xTaskResumeAll();
    306          
    307          	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
    308          	{
    309          		if( pvReturn == NULL )
    310          		{
    311          			extern void vApplicationMallocFailedHook( void );
    312          			vApplicationMallocFailedHook();
    313          		}
    314          		else
    315          		{
    316          			mtCOVERAGE_TEST_MARKER();
    317          		}
    318          	}
    319          	#endif
    320          
    321          	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
    322          	return pvReturn;
    323          }
    324          /*-----------------------------------------------------------*/
    325          
    326          void vPortFree( void *pv )
    327          {
    328          uint8_t *puc = ( uint8_t * ) pv;
    329          BlockLink_t *pxLink;
    330          
    331          	if( pv != NULL )
    332          	{
    333          		/* The memory being freed will have an BlockLink_t structure immediately
    334          		before it. */
    335          		puc -= xHeapStructSize;
    336          
    337          		/* This casting is to keep the compiler from issuing warnings. */
    338          		pxLink = ( void * ) puc;
    339          
    340          		/* Check the block is actually allocated. */
    341          		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
    342          		configASSERT( pxLink->pxNextFreeBlock == NULL );
    343          
    344          		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    345          		{
    346          			if( pxLink->pxNextFreeBlock == NULL )
    347          			{
    348          				/* The block is being returned to the heap - it is no longer
    349          				allocated. */
    350          				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    351          
    352          				vTaskSuspendAll();
    353          				{
    354          					/* Add this block to the list of free blocks. */
    355          					xFreeBytesRemaining += pxLink->xBlockSize;
    356          					traceFREE( pv, pxLink->xBlockSize );
    357          					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    358          				}
    359          				( void ) xTaskResumeAll();
    360          			}
    361          			else
    362          			{
    363          				mtCOVERAGE_TEST_MARKER();
    364          			}
    365          		}
    366          		else
    367          		{
    368          			mtCOVERAGE_TEST_MARKER();
    369          		}
    370          	}
    371          }
    372          /*-----------------------------------------------------------*/
    373          
    374          size_t xPortGetFreeHeapSize( void )
    375          {
    376          	return xFreeBytesRemaining;
    377          }
    378          /*-----------------------------------------------------------*/
    379          
    380          size_t xPortGetMinimumEverFreeHeapSize( void )
    381          {
    382          	return xMinimumEverFreeBytesRemaining;
    383          }
    384          /*-----------------------------------------------------------*/
    385          
    386          void vPortInitialiseBlocks( void )
    387          {
    388          	/* This just exists to keep the linker quiet. */
    389          }
    390          /*-----------------------------------------------------------*/
    391          
    392          static void prvHeapInit( void )
    393          {
    394          BlockLink_t *pxFirstFreeBlock;
    395          uint8_t *pucAlignedHeap;
    396          uint32_t ulAddress;
    397          size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
    398          
    399          	/* Ensure the heap starts on a correctly aligned boundary. */
    400          	ulAddress = ( uint32_t ) ucHeap;
    401          	if( ( ulAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    402          	{
    403          		ulAddress += ( portBYTE_ALIGNMENT - 1 );
    404          		ulAddress &= ~portBYTE_ALIGNMENT_MASK;
    405          		xTotalHeapSize -= ulAddress - ( uint32_t ) ucHeap;
    406          	}
    407          
    408          	pucAlignedHeap = ( uint8_t * ) ulAddress;
    409          
    410          	/* xStart is used to hold a pointer to the first item in the list of free
    411          	blocks.  The void cast is used to prevent compiler warnings. */
    412          	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    413          	xStart.xBlockSize = ( size_t ) 0;
    414          
    415          	/* pxEnd is used to mark the end of the list of free blocks and is inserted
    416          	at the end of the heap space. */
    417          	ulAddress = ( ( uint32_t ) pucAlignedHeap ) + xTotalHeapSize;
    418          	ulAddress -= xHeapStructSize;
    419          	ulAddress &= ~portBYTE_ALIGNMENT_MASK;
    420          	pxEnd = ( void * ) ulAddress;
    421          	pxEnd->xBlockSize = 0;
    422          	pxEnd->pxNextFreeBlock = NULL;
    423          
    424          	/* To start with there is a single free block that is sized to take up the
    425          	entire heap space, minus the space taken by pxEnd. */
    426          	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    427          	pxFirstFreeBlock->xBlockSize = ulAddress - ( uint32_t ) pxFirstFreeBlock;
    428          	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    429          	#if defined(MTK_SUPPORT_HEAP_DEBUG) || defined(MTK_HEAP_SIZE_GUARD_ENABLE)
    430          	pxFirstBlock = pxFirstFreeBlock;
    431          	#endif
    432          
    433          	/* Only one block exists - and it covers the entire usable heap space. */
    434          	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    435          	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    436          
    437          	/* Work out the position of the top bit in a size_t variable. */
    438          	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    439          }
    440          /*-----------------------------------------------------------*/
    441          
    442          static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
    443          {
    444          BlockLink_t *pxIterator;
    445          uint8_t *puc;
    446          
    447          	/* Iterate through the list until a block is found that has a higher address
    448          	than the block being inserted. */
    449          	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    450          	{
    451          		/* Nothing to do here, just iterate to the right position. */
    452          	}
    453          
    454          	/* Do the block being inserted, and the block it is being inserted after
    455          	make a contiguous block of memory? */
    456          	puc = ( uint8_t * ) pxIterator;
    457          	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    458          	{
    459          		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    460          		pxBlockToInsert = pxIterator;
    461          	}
    462          	else
    463          	{
    464          		mtCOVERAGE_TEST_MARKER();
    465          	}
    466          
    467          	/* Do the block being inserted, and the block it is being inserted before
    468          	make a contiguous block of memory? */
    469          	puc = ( uint8_t * ) pxBlockToInsert;
    470          	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    471          	{
    472          		if( pxIterator->pxNextFreeBlock != pxEnd )
    473          		{
    474          			/* Form one big block from the two blocks. */
    475          			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    476          			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    477          		}
    478          		else
    479          		{
    480          			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    481          		}
    482          	}
    483          	else
    484          	{
    485          		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    486          	}
    487          
    488          	/* If the block being inserted plugged a gab, so was merged with the block
    489          	before and the block after, then it's pxNextFreeBlock pointer will have
    490          	already been set, and should not be set here as that would make it point
    491          	to itself. */
    492          	if( pxIterator != pxBlockToInsert )
    493          	{
    494          		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    495          	}
    496          	else
    497          	{
    498          		mtCOVERAGE_TEST_MARKER();
    499          	}
    500          }
    501          
    502          
    503          /*-----------------------------------------------------------*/
    504          
    505          void *pvPortCalloc( size_t nmemb, size_t size )
    506          {
    507              void *pvReturn;
    508          #ifdef MTK_HEAP_SIZE_GUARD_ENABLE
    509          	#if defined(__GNUC__) 
    510          	extern void *__wrap_pvPortMalloc(size_t);
    511          	pvReturn = (void *)__wrap_pvPortMalloc(nmemb*size);
    512          	#elif defined(__CC_ARM)
    513          	pvReturn = pvPortMalloc( nmemb*size );
    514          	#endif /* __GNUC__ */
    515          #else
    516              pvReturn = pvPortMalloc( nmemb*size );
    517          #endif /* MTK_HEAP_SIZE_GUARD_ENABLE */
    518              if (pvReturn)
    519              {
    520                  memset(pvReturn, 0, nmemb*size);
    521              }
    522          
    523              return pvReturn;
    524          }
    525          /*-----------------------------------------------------------*/
    526          
    527          
    528          void *pvPortRealloc( void *pv, size_t size )
    529          {
    530              void        *pvReturn   = NULL;
    531              size_t       xBlockSize = 0;
    532              uint8_t     *puc        = ( uint8_t * ) pv;
    533              BlockLink_t *pxLink     = NULL;
    534          
    535              pvReturn = pvPortCalloc( size, 1 );
    536          
    537              if( pv != NULL )
    538              {
    539                  // The memory being freed will have an BlockLink_t structure immediately before it.
    540                  puc -= xHeapStructSize;
    541          
    542                  // This casting is to keep the compiler from issuing warnings.
    543                  pxLink = ( void * ) puc;
    544          
    545                  // Check the block is actually allocated
    546                  configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
    547                  configASSERT( pxLink->pxNextFreeBlock == NULL );
    548          
    549                  // Get Original Block Size
    550                  xBlockSize = (pxLink->xBlockSize & ~xBlockAllocatedBit);
    551          
    552                  // Get Original data length
    553                  xBlockSize = (xBlockSize - xHeapStructSize);
    554          
    555                  if(xBlockSize < size)
    556                      memcpy(pvReturn, pv, xBlockSize);
    557                  else
    558                      memcpy(pvReturn, pv, size);
    559          
    560                  // Free Original Ptr
    561                  vPortFree(pv);
    562              }
    563          
    564              return pvReturn;
    565          }
    566          
    567          #ifdef HAL_CACHE_WITH_REMAP_FEATURE
    568          #define portCacheline_ALIGNMENT HAL_CACHE_LINE_SIZE
    569          #endif
    570          void *pvPortMallocNC( size_t xWantedSize )
    571          {
    572          #ifdef HAL_CACHE_WITH_REMAP_FEATURE
    573          
    574          /*
    575                head        res            xBlockAlignWantedSize         res
    576              |_____|________|______________________|________|
    577              p1     p2     p3     p4
    578          
    579              res is a const value: portCacheline_ALIGNMENT - portBYTE_ALIGNMENT, 
    580              the first res is to confirm this non-cacheable block is located at the different cache line compared with the front heap block
    581              the second res is to confirm this non-cacheable block is located at the differet cache line compared with the next heap block
    582          
    583              p1: block begin address
    584              p2: return address of pvPortMalloc
    585              p3: cache line align address, which is the begin of the cache line invalidate operation
    586              p4: user address,which is equal to p2 + res(portCacheline_ALIGNMENT - portBYTE_ALIGNMENT)
    587          */
    588              const size_t xResSize =  portCacheline_ALIGNMENT - portBYTE_ALIGNMENT; /* res */
    589              size_t xBlockAlignWantedSize = 0;
    590              void *pvReturn = NULL;          /* p2*/
    591              uint32_t xCacheAlignAddr;       /* p3 */
    592              uint32_t xUserAddr;             /* p4 */
    593              uint32_t xInvalidLength;
    594              if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    595              {
    596                  /* The wanted size is increased so it can contain a BlockLink_t
    597                  structure in addition to the requested amount of bytes. */
    598                  if( xWantedSize > 0 )
    599                  {
    600                      xBlockAlignWantedSize = xWantedSize;
    601                  	/* Ensure that blocks are always aligned to the required number of bytes. */
    602                  	if( ( xBlockAlignWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    603                  	{
    604                  		/* Byte alignment required. */
    605                  		xBlockAlignWantedSize += ( portBYTE_ALIGNMENT - ( xBlockAlignWantedSize & portBYTE_ALIGNMENT_MASK ) );
    606                  		configASSERT( ( xBlockAlignWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
    607                  	}
    608                  	else
    609                  	{
    610                  		mtCOVERAGE_TEST_MARKER();
    611                  	}
    612                      /* Allocate a block from heap memory */
    613                      pvReturn = pvPortMalloc(xBlockAlignWantedSize + xResSize * 2);
    614                  }
    615                  else
    616                  {
    617                  	mtCOVERAGE_TEST_MARKER();
    618                  }   
    619              }
    620              else
    621              {
    622                  mtCOVERAGE_TEST_MARKER();
    623              }
    624              
    625              /* directly return if allocate fail */
    626              if(pvReturn == NULL) 
    627              {
    628                  return pvReturn;
    629              }
    630              /* round up to cache line align size for invalidation */    
    631              xCacheAlignAddr = ((uint32_t)pvReturn + portCacheline_ALIGNMENT - 1) & ~(portCacheline_ALIGNMENT - 1); /* p3 */
    632              xUserAddr = (uint32_t)pvReturn + xResSize;      /* p4 = p2 + res */
    633              configASSERT(xCacheAlignAddr <= xUserAddr);     /* p3 <= p4 */
    634              
    635              xInvalidLength = (xUserAddr - xCacheAlignAddr + xBlockAlignWantedSize + portCacheline_ALIGNMENT - 1) & ~(portCacheline_ALIGNMENT - 1); /* (p4 - p3 + xBlockAlignWantedSize) round up to cache line aligne size */
    636              configASSERT((xCacheAlignAddr + xInvalidLength) <= (xUserAddr + xBlockAlignWantedSize + xResSize)); /* (p3 + xInvalidLength) <= (p4 + xBlockAlignWantedSize + res) */
    637          
    638              /* do invalidation*/
    639              if(HAL_CACHE_STATUS_OK != hal_cache_invalidate_multiple_cache_lines(xCacheAlignAddr, xInvalidLength))
    640              {
    641                  configASSERT(0);
    642              }
    643          
    644              /* change to non-cacheable address */
    645          	xUserAddr = HAL_CACHE_VIRTUAL_TO_PHYSICAL(xUserAddr);
    646          
    647              return (void*)xUserAddr;
    648          #else
    649              return pvPortMalloc(xWantedSize);
    650          #endif /* HAL_CACHE_WITH_REMAP_FEATURE */
    651          }
    652          void vPortFreeNC( void *pv )
    653          {
    654          #ifdef HAL_CACHE_WITH_REMAP_FEATURE
    655          /*
    656                head        res        xBlockAlignWantedSize         res
    657              |_____|________|______________________|________|
    658              p1     p2     p3     p4
    659              
    660              p2 = p4 - res
    661          */
    662              const uint32_t xResSize =  portCacheline_ALIGNMENT - portBYTE_ALIGNMENT; /* res */
    663              uint32_t xAddr;
    664          
    665              if(pv != NULL)
    666              {
    667                  xAddr = (uint32_t)pv - xResSize; /* p2 */
    668                  
    669                  /* check address is cacheable or not, if yes, then assert */
    670          		configASSERT(pdFALSE == hal_cache_is_cacheable(xAddr));
    671          
    672                  /* change to virtual address */
    673          		xAddr = HAL_CACHE_PHYSICAL_TO_VIRTUAL(xAddr);
    674          
    675                  /* free */  
    676                  vPortFree((void*)xAddr);
    677              }
    678          
    679          #else
    680              vPortFree(pv);
    681          #endif /* HAL_CACHE_WITH_REMAP_FEATURE*/
    682          }
    683          
    684          /* Wrap c stand library malloc family, include malloc/calloc/realloc/free to FreeRTOS heap service */
    685          #if defined(__GNUC__) 
    686          void *__wrap_malloc(size_t size)
    687          {
    688              return pvPortMalloc(size);    
    689          }
    690          void *__wrap_calloc(size_t nmemb, size_t size )
    691          {
    692              return pvPortCalloc(nmemb,size);
    693          }
    694          void *__wrap_realloc(void *pv, size_t size )
    695          {
    696              return pvPortRealloc(pv,size);
    697          }
    698          void __wrap_free(void *pv)
    699          {
    700               vPortFree(pv);
    701          }
    702          #elif defined(__CC_ARM)
    703          void *$Sub$$malloc(size_t size)
    704          {
    705              return pvPortMalloc(size);    
    706          }
    707          void *$Sub$$calloc(size_t nmemb, size_t size )
    708          {
    709              return pvPortCalloc(nmemb,size);
    710          }
    711          void *$Sub$$realloc(void *pv, size_t size )
    712          {
    713              return pvPortRealloc(pv,size);
    714          }
    715          void $Sub$$free(void *pv)
    716          {
    717               vPortFree(pv);
    718          }
    719          #endif /* __GNUC__ */
    720          
    721          #if defined(MTK_SUPPORT_HEAP_DEBUG) || defined(MTK_HEAP_SIZE_GUARD_ENABLE)
    722          void vCheckAccessRegion(void* addr, size_t size)
    723          {
    724          	BlockLink_t *blk_iter = pxFirstBlock;
    725          	uint32_t blk_size = 0;
    726          	uint32_t xAddr = (uint32_t)addr;
    727          	
    728          	taskENTER_CRITICAL();
    729          	while (blk_iter != pxEnd)
    730          	{
    731          		blk_size = (blk_iter->xBlockSize & ~xBlockAllocatedBit);
    732          		if (xAddr >= (uint32_t)blk_iter + sizeof(BlockLink_t) 
    733          			  && xAddr < ((uint32_t)blk_iter + blk_size))
    734          		{
    735          			if(xAddr + size > ((uint32_t)blk_iter + blk_size))
    736          			{
    737          				configASSERT(0);
    738          			}
    739          		}
    740          		blk_iter = (BlockLink_t*)((uint32_t)blk_iter + blk_size);
    741          	}
    742          	taskEXIT_CRITICAL();
    743          }
    744          
    745          void vDumpHeapStatus()
    746          {
    747              BlockLink_t *blk_iter = pxFirstBlock;
    748              uint32_t blk_size = 0;
    749           
    750              while (blk_iter != pxEnd)
    751              {
    752                  blk_size = blk_iter->xBlockSize & ~xBlockAllocatedBit;
    753                  #ifdef MTK_HEAP_SIZE_GUARD_ENABLE
    754                  printf("block start = 0x%x,\t size = 0x%x \r\n", (unsigned int)blk_iter, (unsigned int)blk_iter->xBlockSize);
    755                  #else
    756                  printf("block start = 0x%x,\t size = 0x%x,\t lr = 0x%x \r\n", (unsigned int)blk_iter, (unsigned int)blk_iter->xBlockSize, (blk_iter->xBlockSize & xBlockAllocatedBit) ? (unsigned int)(blk_iter->xLinkRegAddr) : (unsigned int)NULL);
    757                  #endif /* MTK_HEAP_SIZE_GUARD_ENABLE */
    758          
    759          		blk_iter = (BlockLink_t*)((uint32_t)blk_iter + blk_size);
    760                  if((uint32_t)blk_iter > (uint32_t)pxEnd)
    761                  {
    762                      printf("heap crash!!!!! \r\n");
    763                      configASSERT(0);
    764                  }
    765              }
    766          
    767              #ifdef MTK_HEAP_SIZE_GUARD_ENABLE
    768              printf("block start = 0x%x,\t size = 0x%x \r\n", (unsigned int)blk_iter, (unsigned int)blk_iter->xBlockSize);
    769              #else
    770              printf("block start = 0x%x,\t size = 0x%x,\t lr = 0x%x \r\n", (unsigned int)blk_iter, (unsigned int)blk_iter->xBlockSize,(blk_iter->xBlockSize & xBlockAllocatedBit) ? (unsigned int)(blk_iter->xLinkRegAddr) : (unsigned int)NULL);
    771              #endif /* MTK_HEAP_SIZE_GUARD_ENABLE */
    772          	
    773              printf("reach blk_end \r\n");
    774          }
    775          #endif /* defined(MTK_SUPPORT_HEAP_DEBUG) || defined(MTK_HEAP_SIZE_GUARD_ENABLE) */
    776          /*-----------------------------------------------------------*/
    777          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   prvHeapInit
       8   prvInsertBlockIntoFreeList
      16   pvPortCalloc
        16   -> __aeabi_memset
        16   -> pvPortMalloc
      32   pvPortMalloc
        32   -> platform_assert
        32   -> prvHeapInit
        32   -> prvInsertBlockIntoFreeList
        32   -> vTaskSuspendAll
        32   -> xTaskResumeAll
       0   pvPortMallocNC
         0   -> pvPortMalloc
      24   pvPortRealloc
        24   -> __aeabi_memcpy
        24   -> platform_assert
        24   -> pvPortCalloc
        24   -> vPortFree
      16   vPortFree
        16   -> platform_assert
        16   -> prvInsertBlockIntoFreeList
        16   -> vTaskSuspendAll
         0   -> xTaskResumeAll
       0   vPortFreeNC
         0   -> vPortFree
       0   vPortInitialiseBlocks
       0   xPortGetFreeHeapSize
       0   xPortGetMinimumEverFreeHeapSize


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
      48  ?_0
      88  ?_1
      68  ?_2
      64  ?_3
      52  ?_4
      32  ?_5
      78  prvHeapInit
      78  prvInsertBlockIntoFreeList
      28  pvPortCalloc
     230  pvPortMalloc
       2  pvPortMallocNC
     118  pvPortRealloc
     116  vPortFree
       2  vPortFreeNC
       2  vPortInitialiseBlocks
       6  xPortGetFreeHeapSize
       6  xPortGetMinimumEverFreeHeapSize
   81944  xStart
          pxEnd
          xFreeBytesRemaining
          xMinimumEverFreeBytesRemaining
          xBlockAllocatedBit
          ucHeap

 
 81 944 bytes in section .bss
  1 022 bytes in section .text
 
  1 022 bytes of CODE memory
 81 944 bytes of DATA memory

Errors: none
Warnings: none
