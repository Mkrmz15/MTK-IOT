###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:22
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\board\mt76x7_hdk\util\src\gpio_cli.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW69C5.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\board\mt76x7_hdk\util\src\gpio_cli.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\gpio_cli.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\gpio_cli.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\board\mt76x7_hdk\util\src\gpio_cli.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          #include <stdlib.h>
     36          #include <string.h>
     37          #include <stdio.h>
     38          
     39          #include "toi.h"
     40          #include "hal_gpio.h"
     41          #include "gpio_cli.h"
     42          
     43          #define GPIO_IOT_MODE0_ADD 0x81023020
     44          #define GPIO_IOT_PULL_UP0_ADD 0x8300B000
     45          #define GPIO_IOT_PULL_DOWN0_ADD 0x8300B030
     46          
     47          hal_gpio_status_t hal_iot_gpio_get_pinmux(hal_gpio_pin_t pin_number, uint8_t *function_index)
     48          {
     49              uint32_t no;
     50              uint32_t remainder;
     51              uint32_t temp;
     52          
     53              /* get the register number corresponding to the pin as one register can control 8 pins*/
     54              no = pin_number / 8;
     55          
     56              /* get the bit offset within the register as one register can control 8 pins*/
     57              remainder = pin_number % 8;
     58          
     59              temp = *(volatile unsigned int *)(GPIO_IOT_MODE0_ADD + (no * 0x4));
     60          
     61              temp &= (0xF << ( 4 * remainder ));
     62              *function_index = (temp >> ( 4 * remainder ));
     63              return HAL_GPIO_STATUS_OK;
     64          }
     65          
     66          
     67          hal_gpio_status_t hal_iot_gpio_get_pull(hal_gpio_pin_t pin_number, uint8_t *pull_state)
     68          {
     69              uint8_t no;
     70              uint8_t remainder;
     71              uint32_t temp1, temp2;
     72          
     73              /* get the register number corresponding to the pin as one register can control 8 pins*/
     74              no = pin_number / 32;
     75          
     76              /* get the bit offset within the register as one register can control 8 pins*/
     77              remainder = pin_number % 32;
     78          
     79              temp1 = *(volatile unsigned int *)( GPIO_IOT_PULL_UP0_ADD + (no * 0x10) );
     80              temp1 &= (0x1 << remainder );
     81              temp1 = (temp1 >> remainder);
     82          
     83              temp2 = *(volatile unsigned int *)( GPIO_IOT_PULL_DOWN0_ADD + (no * 0x10) );
     84              temp2 &= (0x1 << remainder);
     85              temp2 = (temp2 >> remainder);
     86              if (0 == temp1 && 0 == temp2) {
     87                  *pull_state = 2;
     88              } else if (1 == temp1) {
     89                  *pull_state = 1;
     90          
     91              } else if (1 == temp2) {
     92                  *pull_state = 0;
     93              }
     94          
     95              return HAL_GPIO_STATUS_OK;
     96          }
     97          
     98          
     99          
    100          static unsigned char gpio_set_pull(uint8_t len, char *param[])
    101          {
    102              uint8_t type;
    103              uint8_t config_index[2];
    104          
    105              if ( 2 != len) {
    106                  cli_puts("parameter error");
    107                  cli_putln();
    108                  return 1;
    109              }
    110          
    111              config_index[0] = toi(param[0], &type);       //  pin
    112              config_index[1] = toi(param[1], &type);       //  pull stat
    113          
    114          
    115              if ((config_index[0] >= 72) || (config_index[1] > 2) ) {
    116                  cli_puts("parameter error");
    117                  cli_putln();
    118                  return 3;
    119              }
    120          
    121              /* set pull */
    122              if (2 == config_index[1]) {
    123                  hal_gpio_disable_pull((hal_gpio_pin_t)config_index[0]);
    124              } else if (1 == config_index[1]) {
    125                  hal_gpio_pull_up((hal_gpio_pin_t)config_index[0]);
    126              } else if (0 == config_index[1]) {
    127                  hal_gpio_pull_down((hal_gpio_pin_t)config_index[0]);
    128              }
    129          
    130              return 0;
    131          }
    132          
    133          
    134          
    135          
    136          static unsigned char gpio_set_od(uint8_t len, char *param[])
    137          {
    138              uint8_t type;
    139              uint8_t config_index[2];
    140          
    141              if ( 2 != len) {
    142                  cli_puts("parameter error");
    143                  cli_putln();
    144                  return 1;
    145              }
    146          
    147              config_index[0] = toi(param[0], &type);       //  pin
    148              config_index[1] = toi(param[1], &type);      //  output data
    149          
    150              if ((config_index[0] >= 72) || (config_index[1] > 1) ) {
    151                  cli_puts("parameter error");
    152                  cli_putln();
    153                  return 3;
    154              }
    155          
    156              /* set pinmux */
    157              hal_gpio_set_output((hal_gpio_pin_t)config_index[0], (hal_gpio_data_t)config_index[1]);
    158          
    159              return 0;
    160          }
    161          
    162          
    163          
    164          static unsigned char gpio_set_dir(uint8_t len, char *param[])
    165          {
    166              uint8_t type;
    167              uint8_t config_index[2];
    168          
    169              if ( 2 != len) {
    170                  cli_puts("parameter error");
    171                  cli_putln();
    172                  return 1;
    173              }
    174          
    175              config_index[0] = toi(param[0], &type);        //  pin
    176              config_index[1] = toi(param[1], &type);        //  dir
    177          
    178              if ((config_index[0] >= 72) || (config_index[1] > 1) ) {
    179                  cli_puts("parameter error");
    180                  cli_putln();
    181                  return 3;
    182              }
    183          
    184              /* set pinmux */
    185              hal_gpio_set_direction((hal_gpio_pin_t)config_index[0], (hal_gpio_direction_t)config_index[1]);
    186          
    187              return 0;
    188          }
    189          
    190          
    191          
    192          static unsigned char gpio_set_mode(uint8_t len, char *param[])
    193          {
    194              uint8_t type;
    195              uint8_t config_index[2];
    196          
    197              if ( 2 != len) {
    198                  cli_puts("parameter error");
    199                  cli_putln();
    200                  return 1;
    201              }
    202          
    203              config_index[0] = toi(param[0], &type);           //  pin
    204              config_index[1] = toi(param[1], &type);           //  mode
    205          
    206              if ((config_index[0] >= 72) || (config_index[1] > 15) ) {
    207                  cli_puts("parameter error");
    208                  cli_putln();
    209                  return 2;
    210              }
    211          
    212              /* set pinmux */
    213              hal_pinmux_set_function((hal_gpio_pin_t)config_index[0], config_index[1]);
    214          
    215              return 0;
    216          }
    217          
    218          
    219          static unsigned char gpio_set(uint8_t len, char *param[])
    220          {
    221              uint8_t type;
    222              uint8_t config_index[7];
    223          
    224              if ( 5 != len) {
    225                  cli_puts("parameter error");
    226                  cli_putln();
    227                  return 1;
    228              }
    229          
    230              config_index[0] = toi(param[0], &type);       //  pin
    231              config_index[1] = toi(param[1], &type);       //  mode
    232              config_index[2] = toi(param[2], &type);       //  dir
    233              config_index[3] = toi(param[3], &type);       //  pull
    234              config_index[4] = toi(param[4], &type);       //  od
    235          
    236              if ((config_index[0] > 72) || (config_index[1] > 15) || (config_index[2] > 1) || (config_index[3] > 2) || (config_index[4] > 1) ) {
    237                  cli_puts("parameter error");
    238                  cli_putln();
    239                  return 3;
    240              }
    241          
    242              /* set pinmux */
    243              hal_pinmux_set_function((hal_gpio_pin_t)config_index[0], config_index[1]);
    244          
    245              /*set direction */
    246              hal_gpio_set_direction((hal_gpio_pin_t)config_index[0], (hal_gpio_direction_t)config_index[2]);
    247          
    248              /*set direction
    249                config_index[3] =
    250                                  2: disable pull
    251                                  0: pull down
    252                                  1: pull up
    253              */
    254              if (config_index[3] == 2) { /*disabl pull*/
    255                  hal_gpio_disable_pull((hal_gpio_pin_t)config_index[0]);
    256              } else if (1 == config_index[3]) {
    257                  hal_gpio_pull_up((hal_gpio_pin_t)config_index[0]);
    258              } else if (0 == config_index[3]) {
    259                  hal_gpio_pull_down((hal_gpio_pin_t)config_index[0]);
    260              }
    261          
    262              /*set output data */
    263              hal_gpio_set_output((hal_gpio_pin_t)config_index[0], (hal_gpio_data_t)config_index[4]);
    264          
    265              return 0;
    266          }
    267          
    268          static unsigned char gpio_get(uint8_t len, char *param[])
    269          {
    270          
    271              hal_gpio_data_t input_gpio_data = HAL_GPIO_DATA_LOW;
    272              hal_gpio_data_t output_gpio_data = HAL_GPIO_DATA_LOW;
    273              hal_gpio_direction_t gpio_dir;
    274              uint8_t i, gpio_function_index, pull;
    275          
    276              cli_puts("PIN:[mode][dir][pull][output][input]"); cli_putln();
    277              
    278              for (i = 0; i < 73; i ++) {
    279                  hal_iot_gpio_get_pinmux((hal_gpio_pin_t)i, &gpio_function_index);
    280          
    281                  hal_gpio_get_direction((hal_gpio_pin_t)i, &gpio_dir);
    282                  if (HAL_GPIO_DIRECTION_OUTPUT == gpio_dir) {
    283                      hal_gpio_get_output((hal_gpio_pin_t)i, &output_gpio_data);
    284                  } else {
    285                      hal_gpio_get_input((hal_gpio_pin_t)i, &input_gpio_data);
    286                  }
    287          
    288                  hal_iot_gpio_get_pull((hal_gpio_pin_t)i, &pull);
    289                  printf("%-6d%-6d%-6d%-6d%-7d%d\n", i, gpio_function_index, gpio_dir, pull, output_gpio_data, input_gpio_data);
    290              }
    291          
    292              cli_puts("0: pull down");    cli_putln();
    293          	cli_puts("1: pull up");      cli_putln();
    294          	cli_puts("2: disable pull"); cli_putln();
    295          
    296              return 0;
    297          }
    298          
    299          
    300          cmd_t gpio_cli_cmds[] = {
    301              { "get",      "get configurations of all pins",                             gpio_get,      NULL },
    302              { "set",      "set pin param:         <pin> <mode> <dir> <pull> <od>",      gpio_set,      NULL },
    303              { "set_mode", "set pin mode:          <pin> <mode>",                        gpio_set_mode, NULL },
    304              { "set_dir",  "set pin direction:     <pin> <dir> (0:in, 1:out)",           gpio_set_dir,  NULL },
    305              { "set_pull", "set pin internal pull: <pin> <pull> (0: dn, 1: up, 2: na)",  gpio_set_pull, NULL },
    306              { "set_od",   "set pin output data:   <pin> <data>",                        gpio_set_od,   NULL },
    307              { NULL, NULL, NULL, NULL }
    308          };

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   gpio_get
        32   -> cli_putln
        32   -> cli_puts
        32   -> hal_gpio_get_direction
        32   -> hal_gpio_get_input
        32   -> hal_gpio_get_output
        32   -> hal_iot_gpio_get_pinmux
        32   -> hal_iot_gpio_get_pull
        32   -> printf
      32   gpio_set
        32   -> cli_putln
        32   -> cli_puts
        32   -> hal_gpio_disable_pull
        32   -> hal_gpio_pull_down
        32   -> hal_gpio_pull_up
        32   -> hal_gpio_set_direction
        32   -> hal_gpio_set_output
        32   -> hal_pinmux_set_function
        32   -> toi
      16   gpio_set_dir
        16   -> cli_putln
        16   -> cli_puts
        16   -> hal_gpio_set_direction
        16   -> toi
      16   gpio_set_mode
        16   -> cli_putln
        16   -> cli_puts
        16   -> hal_pinmux_set_function
        16   -> toi
      16   gpio_set_od
        16   -> cli_putln
        16   -> cli_puts
        16   -> hal_gpio_set_output
        16   -> toi
      16   gpio_set_pull
        16   -> cli_putln
        16   -> cli_puts
        16   -> hal_gpio_disable_pull
        16   -> hal_gpio_pull_down
        16   -> hal_gpio_pull_up
        16   -> toi
       0   hal_iot_gpio_get_pinmux
       8   hal_iot_gpio_get_pull


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ?_0
      32  ?_1
       8  ?_10
      36  ?_11
      16  ?_12
      40  ?_13
      24  ?_14
      16  ?_15
      12  ?_16
      16  ?_17
       4  ?_2
      56  ?_3
      12  ?_4
      36  ?_5
       8  ?_6
      52  ?_7
      12  ?_8
      60  ?_9
     112  gpio_cli_cmds
     174  gpio_get
     192  gpio_set
      82  gpio_set_dir
      82  gpio_set_mode
      82  gpio_set_od
     106  gpio_set_pull
      40  hal_iot_gpio_get_pinmux
      86  hal_iot_gpio_get_pull

 
 112 bytes in section .data
 320 bytes in section .rodata
 976 bytes in section .text
 
 976 bytes of CODE  memory
 320 bytes of CONST memory
 112 bytes of DATA  memory

Errors: none
Warnings: none
