###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:47
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\src\wifi_lwip_helper.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EWCB2D.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\src\wifi_lwip_helper.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\wifi_lwip_helper.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\wifi_lwip_helper.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\src\wifi_lwip_helper.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          #include <stdint.h>
     35          #include <stdio.h>
     36          #include <string.h>
     37          
     38          #include "FreeRTOS.h"
     39          #include "task.h"
     40          #include "os.h"
     41          #include "semphr.h"
     42          #include "wifi_api.h"
     43          #include "lwip/ip4_addr.h"
     44          #include "lwip/inet.h"
     45          #include "lwip/netif.h"
     46          #include "lwip/tcpip.h"
     47          #include "lwip/dhcp.h"
     48          #include "ethernetif.h"
     49          #include "portmacro.h"
     50          #include "dhcpd.h"
     51          #include "wifi_lwip_helper.h"
     52          #include "wifi_nvdm_config.h"
     53          #include "wifi_private_api.h"
     54          
     55          static SemaphoreHandle_t wifi_connected;
     56          
     57          static SemaphoreHandle_t ip_ready;
     58          
     59          static void ip_ready_callback(struct netif *netif);
     60          
     61          static int32_t wifi_station_port_secure_event_handler(wifi_event_t event, uint8_t *payload, uint32_t length);
     62          static int32_t wifi_station_disconnected_event_handler(wifi_event_t event, uint8_t *payload, uint32_t length);
     63          
     64          /**
     65            * @brief  dhcp got ip will callback this function.
     66            * @param[in] struct netif *netif: which network interface got ip.
     67            * @retval None
     68            */
     69          static void ip_ready_callback(struct netif *netif)
     70          {
     71              if (!ip4_addr_isany_val(netif->ip_addr)) {
     72                  char ip_addr[17] = {0};
     73                  if (NULL != inet_ntoa(netif->ip_addr)) {
     74                      strcpy(ip_addr, inet_ntoa(netif->ip_addr));
     75                      LOG_I(common, "************************");
     76                      LOG_I(common, "DHCP got IP:%s", ip_addr);
     77                      LOG_I(common, "************************");
     78          
     79                      xSemaphoreGive(ip_ready);
     80                  } else {
     81                      LOG_E(common, "DHCP got Failed");
     82                  }
     83              #ifdef MTK_WIFI_REPEATER_ENABLE
     84                  uint8_t op_mode = 0;
     85                  struct netif *ap_if = netif_find_by_type(NETIF_TYPE_AP);
     86                  wifi_config_get_opmode(&op_mode);
     87                  if (WIFI_MODE_REPEATER == op_mode) {
     88                      netif_set_addr(ap_if, &netif->ip_addr, &netif->netmask, &netif->gw);
     89                  }
     90              #endif
     91                
     92                 /*This is a private API , which used to inform IP is ready to wifi driver
     93                  *In present, WiFi Driver will do some operation when this API is invoked, such as:
     94                  *Do WiFi&BLE Coexstence relative behavior if BLE is enabled and do Power Saving Status change.
     95                  *This API will be improved, user may need to use new API to replace it in future*/
     96                  wifi_connection_inform_ip_ready();
     97              }
     98          }
     99          
    100          /**
    101            * @brief  wifi connected will call this callback function. set lwip status in this function
    102            * @param[in] wifi_event_t event: not used.
    103            * @param[in] uint8_t *payload: not used.
    104            * @param[in] uint32_t length: not used.
    105            * @retval None
    106            */
    107          static int32_t wifi_station_port_secure_event_handler(wifi_event_t event,
    108                  uint8_t *payload,
    109                  uint32_t length)
    110          {
    111              struct netif *sta_if;
    112          
    113              sta_if = netif_find_by_type(NETIF_TYPE_STA);
    114              netif_set_link_up(sta_if);
    115          
    116              if (dhcp_config_init() == STA_IP_MODE_STATIC) {
    117                 /*This is a private API , which used to inform IP is ready to wifi driver
    118                  *In present, WiFi Driver will do some operation when this API is invoked, such as:
    119                  *Do WiFi&BLE Coexstence relative behavior if BLE is enabled and do Power Saving Status change.
    120                  *This API will be improved, user may need to use new API to replace it in future*/
    121                  wifi_connection_inform_ip_ready();
    122              }
    123          
    124              xSemaphoreGive(wifi_connected);
    125              LOG_I(common, "wifi connected");
    126              return 0;
    127          }
    128          
    129          /**
    130            * @brief  wifi disconnected will call this callback function. set lwip status in this function
    131            * @param[in] wifi_event_t event: not used.
    132            * @param[in] uint8_t *payload: not used.
    133            * @param[in] uint32_t length: not used.
    134            * @retval None
    135            */
    136          static int32_t wifi_station_disconnected_event_handler(wifi_event_t event,
    137                  uint8_t *payload,
    138                  uint32_t length)
    139          {
    140              uint8_t opmode  = 0;
    141          
    142              wifi_config_get_opmode(&opmode);
    143              if ((WIFI_MODE_AP_ONLY != opmode) && WIFI_EVENT_IOT_DISCONNECTED == event) {
    144                  uint8_t link_status = 1;
    145                  //should check link status, it will emit this event when sp disconnect with host under repeater mode.
    146                  wifi_connection_get_link_status(&link_status);
    147                  if (link_status == 0) {
    148                      struct netif *sta_if;
    149                      sta_if = netif_find_by_type(NETIF_TYPE_STA);
    150                      netif_set_link_down(sta_if);
    151                      if(dhcp_config_init() == STA_IP_MODE_DHCP) {
    152                          netif_set_addr(sta_if, IP4_ADDR_ANY, IP4_ADDR_ANY, IP4_ADDR_ANY);
    153                      }
    154                      LOG_I(common, "wifi disconnected");
    155                  }
    156              }
    157              return 1;
    158          }
    159          
    160          /**
    161            * @brief  network init function. initial wifi and lwip config
    162            * @param None
    163            * @retval None
    164            */
    165          
    166          void lwip_network_init(uint8_t opmode)
    167          {
    168              lwip_tcpip_config_t tcpip_config = {{0}, {0}, {0}, {0}, {0}, {0}};
    169          
    170              if (0 != tcpip_config_init(&tcpip_config)) {
    171                  LOG_E(common, "tcpip config init fail");
    172                  return;
    173              }
    174              wifi_connected = xSemaphoreCreateBinary();
    175              if(dhcp_config_init() == STA_IP_MODE_DHCP) {
    176                  ip_ready = xSemaphoreCreateBinary();
    177              }
    178              lwip_tcpip_init(&tcpip_config, opmode);
    179          }
    180          
    181          /**
    182            * @brief  Start lwip service in a certain operation mode.
    183            * @param[in] uint8_t opmode: the target operation mode.
    184            * @retval None
    185            */
    186          void lwip_net_start(uint8_t opmode)
    187          {
    188              struct netif *sta_if;
    189              struct netif *ap_if;
    190          
    191              switch(opmode) {
    192                  case WIFI_MODE_STA_ONLY:
    193                  case WIFI_MODE_REPEATER:
    194                      wifi_connection_register_event_handler(WIFI_EVENT_IOT_PORT_SECURE, wifi_station_port_secure_event_handler);
    195                      wifi_connection_register_event_handler(WIFI_EVENT_IOT_DISCONNECTED, wifi_station_disconnected_event_handler);
    196                      if(dhcp_config_init() == STA_IP_MODE_DHCP) {
    197                          sta_if = netif_find_by_type(NETIF_TYPE_STA);
    198                          netif_set_default(sta_if);
    199                          netif_set_status_callback(sta_if, ip_ready_callback);
    200                          dhcp_start(sta_if);
    201                      }
    202                      break;
    203                  case WIFI_MODE_AP_ONLY: {
    204                      dhcpd_settings_t dhcpd_settings = {{0},{0},{0},{0},{0},{0},{0}};
    205                      lwip_tcpip_config_t tcpip_config = {{0}, {0}, {0}, {0}, {0}, {0}};
    206          
    207                      if (0 != tcpip_config_init(&tcpip_config)) {
    208                          LOG_E(common, "tcpip config init fail");
    209                          return;
    210                      }
    211          
    212                      dhcpd_settings_init(&tcpip_config, &dhcpd_settings);
    213                      ap_if = netif_find_by_type(NETIF_TYPE_AP);
    214                      netif_set_default(ap_if);
    215                      netif_set_link_up(ap_if);
    216                      dhcpd_start(&dhcpd_settings);
    217                      break;
    218                  }
    219              }
    220          }
    221          
    222          /**
    223            * @brief  Stop lwip service in a certain operation mode.
    224            * @param[in] uint8_t opmode: the current operation mode.
    225            * @retval None
    226            */
    227          void lwip_net_stop(uint8_t opmode)
    228          {
    229              struct netif *sta_if;
    230              struct netif *ap_if;
    231          
    232              sta_if = netif_find_by_type(NETIF_TYPE_STA);
    233              ap_if = netif_find_by_type(NETIF_TYPE_AP);
    234              switch (opmode) {
    235                  case WIFI_MODE_AP_ONLY:
    236                      dhcpd_stop();
    237                      netif_set_link_down(ap_if);
    238                      break;
    239                  case WIFI_MODE_STA_ONLY:
    240                  case WIFI_MODE_REPEATER:
    241                      netif_set_status_callback(sta_if, NULL);
    242                      dhcp_release(sta_if);
    243                      dhcp_stop(sta_if);
    244                      netif_set_link_down(sta_if);
    245                      break;
    246              }
    247          }
    248          
    249          /**
    250            * @brief  when wifi and ip ready will return, only used in station and repeater mode.
    251            * @param None
    252            * @retval None
    253            */
    254          void lwip_net_ready()
    255          {
    256              xSemaphoreTake(wifi_connected, portMAX_DELAY);
    257              if(dhcp_config_init() == STA_IP_MODE_DHCP) {
    258                  xSemaphoreTake(ip_ready, portMAX_DELAY);
    259              }
    260          }
    261          
    262          /**
    263            * @brief  Change operation mode dynamically.
    264            * @param[in] uint8_t target_mode: the target switched operation mode.
    265            * @retval None
    266            */
    267          uint8_t wifi_set_opmode(uint8_t target_mode)
    268          {
    269              uint8_t origin_op_mode = 0;
    270              wifi_config_get_opmode(&origin_op_mode);
    271              if(target_mode == origin_op_mode) {
    272                  LOG_I(wifi, "same opmode %d, do nothing", target_mode);
    273                  return 0;
    274              }
    275              lwip_net_stop(origin_op_mode);
    276          
    277              if(wifi_config_set_opmode(target_mode) < 0) {
    278                  return 1;
    279              }
    280              LOG_I(wifi, "set opmode to [%d]", target_mode);
    281          
    282              lwip_net_start(target_mode);
    283              return 0;
    284          }
    285          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   ip_ready_callback
        48   -- Indirect call
        48   -> __aeabi_memclr4
        48   -> ip4addr_ntoa
        48   -> netif_find_by_type
        48   -> netif_set_addr
        48   -> strcpy
        48   -> wifi_config_get_opmode
        48   -> wifi_connection_inform_ip_ready
        48   -> xQueueGenericSend
       8   lwip_net_ready
         8   -> dhcp_config_init
         0   -> xQueueGenericReceive
         8   -> xQueueGenericReceive
     152   lwip_net_start
       152   -- Indirect call
       152   -> __aeabi_memclr4
       152   -> dhcp_config_init
       152   -> dhcp_start
       152   -> dhcpd_settings_init
       152   -> dhcpd_start
       152   -> netif_find_by_type
       152   -> netif_set_default
       152   -> netif_set_link_up
       152   -> netif_set_status_callback
       152   -> tcpip_config_init
       152   -> wifi_connection_register_event_handler
      16   lwip_net_stop
        16   -> dhcp_release
        16   -> dhcp_stop
        16   -> dhcpd_stop
        16   -> netif_find_by_type
         0   -> netif_set_link_down
        16   -> netif_set_status_callback
      40   lwip_network_init
        40   -- Indirect call
        40   -> __aeabi_memclr4
        40   -> dhcp_config_init
        40   -> lwip_tcpip_init
        40   -> tcpip_config_init
        40   -> xQueueGenericCreate
      24   wifi_set_opmode
        24   -- Indirect call
        24   -> lwip_net_start
        24   -> lwip_net_stop
        24   -> wifi_config_get_opmode
        24   -> wifi_config_set_opmode
      16   wifi_station_disconnected_event_handler
        16   -- Indirect call
        16   -> dhcp_config_init
        16   -> netif_find_by_type
        16   -> netif_set_addr
        16   -> netif_set_link_down
        16   -> wifi_config_get_opmode
        16   -> wifi_connection_get_link_status
      16   wifi_station_port_secure_event_handler
        16   -- Indirect call
        16   -> dhcp_config_init
        16   -> netif_find_by_type
        16   -> netif_set_link_up
        16   -> wifi_connection_inform_ip_ready
        16   -> xQueueGenericSend


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
      20  ?_0
      28  ?_1
      28  ?_10
      20  ?_11
      16  ?_2
      16  ?_3
      16  ?_4
      20  ?_5
      24  ?_6
      24  ?_7
     112  ?_8
      24  ?_9
     194  ip_ready_callback
      46  lwip_net_ready
     154  lwip_net_start
      78  lwip_net_stop
      92  lwip_network_init
       8  wifi_connected
          ip_ready
     108  wifi_set_opmode
     106  wifi_station_disconnected_event_handler
      64  wifi_station_port_secure_event_handler
     152  -- Other

 
     8 bytes in section .bss
   180 bytes in section .rodata
 1 190 bytes in section .text
 
 1 190 bytes of CODE  memory
   180 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: 5
