###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Jun/2017  11:27:20
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\third_party\lwip\ports\ethernetif.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EW6352.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\third_party\lwip\ports\ethernetif.c
#        -D MTK_LOAD_MAC_ADDR_FROM_EFUSE -D MTK_PING_OUT_ENABLE -D
#        MTK_WIFI_PROFILE_ENABLE -D PCFG_OS=2 -D _REENT_SMALL -D
#        MTK_MINISUPP_ENABLE -D MTK_MINICLI_ENABLE -D MTK_BSPEXT_ENABLE -D
#        MTK_HAL_LOWPOWER_ENABLE -D MTK_LWIP_ENABLE -D
#        MTK_HTTPCLIENT_SSL_ENABLE -D MTK_IPERF_ENABLE -D PRODUCT_VERSION=7697
#        -D MTK_FLASH_DIRECT_DL -D MTK_PATCH_DL_ENABLE -D MTK_SMTCN_V5_ENABLE
#        -D MTK_CLI_TEST_MODE_ENABLE -D MTK_WIFI_REPEATER_ENABLE -D
#        CONFIG_REPEATER -D MTK_DEBUG_LEVEL_INFO -D MTK_DEBUG_LEVEL_WARNING -D
#        MTK_DEBUG_LEVEL_ERROR -D configOVERRIDE_DEFAULT_TICK_CONFIGURATION -D
#        CFG_SUPPORT_SMNT_PROTO=2 -D BT_DEBUG -D MTK_BLE_CLI_ENABLE -D
#        MTK_BLE_BQB_CLI_ENABLE -D MTK_HCI_CONSOLE_MIX_ENABLE -D
#        MTK_BLE_BQB_TEST_ENABLE -D MTK_BLE_SMTCN_ENABLE -D
#        MBEDTLS_CONFIG_FILE=<config-mtk-md5.h> -D MTK_NVDM_ENABLE -D
#        MTK_WIFI_PRIVILEGE_ENABLE -D __BT_DEBUG__ -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\service\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\Source\portable\IAR\ARM_CM4F\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\kernel\rtos\FreeRTOS\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\dhcpd\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minicli\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\minisupp\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\ports\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\lwip\src\include\lwip\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\common\bsp_ex\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\nvdm\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\ping\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\smtcn\inc\internal\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\iperf\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\util\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\wifi_service\combo\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\prebuilt\middleware\MTK\bluetooth\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\project\mt7697_hdk\apps\iot_sdk\src\ut_app\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\ept\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\third_party\mbedtls\configs\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\driver\board\mt76x7_hdk\external_flash\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\apps\iot_sdk\EWARM\..\..\..\..\..\middleware\MTK\connsys\inc\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\List\ethernetif.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\iot_sdk\Debug\Obj\ethernetif.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\middleware\third_party\lwip\ports\ethernetif.c
      1          /**
      2           * @file
      3           * Ethernet Interface Skeleton
      4           *
      5           */
      6          
      7          /*
      8           * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
      9           * All rights reserved.
     10           *
     11           * Redistribution and use in source and binary forms, with or without modification,
     12           * are permitted provided that the following conditions are met:
     13           *
     14           * 1. Redistributions of source code must retain the above copyright notice,
     15           *    this list of conditions and the following disclaimer.
     16           * 2. Redistributions in binary form must reproduce the above copyright notice,
     17           *    this list of conditions and the following disclaimer in the documentation
     18           *    and/or other materials provided with the distribution.
     19           * 3. The name of the author may not be used to endorse or promote products
     20           *    derived from this software without specific prior written permission.
     21           *
     22           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
     23           * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     24           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
     25           * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     26           * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
     27           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     28           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     29           * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     30           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
     31           * OF SUCH DAMAGE.
     32           *
     33           * This file is part of the lwIP TCP/IP stack.
     34           *
     35           * Author: Adam Dunkels <adam@sics.se>
     36           *
     37           */
     38          
     39          /*
     40           * This file is a skeleton for developing Ethernet network interface
     41           * drivers for lwIP. Add code to the low_level functions and do a
     42           * search-and-replace for the word "ethernetif" to replace it with
     43           * something that better describes your network interface.
     44           */
     45          #include <stdio.h>
     46          #include <string.h>
     47          
     48          #include "lwip/opt.h"
     49          #include <stdint.h>
     50          #include "lwip/def.h"
     51          #include "lwip/mem.h"
     52          #include "lwip/pbuf.h"
     53          #include "lwip/sys.h"
     54          #include <lwip/stats.h>
     55          #include <lwip/snmp.h>
     56          #include <lwip/sockets.h>
     57          #include <lwip/tcpip.h>
     58          #include <lwip/dhcp.h>
     59          #include "netif/etharp.h"
     60          //#include "netif/ppp_oe.h"   //2015-7-21 bing.luo delete on@132599
     61          #include "ethernetif.h"
     62          #include "net_task.h"
     63          #include "type_def.h"
     64          #include "connsys_util.h"
     65          #include "connsys_driver.h"
     66          #include "inband_queue.h"
     67          #include "mt_cmd_fmt.h"
     68          #include "lwip/ethip6.h"
     69          #if defined(MTK_HAL_LOWPOWER_ENABLE)
     70          #include "hal_lp.h"
     71          #endif
     72          #include "syslog.h"
     73          #include "wifi_scan.h"
     74          #if (CFG_WIFI_HIF_GDMA_EN == 1)
     75          #include "hal_gdma.h"
     76          #endif
     77          #include "lwip/netif.h"
     78          #include "os_util.h"
     79          int32_t pkt_lock_init(struct os_time *timeout_value);
     80          
     81          
     82          #ifdef DATA_PATH_87
     83          extern unsigned char IoT_Init_Done;
     84          
     85          void wifi_firmware_rxdata_msg_send(void *pbuffer);
     86          
     87          #endif/*DATA_PATH_87*/
     88          /* Sanity check the configuration. */
     89          #define ALIGN_4BYTE(size)       (((size+3)/4) * 4)
     90          
     91          #ifndef IS_ALIGN_4
     92          #define IS_ALIGN_4(_value)      (((_value) & 0x3) ? FALSE : TRUE)
     93          #define IS_NOT_ALIGN_4(_value)  (((_value) & 0x3) ? TRUE : FALSE)
     94          #endif /* IS_ALIGN_4 */
     95          
     96          #ifndef IS_NOT_ALIGN_4
     97          #define IS_NOT_ALIGN_4(_value)  (((_value) & 0x3) ? TRUE : FALSE)
     98          #endif /* IS_NOT_ALIGN_4 */
     99          
    100          
    101          
    102          #if defined(MTK_BSP_LOOPBACK_ENABLE)
    103          #include "lwip/debug.h"
    104          unsigned int g_loopback_start = 0;
    105          unsigned int loopback_start() { return g_loopback_start;}
    106          void loopback_start_set(unsigned int start) { g_loopback_start = start; }
    107          #endif // MTK_BSP_LOOPBACK_ENABLE
    108          
    109          /* Define those to better describe your network interface. Note: only 2-byte allowed */
    110          #define IFNAME00 's'
    111          #define IFNAME01 't'
    112          #define IFNAME10 'a'
    113          #define IFNAME11 'p'
    114          #define IFNAME20 'l'
    115          #define IFNAME21 'o'
    116          
    117          static int g_lwip_eapol_rx_socket = -1;
    118          static int g_lwip_eapol_rx_socket_second = -1;
    119          
    120          struct netif sta_if, ap_if;//modified by Yong Chang
    121          
    122          /**
    123           * Helper struct to hold private data used to operate your ethernet interface.
    124           * Keeping the ethernet address of the MAC in this struct is not necessary
    125           * as it is already kept in the struct netif.
    126           * But this is only an example, anyway...
    127           */
    128          struct ethernetif {
    129            struct eth_addr *ethaddr;
    130            /* Add whatever per-interface state that is needed here. */
    131          };
    132          
    133          /* Forward declarations. */
    134          void  ethernetif_input(struct netif *netif, int port);
    135          void ethernetif_intr_enhance_mode_allocate_pkt_callback(
    136                                      unsigned int allocate_len,
    137                                      void** pkt_ptr,
    138                                      unsigned char** payload_ptr);
    139          void ethernetif_free_pkt(void *pkt_ptr);
    140          uint8_t enqueue_bottom_half_from_isr(int32_t port, PNETFUNC func);
    141          
    142          void inband_handle_func(void* pkt_ptr, unsigned char *payload, unsigned int len);
    143          
    144          #if defined(MTK_WIFI_STUB_CONF_ENABLE)
    145          #if (MTK_WIFI_STUB_CONF_SPIM_ENABLE || MTK_WIFI_STUB_CONF_SDIO_MSDC_ENABLE)
    146          uint16_t wfcm_to_slave(uint16_t op, uint8_t *ptr, uint32_t ptrSize, uint8_t *rsp, uint32_t *rspSize, uint8_t fromISR);
    147          #else
    148          uint8_t wfc_send_to_host(uint8_t *pbuf, uint32_t bufSize);
    149          #endif
    150          #endif
    151          
    152          #if 0
    153          static void InterruptSimulator( void *pvParameters )
    154          {
    155             /*
    156              *  There is no real way of simulating an interrupt.
    157              *  Make sure other tasks can run.
    158              */
    159          
    160             do
    161             {
    162                vTaskDelay(3*configTICK_RATE_HZ);
    163             }
    164             while (1);
    165          }
    166          #endif
    167          
    168          void
    169          ethernetif_intr_enhance_mode_dispatch(struct pbuf *p, struct netif *netif);
    170          
    171          void enqueue_rx_pkt_lwip(struct pbuf *p, struct netif *netif)
    172          {
    173          ethernetif_intr_enhance_mode_dispatch(p, netif);
    174             //NetJobAddFromISR((PNETFUNC)ethernetif_intr_enhance_mode_dispatch, (uint32_t) p, (uint32_t)netif);
    175          }
    176          
    177          void register_eapol_rx_socket(int eapol_rx_socket)
    178          {
    179          	if (eapol_rx_socket >= 0)
    180          	g_lwip_eapol_rx_socket = eapol_rx_socket;
    181          	g_lwip_eapol_rx_socket_second = -1;
    182          }
    183          
    184          void unregister_eapol_rx_socket()
    185          {
    186              if (g_lwip_eapol_rx_socket >= 0)
    187                  close(g_lwip_eapol_rx_socket);
    188              g_lwip_eapol_rx_socket = -1;
    189          }
    190          
    191          
    192          void register_eapol_rx_socket_dual_intf(int eapol_rx_socket, int eapol_rx_socket_second)
    193          {
    194              if (eapol_rx_socket >= 0)
    195                  g_lwip_eapol_rx_socket = eapol_rx_socket;
    196          
    197              if (eapol_rx_socket_second >= 0)
    198                  g_lwip_eapol_rx_socket_second = eapol_rx_socket_second;
    199          }
    200          
    201          void unregister_eapol_rx_socket_dual_intf(int eapol_rx_socket, int eapol_rx_socket_second)
    202          {
    203              if (eapol_rx_socket >= 0)
    204                  close(eapol_rx_socket);
    205              g_lwip_eapol_rx_socket = -1;
    206          
    207              if (eapol_rx_socket_second >= 0)
    208                  close(eapol_rx_socket_second);
    209              g_lwip_eapol_rx_socket_second = -1;
    210          }
    211          
    212          
    213          void low_level_set_mac_addr(struct netif *netif, uint8_t *mac_addr)
    214          {
    215              /* set MAC hardware address length */
    216              netif->hwaddr_len = ETHARP_HWADDR_LEN;
    217          
    218              /* set MAC hardware address */
    219              memcpy(netif->hwaddr, mac_addr, ETHARP_HWADDR_LEN);
    220          }
    221          
    222          /**
    223           * Find a network interface by searching for its name
    224           *
    225           * @param name the name of the netif (like netif->name) NOT plus concatenated number
    226           * in ascii representation (e.g. 'en0')
    227           */
    228          struct netif *
    229          netif_find_name(char *name)
    230          {
    231            struct netif *netif;
    232          
    233            if (name == NULL) {
    234              return NULL;
    235            }
    236          
    237            for(netif = netif_list; netif != NULL; netif = netif->next) {
    238              if (name[0] == netif->name[0] &&
    239                 name[1] == netif->name[1]) {
    240                LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
    241                return netif;
    242              }
    243            }
    244            LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
    245            return NULL;
    246          }
    247          
    248          
    249          
    250          int low_level_get_sta_mac_addr(unsigned char *mac_addr)
    251          {
    252              char name[3];
    253              struct netif *netif = NULL;
    254          
    255              name[0] = IFNAME00;
    256              name[1] = IFNAME01;
    257          
    258              netif = netif_find_name(name);
    259              if (netif)
    260              {
    261                  memcpy(mac_addr, netif->hwaddr, ETHARP_HWADDR_LEN);
    262              }
    263              else
    264              {
    265                  return -1;
    266              }
    267          
    268              return 0;
    269          }
    270          
    271          int low_level_get_ap_mac_addr(unsigned char *mac_addr)
    272          {
    273              char name[3];
    274              struct netif *netif = NULL;
    275          
    276              name[0] = IFNAME10;
    277              name[1] = IFNAME11;
    278          
    279              netif = netif_find_name(name);
    280              if (netif)
    281              {
    282                  memcpy(mac_addr, netif->hwaddr, ETHARP_HWADDR_LEN);
    283              }
    284              else
    285              {
    286                  return -1;
    287              }
    288          
    289              return 0;
    290          }
    291          
    292          
    293          
    294          /**
    295           * In this function, the hardware should be initialized.
    296           * Called from ethernetif_init().
    297           *
    298           * @param netif the already initialized lwip network interface structure
    299           *        for this ethernetif
    300           */
    301          static void
    302          low_level_init1(struct netif *netif)
    303          {
    304          #if 0 // init MAC address in upper layer
    305            /* set MAC hardware address length */
    306            netif->hwaddr_len = ETHARP_HWADDR_LEN;
    307          
    308            /* set MAC hardware address */
    309            netif->hwaddr[0] = 0x00;
    310            netif->hwaddr[1] = 0x0c;
    311            netif->hwaddr[2] = 0x43;
    312            netif->hwaddr[3] = 0x76;
    313            netif->hwaddr[4] = 0x62;
    314            netif->hwaddr[5] = 0x02;
    315          #endif
    316          
    317            /* maximum transfer unit */
    318            netif->mtu = 1500;
    319          
    320            /* device capabilities */
    321            /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
    322            netif->flags = NETIF_FLAG_IGMP | NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
    323          
    324            /* Do whatever else is needed to initialize interface. */
    325          }
    326          
    327          static void
    328          low_level_init2(struct netif *netif)
    329          {
    330          #if 0 // init MAC address in upper layer
    331            /* set MAC hardware address length */
    332            netif->hwaddr_len = ETHARP_HWADDR_LEN;
    333          
    334            /* set MAC hardware address */
    335            netif->hwaddr[0] = 0x00;
    336            netif->hwaddr[1] = 0x0c;
    337            netif->hwaddr[2] = 0x43;
    338            netif->hwaddr[3] = 0x76;
    339            netif->hwaddr[4] = 0x62;
    340            netif->hwaddr[5] = 0x04;
    341          #endif
    342          
    343            /* maximum transfer unit */
    344            netif->mtu = 1500;
    345          
    346            /* device capabilities */
    347            /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
    348            netif->flags = NETIF_FLAG_IGMP | NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
    349          
    350            /* Do whatever else is needed to initialize interface. */
    351          }
    352          
    353          
    354          /**
    355           * This function should do the actual transmission of the packet. The packet is
    356           * contained in the pbuf that is passed to the function. This pbuf
    357           * might be chained.
    358           *
    359           * @param netif the lwip network interface structure for this ethernetif
    360           * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
    361           * @return ERR_OK if the packet could be sent
    362           *         an err_t value if the packet couldn't be sent
    363           *
    364           * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
    365           *       strange results. You might consider waiting for space in the DMA queue
    366           *       to become availale since the stack doesn't retry to send a packet
    367           *       dropped because of memory failure (except for the TCP timers).
    368           */
    369          #if 0
    370          static int low_level_output(struct netif *netif, struct pbuf *p)
    371          {
    372              struct pbuf *q;
    373              u32_t total_len = 0;
    374              int ret = ERR_OK;
    375              int connsys_ret = CONNSYS_STATUS_SUCCESS;
    376              u32_t pbuf_num = 0;
    377              unsigned char *pBuffer = NULL;
    378              unsigned char *pBuffer_4byte_align = NULL;
    379              unsigned char *pTmp = NULL;
    380              taskENTER_CRITICAL();
    381          
    382          
    383              for(q = p; q != NULL; q = q->next) {
    384                  total_len = total_len + (q->len);
    385                  pbuf_num = pbuf_num + 1;
    386                  DBG_CONNSYS(CONNSYS_DBG_TX_Q1,("==>low_level_output, q->len = %u\n",
    387                      (unsigned int)q->len));
    388              }
    389              DBG_CONNSYS(CONNSYS_DBG_TX_Q1,("==>low_level_output, pbuf_num = %u, total_len = %u\n",
    390                  (unsigned int)pbuf_num, (unsigned int)total_len));
    391          
    392              if (pbuf_num > 1)
    393              {
    394                  /* concate pbuf_chain into single buffer */
    395                  u32_t allocate_len = total_len +
    396                      CFG_CONNSYS_IOT_TX_ZERO_COPY_PAD_LEN +
    397                      WIFI_HIF_TX_BYTE_CNT_LEN;
    398          
    399                  u32_t payload_offset = sizeof(INIT_HIF_TX_HEADER_T);
    400          
    401          #if (CFG_CONNSYS_IOT_TX_ZERO_COPY_EN == 1)
    402                  payload_offset += CFG_CONNSYS_IOT_TX_ZERO_COPY_PAD_LEN;
    403          #endif
    404          
    405                  if (IS_NOT_ALIGN_4(total_len))
    406                      allocate_len += 4;
    407          
    408                  pBuffer = os_malloc(allocate_len);
    409                  if (NULL == pBuffer)
    410                  {
    411                      LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
    412                      DBG_CONNSYS(CONNSYS_DBG_TX_Q1,("==>low_level_output, out of memory\n"));
    413                      taskEXIT_CRITICAL();
    414                      return ERR_MEM;
    415                  }
    416                  pBuffer_4byte_align = (unsigned char *)((unsigned int)pBuffer & (~0x3UL));
    417                  pTmp = pBuffer_4byte_align + payload_offset;
    418          
    419                  for(q = p; q != NULL; q = q->next) {
    420                      memcpy(pTmp, q->payload, q->len);
    421                      pTmp += (q->len);
    422                  }
    423          
    424                  if (netif == &ap_if)
    425                  {
    426                      connsys_ret = connsys_util_low_level_output(pBuffer_4byte_align, total_len, IOT_PACKET_TYPE_INF_1_IDX);
    427                  }
    428                  else
    429                  {
    430                      connsys_ret = connsys_util_low_level_output(pBuffer_4byte_align, total_len, IOT_PACKET_TYPE_INF_0_IDX);
    431                  }
    432                  os_free(pBuffer);
    433              }
    434              else
    435              {
    436          #if CFG_CONNSYS_TXD_PAD_SIZE
    437                  pbuf_header(p, CFG_CONNSYS_TXD_PAD_SIZE);
    438          #endif
    439          
    440                  if (netif == &ap_if)
    441                  {
    442                      connsys_ret = connsys_util_low_level_output(p->payload, total_len, IOT_PACKET_TYPE_INF_1_IDX);
    443                  }
    444                  else
    445                  {
    446                      connsys_ret = connsys_util_low_level_output(p->payload, total_len, IOT_PACKET_TYPE_INF_0_IDX);
    447                  }
    448              }
    449          
    450              if (connsys_ret == CONNSYS_STATUS_FAIL)
    451                  ret = ERR_BUF;
    452          
    453            LINK_STATS_INC(link.xmit);
    454            taskEXIT_CRITICAL();
    455            return ret;
    456          }
    457          #endif
    458          extern unsigned char IoT_Init_Done;
    459          void send_txdata_to_wifi_thread(void *pbuffer);
    460          
    461          #if defined(MTK_WIFI_STUB_CONF_ENABLE) && (MTK_WIFI_STUB_CONF_SPIM_ENABLE || MTK_WIFI_STUB_CONF_SDIO_MSDC_ENABLE || MTK_WFC_WITH_LWIP_NO_WIFI_ENABLE)
    462          
    463          static int32_t low_level_output_scatter(struct netif *netif, struct pbuf *p)
    464          {
    465              struct pbuf *q;
    466              uint32_t total_len = 0;
    467          
    468              for(q = p; q != NULL; q = q->next) {
    469                  total_len = total_len + (q->len);        
    470              }
    471          
    472          #if (MTK_WIFI_STUB_CONF_SPIM_ENABLE || MTK_WIFI_STUB_CONF_SDIO_MSDC_ENABLE)
    473              //printf("lwip(%u) -> S\r\n",total_len);
    474              wfcm_to_slave(6, (void *)p, total_len, NULL, NULL, 0);  //WFC_CMD_DTW_DATA
    475          #else
    476              //printf("S(%u) -> Host lwip\r\n",total_len);
    477              wfc_send_to_host((void *)p, total_len); 
    478          #endif
    479          		
    480              return CONNSYS_STATUS_SUCCESS;
    481          }
    482          
    483          #else
    484          
    485          static int32_t low_level_output_scatter(struct netif *netif, struct pbuf *p)
    486          {
    487              P_HIF_TX_HEADER_PORT1_T p_txd;
    488              int32_t ret = CONNSYS_STATUS_SUCCESS;
    489              int connsys_ret = CONNSYS_STATUS_SUCCESS;
    490              struct pbuf *q;
    491              int32_t inf_num;
    492              uint32_t total_len = 0;
    493              connsys_tx_scatter_info_t tx_info;
    494              signed int flow_control_status;
    495          #if (CONNSYS_DEBUG_MODE_EN == 1)
    496              static uint32_t tx_sequence = 0;
    497          #endif
    498          
    499          #ifdef MTK_CM4_WIFI_TASK_ENABLE
    500              if(IoT_Init_Done)
    501              {
    502          #ifdef MT5932_SINGLE_CONTEXT
    503          	pbuf_ref(p);
    504          #endif
    505                  send_txdata_to_wifi_thread((void *)p);
    506                  return CONNSYS_STATUS_SUCCESS;
    507              }
    508              else
    509              {
    510          #ifndef MT5932_SINGLE_CONTEXT
    511                  pbuf_free(p);
    512                  p = NULL;
    513          #else
    514          	return CONNSYS_STATUS_SUCCESS;
    515          #endif
    516              }
    517          #endif
    518          
    519          #ifdef MTK_WIFI_REPEATER_ENABLE
    520              int    i = 0;
    521              struct eth_hdr *ethhdr;
    522              struct etharp_hdr *hdr;
    523          
    524              int      sndAllInf = 0;
    525              unsigned char op_mode = WIFI_MODE_STA_ONLY;
    526          
    527              ethhdr = (struct eth_hdr *)p->payload;
    528              // Check if OpMode is Repeater Mode. Broadcast to all interfaces only at Repeater Mode.
    529              if (__g_wpa_supplicant_api.wpa_supplicant_entry_op_mode_get)
    530              {
    531                  __g_wpa_supplicant_api.wpa_supplicant_entry_op_mode_get(&op_mode);
    532                  if (op_mode == WIFI_MODE_REPEATER)
    533                  {
    534                     sndAllInf = (memcmp(&(ethhdr->dest.addr), "\xff\xff\xff\xff\xff\xff", 6) == 0)?1:0;
    535                  }
    536              }
    537          
    538              for (i=0; i<=sndAllInf; i++)
    539              {
    540                  total_len = 0;
    541                  // Change Source Mac for Ether/Arp packets if it is need
    542                  if (op_mode == WIFI_MODE_REPEATER)
    543                  {
    544                      if ( sndAllInf && (i==sndAllInf) )
    545                      {
    546                          if (   (memcmp(&ethhdr->src, (struct eth_addr*)(sta_if.hwaddr), 6)==0)
    547                              || (memcmp(&ethhdr->src, (struct eth_addr*)(ap_if.hwaddr), 6)==0)
    548                             )
    549                          {
    550                             //LOG_I(lwip, "src - %2x:%2x:%2x:%2x:%2x:%2x, dest - %2x:%2x:%2x:%2x:%2x:%2x, sndAllInf(%d)\n", ethhdr->src.addr[0], ethhdr->src.addr[1], ethhdr->src.addr[2], ethhdr->src.addr[3], ethhdr->src.addr[4], ethhdr->src.addr[5], ethhdr->dest.addr[0], ethhdr->dest.addr[1], ethhdr->dest.addr[2], ethhdr->dest.addr[3], ethhdr->dest.addr[4], ethhdr->dest.addr[5], sndAllInf);
    551                              netif = (netif == &ap_if)?&sta_if:&ap_if;
    552                              ETHADDR16_COPY(&ethhdr->src, (struct eth_addr*)(netif->hwaddr));
    553                              if ( ethhdr->type == PP_HTONS(ETHTYPE_ARP) )
    554                             {
    555                                 hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
    556                                 #if ETHARP_SUPPORT_VLAN
    557                                   if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
    558                                     hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
    559                                   }
    560                                 #endif /* ETHARP_SUPPORT_VLAN */
    561                                 ETHADDR16_COPY(&(hdr->shwaddr), (struct eth_addr*)(netif->hwaddr));
    562                             }
    563                          }
    564                      }
    565                      // Check if this remote STA mac belong to this AP
    566                      else if ( (__g_wpa_supplicant_api.get_ap_sta) && (__g_wpa_supplicant_api.get_ap_sta((char *)&(ethhdr->dest.addr))) )
    567                      {
    568                          netif = &ap_if;
    569                          if (memcmp(&ethhdr->src, (struct eth_addr*)(sta_if.hwaddr), 6)==0)
    570                          {
    571                              ETHADDR16_COPY(&ethhdr->src, (struct eth_addr*)(netif->hwaddr));
    572                          }
    573                          //LOG_I(lwip,"Change netif to ap_if : src - %2x:%2x:%2x:%2x:%2x:%2x, dest - %2x:%2x:%2x:%2x:%2x:%2x\n", ethhdr->src.addr[0], ethhdr->src.addr[1], ethhdr->src.addr[2], ethhdr->src.addr[3], ethhdr->src.addr[4], ethhdr->src.addr[5],ethhdr->dest.addr[0], ethhdr->dest.addr[1], ethhdr->dest.addr[2], ethhdr->dest.addr[3], ethhdr->dest.addr[4], ethhdr->dest.addr[5]);
    574                      }
    575                  }
    576          #endif
    577          
    578          #if (CONNSYS_DEBUG_MODE_EN == 1)
    579              //if (CONNSYS_TEST_DEBUG(CONNSYS_DBG_TX_Q1))
    580              //{
    581              //    LOG_I(lwip, "== TX Start ==  tx_sequence: %u\n", (unsigned int)tx_sequence);
    582              //}
    583              tx_sequence++;
    584          #endif
    585          
    586              memset(&tx_info, 0, sizeof(connsys_tx_scatter_info_t));
    587              if (netif == &ap_if)
    588              {
    589                  inf_num = IOT_PACKET_TYPE_INF_1_IDX;
    590              }
    591              else
    592              {
    593                  inf_num = IOT_PACKET_TYPE_INF_0_IDX;
    594              }
    595              //LOG_I(lwip, "sendto inf_num(%d)...%s-%d\n",inf_num,__FUNCTION__,__LINE__);
    596              for(q = p; q != NULL; q = q->next) {
    597                  if (tx_info.buf_num >= MAX_TX_BUF)
    598                  {
    599                      LOG_E(lwip, "ERROR! ==> low_level_output_scatter, buf_num exceed MAX_TX_BUF\n");
    600                      LOG_E(lwip, "tx_info.buf_num = %u, MAX_TX_BUF = %u\n",
    601                          (unsigned int)tx_info.buf_num,
    602                          (unsigned int)MAX_TX_BUF);
    603                      connsys_dump_tx_scatter_info(&tx_info);
    604                      return ERR_BUF;
    605                  }
    606          
    607                  total_len = total_len + (q->len);
    608                  tx_info.buff[tx_info.buf_num].buf_ptr = q->payload;
    609                  tx_info.buff[tx_info.buf_num].buf_len= q->len;
    610          
    611          #if (CONNSYS_DEBUG_MODE_EN == 1)
    612                  DBG_CONNSYS(CONNSYS_DBG_TX_Q1,("pbuf chain len[%u]: %u\n",
    613                      (unsigned int)tx_info.buf_num,
    614                      (unsigned int)q->len));
    615          #endif
    616          
    617                  tx_info.buf_num ++;
    618              }
    619          #if (CFG_CONNSYS_IOT_TX_ZERO_COPY_EN == 1)
    620          #ifdef MTK_MINISUPP_ENABLE
    621              if (__g_wpa_supplicant_api.get_sta_qos_bit) {
    622                  tx_info.fg_wmm = __g_wpa_supplicant_api.get_sta_qos_bit(inf_num, (char *)p->payload);
    623              }
    624          #endif    //Castro+
    625              if (tx_info.fg_wmm == 1)
    626                  tx_info.reserved_headroom_len = connsys_get_headroom_offset(CONNSYS_HEADROOM_OFFSET_QOS); //EXTRA_HEADROOM_LEN_FOR_QOS_ENABLE;
    627              else
    628                  tx_info.reserved_headroom_len = connsys_get_headroom_offset(CONNSYS_HEADROOM_OFFSET_NON_QOS); // EXTRA_HEADROOM_LEN_FOR_NON_QOS;
    629          //#endif //Castro-
    630          #else
    631              tx_info.reserved_headroom_len = 0;
    632          #endif
    633              tx_info.tx_len = sizeof(INIT_HIF_TX_HEADER_T)
    634                                  + tx_info.reserved_headroom_len
    635                                  + total_len;
    636          
    637              tx_info.real_tx_len = ALIGN_4BYTE(tx_info.tx_len);
    638          
    639              p_txd = (P_HIF_TX_HEADER_PORT1_T)&tx_info.txd;
    640              p_txd->u2TxByteCount = tx_info.tx_len;
    641              p_txd->u2PQ_ID = P1_Q1;
    642              p_txd->ucPktTypeID = PKT_ID_CMD;
    643              p_txd->ucPacketOffset = tx_info.reserved_headroom_len;
    644          
    645              if (inf_num == IOT_PACKET_TYPE_INF_1_IDX)
    646                  p_txd->ucReserved = IOT_PACKET_TYPE_INF_1;
    647              else
    648                  p_txd->ucReserved = IOT_PACKET_TYPE_INF_0;
    649          
    650          
    651              if (CONNSYS_TEST_DEBUG(CONNSYS_DBG_TX_Q1))
    652              {
    653                  connsys_dump_tx_scatter_info(&tx_info);
    654              }
    655          
    656          #if (CFG_CONNSYS_TRX_BALANCE_EN == 1)
    657              if (g_balance_ctr.balance_en == TRUE)
    658              {
    659                  if (connsys_balance_check_tx_yield())
    660                  {
    661                      vTaskPrioritySet(NULL, (TCPIP_THREAD_PRIO - 1));
    662                      vTaskPrioritySet((TaskHandle_t)g_balance_ctr.rx_handle, TCPIP_THREAD_PRIO);
    663                  }
    664                  else
    665                  {
    666                      vTaskPrioritySet(NULL, TCPIP_THREAD_PRIO);
    667                      vTaskPrioritySet((TaskHandle_t)g_balance_ctr.rx_handle, (TCPIP_THREAD_PRIO - 1));
    668                  }
    669              }
    670          #endif
    671          
    672              flow_control_status =
    673                  connsys_tx_flow_control_check_and_update_tx(WIFI_HIF_TX_PORT_IDX, tx_info.real_tx_len);
    674          
    675              if (flow_control_status == CONNSYS_STATUS_SUCCESS)
    676              {
    677                  connsys_ret = connsys_write_data(&tx_info);
    678              }
    679              else
    680              {
    681                  int query_limit = 1;
    682                  while(query_limit--){
    683                      connsys_tx_query_whisr();
    684                      flow_control_status =
    685                          connsys_tx_flow_control_check_and_update_tx(WIFI_HIF_TX_PORT_IDX, tx_info.real_tx_len);
    686                      if(flow_control_status == CONNSYS_STATUS_SUCCESS)
    687                          break;
    688                  }
    689          
    690                  if(CONNSYS_STATUS_SUCCESS == flow_control_status){
    691                      connsys_ret = connsys_write_data(&tx_info);
    692                  }else{
    693                      connsys_ret = CONNSYS_STATUS_FAIL;
    694                  }
    695              }
    696          
    697              if (connsys_ret == CONNSYS_STATUS_FAIL)
    698                  ret = ERR_BUF;
    699              else
    700                  LINK_STATS_INC(link.xmit);
    701          
    702          #if (CFG_CONNSYS_TRX_BALANCE_EN == 1)
    703              connsys_balance_clear_tx_wait();
    704          #endif
    705          
    706          #if (CONNSYS_DEBUG_MODE_EN == 1)
    707              DBG_CONNSYS(CONNSYS_DBG_TX_Q1,("== TX End ==\n"));
    708          #endif
    709          
    710          #ifdef MTK_WIFI_REPEATER_ENABLE
    711          }
    712          #endif
    713              return ret;
    714          }
    715          #endif
    716          
    717          void ethernetif_intr_enhance_mode_allocate_pkt_callback(
    718                                      unsigned int allocate_len,
    719                                      void** pkt_ptr,
    720                                      unsigned char** payload_ptr);
    721          #if 0
    722          typedef void (*connsys_alloc_pkt_t)(uint32_t allocate_len,
    723                                              void **pkt_ptr,
    724                                              uint8_t **payload_ptr);
    725          #endif
    726          uint8_t lwip_advance_pkt_hdr(void *pkt, int16_t len)
    727          {
    728              return pbuf_header((struct pbuf *)pkt, -(s16_t)len);
    729          }
    730          
    731          struct mt76x7_connsys_ops lwip_connsys_ops = {
    732              .enqueue_bottom_half    = &enqueue_bottom_half_from_isr,
    733              .alloc                  = (connsys_alloc_pkt_t) &ethernetif_intr_enhance_mode_allocate_pkt_callback,
    734              .free                   = &ethernetif_free_pkt,
    735              .advance_pkt_hdr        = &lwip_advance_pkt_hdr,
    736              .deliver_inband         = &connsys_deliver_inband,
    737              .deliver_tcpip          = &lwip_deliver_tcpip,
    738          };
    739          
    740          void ethernetif_init_callback(void)
    741          {
    742              inband_queue_register_callback(inband_handle_func);
    743              connsys_ops = &lwip_connsys_ops;
    744              connsys_enable_interrupt();
    745              //pkt_lock_init(NULL);
    746          }
    747          
    748          /**
    749           * Should be called at the beginning of the program to set up the
    750           * network interface. It calls the function low_level_init() to do the
    751           * actual setup of the hardware.
    752           *
    753           * This function should be passed as a parameter to netif_add().
    754           *
    755           * @param netif the lwip network interface structure for this ethernetif
    756           * @return ERR_OK if the loopif is initialized
    757           *         ERR_MEM if private data couldn't be allocated
    758           *         any other err_t on error
    759           */
    760          err_t
    761          ethernetif_init1(struct netif *netif)
    762          {
    763            struct ethernetif *ethernetif;
    764          
    765            LWIP_ASSERT("netif != NULL", (netif != NULL));
    766          
    767            ethernetif = mem_malloc(sizeof(struct ethernetif));
    768            if (ethernetif == NULL) {
    769              LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
    770              return ERR_MEM;
    771            }
    772          
    773          #if LWIP_NETIF_HOSTNAME
    774            /* Initialize interface hostname */
    775            netif->hostname = "lwip";
    776          #endif /* LWIP_NETIF_HOSTNAME */
    777          
    778            /*
    779             * Initialize the snmp variables and counters inside the struct netif.
    780             * The last argument should be replaced with your link speed, in units
    781             * of bits per second.
    782             */
    783            NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
    784          
    785            netif->state = ethernetif;
    786            netif->name[0] = IFNAME00;
    787            netif->name[1] = IFNAME01;
    788            /* We directly use etharp_output() here to save a function call.
    789             * You can instead declare your own function an call etharp_output()
    790             * from it if you have to do some checks before sending (e.g. if link
    791             * is available...) */
    792            netif->output = etharp_output;
    793            #if LWIP_IPV6
    794            netif->output_ip6 = ethip6_output;
    795            #endif /* LWIP_IPV6 */
    796            netif->linkoutput = (netif_linkoutput_fn)low_level_output_scatter;
    797          
    798            ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
    799          
    800            /* initialize the hardware */
    801            low_level_init1(netif);
    802          
    803          #if 0
    804            /* Create a task that simulates an interrupt in a real system.  This will
    805            block waiting for packets, then send a message to the uIP task when data
    806            is available. */
    807          
    808            LOG_I(lwip, "Create RX task\n\r");
    809            xTaskCreate(InterruptSimulator, "RX", 400, (void *)netif, 3, NULL );
    810          #endif
    811            return ERR_OK;
    812          }
    813          
    814          err_t
    815          ethernetif_init2(struct netif *netif)
    816          {
    817            struct ethernetif *ethernetif;
    818          
    819            LWIP_ASSERT("netif != NULL", (netif != NULL));
    820          
    821            ethernetif = mem_malloc(sizeof(struct ethernetif));
    822            if (ethernetif == NULL) {
    823              LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
    824              return ERR_MEM;
    825            }
    826          
    827          #if LWIP_NETIF_HOSTNAME
    828            /* Initialize interface hostname */
    829            netif->hostname = "lwip";
    830          #endif /* LWIP_NETIF_HOSTNAME */
    831          
    832            /*
    833             * Initialize the snmp variables and counters inside the struct netif.
    834             * The last argument should be replaced with your link speed, in units
    835             * of bits per second.
    836             */
    837            NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
    838          
    839            netif->state = ethernetif;
    840            netif->name[0] = IFNAME10;
    841            netif->name[1] = IFNAME11;
    842            /* We directly use etharp_output() here to save a function call.
    843             * You can instead declare your own function an call etharp_output()
    844             * from it if you have to do some checks before sending (e.g. if link
    845             * is available...) */
    846            netif->output = etharp_output;
    847            #if LWIP_IPV6
    848            netif->output_ip6 = ethip6_output;
    849            #endif /* LWIP_IPV6 */
    850            netif->linkoutput = (netif_linkoutput_fn)low_level_output_scatter;
    851          
    852            ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
    853          
    854            /* initialize the hardware */
    855            low_level_init2(netif);
    856          
    857          #if 0
    858            /* Create a task that simulates an interrupt in a real system.  This will
    859            block waiting for packets, then send a message to the uIP task when data
    860            is available. */
    861          
    862            LOG_I(lwip, "Create RX task\n\r");
    863            xTaskCreate(InterruptSimulator, "RX", 400, (void *)netif, 3, NULL );
    864          #endif
    865            return ERR_OK;
    866          }
    867          
    868          int ethernet_raw_pkt_sender(unsigned char *buf, unsigned int len, struct netif *netif)
    869          {
    870              struct pbuf *p;
    871              int ret = 0;
    872          
    873              p = pbuf_alloc(PBUF_RAW_TX, len, PBUF_POOL);
    874              if (p == NULL)
    875              {
    876                  LOG_E(lwip, "%s pbuf_alloc fail\n\r", __FUNCTION__);
    877                  return -1;
    878              }
    879              memcpy(p->payload, buf, len);
    880          
    881              ret = low_level_output_scatter(netif, p);
    882              pbuf_free(p);
    883              return ret;
    884          }
    885          
    886          void ethernetif_intr_enhance_mode_allocate_pkt_callback(
    887                                      unsigned int allocate_len,
    888                                      void** pkt_ptr,
    889                                      unsigned char** payload_ptr)
    890          {
    891              struct pbuf *p;
    892          
    893              /* We allocate a pbuf chain of pbufs from the pool. */
    894          #if (CFG_CONNSYS_TRX_BALANCE_EN == 1)
    895          
    896              if (g_balance_ctr.balance_en == TRUE)
    897              {
    898                  if (connsys_balance_check_rx_yield())
    899                  {
    900                      vTaskPrioritySet(NULL, (TCPIP_THREAD_PRIO - 1));
    901                      if (g_balance_ctr.tx_handle)
    902                          vTaskPrioritySet((TaskHandle_t)g_balance_ctr.tx_handle, TCPIP_THREAD_PRIO);
    903                  }
    904                  else
    905                  {
    906                      vTaskPrioritySet(NULL, TCPIP_THREAD_PRIO);
    907                  }
    908                  p = pbuf_alloc(PBUF_RAW, (ssize_t)allocate_len, PBUF_RAM);
    909          
    910                  if (p)
    911                  {
    912                      (*pkt_ptr) = p;
    913                      (*payload_ptr) = p->payload;
    914                  }
    915                  else
    916                  {
    917                      (*pkt_ptr) = NULL;
    918                      (*payload_ptr) = NULL;
    919                      vTaskPrioritySet(NULL, (TCPIP_THREAD_PRIO - 1));
    920                      if (g_balance_ctr.tx_handle)
    921                          vTaskPrioritySet((TaskHandle_t)g_balance_ctr.tx_handle, TCPIP_THREAD_PRIO);
    922                  }
    923              }
    924              else
    925              {
    926                  p = pbuf_alloc(PBUF_RAW, (ssize_t)allocate_len, PBUF_RAM);
    927                  if (p)
    928                  {
    929                      (*pkt_ptr) = p;
    930                      (*payload_ptr) = p->payload;
    931                      vTaskPrioritySet(NULL, TCPIP_THREAD_PRIO);
    932                  }
    933                  else
    934                  {
    935                      (*pkt_ptr) = NULL;
    936                      (*payload_ptr) = NULL;
    937                      vTaskPrioritySet(NULL, TCPIP_THREAD_PRIO - 1);
    938                  }
    939              }
    940          #else
    941              p = pbuf_alloc(PBUF_RAW, (ssize_t)allocate_len, PBUF_RAM);
    942              if (p)
    943              {
    944                  (*pkt_ptr) = p;
    945                  (*payload_ptr) = p->payload;
    946                  //vTaskPrioritySet(NULL, TCPIP_THREAD_PRIO);
    947              }
    948              else
    949              {
    950                  (*pkt_ptr) = NULL;
    951                  (*payload_ptr) = NULL;
    952                  //vTaskPrioritySet(NULL, (TCPIP_THREAD_PRIO - 1));
    953              }
    954          #endif /* (CFG_CONNSYS_TRX_BALANCE_EN == 1) */
    955          }
    956          
    957          
    958          #if defined(MTK_WIFI_STUB_CONF_ENABLE) && (!MTK_WIFI_STUB_CONF_SPIM_ENABLE && !MTK_WIFI_STUB_CONF_SDIO_MSDC_ENABLE && !MTK_WFC_WITH_LWIP_NO_WIFI_ENABLE)
    959          void ethernetif_intr_enhance_mode_dispatch(struct pbuf *p, struct netif *netif)
    960          {
    961              struct pbuf *q;
    962              uint32_t total_len = 0;
    963          	
    964              for(q = p; q != NULL; q = q->next) {
    965                  total_len = total_len + (q->len);        
    966              }
    967                       
    968          #if (!MTK_WIFI_STUB_CONF_SPIM_ENABLE && !MTK_WIFI_STUB_CONF_SDIO_MSDC_ENABLE)
    969              //printf("[HRX]:lwip <- S(%d)\r\n",total_len);
    970              wfc_send_to_host((void *)p, total_len); 
    971          #else	
    972              //printf("[HRX]:lwip <- S(%d)\r\n",total_len);
    973              wfcm_to_slave(6, (void *)p, total_len, NULL, NULL, 0); 	
    974          #endif			
    975          }
    976          
    977          #else
    978          
    979          void
    980          ethernetif_intr_enhance_mode_dispatch(struct pbuf *p, struct netif *netif)
    981          {
    982            //struct ethernetif *ethernetif;
    983          
    984            struct eth_hdr *ethhdr;
    985          
    986            //ethernetif = netif->state;
    987            /* move received packet into a new pbuf */
    988          
    989            /* no packet could be read, silently ignore this */
    990            if (p == NULL) return;
    991            /* points to packet payload, which starts with an Ethernet header */
    992            ethhdr = p->payload;
    993          
    994            switch (htons(ethhdr->type)) {
    995            /* IP or ARP packet? */
    996            case ETHTYPE_IP:
    997          #if LWIP_IPV6
    998            case ETHTYPE_IPV6:
    999          #endif
   1000            case ETHTYPE_ARP:
   1001          #if PPPOE_SUPPORT
   1002            /* PPPoE packet? */
   1003            case ETHTYPE_PPPOEDISC:
   1004            case ETHTYPE_PPPOE:
   1005          #endif /* PPPOE_SUPPORT */
   1006              /* full packet send to tcpip_thread to process */
   1007              if (netif->input(p, netif) != ERR_OK)
   1008               { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
   1009                 pbuf_free(p);
   1010                 p = NULL;
   1011               }
   1012              break;
   1013          #if 1 // for wpa_supplicant eapol packets
   1014            case 0x888E:
   1015          #ifndef RELAY
   1016              if((p->len > 12) && (g_lwip_eapol_rx_socket >= 0) && (g_lwip_eapol_rx_socket_second >= 0)) {
   1017                      struct sockaddr_in    to;
   1018                      ssize_t               len;
   1019          
   1020                      //LOG_I(lwip,"<<Dual interface RX EAPOL (Len=%d)>>\n", p->len);
   1021          
   1022                      to.sin_family      = PF_INET;
   1023                      to.sin_addr.s_addr = htonl((127 << 24) | 1);
   1024          
   1025                      if ((IFNAME10 == netif->name[0]) && (IFNAME11 == netif->name[1])) {
   1026                          to.sin_port = htons(66);
   1027                          //LOG_I(lwip,"send to AP socket[%d]...\n", g_lwip_eapol_rx_socket);
   1028                          LWIP_DEBUGF(NETIF_DEBUG, ("send to AP socket: %d\n",  g_lwip_eapol_rx_socket));
   1029                          len = lwip_sendto(g_lwip_eapol_rx_socket, p->payload, p->len, 0, (struct sockaddr *)&to, sizeof(to));
   1030                      } else {
   1031                          to.sin_port = htons(76);
   1032                          //LOG_I(lwip,"send to STA socket[%d]...\n", g_lwip_eapol_rx_socket_second);
   1033                          LWIP_DEBUGF(NETIF_DEBUG, ("send to STA socket: %d\n", g_lwip_eapol_rx_socket_second));
   1034                          len = lwip_sendto(g_lwip_eapol_rx_socket_second, p->payload, p->len, 0, (struct sockaddr *)&to, sizeof(to));
   1035                      }
   1036          
   1037                      if (len != p->len)
   1038                          LOG_E(lwip,"Dual interface eapol-rx relay sendto failed!\n");
   1039              }//dual interface
   1040              else if ((p->len > 12) && (g_lwip_eapol_rx_socket >= 0))
   1041              {
   1042                  struct sockaddr_in    to;
   1043                  ssize_t               len;
   1044          
   1045                  //LOG_I(lwip, "<<RX EAPOL (Len=%d)>>\n", p->len);
   1046          
   1047                  to.sin_family      = PF_INET;
   1048                  to.sin_addr.s_addr = htonl((127 << 24) | 1);
   1049          
   1050                  to.sin_port        = htons(66);
   1051                  //LOG_I(lwip, "send to socket[%d]...\n", g_lwip_eapol_rx_socket);
   1052                  LWIP_DEBUGF(NETIF_DEBUG, ("send to socket: %d%d\n",  p->len, g_lwip_eapol_rx_socket));
   1053                  len = lwip_sendto(g_lwip_eapol_rx_socket, p->payload, p->len, 0, (struct sockaddr *)&to, sizeof(to));
   1054          
   1055                  if (len != p->len)
   1056                      LOG_E(lwip, "Single interface eapol-rx relay sendto failed!\n");
   1057              }
   1058          
   1059              pbuf_free(p);
   1060              p = NULL;
   1061          #else
   1062              if (p->len > 0) {
   1063                  // TODO: relay
   1064              }
   1065          #endif
   1066              break;
   1067          #endif
   1068            default:
   1069              pbuf_free(p);
   1070              p = NULL;
   1071              break;
   1072            }
   1073          }
   1074          #endif
   1075          
   1076          #define MAX_CONNSYS_RX_ZERO_CP_PKT_CONTENT 128
   1077          
   1078          PKT_HANDLE_RESULT_T lwip_deliver_tcpip(void* pkt, uint8_t *payload, uint32_t len, int inf)
   1079          {
   1080              struct pbuf *p = (struct pbuf *) pkt;
   1081              struct netif *netif = &sta_if;
   1082          
   1083              if(p != NULL){
   1084                  //int i;
   1085          
   1086                  if (inf == 1)
   1087                      netif = &ap_if;
   1088          
   1089                  LINK_STATS_INC(link.recv);
   1090                  ethernetif_intr_enhance_mode_dispatch(p, netif);
   1091          
   1092                  return PKT_HANDLE_NON_COMPLETE;
   1093              }else{
   1094                  LOG_E(lwip, "%s pbuf NULL\n\r", __FUNCTION__);
   1095                  LINK_STATS_INC(link.memerr);
   1096                  LINK_STATS_INC(link.drop);
   1097                  return PKT_HANDLE_COMPLETE;
   1098              }
   1099          }
   1100          
   1101          
   1102          void inband_handle_func(void* pkt_ptr, unsigned char *payload, unsigned int len)
   1103          {
   1104              struct pbuf *p = (struct pbuf *) pkt_ptr;
   1105          
   1106              inband_queue_handler(pkt_ptr, payload, len);
   1107              pbuf_free(p);
   1108              pkt_ptr = NULL;
   1109          }
   1110          
   1111          void ethernetif_free_pkt(void *pkt_ptr)
   1112          {
   1113              pbuf_free((struct pbuf*)pkt_ptr);
   1114          }
   1115          
   1116          uint8_t enqueue_bottom_half_from_isr(int32_t port, PNETFUNC func)
   1117          {
   1118              return NetJobAddFromISR(func, 0, 0);
   1119          }
   1120          
   1121          void ethernetif_init(sta_ip_mode_t sta_ip_mode,
   1122                               uint8_t *sta_mac_addr,
   1123                               uint8_t *ap_mac_addr,
   1124                               ip4_addr_t *sta_ip_addr, ip4_addr_t *sta_net_mask, ip4_addr_t *sta_gw,
   1125                               ip4_addr_t *ap_ip_addr, ip4_addr_t *ap_net_mask, ip4_addr_t *ap_gw,
   1126                               uint8_t opmode)
   1127          {
   1128          #if defined(MTK_WIFI_STUB_CONF_ENABLE) && (MTK_WIFI_STUB_CONF_SPIM_ENABLE || MTK_WIFI_STUB_CONF_SDIO_MSDC_ENABLE || MTK_WFC_WITH_LWIP_NO_WIFI_ENABLE)
   1129          #if (MTK_WIFI_STUB_CONF_SPIM_ENABLE || MTK_WIFI_STUB_CONF_SDIO_MSDC_ENABLE)
   1130              uint8_t sta_mac_address[6] = {0x00, 0x0c, 0x43, 0x76, 0x86, 0x08}; //Keep the same as WiFi MAC
   1131              uint8_t ap_mac_address[6] = {0x00, 0xd0, 0x59, 0xe1, 0x39, 0x88};
   1132          #else
   1133              uint8_t sta_mac_address[6] = {0x00, 0xd0, 0x59, 0xe1, 0x40, 0x44};
   1134              uint8_t ap_mac_address[6] = {0x00, 0xd0, 0x59, 0xe1, 0x40, 0x66};
   1135          #endif
   1136          
   1137              memset(&sta_if, 0, sizeof(sta_if));
   1138              memset(&ap_if,  0, sizeof(ap_if));
   1139          #else
   1140              uint8_t sta_mac_address[6];
   1141              uint8_t ap_mac_address[6];
   1142          
   1143              /* for patch and fw download */
   1144              ethernetif_init_callback();
   1145          
   1146              memset(&sta_if, 0, sizeof(sta_if));
   1147              memset(&ap_if,  0, sizeof(ap_if));
   1148          
   1149              // Note: *MUST* first add AP, then STA interface, to make STA the first
   1150              //       interface in the link-list: STA -> AP -> NULL.
   1151              if (0 > wifi_config_get_mac_address(WIFI_PORT_STA, (uint8_t *)&sta_mac_address) ||
   1152                  0 > wifi_config_get_mac_address(WIFI_PORT_AP, (uint8_t *)&ap_mac_address)) {
   1153                  LOG_E(lwip, "get mac fail\n\r");
   1154                  return;
   1155              }
   1156          #endif
   1157          
   1158              netif_add(&ap_if, ap_ip_addr, ap_net_mask, ap_gw, NULL,
   1159                        ethernetif_init2, tcpip_input);
   1160              netif_add(&sta_if, sta_ip_addr, sta_net_mask, sta_gw,
   1161                        NULL, ethernetif_init1, tcpip_input);
   1162          
   1163              low_level_set_mac_addr(&ap_if,  ap_mac_address);
   1164              low_level_set_mac_addr(&sta_if, sta_mac_address);
   1165          
   1166              //netif_set_default(&sta_if);
   1167              netif_set_up(&sta_if);
   1168              netif_set_up(&ap_if);
   1169          
   1170              //install default route
   1171              switch (opmode) {
   1172                  case WIFI_MODE_AP_ONLY:
   1173                      netif_set_default(&ap_if);
   1174                      netif_set_link_down(&sta_if);
   1175                      break;
   1176                  case WIFI_MODE_STA_ONLY:
   1177                      netif_set_default(&sta_if);
   1178                      netif_set_link_down(&ap_if);
   1179                      break;
   1180                  case WIFI_MODE_REPEATER:
   1181                      netif_set_default(&sta_if);
   1182                      break;
   1183              }
   1184          }
   1185          
   1186          void lwip_tcpip_init(lwip_tcpip_config_t *tcpip_config, uint8_t opmode)
   1187          {
   1188              lwip_socket_init();
   1189              tcpip_init(NULL, NULL);
   1190              ethernetif_init(STA_IP_MODE_DHCP,
   1191                              NULL,
   1192                              NULL,
   1193                              &tcpip_config->sta_addr,
   1194                              &tcpip_config->sta_mask,
   1195                              &tcpip_config->sta_gateway,
   1196                              &tcpip_config->ap_addr,
   1197                              &tcpip_config->ap_mask,
   1198                              &tcpip_config->ap_gateway,
   1199                              opmode);
   1200          }
   1201          
   1202          
   1203          static int lwip_get_netif_name(netif_type_t netif_type, char *name)
   1204          {
   1205              struct netif *netif = NULL;
   1206          
   1207              if (name == NULL) {
   1208                  return 0;
   1209              }
   1210          
   1211              for (netif = netif_list; netif != NULL; netif = netif->next) {
   1212                  if (netif_type == NETIF_TYPE_AP &&
   1213                          IFNAME10 == netif->name[0] &&
   1214                          IFNAME11 == netif->name[1]) {
   1215                      name[0] = IFNAME10;
   1216                      name[1] = IFNAME11;
   1217                      name[2] = '0' + netif->num;
   1218                      return 1;
   1219                  } else if (netif_type == NETIF_TYPE_STA &&
   1220                             IFNAME00 == netif->name[0] &&
   1221                             IFNAME01 == netif->name[1]) {
   1222                      name[0] = IFNAME00;
   1223                      name[1] = IFNAME01;
   1224                      name[2] = '0' + netif->num;
   1225                      return 1;
   1226                  } else if (netif_type == NETIF_TYPE_LOOPBACK &&
   1227                             IFNAME20 == netif->name[0] &&
   1228                             IFNAME21 == netif->name[1]) {
   1229                      name[0] = IFNAME20;
   1230                      name[1] = IFNAME21;
   1231                      name[2] = '0' + netif->num;
   1232                      return 1;
   1233                  }
   1234              }
   1235          
   1236              return 0;
   1237          }
   1238          
   1239          struct netif *netif_find_by_type(netif_type_t netif_type)
   1240          {
   1241              char name[4] = {0};
   1242          
   1243              if (lwip_get_netif_name(netif_type, (char *)name) == 1) {
   1244                  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find_by_type: %c%c\n", name[0], name[1]));
   1245                  return netif_find(name);
   1246              } else {
   1247                  return NULL;
   1248              }
   1249          }
   1250          
   1251          void tcpip_stack_init(tcpip_config_t *tcpip_config, uint8_t opmode)
   1252          {
   1253              lwip_socket_init();
   1254              tcpip_init(NULL, NULL);
   1255              ethernetif_init(tcpip_config->sta_ip_mode,
   1256                              tcpip_config->sta_mac_addr,
   1257                              tcpip_config->ap_mac_addr,
   1258                              &tcpip_config->sta_addr,
   1259                              &tcpip_config->sta_mask,
   1260                              &tcpip_config->sta_gateway,
   1261                              &tcpip_config->ap_addr,
   1262                              &tcpip_config->ap_mask,
   1263                              &tcpip_config->ap_gateway,
   1264                              opmode);
   1265          }
   1266          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   enqueue_bottom_half_from_isr
         8   -> NetJobAddFromISR
       0   enqueue_rx_pkt_lwip
         0   -> ethernetif_intr_enhance_mode_dispatch
      32   ethernet_raw_pkt_sender
        32   -- Indirect call
        32   -> __aeabi_memcpy
        32   -> low_level_output_scatter
        32   -> pbuf_alloc
        32   -> pbuf_free
       0   ethernetif_free_pkt
         0   -> pbuf_free
      56   ethernetif_init
        56   -- Indirect call
        56   -> __aeabi_memset4
        56   -> ethernetif_init_callback
        56   -> low_level_set_mac_addr
        56   -> netif_add
        56   -> netif_set_default
        56   -> netif_set_link_down
        56   -> netif_set_up
        56   -> wifi_config_get_mac_address
       8   ethernetif_init1
         8   -> low_level_init1
         8   -> mem_malloc
         8   -> printf
       8   ethernetif_init2
         8   -> low_level_init2
         8   -> mem_malloc
         8   -> printf
       8   ethernetif_init_callback
         0   -> connsys_enable_interrupt
         8   -> inband_queue_register_callback
      16   ethernetif_intr_enhance_mode_allocate_pkt_callback
        16   -> pbuf_alloc
      40   ethernetif_intr_enhance_mode_dispatch
        40   -- Indirect call
        40   -> lwip_htonl
        40   -> lwip_htons
        40   -> lwip_sendto
        40   -> pbuf_free
       8   inband_handle_func
         8   -> inband_queue_handler
         0   -> pbuf_free
      16   low_level_get_ap_mac_addr
        16   -> __aeabi_memcpy
        16   -> netif_find_name
      16   low_level_get_sta_mac_addr
        16   -> __aeabi_memcpy
        16   -> netif_find_name
       0   low_level_init1
       0   low_level_init2
     168   low_level_output_scatter
       168   -- Indirect call
       168   -> __aeabi_memcpy
       168   -> __aeabi_memset4
       168   -> connsys_dump_tx_scatter_info
       168   -> connsys_get_headroom_offset
       168   -> connsys_tx_flow_control_check_and_update_tx
       168   -> connsys_tx_query_whisr
       168   -> connsys_write_data
       168   -> memcmp
       168   -> printf
       0   low_level_set_mac_addr
         0   -> __aeabi_memcpy
       0   lwip_advance_pkt_hdr
         0   -> pbuf_header
      16   lwip_deliver_tcpip
        16   -- Indirect call
        16   -> ethernetif_intr_enhance_mode_dispatch
      12   lwip_get_netif_name
      40   lwip_tcpip_init
        40   -> ethernetif_init
        40   -> tcpip_init
       8   netif_find_by_type
         8   -> lwip_get_netif_name
         8   -> netif_find
       4   netif_find_name
       0   register_eapol_rx_socket
       4   register_eapol_rx_socket_dual_intf
      40   tcpip_stack_init
        40   -> ethernetif_init
        40   -> tcpip_init
       8   unregister_eapol_rx_socket
         8   -> lwip_close
      16   unregister_eapol_rx_socket_dual_intf
        16   -> lwip_close


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable33_10
       4  ??DataTable33_11
       4  ??DataTable33_12
       4  ??DataTable33_13
       4  ??DataTable33_14
       4  ??DataTable33_2
       4  ??DataTable33_3
       4  ??DataTable33_4
       4  ??DataTable33_5
       4  ??DataTable33_6
       4  ??DataTable33_7
       4  ??DataTable33_8
       4  ??DataTable33_9
       8  ?_0
      64  ?_1
      48  ?_10
      16  ?_11
      16  ?_12
       4  ?_13
      40  ?_2
      24  ?_3
      16  ?_4
      40  ?_5
      16  ?_6
      80  ?_7
      24  ?_8
      48  ?_9
      16  enqueue_bottom_half_from_isr
       2  enqueue_rx_pkt_lwip
      86  ethernet_raw_pkt_sender
       4  ethernetif_free_pkt
     232  ethernetif_init
      84  ethernetif_init1
      84  ethernetif_init2
      28  ethernetif_init_callback
      38  ethernetif_intr_enhance_mode_allocate_pkt_callback
     294  ethernetif_intr_enhance_mode_dispatch
       8  g_lwip_eapol_rx_socket
          g_lwip_eapol_rx_socket_second
      18  inband_handle_func
      50  low_level_get_ap_mac_addr
      50  low_level_get_sta_mac_addr
      14  low_level_init1
      14  low_level_init2
     658  low_level_output_scatter
      12  low_level_set_mac_addr
       8  lwip_advance_pkt_hdr
      24  lwip_connsys_ops
      76  lwip_deliver_tcpip
     134  lwip_get_netif_name
      62  lwip_tcpip_init
      28  netif_find_by_type
      48  netif_find_name
      18  register_eapol_rx_socket
      26  register_eapol_rx_socket_dual_intf
      68  tcpip_stack_init
     140  tx_sequence
          sta_if
          ap_if
      24  unregister_eapol_rx_socket
      36  unregister_eapol_rx_socket_dual_intf
     128  -- Other

 
   140 bytes in section .bss
    32 bytes in section .data
     4 bytes in section .rodata
 2 840 bytes in section .text
 
 2 840 bytes of CODE  memory
     4 bytes of CONST memory
   172 bytes of DATA  memory

Errors: none
Warnings: 7
