###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       27/Jun/2017  22:46:49
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\hal_gpio_7687.c
#    Command line =  
#        -f C:\Users\leo\AppData\Local\Temp\EWDA8F.tmp
#        (C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\hal_gpio_7687.c
#        -lcN
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\i2c_control_EEPROM_with_polling\List
#        -lA
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\i2c_control_EEPROM_with_polling\List
#        --diag_suppress Pa050,Ta022,Ta023 --diag_error Pe606 -o
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\i2c_control_EEPROM_with_polling\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\hal_examples\i2c_control_EEPROM_with_polling\EWARM\..\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\hal_examples\i2c_control_EEPROM_with_polling\EWARM\..\..\..\..\..\driver\chip\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\hal_examples\i2c_control_EEPROM_with_polling\EWARM\..\..\..\..\..\driver\chip\mt7687\inc\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\hal_examples\i2c_control_EEPROM_with_polling\EWARM\..\..\..\..\..\driver\chip\mt7687\src\common\include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\hal_examples\i2c_control_EEPROM_with_polling\EWARM\..\..\..\..\..\driver\CMSIS\Include\
#        -I
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\project\mt7697_hdk\hal_examples\i2c_control_EEPROM_with_polling\EWARM\..\..\..\..\..\driver\CMSIS\Device\MTK\mt7687\Include\
#        -Om -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0_2\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\i2c_control_EEPROM_with_polling\List\hal_gpio_7687.lst
#    Object file  =  
#        C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\out_iar\mt7697_hdk\i2c_control_EEPROM_with_polling\Obj\hal_gpio_7687.o
#
###############################################################################

C:\LEO\myGit\MTK-IOT\SDK_V4.3.0\driver\chip\mt7687\src\common\hal_gpio_7687.c
      1          /* Copyright Statement:
      2           *
      3           * (C) 2005-2016  MediaTek Inc. All rights reserved.
      4           *
      5           * This software/firmware and related documentation ("MediaTek Software") are
      6           * protected under relevant copyright laws. The information contained herein
      7           * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
      8           * Without the prior written permission of MediaTek and/or its licensors,
      9           * any reproduction, modification, use or disclosure of MediaTek Software,
     10           * and information contained herein, in whole or in part, shall be strictly prohibited.
     11           * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
     12           * if you have agreed to and been bound by the applicable license agreement with
     13           * MediaTek ("License Agreement") and been granted explicit permission to do so within
     14           * the License Agreement ("Permitted User").  If you are not a Permitted User,
     15           * please cease any access or use of MediaTek Software immediately.
     16           * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
     17           * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
     18           * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
     19           * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
     20           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
     21           * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
     22           * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
     23           * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
     24           * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
     25           * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
     26           * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
     27           * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
     28           * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
     29           * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
     30           * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
     31           * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
     32           * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
     33           */
     34          
     35          #include "hal_eint.h"
     36          #include "hal_gpio.h"
     37          #if defined(HAL_EINT_MODULE_ENABLED) || defined(HAL_GPIO_MODULE_ENABLED)
     38          
     39          #include <stdio.h>
     40          #include "type_def.h"
     41          #include "hal_gpio_7687.h"
     42          #include "nvic.h"
     43          #include "hal_pinmux.h"
     44          #include "hal_nvic.h"
     45          #include "pinmux.h"
     46          
     47          INT32 halGPIO_ConfDirection(UINT32 GPIO_pin, UINT8 outEnable)
     48          {
     49          
     50              UINT16 no;
     51              UINT16 remainder;
     52              no = GPIO_pin / 32;
     53              remainder = GPIO_pin % 32;
     54              switch (no) {
     55                  case 0:
     56          
     57                      //config GPIO direction
     58                      if (outEnable == 1) {
     59                          if (remainder <= 26) {
     60                              DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_IES0) &= ~(1 << remainder);
     61                          } else if (remainder == 27) {
     62                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK) &= ~(0x2);
     63                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK) |= 0x800;
     64                          } else if (remainder == 28) {
     65                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD) &= ~(0x2);
     66                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD) |= 0x800;
     67                          } else if (remainder == 29) {
     68                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3) &= ~(0x2);
     69                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3) |= 0x800;
     70                          } else if (remainder == 30) {
     71                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2) &= ~(0x2);
     72                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2) |= 0x800;
     73                          } else if (remainder == 31) {
     74                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1) &= ~(0x2);
     75                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1) |= 0x800;
     76                          }
     77          
     78                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_OE1_SET, (1 << remainder));
     79                      } else {
     80          
     81                          if (remainder <= 26) {
     82                              DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_IES0) |= (1 << remainder);
     83                          } else if (remainder == 27) {
     84                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK) |= 0x802;
     85                          } else if (remainder == 28) {
     86                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD) |= 0x802;
     87                          } else if (remainder == 29) {
     88                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3) |= 0x802;
     89                          } else if (remainder == 30) {
     90                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2) |= 0x802;
     91                          } else if (remainder == 31) {
     92                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1) |= 0x802;
     93                          }
     94          
     95          
     96                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_OE1_RESET, (1 << remainder));
     97                      }
     98                      break;
     99                  case 1:
    100          
    101                      //config GPIO direction
    102                      if (outEnable == 1) {
    103                          if (remainder > 0) {
    104                              DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_IES1) &= ~(1 << remainder);
    105                          } else {
    106                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0) &= ~(0x2);
    107                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0) |= 0x800;
    108                          }
    109          
    110                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_OE2_SET, (1 << remainder));
    111                      } else {
    112          
    113                          if (remainder > 0) {
    114                              DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_IES1) |= (1 << remainder);
    115                          } else {
    116                              DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0) |= 0x802;
    117                          }
    118          
    119                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_OE2_RESET, (1 << remainder));
    120                      }
    121                      break;
    122                  default:
    123                      return -1;
    124              }
    125              return 0;
    126          }
    127          
    128          
    129          INT32 halGPO_Write(UINT32 GPIO_pin, UINT8 writeValue)
    130          {
    131              UINT16 no;
    132              UINT16 remainder;
    133              no = GPIO_pin / 32;
    134              remainder = GPIO_pin % 32;
    135              switch (no) {
    136                  case 0:
    137          
    138                      if (writeValue) {
    139                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_DOUT1_SET, (1 << remainder));
    140                      } else {
    141                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_DOUT1_RESET, (1 << remainder));
    142                      }
    143                      break;
    144                  case 1:
    145          
    146                      if (writeValue) {
    147                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_DOUT2_SET, (1 << remainder));
    148                      } else {
    149                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_DOUT2_RESET, (1 << remainder));
    150                      }
    151                      break;
    152                  default:
    153                      return -1;
    154              }
    155              return 0;
    156          }
    157          
    158          
    159          
    160          
    161          
    162          UINT8 halgetGPIO_DOUT(UINT32 GPIO_pin)
    163          {
    164              UINT16 no;
    165              UINT16 remainder;
    166              no = GPIO_pin / 32;
    167              remainder = GPIO_pin % 32;
    168              UINT8 dout = 0;
    169          
    170              switch (no) {
    171                  case 0:
    172                      dout = ((DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_DOUT1) >> remainder) & 1);
    173                      break;
    174                  case 1:
    175                      dout = ((DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_DOUT2) >> remainder) & 1);
    176                      break;
    177                  default:
    178                      return 0;
    179              }
    180              return dout ;
    181          }
    182          UINT8 halgetGPIO_DIN(UINT32 GPIO_pin)
    183          {
    184              UINT16 no;
    185              UINT16 remainder;
    186              no = GPIO_pin / 32;
    187              remainder = GPIO_pin % 32;
    188              UINT8 din = 0;
    189              switch (no) {
    190          
    191                  case 0:
    192                      din = ((DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_DIN1) >> remainder) & 1);
    193                      break;
    194                  case 1:
    195                      din = ((DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_DIN2) >> remainder) & 1);
    196                      break;
    197                  default:
    198                      return 0;
    199          
    200              }
    201              return din;
    202          }
    203          UINT8 halgetGPIO_OutEnable(UINT32 GPIO_pin)
    204          {
    205              UINT16 no;
    206              UINT16 remainder;
    207              no = GPIO_pin / 32;
    208              remainder = GPIO_pin % 32;
    209              UINT8 outEnable = 0;
    210          
    211              switch (no) {
    212                  case 0:
    213                      outEnable = ((DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_OE1) >> remainder) & 1);
    214                      break;
    215                  case 1:
    216                      outEnable = ((DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_OE2) >> remainder) & 1);
    217                      break;
    218                  default:
    219                      return 0;
    220              }
    221              return outEnable;
    222          }
    223          
    224          
    225          INT32 halGPIO_PullUp_SET(UINT32 GPIO_pin)
    226          {
    227              UINT16 no;
    228              UINT16 remainder;
    229              no = GPIO_pin / 32;
    230              remainder = GPIO_pin % 32;
    231              halGPIO_PullDown_RESET(GPIO_pin);
    232              switch (no) {
    233                  case 0:
    234                      if (remainder <= 26) {
    235                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_PU1_SET, (1 << remainder));
    236                      } else if (remainder == 27) {
    237                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK) &= ~(0x7 << 2);
    238                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK) |= 0x804;
    239                      } else if (remainder == 28) {
    240                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD) &= ~(0x7 << 2);
    241                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD) |= 0x804;
    242                      } else if (remainder == 29) {
    243                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3) &= ~(0x7 << 2);
    244                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3) |= 0x804;
    245                      } else if (remainder == 30) {
    246                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2) &= ~(0x7 << 2);
    247                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2) |= 0x804;
    248                      } else if (remainder == 31) {
    249                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1) &= ~(0x7 << 2);
    250                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1) |= 0x804;
    251                      }
    252                      break;
    253                  case 1:
    254                      if (!remainder) {
    255                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0) &= ~(0x7 << 2);
    256                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0) |= 0x804;
    257                      } else {
    258                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_PU2_SET, (1 << remainder));
    259                      }
    260                      break;
    261                  default:
    262                      return -1;
    263              }
    264              return 0;
    265          }
    266          
    267          INT32 halGPIO_PullUp_RESET(UINT32 GPIO_pin)
    268          {
    269              UINT16 no;
    270              UINT16 remainder;
    271              no = GPIO_pin / 32;
    272              remainder = GPIO_pin % 32;
    273          
    274              switch (no) {
    275                  case 0:
    276                      if (remainder <= 26) {
    277                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_PU1_RESET, (1 << remainder));
    278                      } else if (remainder == 27) {
    279                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK) &= ~(0x7 << 2);
    280                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK) |= (1 << 0xB);
    281                      } else if (remainder == 28) {
    282                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD) &= ~(0x7 << 2);
    283                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD) |= (1 << 0xB);
    284                      } else if (remainder == 29) {
    285                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3) &= ~(0x7 << 2);
    286                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3) |= (1 << 0xB);
    287                      } else if (remainder == 30) {
    288                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2) &= ~(0x7 << 2);
    289                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2) |= (1 << 0xB);
    290                      } else if (remainder == 31) {
    291                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1) &= ~(0x7 << 2);
    292                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1) |= (1 << 0xB);
    293                      }
    294                      break;
    295                  case 1:
    296                      if (!remainder) {
    297                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0) &= ~(0x7 << 2);
    298                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0) |= (1 << 0xB);
    299                      } else {
    300                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_PU2_RESET, (1 << remainder));
    301                      }
    302                      break;
    303                  default:
    304                      return -1;
    305              }
    306              return 0;
    307          }
    308          
    309          INT32 halGPIO_PullDown_SET(UINT32 GPIO_pin)
    310          {
    311              UINT16 no;
    312              UINT16 remainder;
    313              no = GPIO_pin / 32;
    314              remainder = GPIO_pin % 32;
    315              halGPIO_PullUp_RESET(GPIO_pin);
    316              switch (no) {
    317                  case 0:
    318                      if (remainder <= 26) {
    319                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_PD1_SET, (1 << remainder));
    320                      } else if (remainder == 27) {
    321                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK) &= ~(0x7 << 2);
    322                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK) |= 0x814;
    323                      } else if (remainder == 28) {
    324                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD) &= ~(0x7 << 2);
    325                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD) |= 0x814;
    326                      } else if (remainder == 29) {
    327                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3) &= ~(0x7 << 2);
    328                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3) |= 0x814;
    329                      } else if (remainder == 30) {
    330                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2) &= ~(0x7 << 2);
    331                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2) |= 0x814;
    332                      } else if (remainder == 31) {
    333                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1) &= ~(0x7 << 2);
    334                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1) |= 0x814;
    335                      }
    336                      break;
    337                  case 1:
    338                      if (!remainder) {
    339                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0) &= ~(0x7 << 2);
    340                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0) |= 0x814;
    341                      } else {
    342                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_PD2_SET, (1 << remainder));
    343                      }
    344                      break;
    345                  default:
    346                      return -1;
    347          
    348              }
    349              return 0;
    350          }
    351          
    352          INT32 halGPIO_PullDown_RESET(UINT32 GPIO_pin)
    353          {
    354          
    355              UINT16 no;
    356              UINT16 remainder;
    357              no = GPIO_pin / 32;
    358              remainder = GPIO_pin % 32;
    359          
    360              switch (no) {
    361                  case 0:
    362                      if (remainder <= 26) {
    363                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_PD1_RESET, (1 << remainder));
    364                      } else if (remainder == 27) {
    365                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK) &= ~(0x7 << 2);
    366                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK) |= (1 << 0xB);
    367                      } else if (remainder == 28) {
    368                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD) &= ~(0x7 << 2);
    369                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD) |= (1 << 0xB);
    370                      } else if (remainder == 29) {
    371                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3) &= ~(0x7 << 2);
    372                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3) |= (1 << 0xB);
    373                      } else if (remainder == 30) {
    374                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2) &= ~(0x7 << 2);
    375                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2) |= (1 << 0xB);
    376                      } else if (remainder == 31) {
    377                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1) &= ~(0x7 << 2);
    378                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1) |= (1 << 0xB);
    379                      }
    380                      break;
    381                  case 1:
    382                      if (!remainder) {
    383                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0) &= ~(0x7 << 2);
    384                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0) |= (1 << 0xB);
    385                      } else {
    386                          DRV_WriteReg32(IOT_GPIO_AON_BASE + IOT_GPIO_PD2_RESET, (1 << remainder));
    387                      }
    388                      break;
    389                  default:
    390                      return -1;
    391          
    392              }
    393              return 0;
    394          }
    395          
    396          
    397          INT32 halGPIO_SetDriving(UINT32 GPIO_pin, UINT8 GPIO_driving)
    398          {
    399              UINT16 no;
    400              UINT16 remainder;
    401              no = GPIO_pin / 16;
    402              remainder = GPIO_pin % 16;
    403          
    404              switch (no) {
    405                  case 0:
    406                      DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_PADDRV1) &= ~(0x3 << (remainder * 2));
    407                      DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_PADDRV1) |= ((GPIO_driving / 4 - 1) << (remainder * 2));
    408                      break;
    409                  case 1:
    410                      if (remainder < 11) {
    411                          DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_PADDRV2) &= ~(0x3 << (remainder * 2));
    412                          DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_PADDRV2) |= ((GPIO_driving / 4 - 1) << (remainder * 2));
    413                      } else if (remainder == 11) {
    414                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK) &= ~(0x7 << 6);
    415                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK) |= ((GPIO_driving / 2 - 1) << 6);
    416                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK) |= (1 << 0xB);
    417                      } else if (remainder == 12) {
    418                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD) &= ~(0x7 << 6);
    419                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD) |= ((GPIO_driving / 2 - 1) << 6);
    420                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD) |= (1 << 0xB);
    421                      } else if (remainder == 13) {
    422                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3) &= ~(0x7 << 6);
    423                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3) |= ((GPIO_driving / 2 - 1) << 6);
    424                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3) |= (1 << 0xB);
    425                      } else if (remainder == 14) {
    426                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2) &= ~(0x7 << 6);
    427                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2) |= ((GPIO_driving / 2 - 1) << 6);
    428                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2) |= (1 << 0xB);
    429                      } else if (remainder == 15) {
    430                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1) &= ~(0x7 << 6);
    431                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1) |= ((GPIO_driving / 2 - 1) << 6);
    432                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1) |= (1 << 0xB);
    433                      }
    434                      break;
    435                  case 2:
    436                      if (!remainder) {
    437                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0) &= ~(0x7 << 6);
    438                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0) |= ((GPIO_driving / 2 - 1) << 6);
    439                          DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0) |= (1 << 0xB);
    440                      } else {
    441                          DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_PADDRV3) &= ~(0x3 << (remainder * 2));
    442                          DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_PADDRV3) |= ((GPIO_driving / 4 - 1) << (remainder * 2));
    443                      }
    444                      break;
    445                  case 3:
    446                      DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_PADDRV4) &= ~(0x3 << (remainder * 2));
    447                      DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_PADDRV4) |= ((GPIO_driving / 4 - 1) << (remainder * 2));
    448                      break;
    449                  default:
    450                      return -1;
    451              }
    452              return 0;
    453          }
    454          
    455          
    456          INT32 halGPIO_GetDriving(UINT32 GPIO_pin, UINT8 *GPIO_driving)
    457          {
    458              UINT16 no;
    459              UINT16 remainder;
    460              UINT32 temp;
    461              no = GPIO_pin / 16;
    462              remainder = GPIO_pin % 16;
    463          
    464              switch (no) {
    465                  case 0:
    466                      temp = DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_PADDRV1);
    467                      temp &= (0x3 << (remainder * 2));
    468                      *GPIO_driving = (1 + (temp >> (remainder * 2))) * 4;
    469                      break;
    470                  case 1:
    471                      if (remainder < 11) {
    472                          temp = DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_PADDRV2);
    473                          temp &= (0x3 << (remainder * 2));
    474                          *GPIO_driving = (1 + (temp >> (remainder * 2))) * 4;
    475                      } else if (remainder == 11) {
    476                          temp = DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CLK);
    477                          temp &= 0x1C0;
    478                          *GPIO_driving = ((temp >> 0x6) + 1) * 2;
    479                      } else if (remainder == 12) {
    480                          temp = DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_CMD);
    481                          temp &= 0x1C0;
    482                          *GPIO_driving = ((temp >> 0x6) + 1) * 2;
    483                      } else if (remainder == 13) {
    484                          temp = DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA3);
    485                          temp &= 0x1C0;
    486                          *GPIO_driving = ((temp >> 0x6) + 1) * 2;
    487                      } else if (remainder == 14) {
    488                          temp = DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA2);
    489                          temp &= 0x1C0;
    490                          *GPIO_driving = ((temp >> 0x6) + 1) * 2;
    491                      } else if (remainder == 15) {
    492                          temp = DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA1);
    493                          temp &= 0x1C0;
    494                          *GPIO_driving = ((temp >> 0x6) + 1) * 2;
    495                      }
    496                      break;
    497                  case 2:
    498                      if (!remainder) {
    499                          temp = DRV_Reg32(IOT_GPIO_PINMUX_AON_BASE + IOT_GPIO_SDIO_DATA0);
    500                          temp &= 0x1C0;
    501                          *GPIO_driving = ((temp >> 0x6) + 1) * 2;
    502                      } else {
    503                          temp = DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_PADDRV3);
    504                          temp &= (0x3 << (remainder * 2));
    505                          *GPIO_driving = (1 + (temp >> (remainder * 2))) * 4;
    506                      }
    507                      break;
    508                  case 3:
    509                      temp = DRV_Reg32(IOT_GPIO_AON_BASE + IOT_GPIO_PADDRV4);
    510                      temp &= (0x3 << (remainder * 2));
    511                      *GPIO_driving = (1 + (temp >> (remainder * 2))) * 4;
    512                      break;
    513                  default:
    514                      return -1;
    515              }
    516              return 0;
    517          }
    518          
    519          void topPAD_Control_GPIO(UINT32 GPIO_pin, ENUM_TOP_PAD_CONTROL_T ePadControl)
    520          {
    521          
    522              UINT16 no;
    523              UINT16 remainder;
    524              no = GPIO_pin / 32;
    525              remainder = GPIO_pin % 32;
    526          
    527              if (ePAD_CONTROL_BY_CM4 == ePadControl) {
    528          
    529                  switch (no) {
    530                      case 0:
    531                          DRV_Reg32(IOT_GPIO_PAD_CTRL0) |= (1 << remainder);
    532                          break;
    533                      case 1:
    534                          DRV_Reg32(IOT_GPIO_PAD_CTRL1) |= (1 << remainder);
    535                          break;
    536                      default:
    537                          break;
    538                  }
    539          
    540              } else if (ePAD_CONTROL_BY_N9 == ePadControl) {
    541                  switch (no) {
    542                      case 0:
    543                          DRV_Reg32(IOT_GPIO_PAD_CTRL0) &= ~(1 << remainder);
    544                          break;
    545                      case 1:
    546                          DRV_Reg32(IOT_GPIO_PAD_CTRL1) &= ~(1 << remainder);
    547                          break;
    548                      default:
    549                          break;
    550                  }
    551          
    552              }
    553          }
    554          
    555          
    556          #if 1
    557          
    558          static GPI_LISR_Struct LISR;
    559          
    560          void drvGPIO_IDX_0_LISR(hal_nvic_irq_t irq_number)
    561          {
    562          
    563              LISR.gpiLisr_func.GPIO_IDX_0_LISR((ENUM_IOT_GPIO_NAME_T)ePAD_ANTSEL0);
    564          
    565              //mSetHWEntry(CM4_WIC_SW_CLR, 1);   //this pin has no NVIC wake up function, so no need to clear WIC pending/enable status
    566              //mSetHWEntry(CM4_WIC_SW_CLR, 0);
    567          }
    568          
    569          void drvGPIO_IDX_1_LISR(hal_nvic_irq_t irq_number)
    570          {
    571          
    572              LISR.gpiLisr_func.GPIO_IDX_1_LISR((ENUM_IOT_GPIO_NAME_T)ePAD_ANTSEL1);
    573          
    574          
    575              //mSetHWEntry(CM4_WIC_SW_CLR, 1);   //this pin has no NVIC wake up function, so no need to clear WIC pending/enable status
    576              //mSetHWEntry(CM4_WIC_SW_CLR, 0);
    577          }
    578          
    579          void drvGPIO_IDX_3_LISR(hal_nvic_irq_t irq_number)
    580          {
    581          
    582              LISR.gpiLisr_func.GPIO_IDX_3_LISR((ENUM_IOT_GPIO_NAME_T)ePAD_ANTSEL3);
    583          
    584          
    585              //mSetHWEntry(CM4_WIC_SW_CLR, 1);   //this pin has no NVIC wake up function, so no need to clear WIC pending/enable status
    586              //mSetHWEntry(CM4_WIC_SW_CLR, 0);
    587          }
    588          
    589          void drvGPIO_IDX_4_LISR(hal_nvic_irq_t irq_number)
    590          {
    591          
    592              LISR.gpiLisr_func.GPIO_IDX_4_LISR((ENUM_IOT_GPIO_NAME_T)ePAD_ANTSEL4);
    593          
    594          
    595              //mSetHWEntry(CM4_WIC_SW_CLR, 1);   //this pin has no NVIC wake up function, so no need to clear WIC pending/enable status
    596              //mSetHWEntry(CM4_WIC_SW_CLR, 0);
    597          }
    598          
    599          
    600          void drvGPIO_IDX_5_LISR(hal_nvic_irq_t irq_number)
    601          {
    602          
    603              LISR.gpiLisr_func.GPIO_IDX_5_LISR((ENUM_IOT_GPIO_NAME_T)ePAD_ANTSEL5);
    604          
    605          
    606              //mSetHWEntry(CM4_WIC_SW_CLR, 1);   //this pin has no NVIC wake up function, so no need to clear WIC pending/enable status
    607              //mSetHWEntry(CM4_WIC_SW_CLR, 0);
    608          }
    609          
    610          void drvGPIO_IDX_6_LISR(hal_nvic_irq_t irq_number)
    611          {
    612          
    613              LISR.gpiLisr_func.GPIO_IDX_6_LISR((ENUM_IOT_GPIO_NAME_T)ePAD_ANTSEL6);
    614          
    615          
    616              //mSetHWEntry(CM4_WIC_SW_CLR, 1);   //this pin has no NVIC wake up function, so no need to clear WIC pending/enable status
    617              //mSetHWEntry(CM4_WIC_SW_CLR, 0);
    618          }
    619          
    620          void drvGPIO_IDX_7_LISR(hal_nvic_irq_t irq_number)
    621          {
    622          
    623              LISR.gpiLisr_func.GPIO_IDX_7_LISR((ENUM_IOT_GPIO_NAME_T)ePAD_ANTSEL7);
    624          
    625          
    626              //mSetHWEntry(CM4_WIC_SW_CLR, 1);   //this pin has no NVIC wake up function, so no need to clear WIC pending/enable status
    627              //mSetHWEntry(CM4_WIC_SW_CLR, 0);
    628          }
    629          
    630          void drvGPIO_IDX_35_LISR(hal_nvic_irq_t irq_number)
    631          {
    632          
    633              LISR.gpiLisr_func.GPIO_IDX_35_LISR((ENUM_IOT_GPIO_NAME_T)ePAD_UART_DBG);
    634          
    635          
    636              //mSetHWEntry(CM4_WIC_SW_CLR, 1);   //this pin has no NVIC wake up function, so no need to clear WIC pending/enable status
    637              //mSetHWEntry(CM4_WIC_SW_CLR, 0);
    638          }
    639          
    640          void drvGPIO_IDX_37_LISR(hal_nvic_irq_t irq_number)
    641          {
    642          
    643              LISR.gpiLisr_func.GPIO_IDX_37_LISR((ENUM_IOT_GPIO_NAME_T)ePAD_UART_TX);
    644          
    645          
    646              //mSetHWEntry(CM4_WIC_SW_CLR, 1);   //this pin has no NVIC wake up function, so no need to clear WIC pending/enable status
    647              //mSetHWEntry(CM4_WIC_SW_CLR, 0);
    648          }
    649          
    650          
    651          void drvGPIO_IDX_38_LISR(hal_nvic_irq_t irq_number)
    652          {
    653          
    654              LISR.gpiLisr_func.GPIO_IDX_38_LISR((ENUM_IOT_GPIO_NAME_T)ePAD_UART_RTS);
    655          
    656          
    657              //mSetHWEntry(CM4_WIC_SW_CLR, 1);   //this pin has no NVIC wake up function, so no need to clear WIC pending/enable status
    658              //mSetHWEntry(CM4_WIC_SW_CLR, 0);
    659          }
    660          
    661          void drvGPIO_IDX_39_LISR(hal_nvic_irq_t irq_number)
    662          {
    663          
    664              LISR.gpiLisr_func.GPIO_IDX_39_LISR((ENUM_IOT_GPIO_NAME_T)ePAD_UART_CTS);
    665          
    666          
    667              //mSetHWEntry(CM4_WIC_SW_CLR, 1);   //this pin has no NVIC wake up function, so no need to clear WIC pending/enable status
    668              //mSetHWEntry(CM4_WIC_SW_CLR, 0);
    669          }
    670          
    671          INT32 halRegGPInterrupt(UINT32 pad_name,
    672                                  UINT8 edgeLevelTrig,
    673                                  UINT8 debounceEnable,
    674                                  UINT8 polarity,
    675                                  UINT8 dual,
    676                                  UINT8 prescaler,
    677                                  UINT8 u1PrescalerCount,
    678                                  void (*USER_GPI_Handler)(ENUM_IOT_GPIO_NAME_T pin))
    679          {
    680          
    681              switch (pad_name) {
    682                  case ePAD_ANTSEL0:
    683          
    684                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_0_IRQ);
    685                      halPinmuxTopOnPadFunc(ePAD_ANTSEL0, 3);  //set value 3 is for EINT
    686                      mSetHWEntry(IOT_GPIO0_DEBOUNCE_CNT, u1PrescalerCount);
    687                      mSetHWEntry(IOT_GPIO0_DEBOUNCE_PRESCALER, prescaler);
    688                      mSetHWEntry(IOT_GPIO0_DEBOUNCE_DUAL, dual);
    689                      mSetHWEntry(IOT_GPIO0_DEBOUNCE_POLARITY, polarity);
    690                      mSetHWEntry(IOT_GPIO0_DEBOUNCE_EN, debounceEnable);
    691                      mSetHWEntry(IOT_GPIO0_NVIC_SENSE, edgeLevelTrig);
    692          
    693                      //clear pending status?
    694                      mSetHWEntry(IOT_GPIO0_NVIC_CLR_PEND, 1);   //DE Ethan suggest sequence
    695          
    696                      //mSetHWEntry(IOT_GPIO0_NVIC_EN, 1);   //DE Ethan suggest sequence
    697                      LISR.gpiLisr_func.GPIO_IDX_0_LISR = USER_GPI_Handler;
    698                      hal_nvic_register_isr_handler((IRQn_Type)CM4_EINT_0_IRQ, drvGPIO_IDX_0_LISR);
    699                      NVIC_SetPriority((IRQn_Type)CM4_EINT_0_IRQ, CM4_EINT_0_PRI);
    700                      //NVIC_EnableIRQ((IRQn_Type)CM4_EINT_0_IRQ);
    701                      break;
    702          
    703                  case ePAD_ANTSEL1:
    704          
    705                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_1_IRQ);
    706                      halPinmuxTopOnPadFunc(ePAD_ANTSEL1, 3);  //set value 3 is for EINT
    707                      mSetHWEntry(IOT_GPIO1_DEBOUNCE_CNT, u1PrescalerCount);
    708                      mSetHWEntry(IOT_GPIO1_DEBOUNCE_PRESCALER, prescaler);
    709                      mSetHWEntry(IOT_GPIO1_DEBOUNCE_DUAL, dual);
    710                      mSetHWEntry(IOT_GPIO1_DEBOUNCE_POLARITY, polarity);
    711                      mSetHWEntry(IOT_GPIO1_DEBOUNCE_EN, debounceEnable);
    712                      mSetHWEntry(IOT_GPIO1_NVIC_SENSE, edgeLevelTrig);
    713          
    714                      //clear pending status?
    715                      mSetHWEntry(IOT_GPIO1_NVIC_CLR_PEND, 1);   //DE Ethan suggest sequence
    716          
    717                      //mSetHWEntry(IOT_GPIO1_NVIC_EN, 1);   //DE Ethan suggest sequence
    718                      LISR.gpiLisr_func.GPIO_IDX_1_LISR = USER_GPI_Handler;
    719                      hal_nvic_register_isr_handler((IRQn_Type)CM4_EINT_1_IRQ, drvGPIO_IDX_1_LISR);
    720                      NVIC_SetPriority((IRQn_Type)CM4_EINT_1_IRQ, CM4_EINT_1_PRI);
    721                      //NVIC_EnableIRQ((IRQn_Type)CM4_EINT_1_IRQ);
    722                      break;
    723          
    724                  case ePAD_ANTSEL3:
    725          
    726                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_2_IRQ);
    727                      halPinmuxTopOnPadFunc(ePAD_ANTSEL3, 3);  //set value 3 is for EINT
    728                      mSetHWEntry(IOT_GPIO3_DEBOUNCE_CNT, u1PrescalerCount);
    729                      mSetHWEntry(IOT_GPIO3_DEBOUNCE_PRESCALER, prescaler);
    730                      mSetHWEntry(IOT_GPIO3_DEBOUNCE_DUAL, dual);
    731                      mSetHWEntry(IOT_GPIO3_DEBOUNCE_POLARITY, polarity);
    732                      mSetHWEntry(IOT_GPIO3_DEBOUNCE_EN, debounceEnable);
    733                      mSetHWEntry(IOT_GPIO3_NVIC_SENSE, edgeLevelTrig);
    734          
    735                      //clear pending status?
    736                      mSetHWEntry(IOT_GPIO3_NVIC_CLR_PEND, 1);   //DE Ethan suggest sequence
    737          
    738                      //mSetHWEntry(IOT_GPIO3_NVIC_EN, 1);   //DE Ethan suggest sequence
    739                      LISR.gpiLisr_func.GPIO_IDX_3_LISR = USER_GPI_Handler;
    740                      hal_nvic_register_isr_handler((IRQn_Type)CM4_EINT_2_IRQ, drvGPIO_IDX_3_LISR);
    741                      NVIC_SetPriority((IRQn_Type)CM4_EINT_2_IRQ, CM4_EINT_2_PRI);
    742                      //NVIC_EnableIRQ((IRQn_Type)CM4_EINT_2_IRQ);
    743                      break;
    744          
    745                  case ePAD_ANTSEL4:
    746          
    747                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_3_IRQ);
    748                      halPinmuxTopOnPadFunc(ePAD_ANTSEL4, 3);  //set value 3 is for EINT
    749                      mSetHWEntry(IOT_GPIO4_DEBOUNCE_CNT, u1PrescalerCount);
    750                      mSetHWEntry(IOT_GPIO4_DEBOUNCE_PRESCALER, prescaler);
    751                      mSetHWEntry(IOT_GPIO4_DEBOUNCE_DUAL, dual);
    752                      mSetHWEntry(IOT_GPIO4_DEBOUNCE_POLARITY, polarity);
    753                      mSetHWEntry(IOT_GPIO4_DEBOUNCE_EN, debounceEnable);
    754                      mSetHWEntry(IOT_GPIO4_NVIC_SENSE, edgeLevelTrig);
    755          
    756                      //clear pending status?
    757                      mSetHWEntry(IOT_GPIO4_NVIC_CLR_PEND, 1);   //DE Ethan suggest sequence
    758          
    759                      //mSetHWEntry(IOT_GPIO4_NVIC_EN, 1);   //DE Ethan suggest sequence
    760                      LISR.gpiLisr_func.GPIO_IDX_4_LISR = USER_GPI_Handler;
    761                      hal_nvic_register_isr_handler((IRQn_Type)CM4_EINT_3_IRQ, drvGPIO_IDX_4_LISR);
    762                      NVIC_SetPriority((IRQn_Type)CM4_EINT_3_IRQ, CM4_EINT_3_PRI);
    763                      //NVIC_EnableIRQ((IRQn_Type)CM4_EINT_3_IRQ);
    764                      break;
    765                  case ePAD_ANTSEL5:
    766          
    767                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_4_IRQ);
    768                      halPinmuxTopOnPadFunc(ePAD_ANTSEL5, 3);  //set value 3 is for EINT
    769                      mSetHWEntry(IOT_GPIO5_DEBOUNCE_CNT, u1PrescalerCount);
    770                      mSetHWEntry(IOT_GPIO5_DEBOUNCE_PRESCALER, prescaler);
    771                      mSetHWEntry(IOT_GPIO5_DEBOUNCE_DUAL, dual);
    772                      mSetHWEntry(IOT_GPIO5_DEBOUNCE_POLARITY, polarity);
    773                      mSetHWEntry(IOT_GPIO5_DEBOUNCE_EN, debounceEnable);
    774                      mSetHWEntry(IOT_GPIO5_NVIC_SENSE, edgeLevelTrig);
    775          
    776                      //clear pending status?
    777                      mSetHWEntry(IOT_GPIO5_NVIC_CLR_PEND, 1);   //DE Ethan suggest sequence
    778          
    779                      //mSetHWEntry(IOT_GPIO5_NVIC_EN, 1);   //DE Ethan suggest sequence
    780                      LISR.gpiLisr_func.GPIO_IDX_5_LISR = USER_GPI_Handler;
    781                      hal_nvic_register_isr_handler((IRQn_Type)CM4_EINT_4_IRQ, drvGPIO_IDX_5_LISR);
    782                      NVIC_SetPriority((IRQn_Type)CM4_EINT_4_IRQ, CM4_EINT_4_PRI);
    783                      //NVIC_EnableIRQ((IRQn_Type)CM4_EINT_4_IRQ);
    784                      break;
    785          
    786                  case ePAD_ANTSEL6:
    787          
    788                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_5_IRQ);
    789                      halPinmuxTopOnPadFunc(ePAD_ANTSEL6, 3);  //set value 3 is for EINT
    790                      mSetHWEntry(IOT_GPIO6_DEBOUNCE_CNT, u1PrescalerCount);
    791                      mSetHWEntry(IOT_GPIO6_DEBOUNCE_PRESCALER, prescaler);
    792                      mSetHWEntry(IOT_GPIO6_DEBOUNCE_DUAL, dual);
    793                      mSetHWEntry(IOT_GPIO6_DEBOUNCE_POLARITY, polarity);
    794                      mSetHWEntry(IOT_GPIO6_DEBOUNCE_EN, debounceEnable);
    795                      mSetHWEntry(IOT_GPIO6_NVIC_SENSE, edgeLevelTrig);
    796          
    797                      //clear pending status?
    798                      mSetHWEntry(IOT_GPIO6_NVIC_CLR_PEND, 1);   //DE Ethan suggest sequence
    799          
    800                      //mSetHWEntry(IOT_GPIO6_NVIC_EN, 1);   //DE Ethan suggest sequence
    801                      LISR.gpiLisr_func.GPIO_IDX_6_LISR = USER_GPI_Handler;
    802                      hal_nvic_register_isr_handler((IRQn_Type)CM4_EINT_5_IRQ, drvGPIO_IDX_6_LISR);
    803                      NVIC_SetPriority((IRQn_Type)CM4_EINT_5_IRQ, CM4_EINT_5_PRI);
    804                      //NVIC_EnableIRQ((IRQn_Type)CM4_EINT_5_IRQ);
    805                      break;
    806          
    807                  case ePAD_ANTSEL7:
    808          
    809                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_6_IRQ);
    810                      halPinmuxTopOnPadFunc(ePAD_ANTSEL7, 3);  //set value 3 is for EINT
    811                      mSetHWEntry(IOT_GPIO7_DEBOUNCE_CNT, u1PrescalerCount);
    812                      mSetHWEntry(IOT_GPIO7_DEBOUNCE_PRESCALER, prescaler);
    813                      mSetHWEntry(IOT_GPIO7_DEBOUNCE_DUAL, dual);
    814                      mSetHWEntry(IOT_GPIO7_DEBOUNCE_POLARITY, polarity);
    815                      mSetHWEntry(IOT_GPIO7_DEBOUNCE_EN, debounceEnable);
    816                      mSetHWEntry(IOT_GPIO7_NVIC_SENSE, edgeLevelTrig);
    817          
    818                      //clear pending status?
    819                      mSetHWEntry(IOT_GPIO7_NVIC_CLR_PEND, 1);   //DE Ethan suggest sequence
    820          
    821                      //mSetHWEntry(IOT_GPIO7_NVIC_EN, 1);   //DE Ethan suggest sequence
    822                      LISR.gpiLisr_func.GPIO_IDX_7_LISR = USER_GPI_Handler;
    823                      hal_nvic_register_isr_handler((IRQn_Type)CM4_EINT_6_IRQ, drvGPIO_IDX_7_LISR);
    824                      NVIC_SetPriority((IRQn_Type)CM4_EINT_6_IRQ, CM4_EINT_6_PRI);
    825                      //NVIC_EnableIRQ((IRQn_Type)CM4_EINT_6_IRQ);
    826                      break;
    827          
    828                  case ePAD_UART_DBG:
    829          
    830                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_19_IRQ);
    831                      halPinmuxTopOnPadFunc(ePAD_UART_DBG, 3);  //set value 3 is for EINT
    832                      mSetHWEntry(IOT_GPIO35_DEBOUNCE_CNT, u1PrescalerCount);
    833                      mSetHWEntry(IOT_GPIO35_DEBOUNCE_PRESCALER, prescaler);
    834                      mSetHWEntry(IOT_GPIO35_DEBOUNCE_DUAL, dual);
    835                      mSetHWEntry(IOT_GPIO35_DEBOUNCE_POLARITY, polarity);
    836                      mSetHWEntry(IOT_GPIO35_DEBOUNCE_EN, debounceEnable);
    837                      mSetHWEntry(IOT_GPIO35_NVIC_SENSE, edgeLevelTrig);
    838          
    839                      //clear pending status?
    840                      mSetHWEntry(IOT_GPIO35_NVIC_CLR_PEND, 1);   //DE Ethan suggest sequence
    841          
    842                      //mSetHWEntry(IOT_GPIO35_NVIC_EN, 1);   //DE Ethan suggest sequence
    843                      LISR.gpiLisr_func.GPIO_IDX_35_LISR = USER_GPI_Handler;
    844                      hal_nvic_register_isr_handler((IRQn_Type)CM4_EINT_19_IRQ, drvGPIO_IDX_35_LISR);
    845                      NVIC_SetPriority((IRQn_Type)CM4_EINT_19_IRQ, CM4_EINT_19_PRI);
    846                      //NVIC_EnableIRQ((IRQn_Type)CM4_EINT_19_IRQ);
    847                      break;
    848          
    849                  case ePAD_UART_TX:
    850          
    851                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_20_IRQ);
    852                      halPinmuxTopOnPadFunc(ePAD_UART_TX, 3);  //set value 3 is for EINT
    853                      mSetHWEntry(IOT_GPIO37_DEBOUNCE_CNT, u1PrescalerCount);
    854                      mSetHWEntry(IOT_GPIO37_DEBOUNCE_PRESCALER, prescaler);
    855                      mSetHWEntry(IOT_GPIO37_DEBOUNCE_DUAL, dual);
    856                      mSetHWEntry(IOT_GPIO37_DEBOUNCE_POLARITY, polarity);
    857                      mSetHWEntry(IOT_GPIO37_DEBOUNCE_EN, debounceEnable);
    858                      mSetHWEntry(IOT_GPIO37_NVIC_SENSE, edgeLevelTrig);
    859          
    860                      //clear pending status?
    861                      mSetHWEntry(IOT_GPIO37_NVIC_CLR_PEND, 1);   //DE Ethan suggest sequence
    862          
    863                      //mSetHWEntry(IOT_GPIO37_NVIC_EN, 1);   //DE Ethan suggest sequence
    864                      LISR.gpiLisr_func.GPIO_IDX_37_LISR = USER_GPI_Handler;
    865                      hal_nvic_register_isr_handler((IRQn_Type)CM4_EINT_20_IRQ, drvGPIO_IDX_37_LISR);
    866                      NVIC_SetPriority((IRQn_Type)CM4_EINT_20_IRQ, CM4_EINT_20_PRI);
    867                      //NVIC_EnableIRQ((IRQn_Type)CM4_EINT_20_IRQ);
    868                      break;
    869          
    870                  case ePAD_UART_RTS:
    871          
    872                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_21_IRQ);
    873                      halPinmuxTopOnPadFunc(ePAD_UART_RTS, 3);  //set value 3 is for EINT
    874                      mSetHWEntry(IOT_GPIO38_DEBOUNCE_CNT, u1PrescalerCount);
    875                      mSetHWEntry(IOT_GPIO38_DEBOUNCE_PRESCALER, prescaler);
    876                      mSetHWEntry(IOT_GPIO38_DEBOUNCE_DUAL, dual);
    877                      mSetHWEntry(IOT_GPIO38_DEBOUNCE_POLARITY, polarity);
    878                      mSetHWEntry(IOT_GPIO38_DEBOUNCE_EN, debounceEnable);
    879                      mSetHWEntry(IOT_GPIO38_NVIC_SENSE, edgeLevelTrig);
    880          
    881                      //clear pending status?
    882                      mSetHWEntry(IOT_GPIO38_NVIC_CLR_PEND, 1);   //DE Ethan suggest sequence
    883          
    884                      //mSetHWEntry(IOT_GPIO38_NVIC_EN, 1);   //DE Ethan suggest sequence
    885                      LISR.gpiLisr_func.GPIO_IDX_38_LISR = USER_GPI_Handler;
    886                      hal_nvic_register_isr_handler((IRQn_Type)CM4_EINT_21_IRQ, drvGPIO_IDX_38_LISR);
    887                      NVIC_SetPriority((IRQn_Type)CM4_EINT_21_IRQ, CM4_EINT_21_PRI);
    888                      //NVIC_EnableIRQ((IRQn_Type)CM4_EINT_21_IRQ);
    889                      break;
    890          
    891                  case ePAD_UART_CTS:
    892          
    893                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_22_IRQ);
    894                      halPinmuxTopOnPadFunc(ePAD_UART_CTS, 3);  //set value 3 is for EINT
    895                      mSetHWEntry(IOT_GPIO39_DEBOUNCE_CNT, u1PrescalerCount);
    896                      mSetHWEntry(IOT_GPIO39_DEBOUNCE_PRESCALER, prescaler);
    897                      mSetHWEntry(IOT_GPIO39_DEBOUNCE_DUAL, dual);
    898                      mSetHWEntry(IOT_GPIO39_DEBOUNCE_POLARITY, polarity);
    899                      mSetHWEntry(IOT_GPIO39_DEBOUNCE_EN, debounceEnable);
    900                      mSetHWEntry(IOT_GPIO39_NVIC_SENSE, edgeLevelTrig);
    901          
    902                      //clear pending status?
    903                      mSetHWEntry(IOT_GPIO39_NVIC_CLR_PEND, 1);   //DE Ethan suggest sequence
    904          
    905                      //mSetHWEntry(IOT_GPIO39_NVIC_EN, 1);   //DE Ethan suggest sequence
    906                      LISR.gpiLisr_func.GPIO_IDX_39_LISR = USER_GPI_Handler;
    907                      hal_nvic_register_isr_handler((IRQn_Type)CM4_EINT_22_IRQ, drvGPIO_IDX_39_LISR);
    908                      NVIC_SetPriority((IRQn_Type)CM4_EINT_22_IRQ, CM4_EINT_22_PRI);
    909                      //NVIC_EnableIRQ((IRQn_Type)CM4_EINT_22_IRQ);
    910                      break;
    911                  default:
    912                      return -1;
    913              }
    914              return 0;
    915          }
    916          
    917          
    918          INT32 halRegGPInterrupt_set_triggermode(UINT32 pad_name,UINT8 edgeLevelTrig,UINT8 polarity,UINT8 dual) 
    919          {
    920               switch (pad_name) {
    921                   case ePAD_ANTSEL0: 
    922                       NVIC_DisableIRQ((IRQn_Type)CM4_EINT_0_IRQ);
    923                       mSetHWEntry(IOT_GPIO0_DEBOUNCE_DUAL, dual);
    924                       mSetHWEntry(IOT_GPIO0_DEBOUNCE_POLARITY, polarity);
    925                       mSetHWEntry(IOT_GPIO0_NVIC_SENSE, edgeLevelTrig);
    926                       mSetHWEntry(IOT_GPIO0_NVIC_CLR_PEND, 1);
    927                       NVIC_EnableIRQ((IRQn_Type)CM4_EINT_0_IRQ);
    928                       break;
    929           
    930                   case ePAD_ANTSEL1: 
    931                       NVIC_DisableIRQ((IRQn_Type)CM4_EINT_1_IRQ);
    932                       mSetHWEntry(IOT_GPIO1_DEBOUNCE_DUAL, dual);
    933                       mSetHWEntry(IOT_GPIO1_DEBOUNCE_POLARITY, polarity);
    934                       mSetHWEntry(IOT_GPIO1_NVIC_SENSE, edgeLevelTrig);
    935                       mSetHWEntry(IOT_GPIO1_NVIC_CLR_PEND, 1);
    936                       NVIC_EnableIRQ((IRQn_Type)CM4_EINT_1_IRQ);
    937                       break;
    938           
    939                   case ePAD_ANTSEL3: 
    940                       NVIC_DisableIRQ((IRQn_Type)CM4_EINT_2_IRQ);
    941                       mSetHWEntry(IOT_GPIO3_DEBOUNCE_DUAL, dual);
    942                       mSetHWEntry(IOT_GPIO3_DEBOUNCE_POLARITY, polarity);
    943                       mSetHWEntry(IOT_GPIO3_NVIC_SENSE, edgeLevelTrig);
    944                       mSetHWEntry(IOT_GPIO3_NVIC_CLR_PEND, 1);
    945                       NVIC_EnableIRQ((IRQn_Type)CM4_EINT_2_IRQ);
    946                       break;
    947           
    948                   case ePAD_ANTSEL4: 
    949                       NVIC_DisableIRQ((IRQn_Type)CM4_EINT_3_IRQ);
    950                       mSetHWEntry(IOT_GPIO4_DEBOUNCE_DUAL, dual);
    951                       mSetHWEntry(IOT_GPIO4_DEBOUNCE_POLARITY, polarity);
    952                       mSetHWEntry(IOT_GPIO4_NVIC_SENSE, edgeLevelTrig);
    953                       mSetHWEntry(IOT_GPIO4_NVIC_CLR_PEND, 1); 
    954                       NVIC_EnableIRQ((IRQn_Type)CM4_EINT_3_IRQ);
    955                       break;
    956                   case ePAD_ANTSEL5: 
    957                       NVIC_DisableIRQ((IRQn_Type)CM4_EINT_4_IRQ);
    958                       mSetHWEntry(IOT_GPIO5_DEBOUNCE_DUAL, dual);
    959                       mSetHWEntry(IOT_GPIO5_DEBOUNCE_POLARITY, polarity);
    960                       mSetHWEntry(IOT_GPIO5_NVIC_SENSE, edgeLevelTrig);
    961                       mSetHWEntry(IOT_GPIO5_NVIC_CLR_PEND, 1);
    962                       NVIC_EnableIRQ((IRQn_Type)CM4_EINT_4_IRQ);
    963                       break;
    964           
    965                   case ePAD_ANTSEL6: 
    966                       NVIC_DisableIRQ((IRQn_Type)CM4_EINT_5_IRQ);
    967                       mSetHWEntry(IOT_GPIO6_DEBOUNCE_DUAL, dual);
    968                       mSetHWEntry(IOT_GPIO6_DEBOUNCE_POLARITY, polarity);
    969                       mSetHWEntry(IOT_GPIO6_NVIC_SENSE, edgeLevelTrig);
    970                       mSetHWEntry(IOT_GPIO6_NVIC_CLR_PEND, 1);
    971                       NVIC_EnableIRQ((IRQn_Type)CM4_EINT_5_IRQ);
    972                       break;
    973           
    974                   case ePAD_ANTSEL7: 
    975                       NVIC_DisableIRQ((IRQn_Type)CM4_EINT_6_IRQ);
    976                       mSetHWEntry(IOT_GPIO7_DEBOUNCE_DUAL, dual);
    977                       mSetHWEntry(IOT_GPIO7_DEBOUNCE_POLARITY, polarity);
    978                       mSetHWEntry(IOT_GPIO7_NVIC_SENSE, edgeLevelTrig);
    979                       mSetHWEntry(IOT_GPIO7_NVIC_CLR_PEND, 1); 
    980                       NVIC_EnableIRQ((IRQn_Type)CM4_EINT_6_IRQ);
    981                       break;
    982           
    983                   case ePAD_UART_DBG: 
    984                       NVIC_DisableIRQ((IRQn_Type)CM4_EINT_19_IRQ);
    985                       mSetHWEntry(IOT_GPIO35_DEBOUNCE_DUAL, dual);
    986                       mSetHWEntry(IOT_GPIO35_DEBOUNCE_POLARITY, polarity);
    987                       mSetHWEntry(IOT_GPIO35_NVIC_SENSE, edgeLevelTrig);
    988                       mSetHWEntry(IOT_GPIO35_NVIC_CLR_PEND, 1);
    989                       NVIC_EnableIRQ((IRQn_Type)CM4_EINT_19_IRQ);
    990                       break;
    991           
    992                   case ePAD_UART_TX: 
    993                       NVIC_DisableIRQ((IRQn_Type)CM4_EINT_20_IRQ);
    994                       halPinmuxTopOnPadFunc(ePAD_UART_TX, 3); 
    995                       mSetHWEntry(IOT_GPIO37_DEBOUNCE_DUAL, dual);
    996                       mSetHWEntry(IOT_GPIO37_DEBOUNCE_POLARITY, polarity);
    997                       mSetHWEntry(IOT_GPIO37_NVIC_SENSE, edgeLevelTrig);
    998                       mSetHWEntry(IOT_GPIO37_NVIC_CLR_PEND, 1);
    999                       NVIC_EnableIRQ((IRQn_Type)CM4_EINT_20_IRQ);
   1000                       break;
   1001           
   1002                   case ePAD_UART_RTS: 
   1003                       NVIC_DisableIRQ((IRQn_Type)CM4_EINT_21_IRQ);
   1004                       mSetHWEntry(IOT_GPIO38_DEBOUNCE_DUAL, dual);
   1005                       mSetHWEntry(IOT_GPIO38_DEBOUNCE_POLARITY, polarity);
   1006                       mSetHWEntry(IOT_GPIO38_NVIC_SENSE, edgeLevelTrig);
   1007                       mSetHWEntry(IOT_GPIO38_NVIC_CLR_PEND, 1); 
   1008                       NVIC_EnableIRQ((IRQn_Type)CM4_EINT_21_IRQ);
   1009                       break;
   1010           
   1011                   case ePAD_UART_CTS: 
   1012                       NVIC_DisableIRQ((IRQn_Type)CM4_EINT_22_IRQ);
   1013                       mSetHWEntry(IOT_GPIO39_DEBOUNCE_DUAL, dual);
   1014                       mSetHWEntry(IOT_GPIO39_DEBOUNCE_POLARITY, polarity);
   1015                       mSetHWEntry(IOT_GPIO39_NVIC_SENSE, edgeLevelTrig);
   1016                       mSetHWEntry(IOT_GPIO39_NVIC_CLR_PEND, 1); 
   1017                       NVIC_EnableIRQ((IRQn_Type)CM4_EINT_22_IRQ);
   1018                       break;
   1019                   default:
   1020                       return -1;
   1021               }
   1022               return 0;
   1023          }
   1024          	
   1025          
   1026          INT32 halRegGPInterrupt_set_debounce(UINT32 pad_name,UINT8 debounceEnable,UINT8 prescaler,uint8_t u1PrescalerCount)
   1027          {
   1028              switch (pad_name) {
   1029                  case ePAD_ANTSEL0:
   1030                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_0_IRQ);
   1031                      mSetHWEntry(IOT_GPIO0_DEBOUNCE_CNT, u1PrescalerCount);
   1032                      mSetHWEntry(IOT_GPIO0_DEBOUNCE_PRESCALER, prescaler);
   1033                      mSetHWEntry(IOT_GPIO0_DEBOUNCE_EN, debounceEnable);
   1034                      mSetHWEntry(IOT_GPIO0_NVIC_CLR_PEND, 1); 
   1035                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_0_IRQ);
   1036                      break;
   1037          
   1038                  case ePAD_ANTSEL1:
   1039                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_1_IRQ);
   1040                      mSetHWEntry(IOT_GPIO1_DEBOUNCE_CNT, u1PrescalerCount);
   1041                      mSetHWEntry(IOT_GPIO1_DEBOUNCE_PRESCALER, prescaler);
   1042                      mSetHWEntry(IOT_GPIO1_DEBOUNCE_EN, debounceEnable);
   1043                      mSetHWEntry(IOT_GPIO1_NVIC_CLR_PEND, 1);
   1044                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_1_IRQ);
   1045                      break;
   1046          
   1047                  case ePAD_ANTSEL3:
   1048                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_2_IRQ);
   1049                      mSetHWEntry(IOT_GPIO3_DEBOUNCE_CNT, u1PrescalerCount);
   1050                      mSetHWEntry(IOT_GPIO3_DEBOUNCE_PRESCALER, prescaler);
   1051                      mSetHWEntry(IOT_GPIO3_DEBOUNCE_EN, debounceEnable);
   1052                      mSetHWEntry(IOT_GPIO3_NVIC_CLR_PEND, 1);
   1053                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_2_IRQ);
   1054                      break;
   1055          
   1056                  case ePAD_ANTSEL4:
   1057                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_3_IRQ);
   1058                      mSetHWEntry(IOT_GPIO4_DEBOUNCE_CNT, u1PrescalerCount);
   1059                      mSetHWEntry(IOT_GPIO4_DEBOUNCE_PRESCALER, prescaler);
   1060                      mSetHWEntry(IOT_GPIO4_DEBOUNCE_EN, debounceEnable);
   1061                      mSetHWEntry(IOT_GPIO4_NVIC_CLR_PEND, 1); 
   1062                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_3_IRQ);
   1063                      break;
   1064                  case ePAD_ANTSEL5:
   1065                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_4_IRQ);
   1066                      mSetHWEntry(IOT_GPIO5_DEBOUNCE_CNT, u1PrescalerCount);
   1067                      mSetHWEntry(IOT_GPIO5_DEBOUNCE_PRESCALER, prescaler);
   1068                      mSetHWEntry(IOT_GPIO5_DEBOUNCE_EN, debounceEnable);
   1069                      mSetHWEntry(IOT_GPIO5_NVIC_CLR_PEND, 1);
   1070                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_4_IRQ);
   1071                      break;
   1072          
   1073                  case ePAD_ANTSEL6:
   1074                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_5_IRQ);
   1075                      mSetHWEntry(IOT_GPIO6_DEBOUNCE_CNT, u1PrescalerCount);
   1076                      mSetHWEntry(IOT_GPIO6_DEBOUNCE_PRESCALER, prescaler);
   1077                      mSetHWEntry(IOT_GPIO6_DEBOUNCE_EN, debounceEnable);
   1078                      mSetHWEntry(IOT_GPIO6_NVIC_CLR_PEND, 1); 
   1079                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_5_IRQ);
   1080                      break;
   1081          
   1082                  case ePAD_ANTSEL7:
   1083                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_6_IRQ);
   1084                      mSetHWEntry(IOT_GPIO7_DEBOUNCE_CNT, u1PrescalerCount);
   1085                      mSetHWEntry(IOT_GPIO7_DEBOUNCE_PRESCALER, prescaler);
   1086                      mSetHWEntry(IOT_GPIO7_DEBOUNCE_EN, debounceEnable);
   1087                      mSetHWEntry(IOT_GPIO7_NVIC_CLR_PEND, 1);
   1088                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_6_IRQ);
   1089                      break;
   1090          
   1091                  case ePAD_UART_DBG:
   1092                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_19_IRQ);
   1093                      mSetHWEntry(IOT_GPIO35_DEBOUNCE_CNT, u1PrescalerCount);
   1094                      mSetHWEntry(IOT_GPIO35_DEBOUNCE_PRESCALER, prescaler);
   1095                      mSetHWEntry(IOT_GPIO35_DEBOUNCE_EN, debounceEnable);
   1096                      mSetHWEntry(IOT_GPIO35_NVIC_CLR_PEND, 1);
   1097                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_19_IRQ);
   1098                      break;
   1099          
   1100                  case ePAD_UART_TX:
   1101                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_20_IRQ);
   1102                      mSetHWEntry(IOT_GPIO37_DEBOUNCE_CNT, u1PrescalerCount);
   1103                      mSetHWEntry(IOT_GPIO37_DEBOUNCE_PRESCALER, prescaler);
   1104                      mSetHWEntry(IOT_GPIO37_DEBOUNCE_EN, debounceEnable);
   1105                      mSetHWEntry(IOT_GPIO37_NVIC_CLR_PEND, 1); 
   1106                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_20_IRQ);
   1107                      break;
   1108          
   1109                  case ePAD_UART_RTS:
   1110                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_21_IRQ);
   1111                      mSetHWEntry(IOT_GPIO38_DEBOUNCE_CNT, u1PrescalerCount);
   1112                      mSetHWEntry(IOT_GPIO38_DEBOUNCE_PRESCALER, prescaler);
   1113                      mSetHWEntry(IOT_GPIO38_DEBOUNCE_EN, debounceEnable);
   1114                      mSetHWEntry(IOT_GPIO38_NVIC_CLR_PEND, 1); 
   1115                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_21_IRQ);
   1116                      break;
   1117          
   1118                  case ePAD_UART_CTS:
   1119                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_22_IRQ);
   1120                      mSetHWEntry(IOT_GPIO39_DEBOUNCE_CNT, u1PrescalerCount);
   1121                      mSetHWEntry(IOT_GPIO39_DEBOUNCE_PRESCALER, prescaler);
   1122                      mSetHWEntry(IOT_GPIO39_DEBOUNCE_EN, debounceEnable);
   1123                      mSetHWEntry(IOT_GPIO39_NVIC_CLR_PEND, 1); 
   1124                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_22_IRQ);
   1125                      break;
   1126                  default:
   1127                      return -1;
   1128              }
   1129              return 0;
   1130          }
   1131          
   1132          INT32 halRegGPInterrupt_mask(UINT32 pad_name)
   1133          {
   1134              switch (pad_name) {
   1135                  case ePAD_ANTSEL0:
   1136                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_0_IRQ);
   1137                      break;
   1138          
   1139                  case ePAD_ANTSEL1:
   1140                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_1_IRQ);
   1141                      break;
   1142          
   1143                  case ePAD_ANTSEL3:
   1144                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_2_IRQ);
   1145                      break;
   1146          
   1147                  case ePAD_ANTSEL4:
   1148                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_3_IRQ);
   1149                      break;
   1150                  case ePAD_ANTSEL5:
   1151                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_4_IRQ);
   1152                      break;
   1153          
   1154                  case ePAD_ANTSEL6:
   1155                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_5_IRQ);
   1156                      break;
   1157          
   1158                  case ePAD_ANTSEL7:
   1159                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_6_IRQ);
   1160                      break;
   1161          
   1162                  case ePAD_UART_DBG:
   1163                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_19_IRQ);
   1164                      break;
   1165          
   1166                  case ePAD_UART_TX:
   1167                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_20_IRQ);
   1168                      break;
   1169          
   1170                  case ePAD_UART_RTS:
   1171                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_21_IRQ);
   1172                      break;
   1173          
   1174                  case ePAD_UART_CTS:
   1175                      NVIC_DisableIRQ((IRQn_Type)CM4_EINT_22_IRQ);
   1176                      break;
   1177                  default:
   1178                      return -1;
   1179              }
   1180              return 0;
   1181          }
   1182          
   1183          INT32 halRegGPInterrupt_unmask(UINT32 pad_name)
   1184          {
   1185              switch (pad_name) {
   1186                  case ePAD_ANTSEL0:
   1187                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_0_IRQ);
   1188                      break;
   1189          
   1190                  case ePAD_ANTSEL1:
   1191                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_1_IRQ);
   1192                      break;
   1193          
   1194                  case ePAD_ANTSEL3:
   1195                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_2_IRQ);
   1196                      break;
   1197          
   1198                  case ePAD_ANTSEL4:
   1199                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_3_IRQ);
   1200                      break;
   1201                  case ePAD_ANTSEL5:
   1202                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_4_IRQ);
   1203                      break;
   1204          
   1205                  case ePAD_ANTSEL6:
   1206                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_5_IRQ);
   1207                      break;
   1208          
   1209                  case ePAD_ANTSEL7:
   1210                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_6_IRQ);
   1211                      break;
   1212          
   1213                  case ePAD_UART_DBG:
   1214                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_19_IRQ);
   1215                      break;
   1216          
   1217                  case ePAD_UART_TX:
   1218                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_20_IRQ);
   1219                      break;
   1220          
   1221                  case ePAD_UART_RTS:
   1222                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_21_IRQ);
   1223                      break;
   1224          
   1225                  case ePAD_UART_CTS:
   1226                      NVIC_EnableIRQ((IRQn_Type)CM4_EINT_22_IRQ);
   1227                      break;
   1228                  default:
   1229                      return -1;
   1230              }
   1231              return 0;
   1232          }
   1233          
   1234          static void software_trigger_irq(UINT32 irq_number)
   1235          {
   1236              NVIC->STIR = (irq_number << NVIC_STIR_INTID_Pos) & NVIC_STIR_INTID_Msk;
   1237          }
   1238          
   1239          INT32 halRegGP_set_software_trigger(UINT32 pad_name)
   1240          {
   1241              switch (pad_name) {
   1242                  case ePAD_ANTSEL0:
   1243                  	   software_trigger_irq((IRQn_Type)CM4_EINT_0_IRQ);
   1244                      break;
   1245          
   1246                  case ePAD_ANTSEL1:
   1247                  	   software_trigger_irq((IRQn_Type)CM4_EINT_1_IRQ);
   1248                      break;
   1249          
   1250                  case ePAD_ANTSEL3:
   1251                  	   software_trigger_irq((IRQn_Type)CM4_EINT_2_IRQ);
   1252                      break;
   1253          
   1254                  case ePAD_ANTSEL4:
   1255                  	   software_trigger_irq((IRQn_Type)CM4_EINT_3_IRQ);
   1256                      break;
   1257                  case ePAD_ANTSEL5:
   1258                  	   software_trigger_irq((IRQn_Type)CM4_EINT_4_IRQ);
   1259                      break;
   1260          
   1261                  case ePAD_ANTSEL6:
   1262                  	   software_trigger_irq((IRQn_Type)CM4_EINT_5_IRQ);
   1263                      break;
   1264          
   1265                  case ePAD_ANTSEL7:
   1266                  	   software_trigger_irq((IRQn_Type)CM4_EINT_6_IRQ);
   1267                      break;
   1268          
   1269                  case ePAD_UART_DBG:
   1270                  	   software_trigger_irq((IRQn_Type)CM4_EINT_19_IRQ);
   1271                      break;
   1272          
   1273                  case ePAD_UART_TX:
   1274                  	   software_trigger_irq((IRQn_Type)CM4_EINT_20_IRQ);
   1275                      break;
   1276          
   1277                  case ePAD_UART_RTS:
   1278                  	   software_trigger_irq((IRQn_Type)CM4_EINT_21_IRQ);
   1279                      break;
   1280          
   1281                  case ePAD_UART_CTS:
   1282                  	   software_trigger_irq((IRQn_Type)CM4_EINT_22_IRQ);
   1283                      break;
   1284                  default:
   1285                      return -1;
   1286              }
   1287              return 0;
   1288          }
   1289          
   1290          INT32 halRegGP_clear_software_trigger(UINT32 pad_name)
   1291          {
   1292              switch (pad_name) {
   1293                  case ePAD_ANTSEL0:
   1294                  	   NVIC_ClearPendingIRQ((IRQn_Type)CM4_EINT_0_IRQ);
   1295                      break;
   1296          
   1297                  case ePAD_ANTSEL1:
   1298                  	   NVIC_ClearPendingIRQ((IRQn_Type)CM4_EINT_1_IRQ);
   1299                      break;
   1300          
   1301                  case ePAD_ANTSEL3:
   1302                  	   NVIC_ClearPendingIRQ((IRQn_Type)CM4_EINT_2_IRQ);
   1303                      break;
   1304          
   1305                  case ePAD_ANTSEL4:
   1306                  	   NVIC_ClearPendingIRQ((IRQn_Type)CM4_EINT_3_IRQ);
   1307                      break;
   1308                  case ePAD_ANTSEL5:
   1309                  	   NVIC_ClearPendingIRQ((IRQn_Type)CM4_EINT_4_IRQ);
   1310                      break;
   1311          
   1312                  case ePAD_ANTSEL6:
   1313                  	   NVIC_ClearPendingIRQ((IRQn_Type)CM4_EINT_5_IRQ);
   1314                      break;
   1315          
   1316                  case ePAD_ANTSEL7:
   1317                  	   NVIC_ClearPendingIRQ((IRQn_Type)CM4_EINT_6_IRQ);
   1318                      break;
   1319          
   1320                  case ePAD_UART_DBG:
   1321                  	   NVIC_ClearPendingIRQ((IRQn_Type)CM4_EINT_19_IRQ);
   1322                      break;
   1323          
   1324                  case ePAD_UART_TX:
   1325                  	   NVIC_ClearPendingIRQ((IRQn_Type)CM4_EINT_20_IRQ);
   1326                      break;
   1327          
   1328                  case ePAD_UART_RTS:
   1329                  	   NVIC_ClearPendingIRQ((IRQn_Type)CM4_EINT_21_IRQ);
   1330                      break;
   1331          
   1332                  case ePAD_UART_CTS:
   1333                  	   NVIC_ClearPendingIRQ((IRQn_Type)CM4_EINT_22_IRQ);
   1334                      break;
   1335                  default:
   1336                      return -1;
   1337              }
   1338              return 0;
   1339          }
   1340          
   1341          #endif
   1342          #endif
   1343          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_ClearPendingIRQ
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       4   NVIC_SetPriority
       0   drvGPIO_IDX_0_LISR
         0   -- Indirect call
       0   drvGPIO_IDX_1_LISR
         0   -- Indirect call
       0   drvGPIO_IDX_35_LISR
         0   -- Indirect call
       0   drvGPIO_IDX_37_LISR
         0   -- Indirect call
       0   drvGPIO_IDX_38_LISR
         0   -- Indirect call
       0   drvGPIO_IDX_39_LISR
         0   -- Indirect call
       0   drvGPIO_IDX_3_LISR
         0   -- Indirect call
       0   drvGPIO_IDX_4_LISR
         0   -- Indirect call
       0   drvGPIO_IDX_5_LISR
         0   -- Indirect call
       0   drvGPIO_IDX_6_LISR
         0   -- Indirect call
       0   drvGPIO_IDX_7_LISR
         0   -- Indirect call
       8   halGPIO_ConfDirection
       0   halGPIO_GetDriving
       0   halGPIO_PullDown_RESET
      16   halGPIO_PullDown_SET
        16   -> halGPIO_PullUp_RESET
       0   halGPIO_PullUp_RESET
      16   halGPIO_PullUp_SET
        16   -> halGPIO_PullDown_RESET
       4   halGPIO_SetDriving
       4   halGPO_Write
      32   halRegGPInterrupt
        32   -> NVIC_DisableIRQ
        32   -> NVIC_SetPriority
        32   -> halPinmuxTopOnPadFunc
        32   -> hal_nvic_register_isr_handler
       8   halRegGPInterrupt_mask
         8   -> NVIC_DisableIRQ
      16   halRegGPInterrupt_set_debounce
        16   -> NVIC_DisableIRQ
        16   -> NVIC_EnableIRQ
      16   halRegGPInterrupt_set_triggermode
        16   -> NVIC_DisableIRQ
        16   -> NVIC_EnableIRQ
        16   -> halPinmuxTopOnPadFunc
       8   halRegGPInterrupt_unmask
         8   -> NVIC_EnableIRQ
       8   halRegGP_clear_software_trigger
         8   -> NVIC_ClearPendingIRQ
       8   halRegGP_set_software_trigger
         8   -> software_trigger_irq
       0   halgetGPIO_DIN
       0   halgetGPIO_DOUT
       0   halgetGPIO_OutEnable
       0   software_trigger_irq
       0   topPAD_Control_GPIO


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_10
       4  ??DataTable26_11
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable26_6
       4  ??DataTable26_7
       4  ??DataTable26_8
       4  ??DataTable26_9
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_2
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_2
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable30_5
       4  ??DataTable30_6
       4  ??DataTable30_7
       4  ??DataTable30_8
       4  ??DataTable30_9
      44  LISR
      20  NVIC_ClearPendingIRQ
      20  NVIC_DisableIRQ
      20  NVIC_EnableIRQ
      34  NVIC_SetPriority
      10  drvGPIO_IDX_0_LISR
      10  drvGPIO_IDX_1_LISR
      10  drvGPIO_IDX_35_LISR
      10  drvGPIO_IDX_37_LISR
      10  drvGPIO_IDX_38_LISR
      10  drvGPIO_IDX_39_LISR
      10  drvGPIO_IDX_3_LISR
      10  drvGPIO_IDX_4_LISR
      10  drvGPIO_IDX_5_LISR
      10  drvGPIO_IDX_6_LISR
      10  drvGPIO_IDX_7_LISR
     406  halGPIO_ConfDirection
     260  halGPIO_GetDriving
     212  halGPIO_PullDown_RESET
     232  halGPIO_PullDown_SET
     212  halGPIO_PullUp_RESET
     232  halGPIO_PullUp_SET
     372  halGPIO_SetDriving
      74  halGPO_Write
    1942  halRegGPInterrupt
     144  halRegGPInterrupt_mask
     870  halRegGPInterrupt_set_debounce
     988  halRegGPInterrupt_set_triggermode
     144  halRegGPInterrupt_unmask
     144  halRegGP_clear_software_trigger
     144  halRegGP_set_software_trigger
      50  halgetGPIO_DIN
      50  halgetGPIO_DOUT
      50  halgetGPIO_OutEnable
      10  software_trigger_irq
     114  topPAD_Control_GPIO

 
    44 bytes in section .bss
 6 986 bytes in section .text
 
 6 986 bytes of CODE memory
    44 bytes of DATA memory

Errors: none
Warnings: none
